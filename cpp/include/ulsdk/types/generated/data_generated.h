// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATA_H_
#define FLATBUFFERS_GENERATED_DATA_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"
#include "flatbuffers/flex_flat_util.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "Schema_generated.h"
#include "id_generated.h"
#include "reflection_generated.h"

struct NamedParameter;
struct NamedParameterBuilder;

struct Source;
struct SourceBuilder;

struct AttributePair;
struct AttributePairBuilder;

struct DirectionAndRoadName;
struct DirectionAndRoadNameBuilder;

struct DirectionAndRoadNames;
struct DirectionAndRoadNamesBuilder;

enum class NamedParameterFlags : uint32_t {
  Value = 1,
  Optional = 2,
  NONE = 0,
  ANY = 3
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(NamedParameterFlags, uint32_t)

inline const NamedParameterFlags (&EnumValuesNamedParameterFlags())[2] {
  static const NamedParameterFlags values[] = {
    NamedParameterFlags::Value,
    NamedParameterFlags::Optional
  };
  return values;
}

inline const char * const *EnumNamesNamedParameterFlags() {
  static const char * const names[3] = {
    "Value",
    "Optional",
    nullptr
  };
  return names;
}

inline const char *EnumNameNamedParameterFlags(NamedParameterFlags e) {
  if (::flatbuffers::IsOutRange(e, NamedParameterFlags::Value, NamedParameterFlags::Optional)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(NamedParameterFlags::Value);
  return EnumNamesNamedParameterFlags()[index];
}

enum class StatisticTy : int32_t {
  PERCENTILE_15 = 15,
  PERCENTILE_20 = 20,
  PERCENTILE_30 = 30,
  PERCENTILE_40 = 40,
  PERCENTILE_50 = 50,
  PERCENTILE_85 = 85,
  PERCENTILE_95 = 95,
  PERCENTILE_100 = 100,
  MEDIAN = 101,
  MEAN = 102,
  MODE = 103,
  SPEED_LIMIT = 104,
  STAT_MAX = 105,
  STAT_MIN = 106,
  MEAN_EXCEEDING = 107,
  STANDARD_DEVIATION = 108,
  NUMBER_OF_VEHICLES_EXCEEDING = 109,
  MIN = PERCENTILE_15,
  MAX = NUMBER_OF_VEHICLES_EXCEEDING
};

inline const StatisticTy (&EnumValuesStatisticTy())[17] {
  static const StatisticTy values[] = {
    StatisticTy::PERCENTILE_15,
    StatisticTy::PERCENTILE_20,
    StatisticTy::PERCENTILE_30,
    StatisticTy::PERCENTILE_40,
    StatisticTy::PERCENTILE_50,
    StatisticTy::PERCENTILE_85,
    StatisticTy::PERCENTILE_95,
    StatisticTy::PERCENTILE_100,
    StatisticTy::MEDIAN,
    StatisticTy::MEAN,
    StatisticTy::MODE,
    StatisticTy::SPEED_LIMIT,
    StatisticTy::STAT_MAX,
    StatisticTy::STAT_MIN,
    StatisticTy::MEAN_EXCEEDING,
    StatisticTy::STANDARD_DEVIATION,
    StatisticTy::NUMBER_OF_VEHICLES_EXCEEDING
  };
  return values;
}

inline const char *EnumNameStatisticTy(StatisticTy e) {
  switch (e) {
    case StatisticTy::PERCENTILE_15: return "PERCENTILE_15";
    case StatisticTy::PERCENTILE_20: return "PERCENTILE_20";
    case StatisticTy::PERCENTILE_30: return "PERCENTILE_30";
    case StatisticTy::PERCENTILE_40: return "PERCENTILE_40";
    case StatisticTy::PERCENTILE_50: return "PERCENTILE_50";
    case StatisticTy::PERCENTILE_85: return "PERCENTILE_85";
    case StatisticTy::PERCENTILE_95: return "PERCENTILE_95";
    case StatisticTy::PERCENTILE_100: return "PERCENTILE_100";
    case StatisticTy::MEDIAN: return "MEDIAN";
    case StatisticTy::MEAN: return "MEAN";
    case StatisticTy::MODE: return "MODE";
    case StatisticTy::SPEED_LIMIT: return "SPEED_LIMIT";
    case StatisticTy::STAT_MAX: return "STAT_MAX";
    case StatisticTy::STAT_MIN: return "STAT_MIN";
    case StatisticTy::MEAN_EXCEEDING: return "MEAN_EXCEEDING";
    case StatisticTy::STANDARD_DEVIATION: return "STANDARD_DEVIATION";
    case StatisticTy::NUMBER_OF_VEHICLES_EXCEEDING: return "NUMBER_OF_VEHICLES_EXCEEDING";
    default: return "";
  }
}

enum class TimeGranularity : int32_t {
  NONE = 0,
  Daily = 1,
  MIN = NONE,
  MAX = Daily
};

inline const TimeGranularity (&EnumValuesTimeGranularity())[2] {
  static const TimeGranularity values[] = {
    TimeGranularity::NONE,
    TimeGranularity::Daily
  };
  return values;
}

inline const char * const *EnumNamesTimeGranularity() {
  static const char * const names[3] = {
    "NONE",
    "Daily",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeGranularity(TimeGranularity e) {
  if (::flatbuffers::IsOutRange(e, TimeGranularity::NONE, TimeGranularity::Daily)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeGranularity()[index];
}

enum class RoadUserTy : int32_t {
  BIKES = 0,
  BUSES = 1,
  CARS = 2,
  ARTICULATED_TRUCKS = 3,
  CARS_AND_LIGHT_GOODS_VEHICLES = 4,
  LIGHT_GOODS_VEHICLES = 5,
  SINGLE_UNIT_TRUCKS = 6,
  HEAVY_VEHICLES = 7,
  MOTORCYCLES = 8,
  ALL_VEHICLES = 9,
  TRUCKS = 10,
  REGULAR_VEHICLES = 11,
  MEDIUM_TRUCKS = 12,
  HEAVY_TRUCKS = 13,
  LIGHT_TRUCKS = 14,
  LIGHT_VEHICLES = 15,
  MEDIUM_VEHICLES = 16,
  MULTI_UNIT_TRUCKS = 17,
  TRUCKS_AND_BUSES = 18,
  TRANSIT_BUSES = 19,
  SCHOOL_BUSES = 20,
  E_SCOOTERS = 21,
  MOTORIZED_VEHICLES = 22,
  CARS_AND_OTHERS = 23,
  PEDS = 24,
  ADULT_PEDS = 25,
  CHILD_PEDS = 26,
  SENIOR_PEDS = 27,
  DISABLED_PEDS = 28,
  BICYCLES_ON_CROSSWALK = 29,
  PEDS_AND_BIKES = 30,
  PHYSICALLY_CHALLENGED_PEDS = 31,
  CROSSWALKS = 32,
  TRAMS = 33,
  MIN = BIKES,
  MAX = TRAMS
};

inline const RoadUserTy (&EnumValuesRoadUserTy())[34] {
  static const RoadUserTy values[] = {
    RoadUserTy::BIKES,
    RoadUserTy::BUSES,
    RoadUserTy::CARS,
    RoadUserTy::ARTICULATED_TRUCKS,
    RoadUserTy::CARS_AND_LIGHT_GOODS_VEHICLES,
    RoadUserTy::LIGHT_GOODS_VEHICLES,
    RoadUserTy::SINGLE_UNIT_TRUCKS,
    RoadUserTy::HEAVY_VEHICLES,
    RoadUserTy::MOTORCYCLES,
    RoadUserTy::ALL_VEHICLES,
    RoadUserTy::TRUCKS,
    RoadUserTy::REGULAR_VEHICLES,
    RoadUserTy::MEDIUM_TRUCKS,
    RoadUserTy::HEAVY_TRUCKS,
    RoadUserTy::LIGHT_TRUCKS,
    RoadUserTy::LIGHT_VEHICLES,
    RoadUserTy::MEDIUM_VEHICLES,
    RoadUserTy::MULTI_UNIT_TRUCKS,
    RoadUserTy::TRUCKS_AND_BUSES,
    RoadUserTy::TRANSIT_BUSES,
    RoadUserTy::SCHOOL_BUSES,
    RoadUserTy::E_SCOOTERS,
    RoadUserTy::MOTORIZED_VEHICLES,
    RoadUserTy::CARS_AND_OTHERS,
    RoadUserTy::PEDS,
    RoadUserTy::ADULT_PEDS,
    RoadUserTy::CHILD_PEDS,
    RoadUserTy::SENIOR_PEDS,
    RoadUserTy::DISABLED_PEDS,
    RoadUserTy::BICYCLES_ON_CROSSWALK,
    RoadUserTy::PEDS_AND_BIKES,
    RoadUserTy::PHYSICALLY_CHALLENGED_PEDS,
    RoadUserTy::CROSSWALKS,
    RoadUserTy::TRAMS
  };
  return values;
}

inline const char * const *EnumNamesRoadUserTy() {
  static const char * const names[35] = {
    "BIKES",
    "BUSES",
    "CARS",
    "ARTICULATED_TRUCKS",
    "CARS_AND_LIGHT_GOODS_VEHICLES",
    "LIGHT_GOODS_VEHICLES",
    "SINGLE_UNIT_TRUCKS",
    "HEAVY_VEHICLES",
    "MOTORCYCLES",
    "ALL_VEHICLES",
    "TRUCKS",
    "REGULAR_VEHICLES",
    "MEDIUM_TRUCKS",
    "HEAVY_TRUCKS",
    "LIGHT_TRUCKS",
    "LIGHT_VEHICLES",
    "MEDIUM_VEHICLES",
    "MULTI_UNIT_TRUCKS",
    "TRUCKS_AND_BUSES",
    "TRANSIT_BUSES",
    "SCHOOL_BUSES",
    "E_SCOOTERS",
    "MOTORIZED_VEHICLES",
    "CARS_AND_OTHERS",
    "PEDS",
    "ADULT_PEDS",
    "CHILD_PEDS",
    "SENIOR_PEDS",
    "DISABLED_PEDS",
    "BICYCLES_ON_CROSSWALK",
    "PEDS_AND_BIKES",
    "PHYSICALLY_CHALLENGED_PEDS",
    "CROSSWALKS",
    "TRAMS",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoadUserTy(RoadUserTy e) {
  if (::flatbuffers::IsOutRange(e, RoadUserTy::BIKES, RoadUserTy::TRAMS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoadUserTy()[index];
}

enum class DirectionTy : int32_t {
  NB = 0,
  WB = 1,
  SB = 2,
  EB = 3,
  NWB = 4,
  NEB = 5,
  SWB = 6,
  SEB = 7,
  MINUS_MP = 8,
  PLUS_MP = 9,
  IN = 10,
  OUT = 11,
  TOTAL = 12,
  N = 13,
  W = 14,
  E = 15,
  S = 16,
  NW = 17,
  NE = 18,
  SW = 19,
  SE = 20,
  MIN = NB,
  MAX = SE
};

inline const DirectionTy (&EnumValuesDirectionTy())[21] {
  static const DirectionTy values[] = {
    DirectionTy::NB,
    DirectionTy::WB,
    DirectionTy::SB,
    DirectionTy::EB,
    DirectionTy::NWB,
    DirectionTy::NEB,
    DirectionTy::SWB,
    DirectionTy::SEB,
    DirectionTy::MINUS_MP,
    DirectionTy::PLUS_MP,
    DirectionTy::IN,
    DirectionTy::OUT,
    DirectionTy::TOTAL,
    DirectionTy::N,
    DirectionTy::W,
    DirectionTy::E,
    DirectionTy::S,
    DirectionTy::NW,
    DirectionTy::NE,
    DirectionTy::SW,
    DirectionTy::SE
  };
  return values;
}

inline const char * const *EnumNamesDirectionTy() {
  static const char * const names[22] = {
    "NB",
    "WB",
    "SB",
    "EB",
    "NWB",
    "NEB",
    "SWB",
    "SEB",
    "MINUS_MP",
    "PLUS_MP",
    "IN",
    "OUT",
    "TOTAL",
    "N",
    "W",
    "E",
    "S",
    "NW",
    "NE",
    "SW",
    "SE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDirectionTy(DirectionTy e) {
  if (::flatbuffers::IsOutRange(e, DirectionTy::NB, DirectionTy::SE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDirectionTy()[index];
}

enum class TurnTy : int32_t {
  CW = 0,
  CCW = 1,
  NONE = 2,
  LEFT = 3,
  RIGHT = 4,
  THRU = 5,
  U_TURN = 6,
  BEAR_RIGHT = 7,
  BEAR_LEFT = 8,
  HARD_RIGHT = 9,
  HARD_LEFT = 10,
  RIGHT_TURNING_ON_RED = 11,
  BEAR_RIGHT_ON_RED = 12,
  MIN = CW,
  MAX = BEAR_RIGHT_ON_RED
};

inline const TurnTy (&EnumValuesTurnTy())[13] {
  static const TurnTy values[] = {
    TurnTy::CW,
    TurnTy::CCW,
    TurnTy::NONE,
    TurnTy::LEFT,
    TurnTy::RIGHT,
    TurnTy::THRU,
    TurnTy::U_TURN,
    TurnTy::BEAR_RIGHT,
    TurnTy::BEAR_LEFT,
    TurnTy::HARD_RIGHT,
    TurnTy::HARD_LEFT,
    TurnTy::RIGHT_TURNING_ON_RED,
    TurnTy::BEAR_RIGHT_ON_RED
  };
  return values;
}

inline const char * const *EnumNamesTurnTy() {
  static const char * const names[14] = {
    "CW",
    "CCW",
    "NONE",
    "LEFT",
    "RIGHT",
    "THRU",
    "U_TURN",
    "BEAR_RIGHT",
    "BEAR_LEFT",
    "HARD_RIGHT",
    "HARD_LEFT",
    "RIGHT_TURNING_ON_RED",
    "BEAR_RIGHT_ON_RED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTurnTy(TurnTy e) {
  if (::flatbuffers::IsOutRange(e, TurnTy::CW, TurnTy::BEAR_RIGHT_ON_RED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTurnTy()[index];
}

enum class DayOfWeek : uint8_t {
  MONDAY = 0,
  TUESDAY = 1,
  WEDNESDAY = 2,
  THURSDAY = 3,
  FRIDAY = 4,
  SATURDAY = 5,
  SUNDAY = 6,
  MIN = MONDAY,
  MAX = SUNDAY
};

inline const DayOfWeek (&EnumValuesDayOfWeek())[7] {
  static const DayOfWeek values[] = {
    DayOfWeek::MONDAY,
    DayOfWeek::TUESDAY,
    DayOfWeek::WEDNESDAY,
    DayOfWeek::THURSDAY,
    DayOfWeek::FRIDAY,
    DayOfWeek::SATURDAY,
    DayOfWeek::SUNDAY
  };
  return values;
}

inline const char * const *EnumNamesDayOfWeek() {
  static const char * const names[8] = {
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
    "SUNDAY",
    nullptr
  };
  return names;
}

inline const char *EnumNameDayOfWeek(DayOfWeek e) {
  if (::flatbuffers::IsOutRange(e, DayOfWeek::MONDAY, DayOfWeek::SUNDAY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDayOfWeek()[index];
}

struct NamedParameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedParameterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SCHEMA = 6,
    VT_FLAGS = 8,
    VT_DESCRIPTION = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const Schema *schema() const {
    return GetPointer<const Schema *>(VT_SCHEMA);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           verifier.EndTable();
  }
};

struct NamedParameterBuilder {
  typedef NamedParameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NamedParameter::VT_NAME, name);
  }
  void add_schema(::flatbuffers::Offset<Schema> schema) {
    fbb_.AddOffset(NamedParameter::VT_SCHEMA, schema);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(NamedParameter::VT_FLAGS, flags, 0);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(NamedParameter::VT_DESCRIPTION, description);
  }
  explicit NamedParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedParameter>(end);
    fbb_.Required(o, NamedParameter::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedParameter> CreateNamedParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<Schema> schema = 0,
    uint32_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0) {
  NamedParameterBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_flags(flags);
  builder_.add_schema(schema);
  builder_.add_name(name);
  return builder_.Finish();
}

struct NamedParameter::Traits {
  using type = NamedParameter;
  static auto constexpr Create = CreateNamedParameter;
};

inline ::flatbuffers::Offset<NamedParameter> CreateNamedParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<Schema> schema = 0,
    uint32_t flags = 0,
    const char *description = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  return CreateNamedParameter(
      _fbb,
      name__,
      schema,
      flags,
      description__);
}

struct Source FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SourceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4,
    VT_NAME = 6,
    VT_OPTIONS = 8,
    VT_SCHEMAS = 10,
    VT_METADATA = 14,
    VT_METADATA_REVISION = 16,
    VT_NAMED_PARAMETERS = 18
  };
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *options() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OPTIONS);
  }
  flexbuffers::Reference options_flexbuffer_root() const {
    const auto _f = options();
    return _f ? flexbuffers::GetRoot(_f->Data(), _f->size())
              : flexbuffers::Reference();
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Schema>> *schemas() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Schema>> *>(VT_SCHEMAS);
  }
  const ObjectId *metadata() const {
    return GetPointer<const ObjectId *>(VT_METADATA);
  }
  const ContentId *metadata_revision() const {
    return GetPointer<const ContentId *>(VT_METADATA_REVISION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NamedParameter>> *named_parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NamedParameter>> *>(VT_NAMED_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyVector(options()) &&
           flexbuffers::VerifyNestedFlexBuffer(options(), verifier) &&
           VerifyOffset(verifier, VT_SCHEMAS) &&
           verifier.VerifyVector(schemas()) &&
           verifier.VerifyVectorOfTables(schemas()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           VerifyOffset(verifier, VT_METADATA_REVISION) &&
           verifier.VerifyTable(metadata_revision()) &&
           VerifyOffset(verifier, VT_NAMED_PARAMETERS) &&
           verifier.VerifyVector(named_parameters()) &&
           verifier.VerifyVectorOfTables(named_parameters()) &&
           verifier.EndTable();
  }
};

struct SourceBuilder {
  typedef Source Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(Source::VT_URL, url);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Source::VT_NAME, name);
  }
  void add_options(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> options) {
    fbb_.AddOffset(Source::VT_OPTIONS, options);
  }
  void add_schemas(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Schema>>> schemas) {
    fbb_.AddOffset(Source::VT_SCHEMAS, schemas);
  }
  void add_metadata(::flatbuffers::Offset<ObjectId> metadata) {
    fbb_.AddOffset(Source::VT_METADATA, metadata);
  }
  void add_metadata_revision(::flatbuffers::Offset<ContentId> metadata_revision) {
    fbb_.AddOffset(Source::VT_METADATA_REVISION, metadata_revision);
  }
  void add_named_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NamedParameter>>> named_parameters) {
    fbb_.AddOffset(Source::VT_NAMED_PARAMETERS, named_parameters);
  }
  explicit SourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Source> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Source>(end);
    fbb_.Required(o, Source::VT_URL);
    fbb_.Required(o, Source::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Source> CreateSource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Schema>>> schemas = 0,
    ::flatbuffers::Offset<ObjectId> metadata = 0,
    ::flatbuffers::Offset<ContentId> metadata_revision = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NamedParameter>>> named_parameters = 0) {
  SourceBuilder builder_(_fbb);
  builder_.add_named_parameters(named_parameters);
  builder_.add_metadata_revision(metadata_revision);
  builder_.add_metadata(metadata);
  builder_.add_schemas(schemas);
  builder_.add_options(options);
  builder_.add_name(name);
  builder_.add_url(url);
  return builder_.Finish();
}

struct Source::Traits {
  using type = Source;
  static auto constexpr Create = CreateSource;
};

inline ::flatbuffers::Offset<Source> CreateSourceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr,
    const char *name = nullptr,
    const std::vector<uint8_t> *options = nullptr,
    const std::vector<::flatbuffers::Offset<Schema>> *schemas = nullptr,
    ::flatbuffers::Offset<ObjectId> metadata = 0,
    ::flatbuffers::Offset<ContentId> metadata_revision = 0,
    const std::vector<::flatbuffers::Offset<NamedParameter>> *named_parameters = nullptr) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto options__ = options ? _fbb.CreateVector<uint8_t>(*options) : 0;
  auto schemas__ = schemas ? _fbb.CreateVector<::flatbuffers::Offset<Schema>>(*schemas) : 0;
  auto named_parameters__ = named_parameters ? _fbb.CreateVector<::flatbuffers::Offset<NamedParameter>>(*named_parameters) : 0;
  return CreateSource(
      _fbb,
      url__,
      name__,
      options__,
      schemas__,
      metadata,
      metadata_revision,
      named_parameters__);
}

struct AttributePair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributePairBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct AttributePairBuilder {
  typedef AttributePair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(AttributePair::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(AttributePair::VT_VALUE, value);
  }
  explicit AttributePairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AttributePair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AttributePair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AttributePair> CreateAttributePair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  AttributePairBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct AttributePair::Traits {
  using type = AttributePair;
  static auto constexpr Create = CreateAttributePair;
};

inline ::flatbuffers::Offset<AttributePair> CreateAttributePairDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return CreateAttributePair(
      _fbb,
      key__,
      value__);
}

struct DirectionAndRoadName FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DirectionAndRoadNameBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIRECTION = 4,
    VT_ROAD_NAME = 6
  };
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  const ::flatbuffers::String *road_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROAD_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           VerifyOffsetRequired(verifier, VT_ROAD_NAME) &&
           verifier.VerifyString(road_name()) &&
           verifier.EndTable();
  }
};

struct DirectionAndRoadNameBuilder {
  typedef DirectionAndRoadName Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(DirectionAndRoadName::VT_DIRECTION, direction);
  }
  void add_road_name(::flatbuffers::Offset<::flatbuffers::String> road_name) {
    fbb_.AddOffset(DirectionAndRoadName::VT_ROAD_NAME, road_name);
  }
  explicit DirectionAndRoadNameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DirectionAndRoadName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DirectionAndRoadName>(end);
    fbb_.Required(o, DirectionAndRoadName::VT_DIRECTION);
    fbb_.Required(o, DirectionAndRoadName::VT_ROAD_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<DirectionAndRoadName> CreateDirectionAndRoadName(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0,
    ::flatbuffers::Offset<::flatbuffers::String> road_name = 0) {
  DirectionAndRoadNameBuilder builder_(_fbb);
  builder_.add_road_name(road_name);
  builder_.add_direction(direction);
  return builder_.Finish();
}

struct DirectionAndRoadName::Traits {
  using type = DirectionAndRoadName;
  static auto constexpr Create = CreateDirectionAndRoadName;
};

inline ::flatbuffers::Offset<DirectionAndRoadName> CreateDirectionAndRoadNameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *direction = nullptr,
    const char *road_name = nullptr) {
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  auto road_name__ = road_name ? _fbb.CreateString(road_name) : 0;
  return CreateDirectionAndRoadName(
      _fbb,
      direction__,
      road_name__);
}

struct DirectionAndRoadNames FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DirectionAndRoadNamesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIRECTION_AND_ROAD_NAMES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<DirectionAndRoadName>> *direction_and_road_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DirectionAndRoadName>> *>(VT_DIRECTION_AND_ROAD_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIRECTION_AND_ROAD_NAMES) &&
           verifier.VerifyVector(direction_and_road_names()) &&
           verifier.VerifyVectorOfTables(direction_and_road_names()) &&
           verifier.EndTable();
  }
};

struct DirectionAndRoadNamesBuilder {
  typedef DirectionAndRoadNames Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_direction_and_road_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DirectionAndRoadName>>> direction_and_road_names) {
    fbb_.AddOffset(DirectionAndRoadNames::VT_DIRECTION_AND_ROAD_NAMES, direction_and_road_names);
  }
  explicit DirectionAndRoadNamesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DirectionAndRoadNames> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DirectionAndRoadNames>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DirectionAndRoadNames> CreateDirectionAndRoadNames(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DirectionAndRoadName>>> direction_and_road_names = 0) {
  DirectionAndRoadNamesBuilder builder_(_fbb);
  builder_.add_direction_and_road_names(direction_and_road_names);
  return builder_.Finish();
}

struct DirectionAndRoadNames::Traits {
  using type = DirectionAndRoadNames;
  static auto constexpr Create = CreateDirectionAndRoadNames;
};

inline ::flatbuffers::Offset<DirectionAndRoadNames> CreateDirectionAndRoadNamesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<DirectionAndRoadName>> *direction_and_road_names = nullptr) {
  auto direction_and_road_names__ = direction_and_road_names ? _fbb.CreateVector<::flatbuffers::Offset<DirectionAndRoadName>>(*direction_and_road_names) : 0;
  return CreateDirectionAndRoadNames(
      _fbb,
      direction_and_road_names__);
}

#endif  // FLATBUFFERS_GENERATED_DATA_H_
