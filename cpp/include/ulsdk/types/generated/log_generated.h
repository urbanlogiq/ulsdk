// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOG_H_
#define FLATBUFFERS_GENERATED_LOG_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "value_generated.h"

struct Pair;
struct PairBuilder;

struct Label;
struct LabelBuilder;

struct Log;
struct LogBuilder;

enum class Severity : uint8_t {
  CRITICAL = 0,
  ERROR = 1,
  WARN = 2,
  INFO = 3,
  DEBUG = 4,
  TRACE = 5,
  MIN = CRITICAL,
  MAX = TRACE
};

inline const Severity (&EnumValuesSeverity())[6] {
  static const Severity values[] = {
    Severity::CRITICAL,
    Severity::ERROR,
    Severity::WARN,
    Severity::INFO,
    Severity::DEBUG,
    Severity::TRACE
  };
  return values;
}

inline const char * const *EnumNamesSeverity() {
  static const char * const names[7] = {
    "CRITICAL",
    "ERROR",
    "WARN",
    "INFO",
    "DEBUG",
    "TRACE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSeverity(Severity e) {
  if (::flatbuffers::IsOutRange(e, Severity::CRITICAL, Severity::TRACE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSeverity()[index];
}

struct Pair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PairBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  Value value_type() const {
    return static_cast<Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const VBool *value_as_VBool() const {
    return value_type() == Value::VBool ? static_cast<const VBool *>(value()) : nullptr;
  }
  const VUnit *value_as_VUnit() const {
    return value_type() == Value::VUnit ? static_cast<const VUnit *>(value()) : nullptr;
  }
  const VChar *value_as_VChar() const {
    return value_type() == Value::VChar ? static_cast<const VChar *>(value()) : nullptr;
  }
  const VNull *value_as_VNull() const {
    return value_type() == Value::VNull ? static_cast<const VNull *>(value()) : nullptr;
  }
  const VI8 *value_as_VI8() const {
    return value_type() == Value::VI8 ? static_cast<const VI8 *>(value()) : nullptr;
  }
  const VU8 *value_as_VU8() const {
    return value_type() == Value::VU8 ? static_cast<const VU8 *>(value()) : nullptr;
  }
  const VI16 *value_as_VI16() const {
    return value_type() == Value::VI16 ? static_cast<const VI16 *>(value()) : nullptr;
  }
  const VU16 *value_as_VU16() const {
    return value_type() == Value::VU16 ? static_cast<const VU16 *>(value()) : nullptr;
  }
  const VI32 *value_as_VI32() const {
    return value_type() == Value::VI32 ? static_cast<const VI32 *>(value()) : nullptr;
  }
  const VU32 *value_as_VU32() const {
    return value_type() == Value::VU32 ? static_cast<const VU32 *>(value()) : nullptr;
  }
  const VF32 *value_as_VF32() const {
    return value_type() == Value::VF32 ? static_cast<const VF32 *>(value()) : nullptr;
  }
  const VIsize *value_as_VIsize() const {
    return value_type() == Value::VIsize ? static_cast<const VIsize *>(value()) : nullptr;
  }
  const VUsize *value_as_VUsize() const {
    return value_type() == Value::VUsize ? static_cast<const VUsize *>(value()) : nullptr;
  }
  const VI64 *value_as_VI64() const {
    return value_type() == Value::VI64 ? static_cast<const VI64 *>(value()) : nullptr;
  }
  const VU64 *value_as_VU64() const {
    return value_type() == Value::VU64 ? static_cast<const VU64 *>(value()) : nullptr;
  }
  const VF64 *value_as_VF64() const {
    return value_type() == Value::VF64 ? static_cast<const VF64 *>(value()) : nullptr;
  }
  const VStr *value_as_VStr() const {
    return value_type() == Value::VStr ? static_cast<const VStr *>(value()) : nullptr;
  }
  const VBytes *value_as_VBytes() const {
    return value_type() == Value::VBytes ? static_cast<const VBytes *>(value()) : nullptr;
  }
  const VArray *value_as_VArray() const {
    return value_type() == Value::VArray ? static_cast<const VArray *>(value()) : nullptr;
  }
  const VTri2D *value_as_VTri2D() const {
    return value_type() == Value::VTri2D ? static_cast<const VTri2D *>(value()) : nullptr;
  }
  const VFixedSizeBytes *value_as_VFixedSizeBytes() const {
    return value_type() == Value::VFixedSizeBytes ? static_cast<const VFixedSizeBytes *>(value()) : nullptr;
  }
  const VTimestampMsUtc *value_as_VTimestampMsUtc() const {
    return value_type() == Value::VTimestampMsUtc ? static_cast<const VTimestampMsUtc *>(value()) : nullptr;
  }
  const VTimestampMs *value_as_VTimestampMs() const {
    return value_type() == Value::VTimestampMs ? static_cast<const VTimestampMs *>(value()) : nullptr;
  }
  const VTimestampNsUtc *value_as_VTimestampNsUtc() const {
    return value_type() == Value::VTimestampNsUtc ? static_cast<const VTimestampNsUtc *>(value()) : nullptr;
  }
  const VTimestampNs *value_as_VTimestampNs() const {
    return value_type() == Value::VTimestampNs ? static_cast<const VTimestampNs *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VBool *Pair::value_as<VBool>() const {
  return value_as_VBool();
}

template<> inline const VUnit *Pair::value_as<VUnit>() const {
  return value_as_VUnit();
}

template<> inline const VChar *Pair::value_as<VChar>() const {
  return value_as_VChar();
}

template<> inline const VNull *Pair::value_as<VNull>() const {
  return value_as_VNull();
}

template<> inline const VI8 *Pair::value_as<VI8>() const {
  return value_as_VI8();
}

template<> inline const VU8 *Pair::value_as<VU8>() const {
  return value_as_VU8();
}

template<> inline const VI16 *Pair::value_as<VI16>() const {
  return value_as_VI16();
}

template<> inline const VU16 *Pair::value_as<VU16>() const {
  return value_as_VU16();
}

template<> inline const VI32 *Pair::value_as<VI32>() const {
  return value_as_VI32();
}

template<> inline const VU32 *Pair::value_as<VU32>() const {
  return value_as_VU32();
}

template<> inline const VF32 *Pair::value_as<VF32>() const {
  return value_as_VF32();
}

template<> inline const VIsize *Pair::value_as<VIsize>() const {
  return value_as_VIsize();
}

template<> inline const VUsize *Pair::value_as<VUsize>() const {
  return value_as_VUsize();
}

template<> inline const VI64 *Pair::value_as<VI64>() const {
  return value_as_VI64();
}

template<> inline const VU64 *Pair::value_as<VU64>() const {
  return value_as_VU64();
}

template<> inline const VF64 *Pair::value_as<VF64>() const {
  return value_as_VF64();
}

template<> inline const VStr *Pair::value_as<VStr>() const {
  return value_as_VStr();
}

template<> inline const VBytes *Pair::value_as<VBytes>() const {
  return value_as_VBytes();
}

template<> inline const VArray *Pair::value_as<VArray>() const {
  return value_as_VArray();
}

template<> inline const VTri2D *Pair::value_as<VTri2D>() const {
  return value_as_VTri2D();
}

template<> inline const VFixedSizeBytes *Pair::value_as<VFixedSizeBytes>() const {
  return value_as_VFixedSizeBytes();
}

template<> inline const VTimestampMsUtc *Pair::value_as<VTimestampMsUtc>() const {
  return value_as_VTimestampMsUtc();
}

template<> inline const VTimestampMs *Pair::value_as<VTimestampMs>() const {
  return value_as_VTimestampMs();
}

template<> inline const VTimestampNsUtc *Pair::value_as<VTimestampNsUtc>() const {
  return value_as_VTimestampNsUtc();
}

template<> inline const VTimestampNs *Pair::value_as<VTimestampNs>() const {
  return value_as_VTimestampNs();
}

struct PairBuilder {
  typedef Pair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(Pair::VT_KEY, key);
  }
  void add_value_type(Value value_type) {
    fbb_.AddElement<uint8_t>(Pair::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Pair::VT_VALUE, value);
  }
  explicit PairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pair>(end);
    fbb_.Required(o, Pair::VT_KEY);
    fbb_.Required(o, Pair::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<Pair> CreatePair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    Value value_type = Value::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  PairBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Pair::Traits {
  using type = Pair;
  static auto constexpr Create = CreatePair;
};

inline ::flatbuffers::Offset<Pair> CreatePairDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    Value value_type = Value::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return CreatePair(
      _fbb,
      key__,
      value_type,
      value);
}

struct Label FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LabelBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct LabelBuilder {
  typedef Label Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(Label::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(Label::VT_VALUE, value);
  }
  explicit LabelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Label>(end);
    fbb_.Required(o, Label::VT_KEY);
    fbb_.Required(o, Label::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<Label> CreateLabel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  LabelBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct Label::Traits {
  using type = Label;
  static auto constexpr Create = CreateLabel;
};

inline ::flatbuffers::Offset<Label> CreateLabelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return CreateLabel(
      _fbb,
      key__,
      value__);
}

struct Log FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LogBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_LABELS = 6,
    VT_PAIRS = 8
  };
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Label>> *labels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Label>> *>(VT_LABELS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Pair>> *pairs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Pair>> *>(VT_PAIRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyOffsetRequired(verifier, VT_LABELS) &&
           verifier.VerifyVector(labels()) &&
           verifier.VerifyVectorOfTables(labels()) &&
           VerifyOffsetRequired(verifier, VT_PAIRS) &&
           verifier.VerifyVector(pairs()) &&
           verifier.VerifyVectorOfTables(pairs()) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  typedef Log Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Log::VT_TIMESTAMP, timestamp, 0);
  }
  void add_labels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Label>>> labels) {
    fbb_.AddOffset(Log::VT_LABELS, labels);
  }
  void add_pairs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Pair>>> pairs) {
    fbb_.AddOffset(Log::VT_PAIRS, pairs);
  }
  explicit LogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Log>(end);
    fbb_.Required(o, Log::VT_LABELS);
    fbb_.Required(o, Log::VT_PAIRS);
    return o;
  }
};

inline ::flatbuffers::Offset<Log> CreateLog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Label>>> labels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Pair>>> pairs = 0) {
  LogBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_pairs(pairs);
  builder_.add_labels(labels);
  return builder_.Finish();
}

struct Log::Traits {
  using type = Log;
  static auto constexpr Create = CreateLog;
};

inline ::flatbuffers::Offset<Log> CreateLogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    const std::vector<::flatbuffers::Offset<Label>> *labels = nullptr,
    const std::vector<::flatbuffers::Offset<Pair>> *pairs = nullptr) {
  auto labels__ = labels ? _fbb.CreateVector<::flatbuffers::Offset<Label>>(*labels) : 0;
  auto pairs__ = pairs ? _fbb.CreateVector<::flatbuffers::Offset<Pair>>(*pairs) : 0;
  return CreateLog(
      _fbb,
      timestamp,
      labels__,
      pairs__);
}

#endif  // FLATBUFFERS_GENERATED_LOG_H_
