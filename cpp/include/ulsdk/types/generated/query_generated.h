// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_QUERY_H_
#define FLATBUFFERS_GENERATED_QUERY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "api_generated.h"
#include "fun_generated.h"
#include "graph_generated.h"
#include "id_generated.h"
#include "value_generated.h"

struct ValueIndex;
struct ValueIndexBuilder;

struct NullableUint;
struct NullableUintBuilder;

struct Column;
struct ColumnBuilder;

struct Function;
struct FunctionBuilder;

struct When;
struct WhenBuilder;

struct Case;
struct CaseBuilder;

struct AllColumns;
struct AllColumnsBuilder;

struct Partition;
struct PartitionBuilder;

struct UnsetArgument;
struct UnsetArgumentBuilder;

struct OrderByExpr;
struct OrderByExprBuilder;

struct Window;
struct WindowBuilder;

struct Expr;
struct ExprBuilder;

struct Join;
struct JoinBuilder;

struct Arrow;
struct ArrowBuilder;

struct MvdbSubcollection;
struct MvdbSubcollectionBuilder;

struct WorklogSubcollection;
struct WorklogSubcollectionBuilder;

struct DataCatalog;
struct DataCatalogBuilder;

struct QueryTableSource;
struct QueryTableSourceBuilder;

struct Vector;
struct VectorBuilder;

struct TableSource;
struct TableSourceBuilder;

struct TableOrderBy;
struct TableOrderByBuilder;

struct Distinct;
struct DistinctBuilder;

struct UnaryQueryElement;
struct UnaryQueryElementBuilder;

struct BinaryQueryElement;
struct BinaryQueryElementBuilder;

struct SetExpr;
struct SetExprBuilder;

struct UpdateQueryElement;
struct UpdateQueryElementBuilder;

struct DeleteQueryElement;
struct DeleteQueryElementBuilder;

struct QueryElement;
struct QueryElementBuilder;

struct Query;
struct QueryBuilder;

struct Parameter;
struct ParameterBuilder;

struct ParameterInstance;
struct ParameterInstanceBuilder;

struct ParameterizedQuery;
struct ParameterizedQueryBuilder;

enum class TypeHint : int8_t {
  None = 0,
  TimestampMillis = 1,
  TimestampNanos = 2,
  Base64 = 3,
  Uuid = 4,
  MIN = None,
  MAX = Uuid
};

inline const TypeHint (&EnumValuesTypeHint())[5] {
  static const TypeHint values[] = {
    TypeHint::None,
    TypeHint::TimestampMillis,
    TypeHint::TimestampNanos,
    TypeHint::Base64,
    TypeHint::Uuid
  };
  return values;
}

inline const char * const *EnumNamesTypeHint() {
  static const char * const names[6] = {
    "None",
    "TimestampMillis",
    "TimestampNanos",
    "Base64",
    "Uuid",
    nullptr
  };
  return names;
}

inline const char *EnumNameTypeHint(TypeHint e) {
  if (::flatbuffers::IsOutRange(e, TypeHint::None, TypeHint::Uuid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTypeHint()[index];
}

enum class ExprUnion : uint8_t {
  NONE = 0,
  ValueIndex = 1,
  Column = 2,
  Function = 3,
  AllColumns = 4,
  Case = 5,
  OrderByExpr = 6,
  Partition = 7,
  UnsetArgument = 8,
  Window = 9,
  MIN = NONE,
  MAX = Window
};

inline const ExprUnion (&EnumValuesExprUnion())[10] {
  static const ExprUnion values[] = {
    ExprUnion::NONE,
    ExprUnion::ValueIndex,
    ExprUnion::Column,
    ExprUnion::Function,
    ExprUnion::AllColumns,
    ExprUnion::Case,
    ExprUnion::OrderByExpr,
    ExprUnion::Partition,
    ExprUnion::UnsetArgument,
    ExprUnion::Window
  };
  return values;
}

inline const char * const *EnumNamesExprUnion() {
  static const char * const names[11] = {
    "NONE",
    "ValueIndex",
    "Column",
    "Function",
    "AllColumns",
    "Case",
    "OrderByExpr",
    "Partition",
    "UnsetArgument",
    "Window",
    nullptr
  };
  return names;
}

inline const char *EnumNameExprUnion(ExprUnion e) {
  if (::flatbuffers::IsOutRange(e, ExprUnion::NONE, ExprUnion::Window)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExprUnion()[index];
}

template<typename T> struct ExprUnionTraits {
  static const ExprUnion enum_value = ExprUnion::NONE;
};

template<> struct ExprUnionTraits<ValueIndex> {
  static const ExprUnion enum_value = ExprUnion::ValueIndex;
};

template<> struct ExprUnionTraits<Column> {
  static const ExprUnion enum_value = ExprUnion::Column;
};

template<> struct ExprUnionTraits<Function> {
  static const ExprUnion enum_value = ExprUnion::Function;
};

template<> struct ExprUnionTraits<AllColumns> {
  static const ExprUnion enum_value = ExprUnion::AllColumns;
};

template<> struct ExprUnionTraits<Case> {
  static const ExprUnion enum_value = ExprUnion::Case;
};

template<> struct ExprUnionTraits<OrderByExpr> {
  static const ExprUnion enum_value = ExprUnion::OrderByExpr;
};

template<> struct ExprUnionTraits<Partition> {
  static const ExprUnion enum_value = ExprUnion::Partition;
};

template<> struct ExprUnionTraits<UnsetArgument> {
  static const ExprUnion enum_value = ExprUnion::UnsetArgument;
};

template<> struct ExprUnionTraits<Window> {
  static const ExprUnion enum_value = ExprUnion::Window;
};

bool VerifyExprUnion(::flatbuffers::Verifier &verifier, const void *obj, ExprUnion type);
bool VerifyExprUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ExprUnion> *types);

enum class JoinTy : int8_t {
  Inner = 0,
  LeftOuter = 1,
  RightOuter = 2,
  Full = 3,
  Cross = 4,
  MIN = Inner,
  MAX = Cross
};

inline const JoinTy (&EnumValuesJoinTy())[5] {
  static const JoinTy values[] = {
    JoinTy::Inner,
    JoinTy::LeftOuter,
    JoinTy::RightOuter,
    JoinTy::Full,
    JoinTy::Cross
  };
  return values;
}

inline const char * const *EnumNamesJoinTy() {
  static const char * const names[6] = {
    "Inner",
    "LeftOuter",
    "RightOuter",
    "Full",
    "Cross",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinTy(JoinTy e) {
  if (::flatbuffers::IsOutRange(e, JoinTy::Inner, JoinTy::Cross)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinTy()[index];
}

enum class Subcollection : uint8_t {
  NONE = 0,
  MvdbSubcollection = 1,
  WorklogSubcollection = 2,
  MIN = NONE,
  MAX = WorklogSubcollection
};

inline const Subcollection (&EnumValuesSubcollection())[3] {
  static const Subcollection values[] = {
    Subcollection::NONE,
    Subcollection::MvdbSubcollection,
    Subcollection::WorklogSubcollection
  };
  return values;
}

inline const char * const *EnumNamesSubcollection() {
  static const char * const names[4] = {
    "NONE",
    "MvdbSubcollection",
    "WorklogSubcollection",
    nullptr
  };
  return names;
}

inline const char *EnumNameSubcollection(Subcollection e) {
  if (::flatbuffers::IsOutRange(e, Subcollection::NONE, Subcollection::WorklogSubcollection)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSubcollection()[index];
}

template<typename T> struct SubcollectionTraits {
  static const Subcollection enum_value = Subcollection::NONE;
};

template<> struct SubcollectionTraits<MvdbSubcollection> {
  static const Subcollection enum_value = Subcollection::MvdbSubcollection;
};

template<> struct SubcollectionTraits<WorklogSubcollection> {
  static const Subcollection enum_value = Subcollection::WorklogSubcollection;
};

bool VerifySubcollection(::flatbuffers::Verifier &verifier, const void *obj, Subcollection type);
bool VerifySubcollectionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Subcollection> *types);

enum class TableSourceUnion : uint8_t {
  NONE = 0,
  DataCatalog = 1,
  Arrow = 2,
  GraphQuery = 3,
  QueryTableSource = 4,
  Vector = 5,
  MIN = NONE,
  MAX = Vector
};

inline const TableSourceUnion (&EnumValuesTableSourceUnion())[6] {
  static const TableSourceUnion values[] = {
    TableSourceUnion::NONE,
    TableSourceUnion::DataCatalog,
    TableSourceUnion::Arrow,
    TableSourceUnion::GraphQuery,
    TableSourceUnion::QueryTableSource,
    TableSourceUnion::Vector
  };
  return values;
}

inline const char * const *EnumNamesTableSourceUnion() {
  static const char * const names[7] = {
    "NONE",
    "DataCatalog",
    "Arrow",
    "GraphQuery",
    "QueryTableSource",
    "Vector",
    nullptr
  };
  return names;
}

inline const char *EnumNameTableSourceUnion(TableSourceUnion e) {
  if (::flatbuffers::IsOutRange(e, TableSourceUnion::NONE, TableSourceUnion::Vector)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTableSourceUnion()[index];
}

template<typename T> struct TableSourceUnionTraits {
  static const TableSourceUnion enum_value = TableSourceUnion::NONE;
};

template<> struct TableSourceUnionTraits<DataCatalog> {
  static const TableSourceUnion enum_value = TableSourceUnion::DataCatalog;
};

template<> struct TableSourceUnionTraits<Arrow> {
  static const TableSourceUnion enum_value = TableSourceUnion::Arrow;
};

template<> struct TableSourceUnionTraits<GraphQuery> {
  static const TableSourceUnion enum_value = TableSourceUnion::GraphQuery;
};

template<> struct TableSourceUnionTraits<QueryTableSource> {
  static const TableSourceUnion enum_value = TableSourceUnion::QueryTableSource;
};

template<> struct TableSourceUnionTraits<Vector> {
  static const TableSourceUnion enum_value = TableSourceUnion::Vector;
};

bool VerifyTableSourceUnion(::flatbuffers::Verifier &verifier, const void *obj, TableSourceUnion type);
bool VerifyTableSourceUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TableSourceUnion> *types);

enum class QueryElementOp : int8_t {
  Union = 0,
  Intersect = 1,
  Except = 2,
  MIN = Union,
  MAX = Except
};

inline const QueryElementOp (&EnumValuesQueryElementOp())[3] {
  static const QueryElementOp values[] = {
    QueryElementOp::Union,
    QueryElementOp::Intersect,
    QueryElementOp::Except
  };
  return values;
}

inline const char * const *EnumNamesQueryElementOp() {
  static const char * const names[4] = {
    "Union",
    "Intersect",
    "Except",
    nullptr
  };
  return names;
}

inline const char *EnumNameQueryElementOp(QueryElementOp e) {
  if (::flatbuffers::IsOutRange(e, QueryElementOp::Union, QueryElementOp::Except)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQueryElementOp()[index];
}

enum class QueryElementUnion : uint8_t {
  NONE = 0,
  UnaryQueryElement = 1,
  BinaryQueryElement = 2,
  UpdateQueryElement = 3,
  DeleteQueryElement = 4,
  MIN = NONE,
  MAX = DeleteQueryElement
};

inline const QueryElementUnion (&EnumValuesQueryElementUnion())[5] {
  static const QueryElementUnion values[] = {
    QueryElementUnion::NONE,
    QueryElementUnion::UnaryQueryElement,
    QueryElementUnion::BinaryQueryElement,
    QueryElementUnion::UpdateQueryElement,
    QueryElementUnion::DeleteQueryElement
  };
  return values;
}

inline const char * const *EnumNamesQueryElementUnion() {
  static const char * const names[6] = {
    "NONE",
    "UnaryQueryElement",
    "BinaryQueryElement",
    "UpdateQueryElement",
    "DeleteQueryElement",
    nullptr
  };
  return names;
}

inline const char *EnumNameQueryElementUnion(QueryElementUnion e) {
  if (::flatbuffers::IsOutRange(e, QueryElementUnion::NONE, QueryElementUnion::DeleteQueryElement)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQueryElementUnion()[index];
}

template<typename T> struct QueryElementUnionTraits {
  static const QueryElementUnion enum_value = QueryElementUnion::NONE;
};

template<> struct QueryElementUnionTraits<UnaryQueryElement> {
  static const QueryElementUnion enum_value = QueryElementUnion::UnaryQueryElement;
};

template<> struct QueryElementUnionTraits<BinaryQueryElement> {
  static const QueryElementUnion enum_value = QueryElementUnion::BinaryQueryElement;
};

template<> struct QueryElementUnionTraits<UpdateQueryElement> {
  static const QueryElementUnion enum_value = QueryElementUnion::UpdateQueryElement;
};

template<> struct QueryElementUnionTraits<DeleteQueryElement> {
  static const QueryElementUnion enum_value = QueryElementUnion::DeleteQueryElement;
};

bool VerifyQueryElementUnion(::flatbuffers::Verifier &verifier, const void *obj, QueryElementUnion type);
bool VerifyQueryElementUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<QueryElementUnion> *types);

enum class ParameterSlot : uint8_t {
  NONE = 0,
  Parameter = 1,
  ValueInstance = 2,
  MIN = NONE,
  MAX = ValueInstance
};

inline const ParameterSlot (&EnumValuesParameterSlot())[3] {
  static const ParameterSlot values[] = {
    ParameterSlot::NONE,
    ParameterSlot::Parameter,
    ParameterSlot::ValueInstance
  };
  return values;
}

inline const char * const *EnumNamesParameterSlot() {
  static const char * const names[4] = {
    "NONE",
    "Parameter",
    "ValueInstance",
    nullptr
  };
  return names;
}

inline const char *EnumNameParameterSlot(ParameterSlot e) {
  if (::flatbuffers::IsOutRange(e, ParameterSlot::NONE, ParameterSlot::ValueInstance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesParameterSlot()[index];
}

template<typename T> struct ParameterSlotTraits {
  static const ParameterSlot enum_value = ParameterSlot::NONE;
};

template<> struct ParameterSlotTraits<Parameter> {
  static const ParameterSlot enum_value = ParameterSlot::Parameter;
};

template<> struct ParameterSlotTraits<ValueInstance> {
  static const ParameterSlot enum_value = ParameterSlot::ValueInstance;
};

bool VerifyParameterSlot(::flatbuffers::Verifier &verifier, const void *obj, ParameterSlot type);
bool VerifyParameterSlotVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ParameterSlot> *types);

struct ValueIndex FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueIndexBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX = 4
  };
  uint32_t idx() const {
    return GetField<uint32_t>(VT_IDX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_IDX, 4) &&
           verifier.EndTable();
  }
};

struct ValueIndexBuilder {
  typedef ValueIndex Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idx(uint32_t idx) {
    fbb_.AddElement<uint32_t>(ValueIndex::VT_IDX, idx, 0);
  }
  explicit ValueIndexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueIndex>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueIndex> CreateValueIndex(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t idx = 0) {
  ValueIndexBuilder builder_(_fbb);
  builder_.add_idx(idx);
  return builder_.Finish();
}

struct ValueIndex::Traits {
  using type = ValueIndex;
  static auto constexpr Create = CreateValueIndex;
};

struct NullableUint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NullableUintBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  uint32_t v() const {
    return GetField<uint32_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_V, 4) &&
           verifier.EndTable();
  }
};

struct NullableUintBuilder {
  typedef NullableUint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(uint32_t v) {
    fbb_.AddElement<uint32_t>(NullableUint::VT_V, v, 0);
  }
  explicit NullableUintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NullableUint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NullableUint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NullableUint> CreateNullableUint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t v = 0) {
  NullableUintBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct NullableUint::Traits {
  using type = NullableUint;
  static auto constexpr Create = CreateNullableUint;
};

struct Column FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColumnBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE_HINT = 6,
    VT_SOURCE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  TypeHint type_hint() const {
    return static_cast<TypeHint>(GetField<int8_t>(VT_TYPE_HINT, 0));
  }
  const NullableUint *source() const {
    return GetPointer<const NullableUint *>(VT_SOURCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE_HINT, 1) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyTable(source()) &&
           verifier.EndTable();
  }
};

struct ColumnBuilder {
  typedef Column Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Column::VT_NAME, name);
  }
  void add_type_hint(TypeHint type_hint) {
    fbb_.AddElement<int8_t>(Column::VT_TYPE_HINT, static_cast<int8_t>(type_hint), 0);
  }
  void add_source(::flatbuffers::Offset<NullableUint> source) {
    fbb_.AddOffset(Column::VT_SOURCE, source);
  }
  explicit ColumnBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Column> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Column>(end);
    fbb_.Required(o, Column::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Column> CreateColumn(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    TypeHint type_hint = TypeHint::None,
    ::flatbuffers::Offset<NullableUint> source = 0) {
  ColumnBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_name(name);
  builder_.add_type_hint(type_hint);
  return builder_.Finish();
}

struct Column::Traits {
  using type = Column;
  static auto constexpr Create = CreateColumn;
};

inline ::flatbuffers::Offset<Column> CreateColumnDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    TypeHint type_hint = TypeHint::None,
    ::flatbuffers::Offset<NullableUint> source = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateColumn(
      _fbb,
      name__,
      type_hint,
      source);
}

struct Function FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FunctionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FN = 4,
    VT_PARAMETERS = 6
  };
  Fn fn() const {
    return static_cast<Fn>(GetField<int16_t>(VT_FN, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *>(VT_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FN, 2) &&
           VerifyOffsetRequired(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  typedef Function Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fn(Fn fn) {
    fbb_.AddElement<int16_t>(Function::VT_FN, static_cast<int16_t>(fn), 0);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> parameters) {
    fbb_.AddOffset(Function::VT_PARAMETERS, parameters);
  }
  explicit FunctionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Function>(end);
    fbb_.Required(o, Function::VT_PARAMETERS);
    return o;
  }
};

inline ::flatbuffers::Offset<Function> CreateFunction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Fn fn = Fn::None,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> parameters = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_fn(fn);
  return builder_.Finish();
}

struct Function::Traits {
  using type = Function;
  static auto constexpr Create = CreateFunction;
};

inline ::flatbuffers::Offset<Function> CreateFunctionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Fn fn = Fn::None,
    const std::vector<::flatbuffers::Offset<Expr>> *parameters = nullptr) {
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<Expr>>(*parameters) : 0;
  return CreateFunction(
      _fbb,
      fn,
      parameters__);
}

struct When FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhenBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND = 4,
    VT_VALUE = 6
  };
  const Expr *cond() const {
    return GetPointer<const Expr *>(VT_COND);
  }
  const Expr *value() const {
    return GetPointer<const Expr *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COND) &&
           verifier.VerifyTable(cond()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct WhenBuilder {
  typedef When Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond(::flatbuffers::Offset<Expr> cond) {
    fbb_.AddOffset(When::VT_COND, cond);
  }
  void add_value(::flatbuffers::Offset<Expr> value) {
    fbb_.AddOffset(When::VT_VALUE, value);
  }
  explicit WhenBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<When> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<When>(end);
    fbb_.Required(o, When::VT_COND);
    fbb_.Required(o, When::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<When> CreateWhen(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Expr> cond = 0,
    ::flatbuffers::Offset<Expr> value = 0) {
  WhenBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_cond(cond);
  return builder_.Finish();
}

struct When::Traits {
  using type = When;
  static auto constexpr Create = CreateWhen;
};

struct Case FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CaseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WHEN = 4,
    VT_ELSE_ = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<When>> *when() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<When>> *>(VT_WHEN);
  }
  const Expr *else_() const {
    return GetPointer<const Expr *>(VT_ELSE_);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_WHEN) &&
           verifier.VerifyVector(when()) &&
           verifier.VerifyVectorOfTables(when()) &&
           VerifyOffset(verifier, VT_ELSE_) &&
           verifier.VerifyTable(else_()) &&
           verifier.EndTable();
  }
};

struct CaseBuilder {
  typedef Case Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_when(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<When>>> when) {
    fbb_.AddOffset(Case::VT_WHEN, when);
  }
  void add_else_(::flatbuffers::Offset<Expr> else_) {
    fbb_.AddOffset(Case::VT_ELSE_, else_);
  }
  explicit CaseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Case> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Case>(end);
    fbb_.Required(o, Case::VT_WHEN);
    return o;
  }
};

inline ::flatbuffers::Offset<Case> CreateCase(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<When>>> when = 0,
    ::flatbuffers::Offset<Expr> else_ = 0) {
  CaseBuilder builder_(_fbb);
  builder_.add_else_(else_);
  builder_.add_when(when);
  return builder_.Finish();
}

struct Case::Traits {
  using type = Case;
  static auto constexpr Create = CreateCase;
};

inline ::flatbuffers::Offset<Case> CreateCaseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<When>> *when = nullptr,
    ::flatbuffers::Offset<Expr> else_ = 0) {
  auto when__ = when ? _fbb.CreateVector<::flatbuffers::Offset<When>>(*when) : 0;
  return CreateCase(
      _fbb,
      when__,
      else_);
}

struct AllColumns FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AllColumnsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4
  };
  const NullableUint *source() const {
    return GetPointer<const NullableUint *>(VT_SOURCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyTable(source()) &&
           verifier.EndTable();
  }
};

struct AllColumnsBuilder {
  typedef AllColumns Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(::flatbuffers::Offset<NullableUint> source) {
    fbb_.AddOffset(AllColumns::VT_SOURCE, source);
  }
  explicit AllColumnsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AllColumns> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AllColumns>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AllColumns> CreateAllColumns(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<NullableUint> source = 0) {
  AllColumnsBuilder builder_(_fbb);
  builder_.add_source(source);
  return builder_.Finish();
}

struct AllColumns::Traits {
  using type = AllColumns;
  static auto constexpr Create = CreateAllColumns;
};

struct Partition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartitionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPR = 4
  };
  const Expr *expr() const {
    return GetPointer<const Expr *>(VT_EXPR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EXPR) &&
           verifier.VerifyTable(expr()) &&
           verifier.EndTable();
  }
};

struct PartitionBuilder {
  typedef Partition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_expr(::flatbuffers::Offset<Expr> expr) {
    fbb_.AddOffset(Partition::VT_EXPR, expr);
  }
  explicit PartitionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Partition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Partition>(end);
    fbb_.Required(o, Partition::VT_EXPR);
    return o;
  }
};

inline ::flatbuffers::Offset<Partition> CreatePartition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Expr> expr = 0) {
  PartitionBuilder builder_(_fbb);
  builder_.add_expr(expr);
  return builder_.Finish();
}

struct Partition::Traits {
  using type = Partition;
  static auto constexpr Create = CreatePartition;
};

struct UnsetArgument FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnsetArgumentBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnsetArgumentBuilder {
  typedef UnsetArgument Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit UnsetArgumentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnsetArgument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnsetArgument>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnsetArgument> CreateUnsetArgument(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  UnsetArgumentBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsetArgument::Traits {
  using type = UnsetArgument;
  static auto constexpr Create = CreateUnsetArgument;
};

struct OrderByExpr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrderByExprBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER_BY = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>> *order_by() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>> *>(VT_ORDER_BY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ORDER_BY) &&
           verifier.VerifyVector(order_by()) &&
           verifier.VerifyVectorOfTables(order_by()) &&
           verifier.EndTable();
  }
};

struct OrderByExprBuilder {
  typedef OrderByExpr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_order_by(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>>> order_by) {
    fbb_.AddOffset(OrderByExpr::VT_ORDER_BY, order_by);
  }
  explicit OrderByExprBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrderByExpr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrderByExpr>(end);
    fbb_.Required(o, OrderByExpr::VT_ORDER_BY);
    return o;
  }
};

inline ::flatbuffers::Offset<OrderByExpr> CreateOrderByExpr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>>> order_by = 0) {
  OrderByExprBuilder builder_(_fbb);
  builder_.add_order_by(order_by);
  return builder_.Finish();
}

struct OrderByExpr::Traits {
  using type = OrderByExpr;
  static auto constexpr Create = CreateOrderByExpr;
};

inline ::flatbuffers::Offset<OrderByExpr> CreateOrderByExprDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<OrderBy>> *order_by = nullptr) {
  auto order_by__ = order_by ? _fbb.CreateVector<::flatbuffers::Offset<OrderBy>>(*order_by) : 0;
  return CreateOrderByExpr(
      _fbb,
      order_by__);
}

struct Window FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WindowBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUN = 4,
    VT_PARTITION = 6,
    VT_ORDER_BY = 8
  };
  const Function *fun() const {
    return GetPointer<const Function *>(VT_FUN);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *partition() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *>(VT_PARTITION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>> *order_by() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>> *>(VT_ORDER_BY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FUN) &&
           verifier.VerifyTable(fun()) &&
           VerifyOffset(verifier, VT_PARTITION) &&
           verifier.VerifyVector(partition()) &&
           verifier.VerifyVectorOfTables(partition()) &&
           VerifyOffset(verifier, VT_ORDER_BY) &&
           verifier.VerifyVector(order_by()) &&
           verifier.VerifyVectorOfTables(order_by()) &&
           verifier.EndTable();
  }
};

struct WindowBuilder {
  typedef Window Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fun(::flatbuffers::Offset<Function> fun) {
    fbb_.AddOffset(Window::VT_FUN, fun);
  }
  void add_partition(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> partition) {
    fbb_.AddOffset(Window::VT_PARTITION, partition);
  }
  void add_order_by(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>>> order_by) {
    fbb_.AddOffset(Window::VT_ORDER_BY, order_by);
  }
  explicit WindowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Window> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Window>(end);
    fbb_.Required(o, Window::VT_FUN);
    return o;
  }
};

inline ::flatbuffers::Offset<Window> CreateWindow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Function> fun = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> partition = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>>> order_by = 0) {
  WindowBuilder builder_(_fbb);
  builder_.add_order_by(order_by);
  builder_.add_partition(partition);
  builder_.add_fun(fun);
  return builder_.Finish();
}

struct Window::Traits {
  using type = Window;
  static auto constexpr Create = CreateWindow;
};

inline ::flatbuffers::Offset<Window> CreateWindowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Function> fun = 0,
    const std::vector<::flatbuffers::Offset<Expr>> *partition = nullptr,
    const std::vector<::flatbuffers::Offset<OrderBy>> *order_by = nullptr) {
  auto partition__ = partition ? _fbb.CreateVector<::flatbuffers::Offset<Expr>>(*partition) : 0;
  auto order_by__ = order_by ? _fbb.CreateVector<::flatbuffers::Offset<OrderBy>>(*order_by) : 0;
  return CreateWindow(
      _fbb,
      fun,
      partition__,
      order_by__);
}

struct Expr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExprBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRS_TYPE = 4,
    VT_EXPRS = 6
  };
  ExprUnion exprs_type() const {
    return static_cast<ExprUnion>(GetField<uint8_t>(VT_EXPRS_TYPE, 0));
  }
  const void *exprs() const {
    return GetPointer<const void *>(VT_EXPRS);
  }
  template<typename T> const T *exprs_as() const;
  const ValueIndex *exprs_as_ValueIndex() const {
    return exprs_type() == ExprUnion::ValueIndex ? static_cast<const ValueIndex *>(exprs()) : nullptr;
  }
  const Column *exprs_as_Column() const {
    return exprs_type() == ExprUnion::Column ? static_cast<const Column *>(exprs()) : nullptr;
  }
  const Function *exprs_as_Function() const {
    return exprs_type() == ExprUnion::Function ? static_cast<const Function *>(exprs()) : nullptr;
  }
  const AllColumns *exprs_as_AllColumns() const {
    return exprs_type() == ExprUnion::AllColumns ? static_cast<const AllColumns *>(exprs()) : nullptr;
  }
  const Case *exprs_as_Case() const {
    return exprs_type() == ExprUnion::Case ? static_cast<const Case *>(exprs()) : nullptr;
  }
  const OrderByExpr *exprs_as_OrderByExpr() const {
    return exprs_type() == ExprUnion::OrderByExpr ? static_cast<const OrderByExpr *>(exprs()) : nullptr;
  }
  const Partition *exprs_as_Partition() const {
    return exprs_type() == ExprUnion::Partition ? static_cast<const Partition *>(exprs()) : nullptr;
  }
  const UnsetArgument *exprs_as_UnsetArgument() const {
    return exprs_type() == ExprUnion::UnsetArgument ? static_cast<const UnsetArgument *>(exprs()) : nullptr;
  }
  const Window *exprs_as_Window() const {
    return exprs_type() == ExprUnion::Window ? static_cast<const Window *>(exprs()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXPRS_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_EXPRS) &&
           VerifyExprUnion(verifier, exprs(), exprs_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ValueIndex *Expr::exprs_as<ValueIndex>() const {
  return exprs_as_ValueIndex();
}

template<> inline const Column *Expr::exprs_as<Column>() const {
  return exprs_as_Column();
}

template<> inline const Function *Expr::exprs_as<Function>() const {
  return exprs_as_Function();
}

template<> inline const AllColumns *Expr::exprs_as<AllColumns>() const {
  return exprs_as_AllColumns();
}

template<> inline const Case *Expr::exprs_as<Case>() const {
  return exprs_as_Case();
}

template<> inline const OrderByExpr *Expr::exprs_as<OrderByExpr>() const {
  return exprs_as_OrderByExpr();
}

template<> inline const Partition *Expr::exprs_as<Partition>() const {
  return exprs_as_Partition();
}

template<> inline const UnsetArgument *Expr::exprs_as<UnsetArgument>() const {
  return exprs_as_UnsetArgument();
}

template<> inline const Window *Expr::exprs_as<Window>() const {
  return exprs_as_Window();
}

struct ExprBuilder {
  typedef Expr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_exprs_type(ExprUnion exprs_type) {
    fbb_.AddElement<uint8_t>(Expr::VT_EXPRS_TYPE, static_cast<uint8_t>(exprs_type), 0);
  }
  void add_exprs(::flatbuffers::Offset<void> exprs) {
    fbb_.AddOffset(Expr::VT_EXPRS, exprs);
  }
  explicit ExprBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Expr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Expr>(end);
    fbb_.Required(o, Expr::VT_EXPRS);
    return o;
  }
};

inline ::flatbuffers::Offset<Expr> CreateExpr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ExprUnion exprs_type = ExprUnion::NONE,
    ::flatbuffers::Offset<void> exprs = 0) {
  ExprBuilder builder_(_fbb);
  builder_.add_exprs(exprs);
  builder_.add_exprs_type(exprs_type);
  return builder_.Finish();
}

struct Expr::Traits {
  using type = Expr;
  static auto constexpr Create = CreateExpr;
};

struct Join FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC_IDX = 4,
    VT_DEST_IDX = 6,
    VT_SRC_COL = 8,
    VT_DEST_COL = 10,
    VT_TY = 12
  };
  uint32_t src_idx() const {
    return GetField<uint32_t>(VT_SRC_IDX, 0);
  }
  uint32_t dest_idx() const {
    return GetField<uint32_t>(VT_DEST_IDX, 0);
  }
  const ::flatbuffers::String *src_col() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SRC_COL);
  }
  const ::flatbuffers::String *dest_col() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEST_COL);
  }
  JoinTy ty() const {
    return static_cast<JoinTy>(GetField<int8_t>(VT_TY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SRC_IDX, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEST_IDX, 4) &&
           VerifyOffset(verifier, VT_SRC_COL) &&
           verifier.VerifyString(src_col()) &&
           VerifyOffset(verifier, VT_DEST_COL) &&
           verifier.VerifyString(dest_col()) &&
           VerifyField<int8_t>(verifier, VT_TY, 1) &&
           verifier.EndTable();
  }
};

struct JoinBuilder {
  typedef Join Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_src_idx(uint32_t src_idx) {
    fbb_.AddElement<uint32_t>(Join::VT_SRC_IDX, src_idx, 0);
  }
  void add_dest_idx(uint32_t dest_idx) {
    fbb_.AddElement<uint32_t>(Join::VT_DEST_IDX, dest_idx, 0);
  }
  void add_src_col(::flatbuffers::Offset<::flatbuffers::String> src_col) {
    fbb_.AddOffset(Join::VT_SRC_COL, src_col);
  }
  void add_dest_col(::flatbuffers::Offset<::flatbuffers::String> dest_col) {
    fbb_.AddOffset(Join::VT_DEST_COL, dest_col);
  }
  void add_ty(JoinTy ty) {
    fbb_.AddElement<int8_t>(Join::VT_TY, static_cast<int8_t>(ty), 0);
  }
  explicit JoinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Join> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Join>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Join> CreateJoin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t src_idx = 0,
    uint32_t dest_idx = 0,
    ::flatbuffers::Offset<::flatbuffers::String> src_col = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dest_col = 0,
    JoinTy ty = JoinTy::Inner) {
  JoinBuilder builder_(_fbb);
  builder_.add_dest_col(dest_col);
  builder_.add_src_col(src_col);
  builder_.add_dest_idx(dest_idx);
  builder_.add_src_idx(src_idx);
  builder_.add_ty(ty);
  return builder_.Finish();
}

struct Join::Traits {
  using type = Join;
  static auto constexpr Create = CreateJoin;
};

inline ::flatbuffers::Offset<Join> CreateJoinDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t src_idx = 0,
    uint32_t dest_idx = 0,
    const char *src_col = nullptr,
    const char *dest_col = nullptr,
    JoinTy ty = JoinTy::Inner) {
  auto src_col__ = src_col ? _fbb.CreateString(src_col) : 0;
  auto dest_col__ = dest_col ? _fbb.CreateString(dest_col) : 0;
  return CreateJoin(
      _fbb,
      src_idx,
      dest_idx,
      src_col__,
      dest_col__,
      ty);
}

struct Arrow FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrowBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ArrowBuilder {
  typedef Arrow Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(Arrow::VT_VALUE, value);
  }
  explicit ArrowBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Arrow> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Arrow>(end);
    fbb_.Required(o, Arrow::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<Arrow> CreateArrow(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0) {
  ArrowBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Arrow::Traits {
  using type = Arrow;
  static auto constexpr Create = CreateArrow;
};

inline ::flatbuffers::Offset<Arrow> CreateArrowDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return CreateArrow(
      _fbb,
      value__);
}

struct MvdbSubcollection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MvdbSubcollectionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCOLLECTION = 4
  };
  const ::flatbuffers::String *subcollection() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUBCOLLECTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SUBCOLLECTION) &&
           verifier.VerifyString(subcollection()) &&
           verifier.EndTable();
  }
};

struct MvdbSubcollectionBuilder {
  typedef MvdbSubcollection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subcollection(::flatbuffers::Offset<::flatbuffers::String> subcollection) {
    fbb_.AddOffset(MvdbSubcollection::VT_SUBCOLLECTION, subcollection);
  }
  explicit MvdbSubcollectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MvdbSubcollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MvdbSubcollection>(end);
    fbb_.Required(o, MvdbSubcollection::VT_SUBCOLLECTION);
    return o;
  }
};

inline ::flatbuffers::Offset<MvdbSubcollection> CreateMvdbSubcollection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> subcollection = 0) {
  MvdbSubcollectionBuilder builder_(_fbb);
  builder_.add_subcollection(subcollection);
  return builder_.Finish();
}

struct MvdbSubcollection::Traits {
  using type = MvdbSubcollection;
  static auto constexpr Create = CreateMvdbSubcollection;
};

inline ::flatbuffers::Offset<MvdbSubcollection> CreateMvdbSubcollectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *subcollection = nullptr) {
  auto subcollection__ = subcollection ? _fbb.CreateString(subcollection) : 0;
  return CreateMvdbSubcollection(
      _fbb,
      subcollection__);
}

struct WorklogSubcollection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WorklogSubcollectionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDX = 4
  };
  uint32_t idx() const {
    return GetField<uint32_t>(VT_IDX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_IDX, 4) &&
           verifier.EndTable();
  }
};

struct WorklogSubcollectionBuilder {
  typedef WorklogSubcollection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idx(uint32_t idx) {
    fbb_.AddElement<uint32_t>(WorklogSubcollection::VT_IDX, idx, 0);
  }
  explicit WorklogSubcollectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WorklogSubcollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WorklogSubcollection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WorklogSubcollection> CreateWorklogSubcollection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t idx = 0) {
  WorklogSubcollectionBuilder builder_(_fbb);
  builder_.add_idx(idx);
  return builder_.Finish();
}

struct WorklogSubcollection::Traits {
  using type = WorklogSubcollection;
  static auto constexpr Create = CreateWorklogSubcollection;
};

struct DataCatalog FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataCatalogBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SUBCOLLECTION_TYPE = 6,
    VT_SUBCOLLECTION = 8,
    VT_REVISION = 10
  };
  const ObjectId *id() const {
    return GetPointer<const ObjectId *>(VT_ID);
  }
  Subcollection subcollection_type() const {
    return static_cast<Subcollection>(GetField<uint8_t>(VT_SUBCOLLECTION_TYPE, 0));
  }
  const void *subcollection() const {
    return GetPointer<const void *>(VT_SUBCOLLECTION);
  }
  template<typename T> const T *subcollection_as() const;
  const MvdbSubcollection *subcollection_as_MvdbSubcollection() const {
    return subcollection_type() == Subcollection::MvdbSubcollection ? static_cast<const MvdbSubcollection *>(subcollection()) : nullptr;
  }
  const WorklogSubcollection *subcollection_as_WorklogSubcollection() const {
    return subcollection_type() == Subcollection::WorklogSubcollection ? static_cast<const WorklogSubcollection *>(subcollection()) : nullptr;
  }
  const ContentId *revision() const {
    return GetPointer<const ContentId *>(VT_REVISION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint8_t>(verifier, VT_SUBCOLLECTION_TYPE, 1) &&
           VerifyOffset(verifier, VT_SUBCOLLECTION) &&
           VerifySubcollection(verifier, subcollection(), subcollection_type()) &&
           VerifyOffset(verifier, VT_REVISION) &&
           verifier.VerifyTable(revision()) &&
           verifier.EndTable();
  }
};

template<> inline const MvdbSubcollection *DataCatalog::subcollection_as<MvdbSubcollection>() const {
  return subcollection_as_MvdbSubcollection();
}

template<> inline const WorklogSubcollection *DataCatalog::subcollection_as<WorklogSubcollection>() const {
  return subcollection_as_WorklogSubcollection();
}

struct DataCatalogBuilder {
  typedef DataCatalog Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ObjectId> id) {
    fbb_.AddOffset(DataCatalog::VT_ID, id);
  }
  void add_subcollection_type(Subcollection subcollection_type) {
    fbb_.AddElement<uint8_t>(DataCatalog::VT_SUBCOLLECTION_TYPE, static_cast<uint8_t>(subcollection_type), 0);
  }
  void add_subcollection(::flatbuffers::Offset<void> subcollection) {
    fbb_.AddOffset(DataCatalog::VT_SUBCOLLECTION, subcollection);
  }
  void add_revision(::flatbuffers::Offset<ContentId> revision) {
    fbb_.AddOffset(DataCatalog::VT_REVISION, revision);
  }
  explicit DataCatalogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataCatalog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataCatalog>(end);
    fbb_.Required(o, DataCatalog::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<DataCatalog> CreateDataCatalog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    Subcollection subcollection_type = Subcollection::NONE,
    ::flatbuffers::Offset<void> subcollection = 0,
    ::flatbuffers::Offset<ContentId> revision = 0) {
  DataCatalogBuilder builder_(_fbb);
  builder_.add_revision(revision);
  builder_.add_subcollection(subcollection);
  builder_.add_id(id);
  builder_.add_subcollection_type(subcollection_type);
  return builder_.Finish();
}

struct DataCatalog::Traits {
  using type = DataCatalog;
  static auto constexpr Create = CreateDataCatalog;
};

struct QueryTableSource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QueryTableSourceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Q = 4
  };
  const Query *q() const {
    return GetPointer<const Query *>(VT_Q);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_Q) &&
           verifier.VerifyTable(q()) &&
           verifier.EndTable();
  }
};

struct QueryTableSourceBuilder {
  typedef QueryTableSource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_q(::flatbuffers::Offset<Query> q) {
    fbb_.AddOffset(QueryTableSource::VT_Q, q);
  }
  explicit QueryTableSourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QueryTableSource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QueryTableSource>(end);
    fbb_.Required(o, QueryTableSource::VT_Q);
    return o;
  }
};

inline ::flatbuffers::Offset<QueryTableSource> CreateQueryTableSource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Query> q = 0) {
  QueryTableSourceBuilder builder_(_fbb);
  builder_.add_q(q);
  return builder_.Finish();
}

struct QueryTableSource::Traits {
  using type = QueryTableSource;
  static auto constexpr Create = CreateQueryTableSource;
};

struct Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VectorBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUERY = 4,
    VT_LIMIT = 6,
    VT_IDS = 8,
    VT_MAX_DISTANCE = 10
  };
  const ::flatbuffers::String *query() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUERY);
  }
  const NullableUint *limit() const {
    return GetPointer<const NullableUint *>(VT_LIMIT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *ids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *>(VT_IDS);
  }
  float max_distance() const {
    return GetField<float>(VT_MAX_DISTANCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_QUERY) &&
           verifier.VerifyString(query()) &&
           VerifyOffset(verifier, VT_LIMIT) &&
           verifier.VerifyTable(limit()) &&
           VerifyOffsetRequired(verifier, VT_IDS) &&
           verifier.VerifyVector(ids()) &&
           verifier.VerifyVectorOfTables(ids()) &&
           VerifyField<float>(verifier, VT_MAX_DISTANCE, 4) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  typedef Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_query(::flatbuffers::Offset<::flatbuffers::String> query) {
    fbb_.AddOffset(Vector::VT_QUERY, query);
  }
  void add_limit(::flatbuffers::Offset<NullableUint> limit) {
    fbb_.AddOffset(Vector::VT_LIMIT, limit);
  }
  void add_ids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> ids) {
    fbb_.AddOffset(Vector::VT_IDS, ids);
  }
  void add_max_distance(float max_distance) {
    fbb_.AddElement<float>(Vector::VT_MAX_DISTANCE, max_distance, 0.0f);
  }
  explicit VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vector>(end);
    fbb_.Required(o, Vector::VT_QUERY);
    fbb_.Required(o, Vector::VT_IDS);
    return o;
  }
};

inline ::flatbuffers::Offset<Vector> CreateVector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> query = 0,
    ::flatbuffers::Offset<NullableUint> limit = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> ids = 0,
    float max_distance = 0.0f) {
  VectorBuilder builder_(_fbb);
  builder_.add_max_distance(max_distance);
  builder_.add_ids(ids);
  builder_.add_limit(limit);
  builder_.add_query(query);
  return builder_.Finish();
}

struct Vector::Traits {
  using type = Vector;
  static auto constexpr Create = CreateVector;
};

inline ::flatbuffers::Offset<Vector> CreateVectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *query = nullptr,
    ::flatbuffers::Offset<NullableUint> limit = 0,
    const std::vector<::flatbuffers::Offset<ObjectId>> *ids = nullptr,
    float max_distance = 0.0f) {
  auto query__ = query ? _fbb.CreateString(query) : 0;
  auto ids__ = ids ? _fbb.CreateVector<::flatbuffers::Offset<ObjectId>>(*ids) : 0;
  return CreateVector(
      _fbb,
      query__,
      limit,
      ids__,
      max_distance);
}

struct TableSource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TableSourceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T_TYPE = 4,
    VT_T = 6,
    VT_FIELDS = 8,
    VT_FILTER = 10,
    VT_ORDER_BY = 12,
    VT_GROUP_BY = 14
  };
  TableSourceUnion t_type() const {
    return static_cast<TableSourceUnion>(GetField<uint8_t>(VT_T_TYPE, 0));
  }
  const void *t() const {
    return GetPointer<const void *>(VT_T);
  }
  template<typename T> const T *t_as() const;
  const DataCatalog *t_as_DataCatalog() const {
    return t_type() == TableSourceUnion::DataCatalog ? static_cast<const DataCatalog *>(t()) : nullptr;
  }
  const Arrow *t_as_Arrow() const {
    return t_type() == TableSourceUnion::Arrow ? static_cast<const Arrow *>(t()) : nullptr;
  }
  const GraphQuery *t_as_GraphQuery() const {
    return t_type() == TableSourceUnion::GraphQuery ? static_cast<const GraphQuery *>(t()) : nullptr;
  }
  const QueryTableSource *t_as_QueryTableSource() const {
    return t_type() == TableSourceUnion::QueryTableSource ? static_cast<const QueryTableSource *>(t()) : nullptr;
  }
  const Vector *t_as_Vector() const {
    return t_type() == TableSourceUnion::Vector ? static_cast<const Vector *>(t()) : nullptr;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *>(VT_FIELDS);
  }
  const Function *filter() const {
    return GetPointer<const Function *>(VT_FILTER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>> *order_by() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>> *>(VT_ORDER_BY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *group_by() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *>(VT_GROUP_BY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_T_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_T) &&
           VerifyTableSourceUnion(verifier, t(), t_type()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyOffset(verifier, VT_FILTER) &&
           verifier.VerifyTable(filter()) &&
           VerifyOffset(verifier, VT_ORDER_BY) &&
           verifier.VerifyVector(order_by()) &&
           verifier.VerifyVectorOfTables(order_by()) &&
           VerifyOffset(verifier, VT_GROUP_BY) &&
           verifier.VerifyVector(group_by()) &&
           verifier.VerifyVectorOfTables(group_by()) &&
           verifier.EndTable();
  }
};

template<> inline const DataCatalog *TableSource::t_as<DataCatalog>() const {
  return t_as_DataCatalog();
}

template<> inline const Arrow *TableSource::t_as<Arrow>() const {
  return t_as_Arrow();
}

template<> inline const GraphQuery *TableSource::t_as<GraphQuery>() const {
  return t_as_GraphQuery();
}

template<> inline const QueryTableSource *TableSource::t_as<QueryTableSource>() const {
  return t_as_QueryTableSource();
}

template<> inline const Vector *TableSource::t_as<Vector>() const {
  return t_as_Vector();
}

struct TableSourceBuilder {
  typedef TableSource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_t_type(TableSourceUnion t_type) {
    fbb_.AddElement<uint8_t>(TableSource::VT_T_TYPE, static_cast<uint8_t>(t_type), 0);
  }
  void add_t(::flatbuffers::Offset<void> t) {
    fbb_.AddOffset(TableSource::VT_T, t);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> fields) {
    fbb_.AddOffset(TableSource::VT_FIELDS, fields);
  }
  void add_filter(::flatbuffers::Offset<Function> filter) {
    fbb_.AddOffset(TableSource::VT_FILTER, filter);
  }
  void add_order_by(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>>> order_by) {
    fbb_.AddOffset(TableSource::VT_ORDER_BY, order_by);
  }
  void add_group_by(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> group_by) {
    fbb_.AddOffset(TableSource::VT_GROUP_BY, group_by);
  }
  explicit TableSourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TableSource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TableSource>(end);
    fbb_.Required(o, TableSource::VT_T);
    return o;
  }
};

inline ::flatbuffers::Offset<TableSource> CreateTableSource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    TableSourceUnion t_type = TableSourceUnion::NONE,
    ::flatbuffers::Offset<void> t = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> fields = 0,
    ::flatbuffers::Offset<Function> filter = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OrderBy>>> order_by = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> group_by = 0) {
  TableSourceBuilder builder_(_fbb);
  builder_.add_group_by(group_by);
  builder_.add_order_by(order_by);
  builder_.add_filter(filter);
  builder_.add_fields(fields);
  builder_.add_t(t);
  builder_.add_t_type(t_type);
  return builder_.Finish();
}

struct TableSource::Traits {
  using type = TableSource;
  static auto constexpr Create = CreateTableSource;
};

inline ::flatbuffers::Offset<TableSource> CreateTableSourceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    TableSourceUnion t_type = TableSourceUnion::NONE,
    ::flatbuffers::Offset<void> t = 0,
    const std::vector<::flatbuffers::Offset<Expr>> *fields = nullptr,
    ::flatbuffers::Offset<Function> filter = 0,
    const std::vector<::flatbuffers::Offset<OrderBy>> *order_by = nullptr,
    const std::vector<::flatbuffers::Offset<Expr>> *group_by = nullptr) {
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<Expr>>(*fields) : 0;
  auto order_by__ = order_by ? _fbb.CreateVector<::flatbuffers::Offset<OrderBy>>(*order_by) : 0;
  auto group_by__ = group_by ? _fbb.CreateVector<::flatbuffers::Offset<Expr>>(*group_by) : 0;
  return CreateTableSource(
      _fbb,
      t_type,
      t,
      fields__,
      filter,
      order_by__,
      group_by__);
}

struct TableOrderBy FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TableOrderByBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_ORDER_BY = 6,
    VT_USE_SOURCE = 8
  };
  uint32_t source() const {
    return GetField<uint32_t>(VT_SOURCE, 0);
  }
  const OrderBy *order_by() const {
    return GetPointer<const OrderBy *>(VT_ORDER_BY);
  }
  bool use_source() const {
    return GetField<uint8_t>(VT_USE_SOURCE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SOURCE, 4) &&
           VerifyOffsetRequired(verifier, VT_ORDER_BY) &&
           verifier.VerifyTable(order_by()) &&
           VerifyField<uint8_t>(verifier, VT_USE_SOURCE, 1) &&
           verifier.EndTable();
  }
};

struct TableOrderByBuilder {
  typedef TableOrderBy Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(uint32_t source) {
    fbb_.AddElement<uint32_t>(TableOrderBy::VT_SOURCE, source, 0);
  }
  void add_order_by(::flatbuffers::Offset<OrderBy> order_by) {
    fbb_.AddOffset(TableOrderBy::VT_ORDER_BY, order_by);
  }
  void add_use_source(bool use_source) {
    fbb_.AddElement<uint8_t>(TableOrderBy::VT_USE_SOURCE, static_cast<uint8_t>(use_source), 1);
  }
  explicit TableOrderByBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TableOrderBy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TableOrderBy>(end);
    fbb_.Required(o, TableOrderBy::VT_ORDER_BY);
    return o;
  }
};

inline ::flatbuffers::Offset<TableOrderBy> CreateTableOrderBy(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t source = 0,
    ::flatbuffers::Offset<OrderBy> order_by = 0,
    bool use_source = true) {
  TableOrderByBuilder builder_(_fbb);
  builder_.add_order_by(order_by);
  builder_.add_source(source);
  builder_.add_use_source(use_source);
  return builder_.Finish();
}

struct TableOrderBy::Traits {
  using type = TableOrderBy;
  static auto constexpr Create = CreateTableOrderBy;
};

struct Distinct FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DistinctBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ON = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *on() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *>(VT_ON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ON) &&
           verifier.VerifyVector(on()) &&
           verifier.VerifyVectorOfTables(on()) &&
           verifier.EndTable();
  }
};

struct DistinctBuilder {
  typedef Distinct Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_on(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> on) {
    fbb_.AddOffset(Distinct::VT_ON, on);
  }
  explicit DistinctBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Distinct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Distinct>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Distinct> CreateDistinct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> on = 0) {
  DistinctBuilder builder_(_fbb);
  builder_.add_on(on);
  return builder_.Finish();
}

struct Distinct::Traits {
  using type = Distinct;
  static auto constexpr Create = CreateDistinct;
};

inline ::flatbuffers::Offset<Distinct> CreateDistinctDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Expr>> *on = nullptr) {
  auto on__ = on ? _fbb.CreateVector<::flatbuffers::Offset<Expr>>(*on) : 0;
  return CreateDistinct(
      _fbb,
      on__);
}

struct UnaryQueryElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnaryQueryElementBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCES = 4,
    VT_JOINS = 6,
    VT_FILTER = 8,
    VT_FIELDS = 10,
    VT_ORDER_BY = 12,
    VT_GROUP_BY = 14,
    VT_DISTINCT = 16,
    VT_LIMIT = 18
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<TableSource>> *sources() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<TableSource>> *>(VT_SOURCES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Join>> *joins() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Join>> *>(VT_JOINS);
  }
  const Function *filter() const {
    return GetPointer<const Function *>(VT_FILTER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *>(VT_FIELDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<TableOrderBy>> *order_by() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<TableOrderBy>> *>(VT_ORDER_BY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *group_by() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Expr>> *>(VT_GROUP_BY);
  }
  const Distinct *distinct() const {
    return GetPointer<const Distinct *>(VT_DISTINCT);
  }
  uint32_t limit() const {
    return GetField<uint32_t>(VT_LIMIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SOURCES) &&
           verifier.VerifyVector(sources()) &&
           verifier.VerifyVectorOfTables(sources()) &&
           VerifyOffset(verifier, VT_JOINS) &&
           verifier.VerifyVector(joins()) &&
           verifier.VerifyVectorOfTables(joins()) &&
           VerifyOffset(verifier, VT_FILTER) &&
           verifier.VerifyTable(filter()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyOffset(verifier, VT_ORDER_BY) &&
           verifier.VerifyVector(order_by()) &&
           verifier.VerifyVectorOfTables(order_by()) &&
           VerifyOffset(verifier, VT_GROUP_BY) &&
           verifier.VerifyVector(group_by()) &&
           verifier.VerifyVectorOfTables(group_by()) &&
           VerifyOffset(verifier, VT_DISTINCT) &&
           verifier.VerifyTable(distinct()) &&
           VerifyField<uint32_t>(verifier, VT_LIMIT, 4) &&
           verifier.EndTable();
  }
};

struct UnaryQueryElementBuilder {
  typedef UnaryQueryElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sources(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TableSource>>> sources) {
    fbb_.AddOffset(UnaryQueryElement::VT_SOURCES, sources);
  }
  void add_joins(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Join>>> joins) {
    fbb_.AddOffset(UnaryQueryElement::VT_JOINS, joins);
  }
  void add_filter(::flatbuffers::Offset<Function> filter) {
    fbb_.AddOffset(UnaryQueryElement::VT_FILTER, filter);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> fields) {
    fbb_.AddOffset(UnaryQueryElement::VT_FIELDS, fields);
  }
  void add_order_by(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TableOrderBy>>> order_by) {
    fbb_.AddOffset(UnaryQueryElement::VT_ORDER_BY, order_by);
  }
  void add_group_by(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> group_by) {
    fbb_.AddOffset(UnaryQueryElement::VT_GROUP_BY, group_by);
  }
  void add_distinct(::flatbuffers::Offset<Distinct> distinct) {
    fbb_.AddOffset(UnaryQueryElement::VT_DISTINCT, distinct);
  }
  void add_limit(uint32_t limit) {
    fbb_.AddElement<uint32_t>(UnaryQueryElement::VT_LIMIT, limit, 0);
  }
  explicit UnaryQueryElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnaryQueryElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnaryQueryElement>(end);
    fbb_.Required(o, UnaryQueryElement::VT_SOURCES);
    return o;
  }
};

inline ::flatbuffers::Offset<UnaryQueryElement> CreateUnaryQueryElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TableSource>>> sources = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Join>>> joins = 0,
    ::flatbuffers::Offset<Function> filter = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TableOrderBy>>> order_by = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Expr>>> group_by = 0,
    ::flatbuffers::Offset<Distinct> distinct = 0,
    uint32_t limit = 0) {
  UnaryQueryElementBuilder builder_(_fbb);
  builder_.add_limit(limit);
  builder_.add_distinct(distinct);
  builder_.add_group_by(group_by);
  builder_.add_order_by(order_by);
  builder_.add_fields(fields);
  builder_.add_filter(filter);
  builder_.add_joins(joins);
  builder_.add_sources(sources);
  return builder_.Finish();
}

struct UnaryQueryElement::Traits {
  using type = UnaryQueryElement;
  static auto constexpr Create = CreateUnaryQueryElement;
};

inline ::flatbuffers::Offset<UnaryQueryElement> CreateUnaryQueryElementDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<TableSource>> *sources = nullptr,
    const std::vector<::flatbuffers::Offset<Join>> *joins = nullptr,
    ::flatbuffers::Offset<Function> filter = 0,
    const std::vector<::flatbuffers::Offset<Expr>> *fields = nullptr,
    const std::vector<::flatbuffers::Offset<TableOrderBy>> *order_by = nullptr,
    const std::vector<::flatbuffers::Offset<Expr>> *group_by = nullptr,
    ::flatbuffers::Offset<Distinct> distinct = 0,
    uint32_t limit = 0) {
  auto sources__ = sources ? _fbb.CreateVector<::flatbuffers::Offset<TableSource>>(*sources) : 0;
  auto joins__ = joins ? _fbb.CreateVector<::flatbuffers::Offset<Join>>(*joins) : 0;
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<Expr>>(*fields) : 0;
  auto order_by__ = order_by ? _fbb.CreateVector<::flatbuffers::Offset<TableOrderBy>>(*order_by) : 0;
  auto group_by__ = group_by ? _fbb.CreateVector<::flatbuffers::Offset<Expr>>(*group_by) : 0;
  return CreateUnaryQueryElement(
      _fbb,
      sources__,
      joins__,
      filter,
      fields__,
      order_by__,
      group_by__,
      distinct,
      limit);
}

struct BinaryQueryElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BinaryQueryElementBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_LHS = 6,
    VT_RHS = 8
  };
  QueryElementOp op() const {
    return static_cast<QueryElementOp>(GetField<int8_t>(VT_OP, 0));
  }
  const QueryElement *lhs() const {
    return GetPointer<const QueryElement *>(VT_LHS);
  }
  const QueryElement *rhs() const {
    return GetPointer<const QueryElement *>(VT_RHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OP, 1) &&
           VerifyOffsetRequired(verifier, VT_LHS) &&
           verifier.VerifyTable(lhs()) &&
           VerifyOffsetRequired(verifier, VT_RHS) &&
           verifier.VerifyTable(rhs()) &&
           verifier.EndTable();
  }
};

struct BinaryQueryElementBuilder {
  typedef BinaryQueryElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op(QueryElementOp op) {
    fbb_.AddElement<int8_t>(BinaryQueryElement::VT_OP, static_cast<int8_t>(op), 0);
  }
  void add_lhs(::flatbuffers::Offset<QueryElement> lhs) {
    fbb_.AddOffset(BinaryQueryElement::VT_LHS, lhs);
  }
  void add_rhs(::flatbuffers::Offset<QueryElement> rhs) {
    fbb_.AddOffset(BinaryQueryElement::VT_RHS, rhs);
  }
  explicit BinaryQueryElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BinaryQueryElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BinaryQueryElement>(end);
    fbb_.Required(o, BinaryQueryElement::VT_LHS);
    fbb_.Required(o, BinaryQueryElement::VT_RHS);
    return o;
  }
};

inline ::flatbuffers::Offset<BinaryQueryElement> CreateBinaryQueryElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    QueryElementOp op = QueryElementOp::Union,
    ::flatbuffers::Offset<QueryElement> lhs = 0,
    ::flatbuffers::Offset<QueryElement> rhs = 0) {
  BinaryQueryElementBuilder builder_(_fbb);
  builder_.add_rhs(rhs);
  builder_.add_lhs(lhs);
  builder_.add_op(op);
  return builder_.Finish();
}

struct BinaryQueryElement::Traits {
  using type = BinaryQueryElement;
  static auto constexpr Create = CreateBinaryQueryElement;
};

struct SetExpr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetExprBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COL = 4,
    VT_EXPR = 6
  };
  const ::flatbuffers::String *col() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COL);
  }
  const Expr *expr() const {
    return GetPointer<const Expr *>(VT_EXPR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COL) &&
           verifier.VerifyString(col()) &&
           VerifyOffsetRequired(verifier, VT_EXPR) &&
           verifier.VerifyTable(expr()) &&
           verifier.EndTable();
  }
};

struct SetExprBuilder {
  typedef SetExpr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_col(::flatbuffers::Offset<::flatbuffers::String> col) {
    fbb_.AddOffset(SetExpr::VT_COL, col);
  }
  void add_expr(::flatbuffers::Offset<Expr> expr) {
    fbb_.AddOffset(SetExpr::VT_EXPR, expr);
  }
  explicit SetExprBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetExpr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetExpr>(end);
    fbb_.Required(o, SetExpr::VT_COL);
    fbb_.Required(o, SetExpr::VT_EXPR);
    return o;
  }
};

inline ::flatbuffers::Offset<SetExpr> CreateSetExpr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> col = 0,
    ::flatbuffers::Offset<Expr> expr = 0) {
  SetExprBuilder builder_(_fbb);
  builder_.add_expr(expr);
  builder_.add_col(col);
  return builder_.Finish();
}

struct SetExpr::Traits {
  using type = SetExpr;
  static auto constexpr Create = CreateSetExpr;
};

inline ::flatbuffers::Offset<SetExpr> CreateSetExprDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *col = nullptr,
    ::flatbuffers::Offset<Expr> expr = 0) {
  auto col__ = col ? _fbb.CreateString(col) : 0;
  return CreateSetExpr(
      _fbb,
      col__,
      expr);
}

struct UpdateQueryElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UpdateQueryElementBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_TYPE = 4,
    VT_SOURCE = 6,
    VT_SETS = 8,
    VT_FILTER = 10
  };
  TableSourceUnion source_type() const {
    return static_cast<TableSourceUnion>(GetField<uint8_t>(VT_SOURCE_TYPE, 0));
  }
  const void *source() const {
    return GetPointer<const void *>(VT_SOURCE);
  }
  template<typename T> const T *source_as() const;
  const DataCatalog *source_as_DataCatalog() const {
    return source_type() == TableSourceUnion::DataCatalog ? static_cast<const DataCatalog *>(source()) : nullptr;
  }
  const Arrow *source_as_Arrow() const {
    return source_type() == TableSourceUnion::Arrow ? static_cast<const Arrow *>(source()) : nullptr;
  }
  const GraphQuery *source_as_GraphQuery() const {
    return source_type() == TableSourceUnion::GraphQuery ? static_cast<const GraphQuery *>(source()) : nullptr;
  }
  const QueryTableSource *source_as_QueryTableSource() const {
    return source_type() == TableSourceUnion::QueryTableSource ? static_cast<const QueryTableSource *>(source()) : nullptr;
  }
  const Vector *source_as_Vector() const {
    return source_type() == TableSourceUnion::Vector ? static_cast<const Vector *>(source()) : nullptr;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<SetExpr>> *sets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SetExpr>> *>(VT_SETS);
  }
  const Function *filter() const {
    return GetPointer<const Function *>(VT_FILTER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SOURCE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           VerifyTableSourceUnion(verifier, source(), source_type()) &&
           VerifyOffsetRequired(verifier, VT_SETS) &&
           verifier.VerifyVector(sets()) &&
           verifier.VerifyVectorOfTables(sets()) &&
           VerifyOffset(verifier, VT_FILTER) &&
           verifier.VerifyTable(filter()) &&
           verifier.EndTable();
  }
};

template<> inline const DataCatalog *UpdateQueryElement::source_as<DataCatalog>() const {
  return source_as_DataCatalog();
}

template<> inline const Arrow *UpdateQueryElement::source_as<Arrow>() const {
  return source_as_Arrow();
}

template<> inline const GraphQuery *UpdateQueryElement::source_as<GraphQuery>() const {
  return source_as_GraphQuery();
}

template<> inline const QueryTableSource *UpdateQueryElement::source_as<QueryTableSource>() const {
  return source_as_QueryTableSource();
}

template<> inline const Vector *UpdateQueryElement::source_as<Vector>() const {
  return source_as_Vector();
}

struct UpdateQueryElementBuilder {
  typedef UpdateQueryElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source_type(TableSourceUnion source_type) {
    fbb_.AddElement<uint8_t>(UpdateQueryElement::VT_SOURCE_TYPE, static_cast<uint8_t>(source_type), 0);
  }
  void add_source(::flatbuffers::Offset<void> source) {
    fbb_.AddOffset(UpdateQueryElement::VT_SOURCE, source);
  }
  void add_sets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SetExpr>>> sets) {
    fbb_.AddOffset(UpdateQueryElement::VT_SETS, sets);
  }
  void add_filter(::flatbuffers::Offset<Function> filter) {
    fbb_.AddOffset(UpdateQueryElement::VT_FILTER, filter);
  }
  explicit UpdateQueryElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UpdateQueryElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UpdateQueryElement>(end);
    fbb_.Required(o, UpdateQueryElement::VT_SOURCE);
    fbb_.Required(o, UpdateQueryElement::VT_SETS);
    return o;
  }
};

inline ::flatbuffers::Offset<UpdateQueryElement> CreateUpdateQueryElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    TableSourceUnion source_type = TableSourceUnion::NONE,
    ::flatbuffers::Offset<void> source = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SetExpr>>> sets = 0,
    ::flatbuffers::Offset<Function> filter = 0) {
  UpdateQueryElementBuilder builder_(_fbb);
  builder_.add_filter(filter);
  builder_.add_sets(sets);
  builder_.add_source(source);
  builder_.add_source_type(source_type);
  return builder_.Finish();
}

struct UpdateQueryElement::Traits {
  using type = UpdateQueryElement;
  static auto constexpr Create = CreateUpdateQueryElement;
};

inline ::flatbuffers::Offset<UpdateQueryElement> CreateUpdateQueryElementDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    TableSourceUnion source_type = TableSourceUnion::NONE,
    ::flatbuffers::Offset<void> source = 0,
    const std::vector<::flatbuffers::Offset<SetExpr>> *sets = nullptr,
    ::flatbuffers::Offset<Function> filter = 0) {
  auto sets__ = sets ? _fbb.CreateVector<::flatbuffers::Offset<SetExpr>>(*sets) : 0;
  return CreateUpdateQueryElement(
      _fbb,
      source_type,
      source,
      sets__,
      filter);
}

struct DeleteQueryElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeleteQueryElementBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE_TYPE = 4,
    VT_SOURCE = 6,
    VT_FILTER = 8
  };
  TableSourceUnion source_type() const {
    return static_cast<TableSourceUnion>(GetField<uint8_t>(VT_SOURCE_TYPE, 0));
  }
  const void *source() const {
    return GetPointer<const void *>(VT_SOURCE);
  }
  template<typename T> const T *source_as() const;
  const DataCatalog *source_as_DataCatalog() const {
    return source_type() == TableSourceUnion::DataCatalog ? static_cast<const DataCatalog *>(source()) : nullptr;
  }
  const Arrow *source_as_Arrow() const {
    return source_type() == TableSourceUnion::Arrow ? static_cast<const Arrow *>(source()) : nullptr;
  }
  const GraphQuery *source_as_GraphQuery() const {
    return source_type() == TableSourceUnion::GraphQuery ? static_cast<const GraphQuery *>(source()) : nullptr;
  }
  const QueryTableSource *source_as_QueryTableSource() const {
    return source_type() == TableSourceUnion::QueryTableSource ? static_cast<const QueryTableSource *>(source()) : nullptr;
  }
  const Vector *source_as_Vector() const {
    return source_type() == TableSourceUnion::Vector ? static_cast<const Vector *>(source()) : nullptr;
  }
  const Function *filter() const {
    return GetPointer<const Function *>(VT_FILTER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SOURCE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_SOURCE) &&
           VerifyTableSourceUnion(verifier, source(), source_type()) &&
           VerifyOffset(verifier, VT_FILTER) &&
           verifier.VerifyTable(filter()) &&
           verifier.EndTable();
  }
};

template<> inline const DataCatalog *DeleteQueryElement::source_as<DataCatalog>() const {
  return source_as_DataCatalog();
}

template<> inline const Arrow *DeleteQueryElement::source_as<Arrow>() const {
  return source_as_Arrow();
}

template<> inline const GraphQuery *DeleteQueryElement::source_as<GraphQuery>() const {
  return source_as_GraphQuery();
}

template<> inline const QueryTableSource *DeleteQueryElement::source_as<QueryTableSource>() const {
  return source_as_QueryTableSource();
}

template<> inline const Vector *DeleteQueryElement::source_as<Vector>() const {
  return source_as_Vector();
}

struct DeleteQueryElementBuilder {
  typedef DeleteQueryElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source_type(TableSourceUnion source_type) {
    fbb_.AddElement<uint8_t>(DeleteQueryElement::VT_SOURCE_TYPE, static_cast<uint8_t>(source_type), 0);
  }
  void add_source(::flatbuffers::Offset<void> source) {
    fbb_.AddOffset(DeleteQueryElement::VT_SOURCE, source);
  }
  void add_filter(::flatbuffers::Offset<Function> filter) {
    fbb_.AddOffset(DeleteQueryElement::VT_FILTER, filter);
  }
  explicit DeleteQueryElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeleteQueryElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeleteQueryElement>(end);
    fbb_.Required(o, DeleteQueryElement::VT_SOURCE);
    return o;
  }
};

inline ::flatbuffers::Offset<DeleteQueryElement> CreateDeleteQueryElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    TableSourceUnion source_type = TableSourceUnion::NONE,
    ::flatbuffers::Offset<void> source = 0,
    ::flatbuffers::Offset<Function> filter = 0) {
  DeleteQueryElementBuilder builder_(_fbb);
  builder_.add_filter(filter);
  builder_.add_source(source);
  builder_.add_source_type(source_type);
  return builder_.Finish();
}

struct DeleteQueryElement::Traits {
  using type = DeleteQueryElement;
  static auto constexpr Create = CreateDeleteQueryElement;
};

struct QueryElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QueryElementBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Q_TYPE = 4,
    VT_Q = 6
  };
  QueryElementUnion q_type() const {
    return static_cast<QueryElementUnion>(GetField<uint8_t>(VT_Q_TYPE, 0));
  }
  const void *q() const {
    return GetPointer<const void *>(VT_Q);
  }
  template<typename T> const T *q_as() const;
  const UnaryQueryElement *q_as_UnaryQueryElement() const {
    return q_type() == QueryElementUnion::UnaryQueryElement ? static_cast<const UnaryQueryElement *>(q()) : nullptr;
  }
  const BinaryQueryElement *q_as_BinaryQueryElement() const {
    return q_type() == QueryElementUnion::BinaryQueryElement ? static_cast<const BinaryQueryElement *>(q()) : nullptr;
  }
  const UpdateQueryElement *q_as_UpdateQueryElement() const {
    return q_type() == QueryElementUnion::UpdateQueryElement ? static_cast<const UpdateQueryElement *>(q()) : nullptr;
  }
  const DeleteQueryElement *q_as_DeleteQueryElement() const {
    return q_type() == QueryElementUnion::DeleteQueryElement ? static_cast<const DeleteQueryElement *>(q()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_Q_TYPE, 1) &&
           VerifyOffset(verifier, VT_Q) &&
           VerifyQueryElementUnion(verifier, q(), q_type()) &&
           verifier.EndTable();
  }
};

template<> inline const UnaryQueryElement *QueryElement::q_as<UnaryQueryElement>() const {
  return q_as_UnaryQueryElement();
}

template<> inline const BinaryQueryElement *QueryElement::q_as<BinaryQueryElement>() const {
  return q_as_BinaryQueryElement();
}

template<> inline const UpdateQueryElement *QueryElement::q_as<UpdateQueryElement>() const {
  return q_as_UpdateQueryElement();
}

template<> inline const DeleteQueryElement *QueryElement::q_as<DeleteQueryElement>() const {
  return q_as_DeleteQueryElement();
}

struct QueryElementBuilder {
  typedef QueryElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_q_type(QueryElementUnion q_type) {
    fbb_.AddElement<uint8_t>(QueryElement::VT_Q_TYPE, static_cast<uint8_t>(q_type), 0);
  }
  void add_q(::flatbuffers::Offset<void> q) {
    fbb_.AddOffset(QueryElement::VT_Q, q);
  }
  explicit QueryElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QueryElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QueryElement>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QueryElement> CreateQueryElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    QueryElementUnion q_type = QueryElementUnion::NONE,
    ::flatbuffers::Offset<void> q = 0) {
  QueryElementBuilder builder_(_fbb);
  builder_.add_q(q);
  builder_.add_q_type(q_type);
  return builder_.Finish();
}

struct QueryElement::Traits {
  using type = QueryElement;
  static auto constexpr Create = CreateQueryElement;
};

struct Query FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QueryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUERY = 4,
    VT_VALUES = 6,
    VT_LIMIT = 8
  };
  const QueryElement *query() const {
    return GetPointer<const QueryElement *>(VT_QUERY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>> *>(VT_VALUES);
  }
  uint32_t limit() const {
    return GetField<uint32_t>(VT_LIMIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_QUERY) &&
           verifier.VerifyTable(query()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           VerifyField<uint32_t>(verifier, VT_LIMIT, 4) &&
           verifier.EndTable();
  }
};

struct QueryBuilder {
  typedef Query Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_query(::flatbuffers::Offset<QueryElement> query) {
    fbb_.AddOffset(Query::VT_QUERY, query);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>>> values) {
    fbb_.AddOffset(Query::VT_VALUES, values);
  }
  void add_limit(uint32_t limit) {
    fbb_.AddElement<uint32_t>(Query::VT_LIMIT, limit, 0);
  }
  explicit QueryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Query> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Query>(end);
    fbb_.Required(o, Query::VT_QUERY);
    return o;
  }
};

inline ::flatbuffers::Offset<Query> CreateQuery(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<QueryElement> query = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>>> values = 0,
    uint32_t limit = 0) {
  QueryBuilder builder_(_fbb);
  builder_.add_limit(limit);
  builder_.add_values(values);
  builder_.add_query(query);
  return builder_.Finish();
}

struct Query::Traits {
  using type = Query;
  static auto constexpr Create = CreateQuery;
};

inline ::flatbuffers::Offset<Query> CreateQueryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<QueryElement> query = 0,
    const std::vector<::flatbuffers::Offset<ValueInstance>> *values = nullptr,
    uint32_t limit = 0) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<ValueInstance>>(*values) : 0;
  return CreateQuery(
      _fbb,
      query,
      values__,
      limit);
}

struct Parameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TY = 6,
    VT_HINT = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ValueTy ty() const {
    return static_cast<ValueTy>(GetField<uint8_t>(VT_TY, 0));
  }
  TypeHint hint() const {
    return static_cast<TypeHint>(GetField<int8_t>(VT_HINT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TY, 1) &&
           VerifyField<int8_t>(verifier, VT_HINT, 1) &&
           verifier.EndTable();
  }
};

struct ParameterBuilder {
  typedef Parameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Parameter::VT_NAME, name);
  }
  void add_ty(ValueTy ty) {
    fbb_.AddElement<uint8_t>(Parameter::VT_TY, static_cast<uint8_t>(ty), 0);
  }
  void add_hint(TypeHint hint) {
    fbb_.AddElement<int8_t>(Parameter::VT_HINT, static_cast<int8_t>(hint), 0);
  }
  explicit ParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Parameter>(end);
    fbb_.Required(o, Parameter::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Parameter> CreateParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ValueTy ty = ValueTy::Bool,
    TypeHint hint = TypeHint::None) {
  ParameterBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_hint(hint);
  builder_.add_ty(ty);
  return builder_.Finish();
}

struct Parameter::Traits {
  using type = Parameter;
  static auto constexpr Create = CreateParameter;
};

inline ::flatbuffers::Offset<Parameter> CreateParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ValueTy ty = ValueTy::Bool,
    TypeHint hint = TypeHint::None) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateParameter(
      _fbb,
      name__,
      ty,
      hint);
}

struct ParameterInstance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterInstanceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P_TYPE = 4,
    VT_P = 6
  };
  ParameterSlot p_type() const {
    return static_cast<ParameterSlot>(GetField<uint8_t>(VT_P_TYPE, 0));
  }
  const void *p() const {
    return GetPointer<const void *>(VT_P);
  }
  template<typename T> const T *p_as() const;
  const Parameter *p_as_Parameter() const {
    return p_type() == ParameterSlot::Parameter ? static_cast<const Parameter *>(p()) : nullptr;
  }
  const ValueInstance *p_as_ValueInstance() const {
    return p_type() == ParameterSlot::ValueInstance ? static_cast<const ValueInstance *>(p()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_P_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_P) &&
           VerifyParameterSlot(verifier, p(), p_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Parameter *ParameterInstance::p_as<Parameter>() const {
  return p_as_Parameter();
}

template<> inline const ValueInstance *ParameterInstance::p_as<ValueInstance>() const {
  return p_as_ValueInstance();
}

struct ParameterInstanceBuilder {
  typedef ParameterInstance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p_type(ParameterSlot p_type) {
    fbb_.AddElement<uint8_t>(ParameterInstance::VT_P_TYPE, static_cast<uint8_t>(p_type), 0);
  }
  void add_p(::flatbuffers::Offset<void> p) {
    fbb_.AddOffset(ParameterInstance::VT_P, p);
  }
  explicit ParameterInstanceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterInstance>(end);
    fbb_.Required(o, ParameterInstance::VT_P);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterInstance> CreateParameterInstance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ParameterSlot p_type = ParameterSlot::NONE,
    ::flatbuffers::Offset<void> p = 0) {
  ParameterInstanceBuilder builder_(_fbb);
  builder_.add_p(p);
  builder_.add_p_type(p_type);
  return builder_.Finish();
}

struct ParameterInstance::Traits {
  using type = ParameterInstance;
  static auto constexpr Create = CreateParameterInstance;
};

struct ParameterizedQuery FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterizedQueryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUERY = 4,
    VT_PARAMETERS = 6,
    VT_LIMIT = 8
  };
  const QueryElement *query() const {
    return GetPointer<const QueryElement *>(VT_QUERY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ParameterInstance>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ParameterInstance>> *>(VT_PARAMETERS);
  }
  uint32_t limit() const {
    return GetField<uint32_t>(VT_LIMIT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_QUERY) &&
           verifier.VerifyTable(query()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyField<uint32_t>(verifier, VT_LIMIT, 4) &&
           verifier.EndTable();
  }
};

struct ParameterizedQueryBuilder {
  typedef ParameterizedQuery Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_query(::flatbuffers::Offset<QueryElement> query) {
    fbb_.AddOffset(ParameterizedQuery::VT_QUERY, query);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParameterInstance>>> parameters) {
    fbb_.AddOffset(ParameterizedQuery::VT_PARAMETERS, parameters);
  }
  void add_limit(uint32_t limit) {
    fbb_.AddElement<uint32_t>(ParameterizedQuery::VT_LIMIT, limit, 0);
  }
  explicit ParameterizedQueryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterizedQuery> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterizedQuery>(end);
    fbb_.Required(o, ParameterizedQuery::VT_QUERY);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterizedQuery> CreateParameterizedQuery(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<QueryElement> query = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParameterInstance>>> parameters = 0,
    uint32_t limit = 0) {
  ParameterizedQueryBuilder builder_(_fbb);
  builder_.add_limit(limit);
  builder_.add_parameters(parameters);
  builder_.add_query(query);
  return builder_.Finish();
}

struct ParameterizedQuery::Traits {
  using type = ParameterizedQuery;
  static auto constexpr Create = CreateParameterizedQuery;
};

inline ::flatbuffers::Offset<ParameterizedQuery> CreateParameterizedQueryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<QueryElement> query = 0,
    const std::vector<::flatbuffers::Offset<ParameterInstance>> *parameters = nullptr,
    uint32_t limit = 0) {
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<ParameterInstance>>(*parameters) : 0;
  return CreateParameterizedQuery(
      _fbb,
      query,
      parameters__,
      limit);
}

inline bool VerifyExprUnion(::flatbuffers::Verifier &verifier, const void *obj, ExprUnion type) {
  switch (type) {
    case ExprUnion::NONE: {
      return true;
    }
    case ExprUnion::ValueIndex: {
      auto ptr = reinterpret_cast<const ValueIndex *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::Column: {
      auto ptr = reinterpret_cast<const Column *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::Function: {
      auto ptr = reinterpret_cast<const Function *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::AllColumns: {
      auto ptr = reinterpret_cast<const AllColumns *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::Case: {
      auto ptr = reinterpret_cast<const Case *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::OrderByExpr: {
      auto ptr = reinterpret_cast<const OrderByExpr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::Partition: {
      auto ptr = reinterpret_cast<const Partition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::UnsetArgument: {
      auto ptr = reinterpret_cast<const UnsetArgument *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExprUnion::Window: {
      auto ptr = reinterpret_cast<const Window *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExprUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ExprUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExprUnion(
        verifier,  values->Get(i), types->GetEnum<ExprUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifySubcollection(::flatbuffers::Verifier &verifier, const void *obj, Subcollection type) {
  switch (type) {
    case Subcollection::NONE: {
      return true;
    }
    case Subcollection::MvdbSubcollection: {
      auto ptr = reinterpret_cast<const MvdbSubcollection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Subcollection::WorklogSubcollection: {
      auto ptr = reinterpret_cast<const WorklogSubcollection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySubcollectionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Subcollection> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySubcollection(
        verifier,  values->Get(i), types->GetEnum<Subcollection>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyTableSourceUnion(::flatbuffers::Verifier &verifier, const void *obj, TableSourceUnion type) {
  switch (type) {
    case TableSourceUnion::NONE: {
      return true;
    }
    case TableSourceUnion::DataCatalog: {
      auto ptr = reinterpret_cast<const DataCatalog *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TableSourceUnion::Arrow: {
      auto ptr = reinterpret_cast<const Arrow *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TableSourceUnion::GraphQuery: {
      auto ptr = reinterpret_cast<const GraphQuery *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TableSourceUnion::QueryTableSource: {
      auto ptr = reinterpret_cast<const QueryTableSource *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TableSourceUnion::Vector: {
      auto ptr = reinterpret_cast<const Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTableSourceUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TableSourceUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTableSourceUnion(
        verifier,  values->Get(i), types->GetEnum<TableSourceUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyQueryElementUnion(::flatbuffers::Verifier &verifier, const void *obj, QueryElementUnion type) {
  switch (type) {
    case QueryElementUnion::NONE: {
      return true;
    }
    case QueryElementUnion::UnaryQueryElement: {
      auto ptr = reinterpret_cast<const UnaryQueryElement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case QueryElementUnion::BinaryQueryElement: {
      auto ptr = reinterpret_cast<const BinaryQueryElement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case QueryElementUnion::UpdateQueryElement: {
      auto ptr = reinterpret_cast<const UpdateQueryElement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case QueryElementUnion::DeleteQueryElement: {
      auto ptr = reinterpret_cast<const DeleteQueryElement *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyQueryElementUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<QueryElementUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQueryElementUnion(
        verifier,  values->Get(i), types->GetEnum<QueryElementUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyParameterSlot(::flatbuffers::Verifier &verifier, const void *obj, ParameterSlot type) {
  switch (type) {
    case ParameterSlot::NONE: {
      return true;
    }
    case ParameterSlot::Parameter: {
      auto ptr = reinterpret_cast<const Parameter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ParameterSlot::ValueInstance: {
      auto ptr = reinterpret_cast<const ValueInstance *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyParameterSlotVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ParameterSlot> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyParameterSlot(
        verifier,  values->Get(i), types->GetEnum<ParameterSlot>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_QUERY_H_
