// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEJO_H_
#define FLATBUFFERS_GENERATED_WEJO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct TimeSpacePoint;
struct TimeSpacePointBuilder;

struct Event;
struct EventBuilder;

struct Trip;
struct TripBuilder;

struct StateHeader;
struct StateHeaderBuilder;

enum class EventTy : int32_t {
  Invalid = 0,
  Unknown = 1,
  Pulse = 2,
  KeyOn = 3,
  KeyOff = 4,
  AccelerationThresholdPositive = 5,
  AccelerationThresholdNegative = 6,
  SeatbeltLatched = 7,
  SeatbeltUnlatched = 8,
  SpeedThresholdAbove = 9,
  SpeedThresholdBelow = 10,
  MIN = Invalid,
  MAX = SpeedThresholdBelow
};

inline const EventTy (&EnumValuesEventTy())[11] {
  static const EventTy values[] = {
    EventTy::Invalid,
    EventTy::Unknown,
    EventTy::Pulse,
    EventTy::KeyOn,
    EventTy::KeyOff,
    EventTy::AccelerationThresholdPositive,
    EventTy::AccelerationThresholdNegative,
    EventTy::SeatbeltLatched,
    EventTy::SeatbeltUnlatched,
    EventTy::SpeedThresholdAbove,
    EventTy::SpeedThresholdBelow
  };
  return values;
}

inline const char * const *EnumNamesEventTy() {
  static const char * const names[12] = {
    "Invalid",
    "Unknown",
    "Pulse",
    "KeyOn",
    "KeyOff",
    "AccelerationThresholdPositive",
    "AccelerationThresholdNegative",
    "SeatbeltLatched",
    "SeatbeltUnlatched",
    "SpeedThresholdAbove",
    "SpeedThresholdBelow",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventTy(EventTy e) {
  if (::flatbuffers::IsOutRange(e, EventTy::Invalid, EventTy::SpeedThresholdBelow)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEventTy()[index];
}

struct TimeSpacePoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TimeSpacePointBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LNG = 4,
    VT_LAT = 6,
    VT_TIMESTAMP = 8
  };
  float lng() const {
    return GetField<float>(VT_LNG, 0.0f);
  }
  float lat() const {
    return GetField<float>(VT_LAT, 0.0f);
  }
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LNG, 4) &&
           VerifyField<float>(verifier, VT_LAT, 4) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct TimeSpacePointBuilder {
  typedef TimeSpacePoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lng(float lng) {
    fbb_.AddElement<float>(TimeSpacePoint::VT_LNG, lng, 0.0f);
  }
  void add_lat(float lat) {
    fbb_.AddElement<float>(TimeSpacePoint::VT_LAT, lat, 0.0f);
  }
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(TimeSpacePoint::VT_TIMESTAMP, timestamp, 0);
  }
  explicit TimeSpacePointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TimeSpacePoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TimeSpacePoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TimeSpacePoint> CreateTimeSpacePoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float lng = 0.0f,
    float lat = 0.0f,
    int64_t timestamp = 0) {
  TimeSpacePointBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_lat(lat);
  builder_.add_lng(lng);
  return builder_.Finish();
}

struct TimeSpacePoint::Traits {
  using type = TimeSpacePoint;
  static auto constexpr Create = CreateTimeSpacePoint;
};

struct Event FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINT = 4,
    VT_TY = 6,
    VT_SPEED = 8,
    VT_COUNT = 10
  };
  const TimeSpacePoint *point() const {
    return GetPointer<const TimeSpacePoint *>(VT_POINT);
  }
  int32_t ty() const {
    return GetField<int32_t>(VT_TY, 0);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POINT) &&
           verifier.VerifyTable(point()) &&
           VerifyField<int32_t>(verifier, VT_TY, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyField<int32_t>(verifier, VT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct EventBuilder {
  typedef Event Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_point(::flatbuffers::Offset<TimeSpacePoint> point) {
    fbb_.AddOffset(Event::VT_POINT, point);
  }
  void add_ty(int32_t ty) {
    fbb_.AddElement<int32_t>(Event::VT_TY, ty, 0);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Event::VT_SPEED, speed, 0.0f);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(Event::VT_COUNT, count, 0);
  }
  explicit EventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Event> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Event>(end);
    fbb_.Required(o, Event::VT_POINT);
    return o;
  }
};

inline ::flatbuffers::Offset<Event> CreateEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<TimeSpacePoint> point = 0,
    int32_t ty = 0,
    float speed = 0.0f,
    int32_t count = 0) {
  EventBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_speed(speed);
  builder_.add_ty(ty);
  builder_.add_point(point);
  return builder_.Finish();
}

struct Event::Traits {
  using type = Event;
  static auto constexpr Create = CreateEvent;
};

struct Trip FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TripBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEJO_ID = 4,
    VT_START = 6,
    VT_END = 8,
    VT_EVENTS = 10
  };
  const ::flatbuffers::Vector<uint8_t> *wejo_id() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_WEJO_ID);
  }
  const TimeSpacePoint *start() const {
    return GetPointer<const TimeSpacePoint *>(VT_START);
  }
  const TimeSpacePoint *end() const {
    return GetPointer<const TimeSpacePoint *>(VT_END);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Event>> *events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Event>> *>(VT_EVENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WEJO_ID) &&
           verifier.VerifyVector(wejo_id()) &&
           VerifyOffset(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyOffset(verifier, VT_END) &&
           verifier.VerifyTable(end()) &&
           VerifyOffsetRequired(verifier, VT_EVENTS) &&
           verifier.VerifyVector(events()) &&
           verifier.VerifyVectorOfTables(events()) &&
           verifier.EndTable();
  }
};

struct TripBuilder {
  typedef Trip Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wejo_id(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> wejo_id) {
    fbb_.AddOffset(Trip::VT_WEJO_ID, wejo_id);
  }
  void add_start(::flatbuffers::Offset<TimeSpacePoint> start) {
    fbb_.AddOffset(Trip::VT_START, start);
  }
  void add_end(::flatbuffers::Offset<TimeSpacePoint> end) {
    fbb_.AddOffset(Trip::VT_END, end);
  }
  void add_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Event>>> events) {
    fbb_.AddOffset(Trip::VT_EVENTS, events);
  }
  explicit TripBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Trip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Trip>(end);
    fbb_.Required(o, Trip::VT_EVENTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Trip> CreateTrip(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> wejo_id = 0,
    ::flatbuffers::Offset<TimeSpacePoint> start = 0,
    ::flatbuffers::Offset<TimeSpacePoint> end = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Event>>> events = 0) {
  TripBuilder builder_(_fbb);
  builder_.add_events(events);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_wejo_id(wejo_id);
  return builder_.Finish();
}

struct Trip::Traits {
  using type = Trip;
  static auto constexpr Create = CreateTrip;
};

inline ::flatbuffers::Offset<Trip> CreateTripDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *wejo_id = nullptr,
    ::flatbuffers::Offset<TimeSpacePoint> start = 0,
    ::flatbuffers::Offset<TimeSpacePoint> end = 0,
    const std::vector<::flatbuffers::Offset<Event>> *events = nullptr) {
  auto wejo_id__ = wejo_id ? _fbb.CreateVector<uint8_t>(*wejo_id) : 0;
  auto events__ = events ? _fbb.CreateVector<::flatbuffers::Offset<Event>>(*events) : 0;
  return CreateTrip(
      _fbb,
      wejo_id__,
      start,
      end,
      events__);
}

struct StateHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateHeaderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAST_TIME = 4
  };
  int64_t last_time() const {
    return GetField<int64_t>(VT_LAST_TIME, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LAST_TIME, 8) &&
           verifier.EndTable();
  }
};

struct StateHeaderBuilder {
  typedef StateHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_last_time(int64_t last_time) {
    fbb_.AddElement<int64_t>(StateHeader::VT_LAST_TIME, last_time, 0);
  }
  explicit StateHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateHeader> CreateStateHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t last_time = 0) {
  StateHeaderBuilder builder_(_fbb);
  builder_.add_last_time(last_time);
  return builder_.Finish();
}

struct StateHeader::Traits {
  using type = StateHeader;
  static auto constexpr Create = CreateStateHeader;
};

#endif  // FLATBUFFERS_GENERATED_WEJO_H_
