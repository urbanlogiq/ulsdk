// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_JOB_H_
#define FLATBUFFERS_GENERATED_JOB_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"
#include "flatbuffers/flex_flat_util.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "Schema_generated.h"
#include "data_generated.h"
#include "id_generated.h"
#include "value_generated.h"

struct Edge;
struct EdgeBuilder;

struct Node;
struct NodeBuilder;

struct Schematic;
struct SchematicBuilder;

struct EmbeddedTable;
struct EmbeddedTableBuilder;

struct TaskParameter;
struct TaskParameterBuilder;

struct ParamIndices;
struct ParamIndicesBuilder;

struct Task;
struct TaskBuilder;

struct TaskList;
struct TaskListBuilder;

struct Job;
struct JobBuilder;

struct RunSpec;
struct RunSpecBuilder;

struct DeprecatedTaskParameter;
struct DeprecatedTaskParameterBuilder;

struct DeprecatedRunSpec;
struct DeprecatedRunSpecBuilder;

enum class TaskRunFlags : uint32_t {
  PodLocked = 1,
  NONE = 0,
  ANY = 1
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(TaskRunFlags, uint32_t)

inline const TaskRunFlags (&EnumValuesTaskRunFlags())[1] {
  static const TaskRunFlags values[] = {
    TaskRunFlags::PodLocked
  };
  return values;
}

inline const char * const *EnumNamesTaskRunFlags() {
  static const char * const names[2] = {
    "PodLocked",
    nullptr
  };
  return names;
}

inline const char *EnumNameTaskRunFlags(TaskRunFlags e) {
  if (::flatbuffers::IsOutRange(e, TaskRunFlags::PodLocked, TaskRunFlags::PodLocked)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(TaskRunFlags::PodLocked);
  return EnumNamesTaskRunFlags()[index];
}

enum class TaskPriority : int32_t {
  High = -256,
  Medium = 0,
  Low = 256,
  MIN = High,
  MAX = Low
};

inline const TaskPriority (&EnumValuesTaskPriority())[3] {
  static const TaskPriority values[] = {
    TaskPriority::High,
    TaskPriority::Medium,
    TaskPriority::Low
  };
  return values;
}

inline const char *EnumNameTaskPriority(TaskPriority e) {
  switch (e) {
    case TaskPriority::High: return "High";
    case TaskPriority::Medium: return "Medium";
    case TaskPriority::Low: return "Low";
    default: return "";
  }
}

enum class TaskParameterValue : uint8_t {
  NONE = 0,
  ObjectId = 1,
  EmbeddedTable = 2,
  ValueInstance = 3,
  MIN = NONE,
  MAX = ValueInstance
};

inline const TaskParameterValue (&EnumValuesTaskParameterValue())[4] {
  static const TaskParameterValue values[] = {
    TaskParameterValue::NONE,
    TaskParameterValue::ObjectId,
    TaskParameterValue::EmbeddedTable,
    TaskParameterValue::ValueInstance
  };
  return values;
}

inline const char * const *EnumNamesTaskParameterValue() {
  static const char * const names[5] = {
    "NONE",
    "ObjectId",
    "EmbeddedTable",
    "ValueInstance",
    nullptr
  };
  return names;
}

inline const char *EnumNameTaskParameterValue(TaskParameterValue e) {
  if (::flatbuffers::IsOutRange(e, TaskParameterValue::NONE, TaskParameterValue::ValueInstance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTaskParameterValue()[index];
}

template<typename T> struct TaskParameterValueTraits {
  static const TaskParameterValue enum_value = TaskParameterValue::NONE;
};

template<> struct TaskParameterValueTraits<ObjectId> {
  static const TaskParameterValue enum_value = TaskParameterValue::ObjectId;
};

template<> struct TaskParameterValueTraits<EmbeddedTable> {
  static const TaskParameterValue enum_value = TaskParameterValue::EmbeddedTable;
};

template<> struct TaskParameterValueTraits<ValueInstance> {
  static const TaskParameterValue enum_value = TaskParameterValue::ValueInstance;
};

bool VerifyTaskParameterValue(::flatbuffers::Verifier &verifier, const void *obj, TaskParameterValue type);
bool VerifyTaskParameterValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TaskParameterValue> *types);

enum class Status : int8_t {
  Pending = 0,
  Running = 1,
  Complete = 2,
  Error = 3,
  RetryableError = 4,
  MIN = Pending,
  MAX = RetryableError
};

inline const Status (&EnumValuesStatus())[5] {
  static const Status values[] = {
    Status::Pending,
    Status::Running,
    Status::Complete,
    Status::Error,
    Status::RetryableError
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[6] = {
    "Pending",
    "Running",
    "Complete",
    "Error",
    "RetryableError",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (::flatbuffers::IsOutRange(e, Status::Pending, Status::RetryableError)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

enum class TaskErrorTy : int32_t {
  NONE = 0,
  DuplicateData = 1,
  MIN = NONE,
  MAX = DuplicateData
};

inline const TaskErrorTy (&EnumValuesTaskErrorTy())[2] {
  static const TaskErrorTy values[] = {
    TaskErrorTy::NONE,
    TaskErrorTy::DuplicateData
  };
  return values;
}

inline const char * const *EnumNamesTaskErrorTy() {
  static const char * const names[3] = {
    "NONE",
    "DuplicateData",
    nullptr
  };
  return names;
}

inline const char *EnumNameTaskErrorTy(TaskErrorTy e) {
  if (::flatbuffers::IsOutRange(e, TaskErrorTy::NONE, TaskErrorTy::DuplicateData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTaskErrorTy()[index];
}

struct Edge FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EdgeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FROM = 4,
    VT_TO = 6
  };
  uint32_t from() const {
    return GetField<uint32_t>(VT_FROM, 0);
  }
  uint32_t to() const {
    return GetField<uint32_t>(VT_TO, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FROM, 4) &&
           VerifyField<uint32_t>(verifier, VT_TO, 4) &&
           verifier.EndTable();
  }
};

struct EdgeBuilder {
  typedef Edge Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_from(uint32_t from) {
    fbb_.AddElement<uint32_t>(Edge::VT_FROM, from, 0);
  }
  void add_to(uint32_t to) {
    fbb_.AddElement<uint32_t>(Edge::VT_TO, to, 0);
  }
  explicit EdgeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Edge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Edge>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Edge> CreateEdge(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t from = 0,
    uint32_t to = 0) {
  EdgeBuilder builder_(_fbb);
  builder_.add_to(to);
  builder_.add_from(from);
  return builder_.Finish();
}

struct Edge::Traits {
  using type = Edge;
  static auto constexpr Create = CreateEdge;
};

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJ = 4,
    VT_NAME = 6
  };
  const ObjectId *obj() const {
    return GetPointer<const ObjectId *>(VT_OBJ);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OBJ) &&
           verifier.VerifyTable(obj()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_obj(::flatbuffers::Offset<ObjectId> obj) {
    fbb_.AddOffset(Node::VT_OBJ, obj);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    fbb_.Required(o, Node::VT_OBJ);
    fbb_.Required(o, Node::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> obj = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_obj(obj);
  return builder_.Finish();
}

struct Node::Traits {
  using type = Node;
  static auto constexpr Create = CreateNode;
};

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> obj = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateNode(
      _fbb,
      obj,
      name__);
}

struct Schematic FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SchematicBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODES = 4,
    VT_EDGES = 6,
    VT_ATTRIBUTES = 8,
    VT_NAME = 10
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Node>> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Edge>> *edges() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Edge>> *>(VT_EDGES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>> *>(VT_ATTRIBUTES);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffsetRequired(verifier, VT_EDGES) &&
           verifier.VerifyVector(edges()) &&
           verifier.VerifyVectorOfTables(edges()) &&
           VerifyOffsetRequired(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SchematicBuilder {
  typedef Schematic Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Node>>> nodes) {
    fbb_.AddOffset(Schematic::VT_NODES, nodes);
  }
  void add_edges(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Edge>>> edges) {
    fbb_.AddOffset(Schematic::VT_EDGES, edges);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>>> attributes) {
    fbb_.AddOffset(Schematic::VT_ATTRIBUTES, attributes);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Schematic::VT_NAME, name);
  }
  explicit SchematicBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Schematic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Schematic>(end);
    fbb_.Required(o, Schematic::VT_NODES);
    fbb_.Required(o, Schematic::VT_EDGES);
    fbb_.Required(o, Schematic::VT_ATTRIBUTES);
    return o;
  }
};

inline ::flatbuffers::Offset<Schematic> CreateSchematic(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Node>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Edge>>> edges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>>> attributes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  SchematicBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_attributes(attributes);
  builder_.add_edges(edges);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

struct Schematic::Traits {
  using type = Schematic;
  static auto constexpr Create = CreateSchematic;
};

inline ::flatbuffers::Offset<Schematic> CreateSchematicDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Node>> *nodes = nullptr,
    const std::vector<::flatbuffers::Offset<Edge>> *edges = nullptr,
    const std::vector<::flatbuffers::Offset<AttributePair>> *attributes = nullptr,
    const char *name = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<Node>>(*nodes) : 0;
  auto edges__ = edges ? _fbb.CreateVector<::flatbuffers::Offset<Edge>>(*edges) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<AttributePair>>(*attributes) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateSchematic(
      _fbb,
      nodes__,
      edges__,
      attributes__,
      name__);
}

struct EmbeddedTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmbeddedTableBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  const ::flatbuffers::Vector<uint8_t> *v() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_V);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_V) &&
           verifier.VerifyVector(v()) &&
           verifier.EndTable();
  }
};

struct EmbeddedTableBuilder {
  typedef EmbeddedTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> v) {
    fbb_.AddOffset(EmbeddedTable::VT_V, v);
  }
  explicit EmbeddedTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmbeddedTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmbeddedTable>(end);
    fbb_.Required(o, EmbeddedTable::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<EmbeddedTable> CreateEmbeddedTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> v = 0) {
  EmbeddedTableBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct EmbeddedTable::Traits {
  using type = EmbeddedTable;
  static auto constexpr Create = CreateEmbeddedTable;
};

inline ::flatbuffers::Offset<EmbeddedTable> CreateEmbeddedTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *v = nullptr) {
  auto v__ = v ? _fbb.CreateVector<uint8_t>(*v) : 0;
  return CreateEmbeddedTable(
      _fbb,
      v__);
}

struct TaskParameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaskParameterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  TaskParameterValue value_type() const {
    return static_cast<TaskParameterValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ObjectId *value_as_ObjectId() const {
    return value_type() == TaskParameterValue::ObjectId ? static_cast<const ObjectId *>(value()) : nullptr;
  }
  const EmbeddedTable *value_as_EmbeddedTable() const {
    return value_type() == TaskParameterValue::EmbeddedTable ? static_cast<const EmbeddedTable *>(value()) : nullptr;
  }
  const ValueInstance *value_as_ValueInstance() const {
    return value_type() == TaskParameterValue::ValueInstance ? static_cast<const ValueInstance *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyTaskParameterValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ObjectId *TaskParameter::value_as<ObjectId>() const {
  return value_as_ObjectId();
}

template<> inline const EmbeddedTable *TaskParameter::value_as<EmbeddedTable>() const {
  return value_as_EmbeddedTable();
}

template<> inline const ValueInstance *TaskParameter::value_as<ValueInstance>() const {
  return value_as_ValueInstance();
}

struct TaskParameterBuilder {
  typedef TaskParameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(TaskParameter::VT_KEY, key);
  }
  void add_value_type(TaskParameterValue value_type) {
    fbb_.AddElement<uint8_t>(TaskParameter::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(TaskParameter::VT_VALUE, value);
  }
  explicit TaskParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaskParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaskParameter>(end);
    fbb_.Required(o, TaskParameter::VT_KEY);
    fbb_.Required(o, TaskParameter::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<TaskParameter> CreateTaskParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    TaskParameterValue value_type = TaskParameterValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  TaskParameterBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct TaskParameter::Traits {
  using type = TaskParameter;
  static auto constexpr Create = CreateTaskParameter;
};

inline ::flatbuffers::Offset<TaskParameter> CreateTaskParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    TaskParameterValue value_type = TaskParameterValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return CreateTaskParameter(
      _fbb,
      key__,
      value_type,
      value);
}

struct ParamIndices FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParamIndicesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDXS = 4
  };
  const ::flatbuffers::Vector<int32_t> *idxs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_IDXS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_IDXS) &&
           verifier.VerifyVector(idxs()) &&
           verifier.EndTable();
  }
};

struct ParamIndicesBuilder {
  typedef ParamIndices Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idxs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> idxs) {
    fbb_.AddOffset(ParamIndices::VT_IDXS, idxs);
  }
  explicit ParamIndicesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParamIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParamIndices>(end);
    fbb_.Required(o, ParamIndices::VT_IDXS);
    return o;
  }
};

inline ::flatbuffers::Offset<ParamIndices> CreateParamIndices(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> idxs = 0) {
  ParamIndicesBuilder builder_(_fbb);
  builder_.add_idxs(idxs);
  return builder_.Finish();
}

struct ParamIndices::Traits {
  using type = ParamIndices;
  static auto constexpr Create = CreateParamIndices;
};

inline ::flatbuffers::Offset<ParamIndices> CreateParamIndicesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *idxs = nullptr) {
  auto idxs__ = idxs ? _fbb.CreateVector<int32_t>(*idxs) : 0;
  return CreateParamIndices(
      _fbb,
      idxs__);
}

struct Task FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaskBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT__ID = 4,
    VT_USER_ID = 6,
    VT_TASK = 8,
    VT_NAME = 10,
    VT_JOB_ID = 12,
    VT_STATUS = 14,
    VT_MESSAGE = 16,
    VT_PARAMS = 18,
    VT_OUTPUT = 20,
    VT_DISCARD = 22,
    VT_UPSTREAM = 24,
    VT_DOWNSTREAM = 26,
    VT_CREATED = 28,
    VT_START = 30,
    VT_LAST_UPDATED = 32,
    VT_END = 34,
    VT_RETRIES = 36,
    VT_BARRIER_COUNT = 38,
    VT_LAST_UPDATED_BY_POD = 40,
    VT_FLAGS = 42,
    VT_ERROR_TY = 44,
    VT_SCHEMATIC_ID = 46
  };
  const ObjectId *_id() const {
    return GetPointer<const ObjectId *>(VT__ID);
  }
  /// User who created the job. This is the same as the user_id field in the
  /// job structure but duplicated for convenience when looking up task related
  /// information.
  const ObjectId *user_id() const {
    return GetPointer<const ObjectId *>(VT_USER_ID);
  }
  /// Task object, either a source or a stream
  const ObjectId *task() const {
    return GetPointer<const ObjectId *>(VT_TASK);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Associated Job ID
  const ObjectId *job_id() const {
    return GetPointer<const ObjectId *>(VT_JOB_ID);
  }
  /// Task status
  Status status() const {
    return static_cast<Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  /// For errors, generic information.
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  /// Parameter indices taken from the RunSpec for this particular task step.
  const ParamIndices *params() const {
    return GetPointer<const ParamIndices *>(VT_PARAMS);
  }
  /// The output of this step. If the task is computational (ie: not just a
  /// data stream lookup) this is a blank object where the results will be
  /// written. If it is a lookup of an existing stream, this will be populated
  /// with the stream ID
  const ObjectId *output() const {
    return GetPointer<const ObjectId *>(VT_OUTPUT);
  }
  /// If false, keep this object if it's a temporary/intermediate after job
  /// creation. This must not be set if the output object above is a provided
  /// stream.
  bool discard() const {
    return GetField<uint8_t>(VT_DISCARD, 0) != 0;
  }
  /// The upstream nodes that enabled this task
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *upstream() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *>(VT_UPSTREAM);
  }
  /// The downstream nodes to enable once this task is complete
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *downstream() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *>(VT_DOWNSTREAM);
  }
  /// Task creation time, in ms-since-Unix-epoch UTC.
  uint64_t created() const {
    return GetField<uint64_t>(VT_CREATED, 0);
  }
  /// Task start time, in ms-since-Unix-epoch UTC.
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  /// Task last poll time, in ms-since-Unix-epoch UTC.
  uint64_t last_updated() const {
    return GetField<uint64_t>(VT_LAST_UPDATED, 0);
  }
  uint64_t end() const {
    return GetField<uint64_t>(VT_END, 0);
  }
  int32_t retries() const {
    return GetField<int32_t>(VT_RETRIES, 0);
  }
  int32_t barrier_count() const {
    return GetField<int32_t>(VT_BARRIER_COUNT, 0);
  }
  const ::flatbuffers::String *last_updated_by_pod() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAST_UPDATED_BY_POD);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  TaskErrorTy error_ty() const {
    return static_cast<TaskErrorTy>(GetField<int32_t>(VT_ERROR_TY, 0));
  }
  const ObjectId *schematic_id() const {
    return GetPointer<const ObjectId *>(VT_SCHEMATIC_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT__ID) &&
           verifier.VerifyTable(_id()) &&
           VerifyOffsetRequired(verifier, VT_USER_ID) &&
           verifier.VerifyTable(user_id()) &&
           VerifyOffsetRequired(verifier, VT_TASK) &&
           verifier.VerifyTable(task()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_JOB_ID) &&
           verifier.VerifyTable(job_id()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyTable(params()) &&
           VerifyOffsetRequired(verifier, VT_OUTPUT) &&
           verifier.VerifyTable(output()) &&
           VerifyField<uint8_t>(verifier, VT_DISCARD, 1) &&
           VerifyOffsetRequired(verifier, VT_UPSTREAM) &&
           verifier.VerifyVector(upstream()) &&
           verifier.VerifyVectorOfTables(upstream()) &&
           VerifyOffsetRequired(verifier, VT_DOWNSTREAM) &&
           verifier.VerifyVector(downstream()) &&
           verifier.VerifyVectorOfTables(downstream()) &&
           VerifyField<uint64_t>(verifier, VT_CREATED, 8) &&
           VerifyField<uint64_t>(verifier, VT_START, 8) &&
           VerifyField<uint64_t>(verifier, VT_LAST_UPDATED, 8) &&
           VerifyField<uint64_t>(verifier, VT_END, 8) &&
           VerifyField<int32_t>(verifier, VT_RETRIES, 4) &&
           VerifyField<int32_t>(verifier, VT_BARRIER_COUNT, 4) &&
           VerifyOffset(verifier, VT_LAST_UPDATED_BY_POD) &&
           verifier.VerifyString(last_updated_by_pod()) &&
           VerifyField<int32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<int32_t>(verifier, VT_ERROR_TY, 4) &&
           VerifyOffset(verifier, VT_SCHEMATIC_ID) &&
           verifier.VerifyTable(schematic_id()) &&
           verifier.EndTable();
  }
};

struct TaskBuilder {
  typedef Task Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add__id(::flatbuffers::Offset<ObjectId> _id) {
    fbb_.AddOffset(Task::VT__ID, _id);
  }
  void add_user_id(::flatbuffers::Offset<ObjectId> user_id) {
    fbb_.AddOffset(Task::VT_USER_ID, user_id);
  }
  void add_task(::flatbuffers::Offset<ObjectId> task) {
    fbb_.AddOffset(Task::VT_TASK, task);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Task::VT_NAME, name);
  }
  void add_job_id(::flatbuffers::Offset<ObjectId> job_id) {
    fbb_.AddOffset(Task::VT_JOB_ID, job_id);
  }
  void add_status(Status status) {
    fbb_.AddElement<int8_t>(Task::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(Task::VT_MESSAGE, message);
  }
  void add_params(::flatbuffers::Offset<ParamIndices> params) {
    fbb_.AddOffset(Task::VT_PARAMS, params);
  }
  void add_output(::flatbuffers::Offset<ObjectId> output) {
    fbb_.AddOffset(Task::VT_OUTPUT, output);
  }
  void add_discard(bool discard) {
    fbb_.AddElement<uint8_t>(Task::VT_DISCARD, static_cast<uint8_t>(discard), 0);
  }
  void add_upstream(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> upstream) {
    fbb_.AddOffset(Task::VT_UPSTREAM, upstream);
  }
  void add_downstream(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> downstream) {
    fbb_.AddOffset(Task::VT_DOWNSTREAM, downstream);
  }
  void add_created(uint64_t created) {
    fbb_.AddElement<uint64_t>(Task::VT_CREATED, created, 0);
  }
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(Task::VT_START, start, 0);
  }
  void add_last_updated(uint64_t last_updated) {
    fbb_.AddElement<uint64_t>(Task::VT_LAST_UPDATED, last_updated, 0);
  }
  void add_end(uint64_t end) {
    fbb_.AddElement<uint64_t>(Task::VT_END, end, 0);
  }
  void add_retries(int32_t retries) {
    fbb_.AddElement<int32_t>(Task::VT_RETRIES, retries, 0);
  }
  void add_barrier_count(int32_t barrier_count) {
    fbb_.AddElement<int32_t>(Task::VT_BARRIER_COUNT, barrier_count, 0);
  }
  void add_last_updated_by_pod(::flatbuffers::Offset<::flatbuffers::String> last_updated_by_pod) {
    fbb_.AddOffset(Task::VT_LAST_UPDATED_BY_POD, last_updated_by_pod);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(Task::VT_FLAGS, flags, 0);
  }
  void add_error_ty(TaskErrorTy error_ty) {
    fbb_.AddElement<int32_t>(Task::VT_ERROR_TY, static_cast<int32_t>(error_ty), 0);
  }
  void add_schematic_id(::flatbuffers::Offset<ObjectId> schematic_id) {
    fbb_.AddOffset(Task::VT_SCHEMATIC_ID, schematic_id);
  }
  explicit TaskBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Task> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Task>(end);
    fbb_.Required(o, Task::VT__ID);
    fbb_.Required(o, Task::VT_USER_ID);
    fbb_.Required(o, Task::VT_TASK);
    fbb_.Required(o, Task::VT_NAME);
    fbb_.Required(o, Task::VT_JOB_ID);
    fbb_.Required(o, Task::VT_PARAMS);
    fbb_.Required(o, Task::VT_OUTPUT);
    fbb_.Required(o, Task::VT_UPSTREAM);
    fbb_.Required(o, Task::VT_DOWNSTREAM);
    return o;
  }
};

inline ::flatbuffers::Offset<Task> CreateTask(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> _id = 0,
    ::flatbuffers::Offset<ObjectId> user_id = 0,
    ::flatbuffers::Offset<ObjectId> task = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<ObjectId> job_id = 0,
    Status status = Status::Pending,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    ::flatbuffers::Offset<ParamIndices> params = 0,
    ::flatbuffers::Offset<ObjectId> output = 0,
    bool discard = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> upstream = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> downstream = 0,
    uint64_t created = 0,
    uint64_t start = 0,
    uint64_t last_updated = 0,
    uint64_t end = 0,
    int32_t retries = 0,
    int32_t barrier_count = 0,
    ::flatbuffers::Offset<::flatbuffers::String> last_updated_by_pod = 0,
    int32_t flags = 0,
    TaskErrorTy error_ty = TaskErrorTy::NONE,
    ::flatbuffers::Offset<ObjectId> schematic_id = 0) {
  TaskBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_last_updated(last_updated);
  builder_.add_start(start);
  builder_.add_created(created);
  builder_.add_schematic_id(schematic_id);
  builder_.add_error_ty(error_ty);
  builder_.add_flags(flags);
  builder_.add_last_updated_by_pod(last_updated_by_pod);
  builder_.add_barrier_count(barrier_count);
  builder_.add_retries(retries);
  builder_.add_downstream(downstream);
  builder_.add_upstream(upstream);
  builder_.add_output(output);
  builder_.add_params(params);
  builder_.add_message(message);
  builder_.add_job_id(job_id);
  builder_.add_name(name);
  builder_.add_task(task);
  builder_.add_user_id(user_id);
  builder_.add__id(_id);
  builder_.add_discard(discard);
  builder_.add_status(status);
  return builder_.Finish();
}

struct Task::Traits {
  using type = Task;
  static auto constexpr Create = CreateTask;
};

inline ::flatbuffers::Offset<Task> CreateTaskDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> _id = 0,
    ::flatbuffers::Offset<ObjectId> user_id = 0,
    ::flatbuffers::Offset<ObjectId> task = 0,
    const char *name = nullptr,
    ::flatbuffers::Offset<ObjectId> job_id = 0,
    Status status = Status::Pending,
    const char *message = nullptr,
    ::flatbuffers::Offset<ParamIndices> params = 0,
    ::flatbuffers::Offset<ObjectId> output = 0,
    bool discard = false,
    const std::vector<::flatbuffers::Offset<ObjectId>> *upstream = nullptr,
    const std::vector<::flatbuffers::Offset<ObjectId>> *downstream = nullptr,
    uint64_t created = 0,
    uint64_t start = 0,
    uint64_t last_updated = 0,
    uint64_t end = 0,
    int32_t retries = 0,
    int32_t barrier_count = 0,
    const char *last_updated_by_pod = nullptr,
    int32_t flags = 0,
    TaskErrorTy error_ty = TaskErrorTy::NONE,
    ::flatbuffers::Offset<ObjectId> schematic_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto upstream__ = upstream ? _fbb.CreateVector<::flatbuffers::Offset<ObjectId>>(*upstream) : 0;
  auto downstream__ = downstream ? _fbb.CreateVector<::flatbuffers::Offset<ObjectId>>(*downstream) : 0;
  auto last_updated_by_pod__ = last_updated_by_pod ? _fbb.CreateString(last_updated_by_pod) : 0;
  return CreateTask(
      _fbb,
      _id,
      user_id,
      task,
      name__,
      job_id,
      status,
      message__,
      params,
      output,
      discard,
      upstream__,
      downstream__,
      created,
      start,
      last_updated,
      end,
      retries,
      barrier_count,
      last_updated_by_pod__,
      flags,
      error_ty,
      schematic_id);
}

struct TaskList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaskListBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TASKS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Task>> *tasks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Task>> *>(VT_TASKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TASKS) &&
           verifier.VerifyVector(tasks()) &&
           verifier.VerifyVectorOfTables(tasks()) &&
           verifier.EndTable();
  }
};

struct TaskListBuilder {
  typedef TaskList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tasks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Task>>> tasks) {
    fbb_.AddOffset(TaskList::VT_TASKS, tasks);
  }
  explicit TaskListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaskList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaskList>(end);
    fbb_.Required(o, TaskList::VT_TASKS);
    return o;
  }
};

inline ::flatbuffers::Offset<TaskList> CreateTaskList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Task>>> tasks = 0) {
  TaskListBuilder builder_(_fbb);
  builder_.add_tasks(tasks);
  return builder_.Finish();
}

struct TaskList::Traits {
  using type = TaskList;
  static auto constexpr Create = CreateTaskList;
};

inline ::flatbuffers::Offset<TaskList> CreateTaskListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Task>> *tasks = nullptr) {
  auto tasks__ = tasks ? _fbb.CreateVector<::flatbuffers::Offset<Task>>(*tasks) : 0;
  return CreateTaskList(
      _fbb,
      tasks__);
}

struct Job FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JobBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_USER_ID = 6,
    VT_TASKS = 8,
    VT_PARAMS = 10,
    VT_ERROR_TYS = 12
  };
  /// Is the job complete?
  Status status() const {
    return static_cast<Status>(GetField<int8_t>(VT_STATUS, 0));
  }
  /// User ID who created this job.
  const ObjectId *user_id() const {
    return GetPointer<const ObjectId *>(VT_USER_ID);
  }
  /// A list of all the tasks that constitute this job.
  const ::flatbuffers::Vector<::flatbuffers::Offset<Task>> *tasks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Task>> *>(VT_TASKS);
  }
  /// Parameters verbatim from the RunSpec
  const ::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>> *params() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>> *>(VT_PARAMS);
  }
  const ::flatbuffers::Vector<TaskErrorTy> *error_tys() const {
    return GetPointer<const ::flatbuffers::Vector<TaskErrorTy> *>(VT_ERROR_TYS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffsetRequired(verifier, VT_USER_ID) &&
           verifier.VerifyTable(user_id()) &&
           VerifyOffsetRequired(verifier, VT_TASKS) &&
           verifier.VerifyVector(tasks()) &&
           verifier.VerifyVectorOfTables(tasks()) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           VerifyOffset(verifier, VT_ERROR_TYS) &&
           verifier.VerifyVector(error_tys()) &&
           verifier.EndTable();
  }
};

struct JobBuilder {
  typedef Job Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(Status status) {
    fbb_.AddElement<int8_t>(Job::VT_STATUS, static_cast<int8_t>(status), 0);
  }
  void add_user_id(::flatbuffers::Offset<ObjectId> user_id) {
    fbb_.AddOffset(Job::VT_USER_ID, user_id);
  }
  void add_tasks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Task>>> tasks) {
    fbb_.AddOffset(Job::VT_TASKS, tasks);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>>> params) {
    fbb_.AddOffset(Job::VT_PARAMS, params);
  }
  void add_error_tys(::flatbuffers::Offset<::flatbuffers::Vector<TaskErrorTy>> error_tys) {
    fbb_.AddOffset(Job::VT_ERROR_TYS, error_tys);
  }
  explicit JobBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Job> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Job>(end);
    fbb_.Required(o, Job::VT_USER_ID);
    fbb_.Required(o, Job::VT_TASKS);
    fbb_.Required(o, Job::VT_PARAMS);
    return o;
  }
};

inline ::flatbuffers::Offset<Job> CreateJob(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Status status = Status::Pending,
    ::flatbuffers::Offset<ObjectId> user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Task>>> tasks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>>> params = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<TaskErrorTy>> error_tys = 0) {
  JobBuilder builder_(_fbb);
  builder_.add_error_tys(error_tys);
  builder_.add_params(params);
  builder_.add_tasks(tasks);
  builder_.add_user_id(user_id);
  builder_.add_status(status);
  return builder_.Finish();
}

struct Job::Traits {
  using type = Job;
  static auto constexpr Create = CreateJob;
};

inline ::flatbuffers::Offset<Job> CreateJobDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Status status = Status::Pending,
    ::flatbuffers::Offset<ObjectId> user_id = 0,
    const std::vector<::flatbuffers::Offset<Task>> *tasks = nullptr,
    const std::vector<::flatbuffers::Offset<TaskParameter>> *params = nullptr,
    const std::vector<TaskErrorTy> *error_tys = nullptr) {
  auto tasks__ = tasks ? _fbb.CreateVector<::flatbuffers::Offset<Task>>(*tasks) : 0;
  auto params__ = params ? _fbb.CreateVector<::flatbuffers::Offset<TaskParameter>>(*params) : 0;
  auto error_tys__ = error_tys ? _fbb.CreateVector<TaskErrorTy>(*error_tys) : 0;
  return CreateJob(
      _fbb,
      status,
      user_id,
      tasks__,
      params__,
      error_tys__);
}

/// A RunSpec is the data required in order to kickstart a schematic job.
/// It includes the ID of the schematic to run along with the parameters.
/// The param_indices list must be *exactly* as long as the nodes list in
/// the Schematic. Each entry in the param_indices list is itself a list
/// that points to all the parameters in the params array. This lets
/// us reuse the task parameters across nodes (ie: if we want a shared
/// start_date / end_date to be used in a number of calculations)
struct RunSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunSpecBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERSIST = 4,
    VT_SCHEMATIC = 6,
    VT_PARAM_INDICES = 8,
    VT_PARAMS = 10,
    VT_PRIORITY = 12,
    VT_NOTIFY = 14
  };
  bool persist() const {
    return GetField<uint8_t>(VT_PERSIST, 0) != 0;
  }
  const ObjectId *schematic() const {
    return GetPointer<const ObjectId *>(VT_SCHEMATIC);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>> *param_indices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>> *>(VT_PARAM_INDICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>> *params() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>> *>(VT_PARAMS);
  }
  TaskPriority priority() const {
    return static_cast<TaskPriority>(GetField<int32_t>(VT_PRIORITY, 0));
  }
  bool notify() const {
    return GetField<uint8_t>(VT_NOTIFY, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PERSIST, 1) &&
           VerifyOffsetRequired(verifier, VT_SCHEMATIC) &&
           verifier.VerifyTable(schematic()) &&
           VerifyOffsetRequired(verifier, VT_PARAM_INDICES) &&
           verifier.VerifyVector(param_indices()) &&
           verifier.VerifyVectorOfTables(param_indices()) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_NOTIFY, 1) &&
           verifier.EndTable();
  }
};

struct RunSpecBuilder {
  typedef RunSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_persist(bool persist) {
    fbb_.AddElement<uint8_t>(RunSpec::VT_PERSIST, static_cast<uint8_t>(persist), 0);
  }
  void add_schematic(::flatbuffers::Offset<ObjectId> schematic) {
    fbb_.AddOffset(RunSpec::VT_SCHEMATIC, schematic);
  }
  void add_param_indices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>>> param_indices) {
    fbb_.AddOffset(RunSpec::VT_PARAM_INDICES, param_indices);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>>> params) {
    fbb_.AddOffset(RunSpec::VT_PARAMS, params);
  }
  void add_priority(TaskPriority priority) {
    fbb_.AddElement<int32_t>(RunSpec::VT_PRIORITY, static_cast<int32_t>(priority), 0);
  }
  void add_notify(bool notify) {
    fbb_.AddElement<uint8_t>(RunSpec::VT_NOTIFY, static_cast<uint8_t>(notify), 1);
  }
  explicit RunSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunSpec>(end);
    fbb_.Required(o, RunSpec::VT_SCHEMATIC);
    fbb_.Required(o, RunSpec::VT_PARAM_INDICES);
    fbb_.Required(o, RunSpec::VT_PARAMS);
    return o;
  }
};

inline ::flatbuffers::Offset<RunSpec> CreateRunSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool persist = false,
    ::flatbuffers::Offset<ObjectId> schematic = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>>> param_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TaskParameter>>> params = 0,
    TaskPriority priority = TaskPriority::Medium,
    bool notify = true) {
  RunSpecBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_params(params);
  builder_.add_param_indices(param_indices);
  builder_.add_schematic(schematic);
  builder_.add_notify(notify);
  builder_.add_persist(persist);
  return builder_.Finish();
}

struct RunSpec::Traits {
  using type = RunSpec;
  static auto constexpr Create = CreateRunSpec;
};

inline ::flatbuffers::Offset<RunSpec> CreateRunSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool persist = false,
    ::flatbuffers::Offset<ObjectId> schematic = 0,
    const std::vector<::flatbuffers::Offset<ParamIndices>> *param_indices = nullptr,
    const std::vector<::flatbuffers::Offset<TaskParameter>> *params = nullptr,
    TaskPriority priority = TaskPriority::Medium,
    bool notify = true) {
  auto param_indices__ = param_indices ? _fbb.CreateVector<::flatbuffers::Offset<ParamIndices>>(*param_indices) : 0;
  auto params__ = params ? _fbb.CreateVector<::flatbuffers::Offset<TaskParameter>>(*params) : 0;
  return CreateRunSpec(
      _fbb,
      persist,
      schematic,
      param_indices__,
      params__,
      priority,
      notify);
}

struct DeprecatedTaskParameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeprecatedTaskParameterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6,
    VT_OBJ = 8,
    VT_FLAGS = 10
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  const ObjectId *obj() const {
    return GetPointer<const ObjectId *>(VT_OBJ);
  }
  int64_t flags() const {
    return GetField<int64_t>(VT_FLAGS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           VerifyOffset(verifier, VT_OBJ) &&
           verifier.VerifyTable(obj()) &&
           VerifyField<int64_t>(verifier, VT_FLAGS, 8) &&
           verifier.EndTable();
  }
};

struct DeprecatedTaskParameterBuilder {
  typedef DeprecatedTaskParameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(DeprecatedTaskParameter::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(DeprecatedTaskParameter::VT_VALUE, value);
  }
  void add_obj(::flatbuffers::Offset<ObjectId> obj) {
    fbb_.AddOffset(DeprecatedTaskParameter::VT_OBJ, obj);
  }
  void add_flags(int64_t flags) {
    fbb_.AddElement<int64_t>(DeprecatedTaskParameter::VT_FLAGS, flags, 0);
  }
  explicit DeprecatedTaskParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeprecatedTaskParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeprecatedTaskParameter>(end);
    fbb_.Required(o, DeprecatedTaskParameter::VT_KEY);
    return o;
  }
};

inline ::flatbuffers::Offset<DeprecatedTaskParameter> CreateDeprecatedTaskParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0,
    ::flatbuffers::Offset<ObjectId> obj = 0,
    int64_t flags = 0) {
  DeprecatedTaskParameterBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_obj(obj);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct DeprecatedTaskParameter::Traits {
  using type = DeprecatedTaskParameter;
  static auto constexpr Create = CreateDeprecatedTaskParameter;
};

inline ::flatbuffers::Offset<DeprecatedTaskParameter> CreateDeprecatedTaskParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<uint8_t> *value = nullptr,
    ::flatbuffers::Offset<ObjectId> obj = 0,
    int64_t flags = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return CreateDeprecatedTaskParameter(
      _fbb,
      key__,
      value__,
      obj,
      flags);
}

struct DeprecatedRunSpec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeprecatedRunSpecBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERSIST = 4,
    VT_SCHEMATIC = 6,
    VT_PARAM_INDICES = 8,
    VT_PARAMS = 10
  };
  bool persist() const {
    return GetField<uint8_t>(VT_PERSIST, 0) != 0;
  }
  const ObjectId *schematic() const {
    return GetPointer<const ObjectId *>(VT_SCHEMATIC);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>> *param_indices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>> *>(VT_PARAM_INDICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedTaskParameter>> *params() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedTaskParameter>> *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PERSIST, 1) &&
           VerifyOffsetRequired(verifier, VT_SCHEMATIC) &&
           verifier.VerifyTable(schematic()) &&
           VerifyOffsetRequired(verifier, VT_PARAM_INDICES) &&
           verifier.VerifyVector(param_indices()) &&
           verifier.VerifyVectorOfTables(param_indices()) &&
           VerifyOffsetRequired(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           verifier.EndTable();
  }
};

struct DeprecatedRunSpecBuilder {
  typedef DeprecatedRunSpec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_persist(bool persist) {
    fbb_.AddElement<uint8_t>(DeprecatedRunSpec::VT_PERSIST, static_cast<uint8_t>(persist), 0);
  }
  void add_schematic(::flatbuffers::Offset<ObjectId> schematic) {
    fbb_.AddOffset(DeprecatedRunSpec::VT_SCHEMATIC, schematic);
  }
  void add_param_indices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>>> param_indices) {
    fbb_.AddOffset(DeprecatedRunSpec::VT_PARAM_INDICES, param_indices);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedTaskParameter>>> params) {
    fbb_.AddOffset(DeprecatedRunSpec::VT_PARAMS, params);
  }
  explicit DeprecatedRunSpecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeprecatedRunSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeprecatedRunSpec>(end);
    fbb_.Required(o, DeprecatedRunSpec::VT_SCHEMATIC);
    fbb_.Required(o, DeprecatedRunSpec::VT_PARAM_INDICES);
    fbb_.Required(o, DeprecatedRunSpec::VT_PARAMS);
    return o;
  }
};

inline ::flatbuffers::Offset<DeprecatedRunSpec> CreateDeprecatedRunSpec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool persist = false,
    ::flatbuffers::Offset<ObjectId> schematic = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParamIndices>>> param_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedTaskParameter>>> params = 0) {
  DeprecatedRunSpecBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_param_indices(param_indices);
  builder_.add_schematic(schematic);
  builder_.add_persist(persist);
  return builder_.Finish();
}

struct DeprecatedRunSpec::Traits {
  using type = DeprecatedRunSpec;
  static auto constexpr Create = CreateDeprecatedRunSpec;
};

inline ::flatbuffers::Offset<DeprecatedRunSpec> CreateDeprecatedRunSpecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool persist = false,
    ::flatbuffers::Offset<ObjectId> schematic = 0,
    const std::vector<::flatbuffers::Offset<ParamIndices>> *param_indices = nullptr,
    const std::vector<::flatbuffers::Offset<DeprecatedTaskParameter>> *params = nullptr) {
  auto param_indices__ = param_indices ? _fbb.CreateVector<::flatbuffers::Offset<ParamIndices>>(*param_indices) : 0;
  auto params__ = params ? _fbb.CreateVector<::flatbuffers::Offset<DeprecatedTaskParameter>>(*params) : 0;
  return CreateDeprecatedRunSpec(
      _fbb,
      persist,
      schematic,
      param_indices__,
      params__);
}

inline bool VerifyTaskParameterValue(::flatbuffers::Verifier &verifier, const void *obj, TaskParameterValue type) {
  switch (type) {
    case TaskParameterValue::NONE: {
      return true;
    }
    case TaskParameterValue::ObjectId: {
      auto ptr = reinterpret_cast<const ObjectId *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TaskParameterValue::EmbeddedTable: {
      auto ptr = reinterpret_cast<const EmbeddedTable *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case TaskParameterValue::ValueInstance: {
      auto ptr = reinterpret_cast<const ValueInstance *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTaskParameterValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<TaskParameterValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTaskParameterValue(
        verifier,  values->Get(i), types->GetEnum<TaskParameterValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const Job *GetJob(const void *buf) {
  return ::flatbuffers::GetRoot<Job>(buf);
}

inline const Job *GetSizePrefixedJob(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Job>(buf);
}

inline bool VerifyJobBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Job>(nullptr);
}

inline bool VerifySizePrefixedJobBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Job>(nullptr);
}

inline void FinishJobBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Job> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedJobBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Job> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_JOB_H_
