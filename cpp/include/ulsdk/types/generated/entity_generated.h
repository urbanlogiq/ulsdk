// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ENTITY_H_
#define FLATBUFFERS_GENERATED_ENTITY_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "id_generated.h"

struct Point;
struct PointBuilder;

struct Line;
struct LineBuilder;

struct MultiLine;
struct MultiLineBuilder;

struct Polygon;
struct PolygonBuilder;

struct MultiPolygon;
struct MultiPolygonBuilder;

struct GraphNode;
struct GraphNodeBuilder;

struct GraphEdge;
struct GraphEdgeBuilder;

enum class EntityTy : int32_t {
  T_INVALID = 0,
  T_TFC = 1,
  T_TFC_LOOP = 2,
  T_TFC_CRASH = 3,
  T_TFC_TMC_REPORT = 4,
  T_ROAD_SEGMENT = 5,
  T_INTERSECTION = 6,
  T_SIDEWAlK = 7,
  T_BIKEWAY = 8,
  T_TRANSIT_LINE = 9,
  T_BIA = 10,
  T_NEIGHBOURHOOD = 11,
  T_NIA = 12,
  T_WARD = 13,
  T_DISTRICT = 14,
  T_CONSTITUENCY = 15,
  T_POSTAL_CODE_GEO = 16,
  T_BUSINESS = 17,
  T_LAND_PARCEL = 18,
  T_ADDRESS = 19,
  T_POSTAL_CODE_DEMOGRAPHICS = 20,
  T_ZONE = 21,
  T_PARK = 22,
  T_PARKING_LOT = 23,
  T_PARKING_TICKET = 24,
  T_PLACE_OF_INTEREST = 25,
  T_DAYCARE_CENTRE = 26,
  T_MEDICAL_CENTRE = 27,
  T_COMMERCIAL_LAND = 28,
  T_DEVELOPMENT_APPLICATION = 29,
  T_AVAILABLE_COMMERCIAL_SPACE = 30,
  T_BUILDING_FOOTPRINT = 31,
  T_DEVELOPED_EMPLOYMENT_LAND = 32,
  T_VACANT_EMPLOYMENT_LAND = 33,
  T_STREET = 34,
  T_BIKESHARE_STATION = 35,
  T_SUBWAY_LINE = 36,
  T_ON_STREET_PARKING = 37,
  T_PEDESTRIAN_ROUTE = 38,
  T_HERITAGE_DISTRICT = 39,
  T_BUS_ROUTE = 40,
  T_BUS_STOP = 41,
  T_POLITICAL_BOUNDARY = 42,
  T_CRIME = 43,
  T_EVENT = 44,
  T_TFC_SEGMENT_VOLUMES = 45,
  T_TFC_TMC_COUNTS = 46,
  T_TFC_AADT = 47,
  T_CONNECTIVITY_CORRIDORS = 48,
  T_MEDIANS = 49,
  T_EVACUATION_ROUTES = 50,
  T_TRAFFIC_METRICS = 51,
  T_COUNTERMEASURES_DEVICES = 52,
  T_TRAFFIC_INCIDENTS = 53,
  T_BLOCKGROUP_DEMOGRAPHIC = 54,
  T_PARKING_METER = 55,
  T_PROPERTY_VALUE_ASSESSMENT = 56,
  T_GOLF_COURSE = 57,
  T_BUILDING_PERMIT = 58,
  T_REALM = 59,
  T_ROAD_SEGMENT_COUNT_LOCATION = 60,
  T_INTERSECTION_COUNT_LOCATION = 61,
  T_TRIPS_ORIGIN_DESTINATION_PASSTHROUGH_BIA = 62,
  T_WORKLOGS = 63,
  T_FORECAST = 64,
  T_BRIDGES = 65,
  T_OPEN_MARKETS = 66,
  T_BIKE_FACILITIES = 67,
  T_DOG_LICENCES = 68,
  T_PEDESTRIAN_COUNT_LOCATION = 69,
  T_DISADVANTAGED_AREA = 70,
  T_TRANSPORTATION_ANALYSIS_ZONE = 71,
  T_ELECTION_DISTRICT = 72,
  T_DISSEMINATION_AREA = 73,
  T_RETAIL_AREA = 74,
  T_GROWTH_CENTER = 75,
  T_SEARCH_ATTRIBUTES = 76,
  T_PROPERTY = 77,
  T_DESIGNATED_AREA = 78,
  T_PROVINCIAL_FOREST = 79,
  T_TIMBER_SUPPLY_AREA = 80,
  T_COMMUNICATION_SITE = 81,
  T_CUT_BLOCK = 82,
  T_PERMIT = 83,
  T_LICENCE = 84,
  T_MAP_NOTATION = 85,
  T_REAL_PROPERTY_PROJECT = 86,
  T_RECREATION_SITE = 87,
  T_RECREATION_LINE = 88,
  T_RECREATION_POLYGON = 89,
  T_SPECIAL_ACCESS_ROAD = 90,
  T_GROWTH_YIELD_SAMPLE = 91,
  T_OLD_GROWTH_MANAGEMENT_AREA = 92,
  T_TREATY_AREA = 93,
  T_TREATY_LAND = 94,
  T_RELATED_TREATY_LAND = 95,
  T_ALC_ALR = 96,
  T_CONSERVATION_LAND = 97,
  T_MINFILE_MINERAL_OCCURRENCE_DATABASE = 98,
  T_CROWN_GRANTED_MINERAL_CLAIM = 99,
  T_MINERAL_RESERVES_SITES_BUSINESS_VIEW = 100,
  T_PETROLEUM_TITLE = 101,
  T_CONSERVANCY_AREA = 102,
  T_WILDLIFE_MANAGEMENT_AREA = 103,
  T_RESERVOIR_PERMIT = 104,
  T_WATER_LICENSED_WORK = 105,
  T_WATER_RIGHTS_APPLICATION = 106,
  T_WATER_RIGHTS_LICENCE = 107,
  T_GUIDE_OUTFITTER_AREA = 108,
  T_UNGULATE_WINTER_RANGE = 109,
  T_WILDLIFE_HABITAT_AREAS = 110,
  T_ROAD_SEGMENT_EXACT_COUNT_LOCATION = 111,
  T_EASEMENT = 112,
  T_STREET_LIGHT = 113,
  T_TRAIL = 114,
  T_ROAD_SEGMENT_TRAVEL_TIME_LOCATION = 115,
  T_CONSTRUCTION_PROJECT = 116,
  T_FACILITY = 117,
  T_SUBDIVISION_APPLICATION = 118,
  T_GARBAGE_ROUTE = 119,
  T_PUBLIC_ART = 120,
  T_CENSUS_TRACTS_DEMOGRAPHIC = 121,
  T_COMMUNITY_OF_CONCERN = 122,
  T_LIBRARY = 123,
  T_SCHOOL = 124,
  T_STREET_TREE = 125,
  T_ELECTRIC_VEHICLE_CHARGING_STATION = 126,
  T_VISION_ZERO_SAFETY_CORRIDOR = 127,
  T_TRAFFIC_VOLUME_MODEL = 128,
  T_PLANNING_PROJECT = 129,
  T_PHARMACY = 130,
  T_CENSUS_BLOCK = 131,
  T_ZIP_CODE = 132,
  T_FIRE_ASSESSMENT = 133,
  T_TRANSPORTATION_PAVEMENT = 134,
  T_VEHICLE = 135,
  T_TRIBAL_LAND = 136,
  T_FIRE_STATION = 137,
  T_WILDFIRE = 138,
  T_ACTIVE_TRANSPORTATION_LOCATION = 139,
  T_TIME_DENSITY = 140,
  T_YOUTH_DISABILITY_SUPPORT_SERVICES = 141,
  T_HOME_FIRE_RISK = 142,
  T_COUNT_LOCATION = 143,
  T_RAILROAD = 144,
  T_COMMUNITY_CENTER = 145,
  T_MEAL_SITE = 146,
  T_FOOD_BANK_AND_PARTNER = 147,
  T_HOUSING_UNIT = 148,
  T_BIKE_RACK = 149,
  T_IMPROVEMENT_AREA = 150,
  T_ZONING_DISTRICT = 151,
  T_RIGHT_OF_WAY = 152,
  T_FREEWAY = 153,
  T_BIKE_SUPPORT = 154,
  T_BIKE_CROSSING = 155,
  T_CYCLING_JUNCTION = 156,
  T_LANEWAYS = 157,
  T_CROSSWALK = 158,
  T_ISSUE = 159,
  T_MONUMENT = 160,
  T_WATER_PARCEL = 161,
  T_CONTOUR = 162,
  T_CAPITAL_PROJECT = 163,
  T_SIGN = 164,
  T_SIGN_POLE = 165,
  T_REQUEST = 166,
  T_EMERGENCY_RESPONSE_ROAD = 167,
  T_RAILWAY_CROSSING = 168,
  T_MOBILITY_HUB = 169,
  T_CORRIDOR = 170,
  T_CRASH = 171,
  T_RAIL_LINE = 172,
  T_RAIL_STOP = 173,
  T_ROUTE = 174,
  T_ROUTE_STOP = 175,
  T_TRANSIT_STOP = 176,
  T_TRANSIT_CENTER = 177,
  T_EXPLORE_MODE_INTERSECTION = 178,
  T_ETS_SEGMENT = 179,
  T_FSA = 180,
  T_NEIGHBORHOOD_BUSINESS_ASSOCIATION = 181,
  T_COUNCIL_DISTRICT = 182,
  T_PROJECT_CRASHBOARD = 183,
  T_ELEVATION_LINE = 184,
  T_AREA = 185,
  T_TAX_LOT = 186,
  T_FLOOD = 187,
  T_COUNTY = 188,
  T_CITY = 189,
  T_ELEMENTARY_SCHOOL_DISTRICT = 190,
  T_HIGH_SCHOOL_DISTRICT = 191,
  T_MIDDLE_SCHOOL_DISTRICT = 192,
  T_POLICY_AREA = 193,
  T_2020_CENSUS_BLOCK = 194,
  T_2010_CENSUS_BLOCK = 195,
  T_2020_CENSUS_TRACT = 196,
  T_NON_CTP_ROADS = 197,
  T_COMMERCIAL_VACANCY = 198,
  T_TESTING_SITE = 199,
  T_CLINIC = 200,
  T_STREET_LITTER = 201,
  T_CHILDCARE_CENTER = 202,
  T_CAMERA = 203,
  T_ALLEY = 204,
  T_PAVEMENT = 205,
  T_PAVEMENT_STRIP = 206,
  T_POLE = 207,
  T_DASHBOARD_BUSINESS = 208,
  T_SIGNAL = 209,
  T_MAST_ARM = 210,
  T_CAMERA_EXPLORE = 211,
  T_DASHBOARD_PROPERTY = 212,
  T_POLICE_REPORTED_CRASH = 213,
  T_PARKING_SPACE = 214,
  T_FIRE_RISK_SCORE = 215,
  T_FIRE_RISK_CAUSE = 216,
  T_FIRE_DEPARTMENT = 217,
  T_PLANNED_SIDEWALK = 218,
  T_PROPOSED_PEDESTRIAN_PROJECT = 219,
  T_PROPOSED_BIKE_PROJECT = 220,
  T_ADMINISTRATIVE_AREA = 221,
  T_CURB_RAMP = 222,
  T_PARKING_PERMIT_AREA = 223,
  T_PARCEL = 224,
  T_BOUNDARY = 225,
  T_RAILWAY = 226,
  T_SOIL = 227,
  T_UTILITY_CABINET = 228,
  T_SIGNAL_CABINET = 229,
  T_PEDESTRIAN_BUTTON = 230,
  T_TRAFFIC_CALMING = 231,
  T_CURB = 232,
  T_TRUCK_ROUTE = 233,
  T_GREENWAY = 234,
  T_ROAD_EDGE = 235,
  T_RESTAURANT = 236,
  T_BARRIER = 237,
  T_PAVEMENT_MARKING = 238,
  T_PLANNING_AREA = 239,
  T_ORDER = 240,
  T_FIRE_HYDRANT = 241,
  T_CANNABIS_AND_LIQUOR_STORES = 242,
  T_CENSUS_SUBDIVISION = 243,
  T_SPEED_HUMP = 244,
  T_CRASH_CUSHION = 245,
  T_DEFAULT_AREA_FILTER = 246,
  T_PLAYGROUND = 247,
  T_PICNIC_SHELTER = 248,
  T_TENNIS_COURT = 249,
  T_SPORTS_FIELD = 250,
  T_WASHROOM = 251,
  T_BASEBALL_DIAMOND = 252,
  T_ITS_DEVICE = 253,
  T_SHORTLINE = 254,
  T_TRANSIT_RELATED = 255,
  T_FREIGHT_ANALYSIS_DASHBOARD = 256,
  T_ACCESS_POINT = 257,
  T_CENSUS_DIVISION = 258,
  T_STATE_PROVINCE = 259,
  T_FEDERAL = 260,
  T_CANNABIS_AND_LIQUOR_STORES_TRANSFER = 261,
  MIN = T_INVALID,
  MAX = T_CANNABIS_AND_LIQUOR_STORES_TRANSFER
};

inline const EntityTy (&EnumValuesEntityTy())[262] {
  static const EntityTy values[] = {
    EntityTy::T_INVALID,
    EntityTy::T_TFC,
    EntityTy::T_TFC_LOOP,
    EntityTy::T_TFC_CRASH,
    EntityTy::T_TFC_TMC_REPORT,
    EntityTy::T_ROAD_SEGMENT,
    EntityTy::T_INTERSECTION,
    EntityTy::T_SIDEWAlK,
    EntityTy::T_BIKEWAY,
    EntityTy::T_TRANSIT_LINE,
    EntityTy::T_BIA,
    EntityTy::T_NEIGHBOURHOOD,
    EntityTy::T_NIA,
    EntityTy::T_WARD,
    EntityTy::T_DISTRICT,
    EntityTy::T_CONSTITUENCY,
    EntityTy::T_POSTAL_CODE_GEO,
    EntityTy::T_BUSINESS,
    EntityTy::T_LAND_PARCEL,
    EntityTy::T_ADDRESS,
    EntityTy::T_POSTAL_CODE_DEMOGRAPHICS,
    EntityTy::T_ZONE,
    EntityTy::T_PARK,
    EntityTy::T_PARKING_LOT,
    EntityTy::T_PARKING_TICKET,
    EntityTy::T_PLACE_OF_INTEREST,
    EntityTy::T_DAYCARE_CENTRE,
    EntityTy::T_MEDICAL_CENTRE,
    EntityTy::T_COMMERCIAL_LAND,
    EntityTy::T_DEVELOPMENT_APPLICATION,
    EntityTy::T_AVAILABLE_COMMERCIAL_SPACE,
    EntityTy::T_BUILDING_FOOTPRINT,
    EntityTy::T_DEVELOPED_EMPLOYMENT_LAND,
    EntityTy::T_VACANT_EMPLOYMENT_LAND,
    EntityTy::T_STREET,
    EntityTy::T_BIKESHARE_STATION,
    EntityTy::T_SUBWAY_LINE,
    EntityTy::T_ON_STREET_PARKING,
    EntityTy::T_PEDESTRIAN_ROUTE,
    EntityTy::T_HERITAGE_DISTRICT,
    EntityTy::T_BUS_ROUTE,
    EntityTy::T_BUS_STOP,
    EntityTy::T_POLITICAL_BOUNDARY,
    EntityTy::T_CRIME,
    EntityTy::T_EVENT,
    EntityTy::T_TFC_SEGMENT_VOLUMES,
    EntityTy::T_TFC_TMC_COUNTS,
    EntityTy::T_TFC_AADT,
    EntityTy::T_CONNECTIVITY_CORRIDORS,
    EntityTy::T_MEDIANS,
    EntityTy::T_EVACUATION_ROUTES,
    EntityTy::T_TRAFFIC_METRICS,
    EntityTy::T_COUNTERMEASURES_DEVICES,
    EntityTy::T_TRAFFIC_INCIDENTS,
    EntityTy::T_BLOCKGROUP_DEMOGRAPHIC,
    EntityTy::T_PARKING_METER,
    EntityTy::T_PROPERTY_VALUE_ASSESSMENT,
    EntityTy::T_GOLF_COURSE,
    EntityTy::T_BUILDING_PERMIT,
    EntityTy::T_REALM,
    EntityTy::T_ROAD_SEGMENT_COUNT_LOCATION,
    EntityTy::T_INTERSECTION_COUNT_LOCATION,
    EntityTy::T_TRIPS_ORIGIN_DESTINATION_PASSTHROUGH_BIA,
    EntityTy::T_WORKLOGS,
    EntityTy::T_FORECAST,
    EntityTy::T_BRIDGES,
    EntityTy::T_OPEN_MARKETS,
    EntityTy::T_BIKE_FACILITIES,
    EntityTy::T_DOG_LICENCES,
    EntityTy::T_PEDESTRIAN_COUNT_LOCATION,
    EntityTy::T_DISADVANTAGED_AREA,
    EntityTy::T_TRANSPORTATION_ANALYSIS_ZONE,
    EntityTy::T_ELECTION_DISTRICT,
    EntityTy::T_DISSEMINATION_AREA,
    EntityTy::T_RETAIL_AREA,
    EntityTy::T_GROWTH_CENTER,
    EntityTy::T_SEARCH_ATTRIBUTES,
    EntityTy::T_PROPERTY,
    EntityTy::T_DESIGNATED_AREA,
    EntityTy::T_PROVINCIAL_FOREST,
    EntityTy::T_TIMBER_SUPPLY_AREA,
    EntityTy::T_COMMUNICATION_SITE,
    EntityTy::T_CUT_BLOCK,
    EntityTy::T_PERMIT,
    EntityTy::T_LICENCE,
    EntityTy::T_MAP_NOTATION,
    EntityTy::T_REAL_PROPERTY_PROJECT,
    EntityTy::T_RECREATION_SITE,
    EntityTy::T_RECREATION_LINE,
    EntityTy::T_RECREATION_POLYGON,
    EntityTy::T_SPECIAL_ACCESS_ROAD,
    EntityTy::T_GROWTH_YIELD_SAMPLE,
    EntityTy::T_OLD_GROWTH_MANAGEMENT_AREA,
    EntityTy::T_TREATY_AREA,
    EntityTy::T_TREATY_LAND,
    EntityTy::T_RELATED_TREATY_LAND,
    EntityTy::T_ALC_ALR,
    EntityTy::T_CONSERVATION_LAND,
    EntityTy::T_MINFILE_MINERAL_OCCURRENCE_DATABASE,
    EntityTy::T_CROWN_GRANTED_MINERAL_CLAIM,
    EntityTy::T_MINERAL_RESERVES_SITES_BUSINESS_VIEW,
    EntityTy::T_PETROLEUM_TITLE,
    EntityTy::T_CONSERVANCY_AREA,
    EntityTy::T_WILDLIFE_MANAGEMENT_AREA,
    EntityTy::T_RESERVOIR_PERMIT,
    EntityTy::T_WATER_LICENSED_WORK,
    EntityTy::T_WATER_RIGHTS_APPLICATION,
    EntityTy::T_WATER_RIGHTS_LICENCE,
    EntityTy::T_GUIDE_OUTFITTER_AREA,
    EntityTy::T_UNGULATE_WINTER_RANGE,
    EntityTy::T_WILDLIFE_HABITAT_AREAS,
    EntityTy::T_ROAD_SEGMENT_EXACT_COUNT_LOCATION,
    EntityTy::T_EASEMENT,
    EntityTy::T_STREET_LIGHT,
    EntityTy::T_TRAIL,
    EntityTy::T_ROAD_SEGMENT_TRAVEL_TIME_LOCATION,
    EntityTy::T_CONSTRUCTION_PROJECT,
    EntityTy::T_FACILITY,
    EntityTy::T_SUBDIVISION_APPLICATION,
    EntityTy::T_GARBAGE_ROUTE,
    EntityTy::T_PUBLIC_ART,
    EntityTy::T_CENSUS_TRACTS_DEMOGRAPHIC,
    EntityTy::T_COMMUNITY_OF_CONCERN,
    EntityTy::T_LIBRARY,
    EntityTy::T_SCHOOL,
    EntityTy::T_STREET_TREE,
    EntityTy::T_ELECTRIC_VEHICLE_CHARGING_STATION,
    EntityTy::T_VISION_ZERO_SAFETY_CORRIDOR,
    EntityTy::T_TRAFFIC_VOLUME_MODEL,
    EntityTy::T_PLANNING_PROJECT,
    EntityTy::T_PHARMACY,
    EntityTy::T_CENSUS_BLOCK,
    EntityTy::T_ZIP_CODE,
    EntityTy::T_FIRE_ASSESSMENT,
    EntityTy::T_TRANSPORTATION_PAVEMENT,
    EntityTy::T_VEHICLE,
    EntityTy::T_TRIBAL_LAND,
    EntityTy::T_FIRE_STATION,
    EntityTy::T_WILDFIRE,
    EntityTy::T_ACTIVE_TRANSPORTATION_LOCATION,
    EntityTy::T_TIME_DENSITY,
    EntityTy::T_YOUTH_DISABILITY_SUPPORT_SERVICES,
    EntityTy::T_HOME_FIRE_RISK,
    EntityTy::T_COUNT_LOCATION,
    EntityTy::T_RAILROAD,
    EntityTy::T_COMMUNITY_CENTER,
    EntityTy::T_MEAL_SITE,
    EntityTy::T_FOOD_BANK_AND_PARTNER,
    EntityTy::T_HOUSING_UNIT,
    EntityTy::T_BIKE_RACK,
    EntityTy::T_IMPROVEMENT_AREA,
    EntityTy::T_ZONING_DISTRICT,
    EntityTy::T_RIGHT_OF_WAY,
    EntityTy::T_FREEWAY,
    EntityTy::T_BIKE_SUPPORT,
    EntityTy::T_BIKE_CROSSING,
    EntityTy::T_CYCLING_JUNCTION,
    EntityTy::T_LANEWAYS,
    EntityTy::T_CROSSWALK,
    EntityTy::T_ISSUE,
    EntityTy::T_MONUMENT,
    EntityTy::T_WATER_PARCEL,
    EntityTy::T_CONTOUR,
    EntityTy::T_CAPITAL_PROJECT,
    EntityTy::T_SIGN,
    EntityTy::T_SIGN_POLE,
    EntityTy::T_REQUEST,
    EntityTy::T_EMERGENCY_RESPONSE_ROAD,
    EntityTy::T_RAILWAY_CROSSING,
    EntityTy::T_MOBILITY_HUB,
    EntityTy::T_CORRIDOR,
    EntityTy::T_CRASH,
    EntityTy::T_RAIL_LINE,
    EntityTy::T_RAIL_STOP,
    EntityTy::T_ROUTE,
    EntityTy::T_ROUTE_STOP,
    EntityTy::T_TRANSIT_STOP,
    EntityTy::T_TRANSIT_CENTER,
    EntityTy::T_EXPLORE_MODE_INTERSECTION,
    EntityTy::T_ETS_SEGMENT,
    EntityTy::T_FSA,
    EntityTy::T_NEIGHBORHOOD_BUSINESS_ASSOCIATION,
    EntityTy::T_COUNCIL_DISTRICT,
    EntityTy::T_PROJECT_CRASHBOARD,
    EntityTy::T_ELEVATION_LINE,
    EntityTy::T_AREA,
    EntityTy::T_TAX_LOT,
    EntityTy::T_FLOOD,
    EntityTy::T_COUNTY,
    EntityTy::T_CITY,
    EntityTy::T_ELEMENTARY_SCHOOL_DISTRICT,
    EntityTy::T_HIGH_SCHOOL_DISTRICT,
    EntityTy::T_MIDDLE_SCHOOL_DISTRICT,
    EntityTy::T_POLICY_AREA,
    EntityTy::T_2020_CENSUS_BLOCK,
    EntityTy::T_2010_CENSUS_BLOCK,
    EntityTy::T_2020_CENSUS_TRACT,
    EntityTy::T_NON_CTP_ROADS,
    EntityTy::T_COMMERCIAL_VACANCY,
    EntityTy::T_TESTING_SITE,
    EntityTy::T_CLINIC,
    EntityTy::T_STREET_LITTER,
    EntityTy::T_CHILDCARE_CENTER,
    EntityTy::T_CAMERA,
    EntityTy::T_ALLEY,
    EntityTy::T_PAVEMENT,
    EntityTy::T_PAVEMENT_STRIP,
    EntityTy::T_POLE,
    EntityTy::T_DASHBOARD_BUSINESS,
    EntityTy::T_SIGNAL,
    EntityTy::T_MAST_ARM,
    EntityTy::T_CAMERA_EXPLORE,
    EntityTy::T_DASHBOARD_PROPERTY,
    EntityTy::T_POLICE_REPORTED_CRASH,
    EntityTy::T_PARKING_SPACE,
    EntityTy::T_FIRE_RISK_SCORE,
    EntityTy::T_FIRE_RISK_CAUSE,
    EntityTy::T_FIRE_DEPARTMENT,
    EntityTy::T_PLANNED_SIDEWALK,
    EntityTy::T_PROPOSED_PEDESTRIAN_PROJECT,
    EntityTy::T_PROPOSED_BIKE_PROJECT,
    EntityTy::T_ADMINISTRATIVE_AREA,
    EntityTy::T_CURB_RAMP,
    EntityTy::T_PARKING_PERMIT_AREA,
    EntityTy::T_PARCEL,
    EntityTy::T_BOUNDARY,
    EntityTy::T_RAILWAY,
    EntityTy::T_SOIL,
    EntityTy::T_UTILITY_CABINET,
    EntityTy::T_SIGNAL_CABINET,
    EntityTy::T_PEDESTRIAN_BUTTON,
    EntityTy::T_TRAFFIC_CALMING,
    EntityTy::T_CURB,
    EntityTy::T_TRUCK_ROUTE,
    EntityTy::T_GREENWAY,
    EntityTy::T_ROAD_EDGE,
    EntityTy::T_RESTAURANT,
    EntityTy::T_BARRIER,
    EntityTy::T_PAVEMENT_MARKING,
    EntityTy::T_PLANNING_AREA,
    EntityTy::T_ORDER,
    EntityTy::T_FIRE_HYDRANT,
    EntityTy::T_CANNABIS_AND_LIQUOR_STORES,
    EntityTy::T_CENSUS_SUBDIVISION,
    EntityTy::T_SPEED_HUMP,
    EntityTy::T_CRASH_CUSHION,
    EntityTy::T_DEFAULT_AREA_FILTER,
    EntityTy::T_PLAYGROUND,
    EntityTy::T_PICNIC_SHELTER,
    EntityTy::T_TENNIS_COURT,
    EntityTy::T_SPORTS_FIELD,
    EntityTy::T_WASHROOM,
    EntityTy::T_BASEBALL_DIAMOND,
    EntityTy::T_ITS_DEVICE,
    EntityTy::T_SHORTLINE,
    EntityTy::T_TRANSIT_RELATED,
    EntityTy::T_FREIGHT_ANALYSIS_DASHBOARD,
    EntityTy::T_ACCESS_POINT,
    EntityTy::T_CENSUS_DIVISION,
    EntityTy::T_STATE_PROVINCE,
    EntityTy::T_FEDERAL,
    EntityTy::T_CANNABIS_AND_LIQUOR_STORES_TRANSFER
  };
  return values;
}

inline const char * const *EnumNamesEntityTy() {
  static const char * const names[263] = {
    "T_INVALID",
    "T_TFC",
    "T_TFC_LOOP",
    "T_TFC_CRASH",
    "T_TFC_TMC_REPORT",
    "T_ROAD_SEGMENT",
    "T_INTERSECTION",
    "T_SIDEWAlK",
    "T_BIKEWAY",
    "T_TRANSIT_LINE",
    "T_BIA",
    "T_NEIGHBOURHOOD",
    "T_NIA",
    "T_WARD",
    "T_DISTRICT",
    "T_CONSTITUENCY",
    "T_POSTAL_CODE_GEO",
    "T_BUSINESS",
    "T_LAND_PARCEL",
    "T_ADDRESS",
    "T_POSTAL_CODE_DEMOGRAPHICS",
    "T_ZONE",
    "T_PARK",
    "T_PARKING_LOT",
    "T_PARKING_TICKET",
    "T_PLACE_OF_INTEREST",
    "T_DAYCARE_CENTRE",
    "T_MEDICAL_CENTRE",
    "T_COMMERCIAL_LAND",
    "T_DEVELOPMENT_APPLICATION",
    "T_AVAILABLE_COMMERCIAL_SPACE",
    "T_BUILDING_FOOTPRINT",
    "T_DEVELOPED_EMPLOYMENT_LAND",
    "T_VACANT_EMPLOYMENT_LAND",
    "T_STREET",
    "T_BIKESHARE_STATION",
    "T_SUBWAY_LINE",
    "T_ON_STREET_PARKING",
    "T_PEDESTRIAN_ROUTE",
    "T_HERITAGE_DISTRICT",
    "T_BUS_ROUTE",
    "T_BUS_STOP",
    "T_POLITICAL_BOUNDARY",
    "T_CRIME",
    "T_EVENT",
    "T_TFC_SEGMENT_VOLUMES",
    "T_TFC_TMC_COUNTS",
    "T_TFC_AADT",
    "T_CONNECTIVITY_CORRIDORS",
    "T_MEDIANS",
    "T_EVACUATION_ROUTES",
    "T_TRAFFIC_METRICS",
    "T_COUNTERMEASURES_DEVICES",
    "T_TRAFFIC_INCIDENTS",
    "T_BLOCKGROUP_DEMOGRAPHIC",
    "T_PARKING_METER",
    "T_PROPERTY_VALUE_ASSESSMENT",
    "T_GOLF_COURSE",
    "T_BUILDING_PERMIT",
    "T_REALM",
    "T_ROAD_SEGMENT_COUNT_LOCATION",
    "T_INTERSECTION_COUNT_LOCATION",
    "T_TRIPS_ORIGIN_DESTINATION_PASSTHROUGH_BIA",
    "T_WORKLOGS",
    "T_FORECAST",
    "T_BRIDGES",
    "T_OPEN_MARKETS",
    "T_BIKE_FACILITIES",
    "T_DOG_LICENCES",
    "T_PEDESTRIAN_COUNT_LOCATION",
    "T_DISADVANTAGED_AREA",
    "T_TRANSPORTATION_ANALYSIS_ZONE",
    "T_ELECTION_DISTRICT",
    "T_DISSEMINATION_AREA",
    "T_RETAIL_AREA",
    "T_GROWTH_CENTER",
    "T_SEARCH_ATTRIBUTES",
    "T_PROPERTY",
    "T_DESIGNATED_AREA",
    "T_PROVINCIAL_FOREST",
    "T_TIMBER_SUPPLY_AREA",
    "T_COMMUNICATION_SITE",
    "T_CUT_BLOCK",
    "T_PERMIT",
    "T_LICENCE",
    "T_MAP_NOTATION",
    "T_REAL_PROPERTY_PROJECT",
    "T_RECREATION_SITE",
    "T_RECREATION_LINE",
    "T_RECREATION_POLYGON",
    "T_SPECIAL_ACCESS_ROAD",
    "T_GROWTH_YIELD_SAMPLE",
    "T_OLD_GROWTH_MANAGEMENT_AREA",
    "T_TREATY_AREA",
    "T_TREATY_LAND",
    "T_RELATED_TREATY_LAND",
    "T_ALC_ALR",
    "T_CONSERVATION_LAND",
    "T_MINFILE_MINERAL_OCCURRENCE_DATABASE",
    "T_CROWN_GRANTED_MINERAL_CLAIM",
    "T_MINERAL_RESERVES_SITES_BUSINESS_VIEW",
    "T_PETROLEUM_TITLE",
    "T_CONSERVANCY_AREA",
    "T_WILDLIFE_MANAGEMENT_AREA",
    "T_RESERVOIR_PERMIT",
    "T_WATER_LICENSED_WORK",
    "T_WATER_RIGHTS_APPLICATION",
    "T_WATER_RIGHTS_LICENCE",
    "T_GUIDE_OUTFITTER_AREA",
    "T_UNGULATE_WINTER_RANGE",
    "T_WILDLIFE_HABITAT_AREAS",
    "T_ROAD_SEGMENT_EXACT_COUNT_LOCATION",
    "T_EASEMENT",
    "T_STREET_LIGHT",
    "T_TRAIL",
    "T_ROAD_SEGMENT_TRAVEL_TIME_LOCATION",
    "T_CONSTRUCTION_PROJECT",
    "T_FACILITY",
    "T_SUBDIVISION_APPLICATION",
    "T_GARBAGE_ROUTE",
    "T_PUBLIC_ART",
    "T_CENSUS_TRACTS_DEMOGRAPHIC",
    "T_COMMUNITY_OF_CONCERN",
    "T_LIBRARY",
    "T_SCHOOL",
    "T_STREET_TREE",
    "T_ELECTRIC_VEHICLE_CHARGING_STATION",
    "T_VISION_ZERO_SAFETY_CORRIDOR",
    "T_TRAFFIC_VOLUME_MODEL",
    "T_PLANNING_PROJECT",
    "T_PHARMACY",
    "T_CENSUS_BLOCK",
    "T_ZIP_CODE",
    "T_FIRE_ASSESSMENT",
    "T_TRANSPORTATION_PAVEMENT",
    "T_VEHICLE",
    "T_TRIBAL_LAND",
    "T_FIRE_STATION",
    "T_WILDFIRE",
    "T_ACTIVE_TRANSPORTATION_LOCATION",
    "T_TIME_DENSITY",
    "T_YOUTH_DISABILITY_SUPPORT_SERVICES",
    "T_HOME_FIRE_RISK",
    "T_COUNT_LOCATION",
    "T_RAILROAD",
    "T_COMMUNITY_CENTER",
    "T_MEAL_SITE",
    "T_FOOD_BANK_AND_PARTNER",
    "T_HOUSING_UNIT",
    "T_BIKE_RACK",
    "T_IMPROVEMENT_AREA",
    "T_ZONING_DISTRICT",
    "T_RIGHT_OF_WAY",
    "T_FREEWAY",
    "T_BIKE_SUPPORT",
    "T_BIKE_CROSSING",
    "T_CYCLING_JUNCTION",
    "T_LANEWAYS",
    "T_CROSSWALK",
    "T_ISSUE",
    "T_MONUMENT",
    "T_WATER_PARCEL",
    "T_CONTOUR",
    "T_CAPITAL_PROJECT",
    "T_SIGN",
    "T_SIGN_POLE",
    "T_REQUEST",
    "T_EMERGENCY_RESPONSE_ROAD",
    "T_RAILWAY_CROSSING",
    "T_MOBILITY_HUB",
    "T_CORRIDOR",
    "T_CRASH",
    "T_RAIL_LINE",
    "T_RAIL_STOP",
    "T_ROUTE",
    "T_ROUTE_STOP",
    "T_TRANSIT_STOP",
    "T_TRANSIT_CENTER",
    "T_EXPLORE_MODE_INTERSECTION",
    "T_ETS_SEGMENT",
    "T_FSA",
    "T_NEIGHBORHOOD_BUSINESS_ASSOCIATION",
    "T_COUNCIL_DISTRICT",
    "T_PROJECT_CRASHBOARD",
    "T_ELEVATION_LINE",
    "T_AREA",
    "T_TAX_LOT",
    "T_FLOOD",
    "T_COUNTY",
    "T_CITY",
    "T_ELEMENTARY_SCHOOL_DISTRICT",
    "T_HIGH_SCHOOL_DISTRICT",
    "T_MIDDLE_SCHOOL_DISTRICT",
    "T_POLICY_AREA",
    "T_2020_CENSUS_BLOCK",
    "T_2010_CENSUS_BLOCK",
    "T_2020_CENSUS_TRACT",
    "T_NON_CTP_ROADS",
    "T_COMMERCIAL_VACANCY",
    "T_TESTING_SITE",
    "T_CLINIC",
    "T_STREET_LITTER",
    "T_CHILDCARE_CENTER",
    "T_CAMERA",
    "T_ALLEY",
    "T_PAVEMENT",
    "T_PAVEMENT_STRIP",
    "T_POLE",
    "T_DASHBOARD_BUSINESS",
    "T_SIGNAL",
    "T_MAST_ARM",
    "T_CAMERA_EXPLORE",
    "T_DASHBOARD_PROPERTY",
    "T_POLICE_REPORTED_CRASH",
    "T_PARKING_SPACE",
    "T_FIRE_RISK_SCORE",
    "T_FIRE_RISK_CAUSE",
    "T_FIRE_DEPARTMENT",
    "T_PLANNED_SIDEWALK",
    "T_PROPOSED_PEDESTRIAN_PROJECT",
    "T_PROPOSED_BIKE_PROJECT",
    "T_ADMINISTRATIVE_AREA",
    "T_CURB_RAMP",
    "T_PARKING_PERMIT_AREA",
    "T_PARCEL",
    "T_BOUNDARY",
    "T_RAILWAY",
    "T_SOIL",
    "T_UTILITY_CABINET",
    "T_SIGNAL_CABINET",
    "T_PEDESTRIAN_BUTTON",
    "T_TRAFFIC_CALMING",
    "T_CURB",
    "T_TRUCK_ROUTE",
    "T_GREENWAY",
    "T_ROAD_EDGE",
    "T_RESTAURANT",
    "T_BARRIER",
    "T_PAVEMENT_MARKING",
    "T_PLANNING_AREA",
    "T_ORDER",
    "T_FIRE_HYDRANT",
    "T_CANNABIS_AND_LIQUOR_STORES",
    "T_CENSUS_SUBDIVISION",
    "T_SPEED_HUMP",
    "T_CRASH_CUSHION",
    "T_DEFAULT_AREA_FILTER",
    "T_PLAYGROUND",
    "T_PICNIC_SHELTER",
    "T_TENNIS_COURT",
    "T_SPORTS_FIELD",
    "T_WASHROOM",
    "T_BASEBALL_DIAMOND",
    "T_ITS_DEVICE",
    "T_SHORTLINE",
    "T_TRANSIT_RELATED",
    "T_FREIGHT_ANALYSIS_DASHBOARD",
    "T_ACCESS_POINT",
    "T_CENSUS_DIVISION",
    "T_STATE_PROVINCE",
    "T_FEDERAL",
    "T_CANNABIS_AND_LIQUOR_STORES_TRANSFER",
    nullptr
  };
  return names;
}

inline const char *EnumNameEntityTy(EntityTy e) {
  if (::flatbuffers::IsOutRange(e, EntityTy::T_INVALID, EntityTy::T_CANNABIS_AND_LIQUOR_STORES_TRANSFER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEntityTy()[index];
}

enum class NodeTy : int32_t {
  N_INVALID = 0,
  /// Entities are world objects with (possible) links to other data sets
  N_ENTITY = 1,
  /// Emitters link to (possibly) deep sources of data (such as loop data sets)
  N_EMITTER = 2,
  /// Boundaries are geometry-only delineations of world-space (postal codes, neighbourhoods, cities, etc.)
  N_BOUNDARY = 3,
  MIN = N_INVALID,
  MAX = N_BOUNDARY
};

inline const NodeTy (&EnumValuesNodeTy())[4] {
  static const NodeTy values[] = {
    NodeTy::N_INVALID,
    NodeTy::N_ENTITY,
    NodeTy::N_EMITTER,
    NodeTy::N_BOUNDARY
  };
  return values;
}

inline const char * const *EnumNamesNodeTy() {
  static const char * const names[5] = {
    "N_INVALID",
    "N_ENTITY",
    "N_EMITTER",
    "N_BOUNDARY",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeTy(NodeTy e) {
  if (::flatbuffers::IsOutRange(e, NodeTy::N_INVALID, NodeTy::N_BOUNDARY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeTy()[index];
}

enum class EdgeTy : int32_t {
  E_INVALID = 0,
  E_POSTAL_CODE = 1,
  E_INTERSECTS = 2,
  E_CONTAINS = 3,
  E_WITHIN = 4,
  E_HAS_COUNTS = 5,
  E_OCCURS_AT = 6,
  E_REALM = 7,
  E_SEARCH_ATTRIBUTES = 8,
  E_ASSOCIATED_TFC_LOOP = 9,
  E_TRAFFIC_METRICS = 10,
  E_TIME_DENSITY = 11,
  E_CRASHBOARD_AGGREGATE_BY = 12,
  E_OPPOSING_ROAD_SEGMENT = 13,
  E_ASSOCIATED_CAMERA = 14,
  MIN = E_INVALID,
  MAX = E_ASSOCIATED_CAMERA
};

inline const EdgeTy (&EnumValuesEdgeTy())[15] {
  static const EdgeTy values[] = {
    EdgeTy::E_INVALID,
    EdgeTy::E_POSTAL_CODE,
    EdgeTy::E_INTERSECTS,
    EdgeTy::E_CONTAINS,
    EdgeTy::E_WITHIN,
    EdgeTy::E_HAS_COUNTS,
    EdgeTy::E_OCCURS_AT,
    EdgeTy::E_REALM,
    EdgeTy::E_SEARCH_ATTRIBUTES,
    EdgeTy::E_ASSOCIATED_TFC_LOOP,
    EdgeTy::E_TRAFFIC_METRICS,
    EdgeTy::E_TIME_DENSITY,
    EdgeTy::E_CRASHBOARD_AGGREGATE_BY,
    EdgeTy::E_OPPOSING_ROAD_SEGMENT,
    EdgeTy::E_ASSOCIATED_CAMERA
  };
  return values;
}

inline const char * const *EnumNamesEdgeTy() {
  static const char * const names[16] = {
    "E_INVALID",
    "E_POSTAL_CODE",
    "E_INTERSECTS",
    "E_CONTAINS",
    "E_WITHIN",
    "E_HAS_COUNTS",
    "E_OCCURS_AT",
    "E_REALM",
    "E_SEARCH_ATTRIBUTES",
    "E_ASSOCIATED_TFC_LOOP",
    "E_TRAFFIC_METRICS",
    "E_TIME_DENSITY",
    "E_CRASHBOARD_AGGREGATE_BY",
    "E_OPPOSING_ROAD_SEGMENT",
    "E_ASSOCIATED_CAMERA",
    nullptr
  };
  return names;
}

inline const char *EnumNameEdgeTy(EdgeTy e) {
  if (::flatbuffers::IsOutRange(e, EdgeTy::E_INVALID, EdgeTy::E_ASSOCIATED_CAMERA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEdgeTy()[index];
}

enum class Geometry : uint8_t {
  NONE = 0,
  Point = 1,
  Line = 2,
  MultiLine = 3,
  Polygon = 4,
  MultiPolygon = 5,
  MIN = NONE,
  MAX = MultiPolygon
};

inline const Geometry (&EnumValuesGeometry())[6] {
  static const Geometry values[] = {
    Geometry::NONE,
    Geometry::Point,
    Geometry::Line,
    Geometry::MultiLine,
    Geometry::Polygon,
    Geometry::MultiPolygon
  };
  return values;
}

inline const char * const *EnumNamesGeometry() {
  static const char * const names[7] = {
    "NONE",
    "Point",
    "Line",
    "MultiLine",
    "Polygon",
    "MultiPolygon",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometry(Geometry e) {
  if (::flatbuffers::IsOutRange(e, Geometry::NONE, Geometry::MultiPolygon)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometry()[index];
}

template<typename T> struct GeometryTraits {
  static const Geometry enum_value = Geometry::NONE;
};

template<> struct GeometryTraits<Point> {
  static const Geometry enum_value = Geometry::Point;
};

template<> struct GeometryTraits<Line> {
  static const Geometry enum_value = Geometry::Line;
};

template<> struct GeometryTraits<MultiLine> {
  static const Geometry enum_value = Geometry::MultiLine;
};

template<> struct GeometryTraits<Polygon> {
  static const Geometry enum_value = Geometry::Polygon;
};

template<> struct GeometryTraits<MultiPolygon> {
  static const Geometry enum_value = Geometry::MultiPolygon;
};

bool VerifyGeometry(::flatbuffers::Verifier &verifier, const void *obj, Geometry type);
bool VerifyGeometryVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Geometry> *types);

struct Point FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINT_GEO = 4
  };
  const ::flatbuffers::Vector<float> *point_geo() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POINT_GEO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POINT_GEO) &&
           verifier.VerifyVector(point_geo()) &&
           verifier.EndTable();
  }
};

struct PointBuilder {
  typedef Point Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_point_geo(::flatbuffers::Offset<::flatbuffers::Vector<float>> point_geo) {
    fbb_.AddOffset(Point::VT_POINT_GEO, point_geo);
  }
  explicit PointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Point> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Point>(end);
    fbb_.Required(o, Point::VT_POINT_GEO);
    return o;
  }
};

inline ::flatbuffers::Offset<Point> CreatePoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> point_geo = 0) {
  PointBuilder builder_(_fbb);
  builder_.add_point_geo(point_geo);
  return builder_.Finish();
}

struct Point::Traits {
  using type = Point;
  static auto constexpr Create = CreatePoint;
};

inline ::flatbuffers::Offset<Point> CreatePointDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *point_geo = nullptr) {
  auto point_geo__ = point_geo ? _fbb.CreateVector<float>(*point_geo) : 0;
  return CreatePoint(
      _fbb,
      point_geo__);
}

struct Line FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINE_GEO = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Point>> *line_geo() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Point>> *>(VT_LINE_GEO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LINE_GEO) &&
           verifier.VerifyVector(line_geo()) &&
           verifier.VerifyVectorOfTables(line_geo()) &&
           verifier.EndTable();
  }
};

struct LineBuilder {
  typedef Line Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_line_geo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Point>>> line_geo) {
    fbb_.AddOffset(Line::VT_LINE_GEO, line_geo);
  }
  explicit LineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Line> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Line>(end);
    fbb_.Required(o, Line::VT_LINE_GEO);
    return o;
  }
};

inline ::flatbuffers::Offset<Line> CreateLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Point>>> line_geo = 0) {
  LineBuilder builder_(_fbb);
  builder_.add_line_geo(line_geo);
  return builder_.Finish();
}

struct Line::Traits {
  using type = Line;
  static auto constexpr Create = CreateLine;
};

inline ::flatbuffers::Offset<Line> CreateLineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Point>> *line_geo = nullptr) {
  auto line_geo__ = line_geo ? _fbb.CreateVector<::flatbuffers::Offset<Point>>(*line_geo) : 0;
  return CreateLine(
      _fbb,
      line_geo__);
}

struct MultiLine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiLineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTILINE_GEO = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Line>> *multiline_geo() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Line>> *>(VT_MULTILINE_GEO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MULTILINE_GEO) &&
           verifier.VerifyVector(multiline_geo()) &&
           verifier.VerifyVectorOfTables(multiline_geo()) &&
           verifier.EndTable();
  }
};

struct MultiLineBuilder {
  typedef MultiLine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_multiline_geo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Line>>> multiline_geo) {
    fbb_.AddOffset(MultiLine::VT_MULTILINE_GEO, multiline_geo);
  }
  explicit MultiLineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MultiLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MultiLine>(end);
    fbb_.Required(o, MultiLine::VT_MULTILINE_GEO);
    return o;
  }
};

inline ::flatbuffers::Offset<MultiLine> CreateMultiLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Line>>> multiline_geo = 0) {
  MultiLineBuilder builder_(_fbb);
  builder_.add_multiline_geo(multiline_geo);
  return builder_.Finish();
}

struct MultiLine::Traits {
  using type = MultiLine;
  static auto constexpr Create = CreateMultiLine;
};

inline ::flatbuffers::Offset<MultiLine> CreateMultiLineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Line>> *multiline_geo = nullptr) {
  auto multiline_geo__ = multiline_geo ? _fbb.CreateVector<::flatbuffers::Offset<Line>>(*multiline_geo) : 0;
  return CreateMultiLine(
      _fbb,
      multiline_geo__);
}

/// Polygon is an array of arrays of points.
/// The first array is exterior coords, following are any interior holes
struct Polygon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolygonBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLYGON_GEO = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Line>> *polygon_geo() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Line>> *>(VT_POLYGON_GEO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_POLYGON_GEO) &&
           verifier.VerifyVector(polygon_geo()) &&
           verifier.VerifyVectorOfTables(polygon_geo()) &&
           verifier.EndTable();
  }
};

struct PolygonBuilder {
  typedef Polygon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_polygon_geo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Line>>> polygon_geo) {
    fbb_.AddOffset(Polygon::VT_POLYGON_GEO, polygon_geo);
  }
  explicit PolygonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Polygon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Polygon>(end);
    fbb_.Required(o, Polygon::VT_POLYGON_GEO);
    return o;
  }
};

inline ::flatbuffers::Offset<Polygon> CreatePolygon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Line>>> polygon_geo = 0) {
  PolygonBuilder builder_(_fbb);
  builder_.add_polygon_geo(polygon_geo);
  return builder_.Finish();
}

struct Polygon::Traits {
  using type = Polygon;
  static auto constexpr Create = CreatePolygon;
};

inline ::flatbuffers::Offset<Polygon> CreatePolygonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Line>> *polygon_geo = nullptr) {
  auto polygon_geo__ = polygon_geo ? _fbb.CreateVector<::flatbuffers::Offset<Line>>(*polygon_geo) : 0;
  return CreatePolygon(
      _fbb,
      polygon_geo__);
}

struct MultiPolygon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MultiPolygonBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTIPOLYGON_GEO = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Polygon>> *multipolygon_geo() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Polygon>> *>(VT_MULTIPOLYGON_GEO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MULTIPOLYGON_GEO) &&
           verifier.VerifyVector(multipolygon_geo()) &&
           verifier.VerifyVectorOfTables(multipolygon_geo()) &&
           verifier.EndTable();
  }
};

struct MultiPolygonBuilder {
  typedef MultiPolygon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_multipolygon_geo(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Polygon>>> multipolygon_geo) {
    fbb_.AddOffset(MultiPolygon::VT_MULTIPOLYGON_GEO, multipolygon_geo);
  }
  explicit MultiPolygonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MultiPolygon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MultiPolygon>(end);
    fbb_.Required(o, MultiPolygon::VT_MULTIPOLYGON_GEO);
    return o;
  }
};

inline ::flatbuffers::Offset<MultiPolygon> CreateMultiPolygon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Polygon>>> multipolygon_geo = 0) {
  MultiPolygonBuilder builder_(_fbb);
  builder_.add_multipolygon_geo(multipolygon_geo);
  return builder_.Finish();
}

struct MultiPolygon::Traits {
  using type = MultiPolygon;
  static auto constexpr Create = CreateMultiPolygon;
};

inline ::flatbuffers::Offset<MultiPolygon> CreateMultiPolygonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Polygon>> *multipolygon_geo = nullptr) {
  auto multipolygon_geo__ = multipolygon_geo ? _fbb.CreateVector<::flatbuffers::Offset<Polygon>>(*multipolygon_geo) : 0;
  return CreateMultiPolygon(
      _fbb,
      multipolygon_geo__);
}

struct GraphNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphNodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT__ENTITY_TYPE = 4,
    VT__NODE_TYPE = 6,
    VT__STREAM = 8,
    VT__NODE_ID = 10,
    VT__LOCATION = 12,
    VT__GEOM_TYPE = 14,
    VT__GEOM = 16,
    VT__DESCRIPTION = 18,
    VT__UID = 20
  };
  /// Entity type (ie: traffic loop, road, power line, building, business, demographic data, collision,  ...)
  EntityTy _entity_type() const {
    return static_cast<EntityTy>(GetField<int32_t>(VT__ENTITY_TYPE, 0));
  }
  /// Node type, such as emitter vs. entity
  NodeTy _node_type() const {
    return static_cast<NodeTy>(GetField<int32_t>(VT__NODE_TYPE, 0));
  }
  /// ID of the associated data source
  const ObjectId *_stream() const {
    return GetPointer<const ObjectId *>(VT__STREAM);
  }
  /// Record id in the data source.
  const GenericId *_node_id() const {
    return GetPointer<const GenericId *>(VT__NODE_ID);
  }
  /// lat/lng point in space, or centroid if not a point
  const Point *_location() const {
    return GetPointer<const Point *>(VT__LOCATION);
  }
  Geometry _geom_type() const {
    return static_cast<Geometry>(GetField<uint8_t>(VT__GEOM_TYPE, 0));
  }
  /// polygon / line / point / null
  const void *_geom() const {
    return GetPointer<const void *>(VT__GEOM);
  }
  template<typename T> const T *_geom_as() const;
  const Point *_geom_as_Point() const {
    return _geom_type() == Geometry::Point ? static_cast<const Point *>(_geom()) : nullptr;
  }
  const Line *_geom_as_Line() const {
    return _geom_type() == Geometry::Line ? static_cast<const Line *>(_geom()) : nullptr;
  }
  const MultiLine *_geom_as_MultiLine() const {
    return _geom_type() == Geometry::MultiLine ? static_cast<const MultiLine *>(_geom()) : nullptr;
  }
  const Polygon *_geom_as_Polygon() const {
    return _geom_type() == Geometry::Polygon ? static_cast<const Polygon *>(_geom()) : nullptr;
  }
  const MultiPolygon *_geom_as_MultiPolygon() const {
    return _geom_type() == Geometry::MultiPolygon ? static_cast<const MultiPolygon *>(_geom()) : nullptr;
  }
  /// A human-centric description of this graph node.
  const ::flatbuffers::String *_description() const {
    return GetPointer<const ::flatbuffers::String *>(VT__DESCRIPTION);
  }
  /// Unique database-specific identifier
  uint64_t _uid() const {
    return GetField<uint64_t>(VT__UID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT__ENTITY_TYPE, 4) &&
           VerifyField<int32_t>(verifier, VT__NODE_TYPE, 4) &&
           VerifyOffset(verifier, VT__STREAM) &&
           verifier.VerifyTable(_stream()) &&
           VerifyOffset(verifier, VT__NODE_ID) &&
           verifier.VerifyTable(_node_id()) &&
           VerifyOffset(verifier, VT__LOCATION) &&
           verifier.VerifyTable(_location()) &&
           VerifyField<uint8_t>(verifier, VT__GEOM_TYPE, 1) &&
           VerifyOffset(verifier, VT__GEOM) &&
           VerifyGeometry(verifier, _geom(), _geom_type()) &&
           VerifyOffset(verifier, VT__DESCRIPTION) &&
           verifier.VerifyString(_description()) &&
           VerifyField<uint64_t>(verifier, VT__UID, 8) &&
           verifier.EndTable();
  }
};

template<> inline const Point *GraphNode::_geom_as<Point>() const {
  return _geom_as_Point();
}

template<> inline const Line *GraphNode::_geom_as<Line>() const {
  return _geom_as_Line();
}

template<> inline const MultiLine *GraphNode::_geom_as<MultiLine>() const {
  return _geom_as_MultiLine();
}

template<> inline const Polygon *GraphNode::_geom_as<Polygon>() const {
  return _geom_as_Polygon();
}

template<> inline const MultiPolygon *GraphNode::_geom_as<MultiPolygon>() const {
  return _geom_as_MultiPolygon();
}

struct GraphNodeBuilder {
  typedef GraphNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add__entity_type(EntityTy _entity_type) {
    fbb_.AddElement<int32_t>(GraphNode::VT__ENTITY_TYPE, static_cast<int32_t>(_entity_type), 0);
  }
  void add__node_type(NodeTy _node_type) {
    fbb_.AddElement<int32_t>(GraphNode::VT__NODE_TYPE, static_cast<int32_t>(_node_type), 0);
  }
  void add__stream(::flatbuffers::Offset<ObjectId> _stream) {
    fbb_.AddOffset(GraphNode::VT__STREAM, _stream);
  }
  void add__node_id(::flatbuffers::Offset<GenericId> _node_id) {
    fbb_.AddOffset(GraphNode::VT__NODE_ID, _node_id);
  }
  void add__location(::flatbuffers::Offset<Point> _location) {
    fbb_.AddOffset(GraphNode::VT__LOCATION, _location);
  }
  void add__geom_type(Geometry _geom_type) {
    fbb_.AddElement<uint8_t>(GraphNode::VT__GEOM_TYPE, static_cast<uint8_t>(_geom_type), 0);
  }
  void add__geom(::flatbuffers::Offset<void> _geom) {
    fbb_.AddOffset(GraphNode::VT__GEOM, _geom);
  }
  void add__description(::flatbuffers::Offset<::flatbuffers::String> _description) {
    fbb_.AddOffset(GraphNode::VT__DESCRIPTION, _description);
  }
  void add__uid(uint64_t _uid) {
    fbb_.AddElement<uint64_t>(GraphNode::VT__UID, _uid, 0);
  }
  explicit GraphNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GraphNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GraphNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GraphNode> CreateGraphNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EntityTy _entity_type = EntityTy::T_INVALID,
    NodeTy _node_type = NodeTy::N_INVALID,
    ::flatbuffers::Offset<ObjectId> _stream = 0,
    ::flatbuffers::Offset<GenericId> _node_id = 0,
    ::flatbuffers::Offset<Point> _location = 0,
    Geometry _geom_type = Geometry::NONE,
    ::flatbuffers::Offset<void> _geom = 0,
    ::flatbuffers::Offset<::flatbuffers::String> _description = 0,
    uint64_t _uid = 0) {
  GraphNodeBuilder builder_(_fbb);
  builder_.add__uid(_uid);
  builder_.add__description(_description);
  builder_.add__geom(_geom);
  builder_.add__location(_location);
  builder_.add__node_id(_node_id);
  builder_.add__stream(_stream);
  builder_.add__node_type(_node_type);
  builder_.add__entity_type(_entity_type);
  builder_.add__geom_type(_geom_type);
  return builder_.Finish();
}

struct GraphNode::Traits {
  using type = GraphNode;
  static auto constexpr Create = CreateGraphNode;
};

inline ::flatbuffers::Offset<GraphNode> CreateGraphNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EntityTy _entity_type = EntityTy::T_INVALID,
    NodeTy _node_type = NodeTy::N_INVALID,
    ::flatbuffers::Offset<ObjectId> _stream = 0,
    ::flatbuffers::Offset<GenericId> _node_id = 0,
    ::flatbuffers::Offset<Point> _location = 0,
    Geometry _geom_type = Geometry::NONE,
    ::flatbuffers::Offset<void> _geom = 0,
    const char *_description = nullptr,
    uint64_t _uid = 0) {
  auto _description__ = _description ? _fbb.CreateString(_description) : 0;
  return CreateGraphNode(
      _fbb,
      _entity_type,
      _node_type,
      _stream,
      _node_id,
      _location,
      _geom_type,
      _geom,
      _description__,
      _uid);
}

struct GraphEdge FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphEdgeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT__KIND = 4,
    VT__FROM = 6,
    VT__TO = 8
  };
  EdgeTy _kind() const {
    return static_cast<EdgeTy>(GetField<int32_t>(VT__KIND, 0));
  }
  int64_t _from() const {
    return GetField<int64_t>(VT__FROM, 0);
  }
  int64_t _to() const {
    return GetField<int64_t>(VT__TO, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT__KIND, 4) &&
           VerifyField<int64_t>(verifier, VT__FROM, 8) &&
           VerifyField<int64_t>(verifier, VT__TO, 8) &&
           verifier.EndTable();
  }
};

struct GraphEdgeBuilder {
  typedef GraphEdge Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add__kind(EdgeTy _kind) {
    fbb_.AddElement<int32_t>(GraphEdge::VT__KIND, static_cast<int32_t>(_kind), 0);
  }
  void add__from(int64_t _from) {
    fbb_.AddElement<int64_t>(GraphEdge::VT__FROM, _from, 0);
  }
  void add__to(int64_t _to) {
    fbb_.AddElement<int64_t>(GraphEdge::VT__TO, _to, 0);
  }
  explicit GraphEdgeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GraphEdge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GraphEdge>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GraphEdge> CreateGraphEdge(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EdgeTy _kind = EdgeTy::E_INVALID,
    int64_t _from = 0,
    int64_t _to = 0) {
  GraphEdgeBuilder builder_(_fbb);
  builder_.add__to(_to);
  builder_.add__from(_from);
  builder_.add__kind(_kind);
  return builder_.Finish();
}

struct GraphEdge::Traits {
  using type = GraphEdge;
  static auto constexpr Create = CreateGraphEdge;
};

inline bool VerifyGeometry(::flatbuffers::Verifier &verifier, const void *obj, Geometry type) {
  switch (type) {
    case Geometry::NONE: {
      return true;
    }
    case Geometry::Point: {
      auto ptr = reinterpret_cast<const Point *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Geometry::Line: {
      auto ptr = reinterpret_cast<const Line *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Geometry::MultiLine: {
      auto ptr = reinterpret_cast<const MultiLine *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Geometry::Polygon: {
      auto ptr = reinterpret_cast<const Polygon *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Geometry::MultiPolygon: {
      auto ptr = reinterpret_cast<const MultiPolygon *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGeometryVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Geometry> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeometry(
        verifier,  values->Get(i), types->GetEnum<Geometry>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_ENTITY_H_
