// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OBJECT_H_
#define FLATBUFFERS_GENERATED_OBJECT_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"
#include "flatbuffers/flex_flat_util.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "data_generated.h"
#include "id_generated.h"
#include "stream_generated.h"
#include "worklog_generated.h"

struct DataCatalogObject;
struct DataCatalogObjectBuilder;

struct ObjectSummary;
struct ObjectSummaryBuilder;

struct ObjectSummaryList;
struct ObjectSummaryListBuilder;

struct ObjectIdList;
struct ObjectIdListBuilder;

struct ObjectIdPair;
struct ObjectIdPairBuilder;

struct ObjectIdPairList;
struct ObjectIdPairListBuilder;

enum class DataCatalogObjectTy : int16_t {
  Invalid = 0,
  WorkLog = 1,
  Schematic = 2,
  Node = 3,
  Stream = 4,
  Metadata = 5,
  Source = 6,
  UserProject = 7,
  UseCase = 8,
  UserPreferences = 9,
  AccessControlList = 10,
  DirectoryEntry = 11,
  Notification = 12,
  Model = 13,
  MIN = Invalid,
  MAX = Model
};

inline const DataCatalogObjectTy (&EnumValuesDataCatalogObjectTy())[14] {
  static const DataCatalogObjectTy values[] = {
    DataCatalogObjectTy::Invalid,
    DataCatalogObjectTy::WorkLog,
    DataCatalogObjectTy::Schematic,
    DataCatalogObjectTy::Node,
    DataCatalogObjectTy::Stream,
    DataCatalogObjectTy::Metadata,
    DataCatalogObjectTy::Source,
    DataCatalogObjectTy::UserProject,
    DataCatalogObjectTy::UseCase,
    DataCatalogObjectTy::UserPreferences,
    DataCatalogObjectTy::AccessControlList,
    DataCatalogObjectTy::DirectoryEntry,
    DataCatalogObjectTy::Notification,
    DataCatalogObjectTy::Model
  };
  return values;
}

inline const char * const *EnumNamesDataCatalogObjectTy() {
  static const char * const names[15] = {
    "Invalid",
    "WorkLog",
    "Schematic",
    "Node",
    "Stream",
    "Metadata",
    "Source",
    "UserProject",
    "UseCase",
    "UserPreferences",
    "AccessControlList",
    "DirectoryEntry",
    "Notification",
    "Model",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataCatalogObjectTy(DataCatalogObjectTy e) {
  if (::flatbuffers::IsOutRange(e, DataCatalogObjectTy::Invalid, DataCatalogObjectTy::Model)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataCatalogObjectTy()[index];
}

enum class DataCatalogObjectFlags : uint32_t {
  /// objects generated by a job
  Generated = 1,
  /// Object contents are encrypted. When this is set the `obj` field is an
  /// EncryptedObject instance.
  Encrypted = 2,
  /// Object has a cryptographic signature
  Signed = 4,
  NONE = 0,
  ANY = 7
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(DataCatalogObjectFlags, uint32_t)

inline const DataCatalogObjectFlags (&EnumValuesDataCatalogObjectFlags())[3] {
  static const DataCatalogObjectFlags values[] = {
    DataCatalogObjectFlags::Generated,
    DataCatalogObjectFlags::Encrypted,
    DataCatalogObjectFlags::Signed
  };
  return values;
}

inline const char * const *EnumNamesDataCatalogObjectFlags() {
  static const char * const names[5] = {
    "Generated",
    "Encrypted",
    "",
    "Signed",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataCatalogObjectFlags(DataCatalogObjectFlags e) {
  if (::flatbuffers::IsOutRange(e, DataCatalogObjectFlags::Generated, DataCatalogObjectFlags::Signed)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(DataCatalogObjectFlags::Generated);
  return EnumNamesDataCatalogObjectFlags()[index];
}

struct DataCatalogObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataCatalogObjectBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TY = 4,
    VT_OBJ = 6,
    VT_PARENTS = 8,
    VT_USER = 10,
    VT_COMMENT = 12,
    VT_TIME = 14,
    VT_TAGS = 16,
    VT_FLAGS = 18,
    VT_ATTRIBUTES = 20,
    VT_VERSION = 22,
    VT_DEFAULT_MODE = 24,
    VT_SIGNATURE = 26
  };
  DataCatalogObjectTy ty() const {
    return static_cast<DataCatalogObjectTy>(GetField<int16_t>(VT_TY, 0));
  }
  /// This field is either an embedded flatbuffer containing the actual object
  /// content (ie: worklog, schematic, ...) if the Encrypted flag is unset, or
  /// an EncryptedObject where the obj field of the EncryptedObject table is
  /// the embedded flatbuffer of the object if it is set.
  const ::flatbuffers::Vector<uint8_t> *obj() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OBJ);
  }
  /// Parent nodes of this commit. To handle the cases of multiple parents (ie:
  /// in cases of parallel mutation), this field allows multiple IDs to be specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContentId>> *parents() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContentId>> *>(VT_PARENTS);
  }
  /// User ID of the person committing the change.
  const B2cId *user() const {
    return GetPointer<const B2cId *>(VT_USER);
  }
  /// Optional change log comment
  const ::flatbuffers::String *comment() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENT);
  }
  /// UTC timestamp (in ms) when this change was made.
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>> *>(VT_ATTRIBUTES);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  /// Default protection mode (see PermissionTy in the permissions module).
  /// Purpose is to determine what happens when an object is navigated to
  /// (ie: a directory in the drive). Defaults to 0 (ie: no access)
  uint32_t default_mode() const {
    return GetField<uint32_t>(VT_DEFAULT_MODE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TY, 2) &&
           VerifyOffsetRequired(verifier, VT_OBJ) &&
           verifier.VerifyVector(obj()) &&
           VerifyOffsetRequired(verifier, VT_PARENTS) &&
           verifier.VerifyVector(parents()) &&
           verifier.VerifyVectorOfTables(parents()) &&
           VerifyOffsetRequired(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyString(comment()) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEFAULT_MODE, 4) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           verifier.EndTable();
  }
};

struct DataCatalogObjectBuilder {
  typedef DataCatalogObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ty(DataCatalogObjectTy ty) {
    fbb_.AddElement<int16_t>(DataCatalogObject::VT_TY, static_cast<int16_t>(ty), 0);
  }
  void add_obj(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> obj) {
    fbb_.AddOffset(DataCatalogObject::VT_OBJ, obj);
  }
  void add_parents(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContentId>>> parents) {
    fbb_.AddOffset(DataCatalogObject::VT_PARENTS, parents);
  }
  void add_user(::flatbuffers::Offset<B2cId> user) {
    fbb_.AddOffset(DataCatalogObject::VT_USER, user);
  }
  void add_comment(::flatbuffers::Offset<::flatbuffers::String> comment) {
    fbb_.AddOffset(DataCatalogObject::VT_COMMENT, comment);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(DataCatalogObject::VT_TIME, time, 0);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(DataCatalogObject::VT_TAGS, tags);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(DataCatalogObject::VT_FLAGS, flags, 0);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>>> attributes) {
    fbb_.AddOffset(DataCatalogObject::VT_ATTRIBUTES, attributes);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(DataCatalogObject::VT_VERSION, version, 0);
  }
  void add_default_mode(uint32_t default_mode) {
    fbb_.AddElement<uint32_t>(DataCatalogObject::VT_DEFAULT_MODE, default_mode, 0);
  }
  void add_signature(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(DataCatalogObject::VT_SIGNATURE, signature);
  }
  explicit DataCatalogObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataCatalogObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataCatalogObject>(end);
    fbb_.Required(o, DataCatalogObject::VT_OBJ);
    fbb_.Required(o, DataCatalogObject::VT_PARENTS);
    fbb_.Required(o, DataCatalogObject::VT_USER);
    return o;
  }
};

inline ::flatbuffers::Offset<DataCatalogObject> CreateDataCatalogObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DataCatalogObjectTy ty = DataCatalogObjectTy::Invalid,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> obj = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContentId>>> parents = 0,
    ::flatbuffers::Offset<B2cId> user = 0,
    ::flatbuffers::Offset<::flatbuffers::String> comment = 0,
    uint64_t time = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0,
    uint32_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AttributePair>>> attributes = 0,
    uint32_t version = 0,
    uint32_t default_mode = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> signature = 0) {
  DataCatalogObjectBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_signature(signature);
  builder_.add_default_mode(default_mode);
  builder_.add_version(version);
  builder_.add_attributes(attributes);
  builder_.add_flags(flags);
  builder_.add_tags(tags);
  builder_.add_comment(comment);
  builder_.add_user(user);
  builder_.add_parents(parents);
  builder_.add_obj(obj);
  builder_.add_ty(ty);
  return builder_.Finish();
}

struct DataCatalogObject::Traits {
  using type = DataCatalogObject;
  static auto constexpr Create = CreateDataCatalogObject;
};

inline ::flatbuffers::Offset<DataCatalogObject> CreateDataCatalogObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DataCatalogObjectTy ty = DataCatalogObjectTy::Invalid,
    const std::vector<uint8_t> *obj = nullptr,
    const std::vector<::flatbuffers::Offset<ContentId>> *parents = nullptr,
    ::flatbuffers::Offset<B2cId> user = 0,
    const char *comment = nullptr,
    uint64_t time = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr,
    uint32_t flags = 0,
    const std::vector<::flatbuffers::Offset<AttributePair>> *attributes = nullptr,
    uint32_t version = 0,
    uint32_t default_mode = 0,
    const std::vector<uint8_t> *signature = nullptr) {
  auto obj__ = obj ? _fbb.CreateVector<uint8_t>(*obj) : 0;
  auto parents__ = parents ? _fbb.CreateVector<::flatbuffers::Offset<ContentId>>(*parents) : 0;
  auto comment__ = comment ? _fbb.CreateString(comment) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<AttributePair>>(*attributes) : 0;
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  return CreateDataCatalogObject(
      _fbb,
      ty,
      obj__,
      parents__,
      user,
      comment__,
      time,
      tags__,
      flags,
      attributes__,
      version,
      default_mode,
      signature__);
}

struct ObjectSummary FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectSummaryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_HEAD_REVISION = 6,
    VT_TY = 8,
    VT_TIME = 10,
    VT_ACL = 12,
    VT_DRIVE_SIZE = 14
  };
  const ObjectId *id() const {
    return GetPointer<const ObjectId *>(VT_ID);
  }
  const ContentId *head_revision() const {
    return GetPointer<const ContentId *>(VT_HEAD_REVISION);
  }
  DataCatalogObjectTy ty() const {
    return static_cast<DataCatalogObjectTy>(GetField<int16_t>(VT_TY, 0));
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const ObjectId *acl() const {
    return GetPointer<const ObjectId *>(VT_ACL);
  }
  uint64_t drive_size() const {
    return GetField<uint64_t>(VT_DRIVE_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_HEAD_REVISION) &&
           verifier.VerifyTable(head_revision()) &&
           VerifyField<int16_t>(verifier, VT_TY, 2) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyOffset(verifier, VT_ACL) &&
           verifier.VerifyTable(acl()) &&
           VerifyField<uint64_t>(verifier, VT_DRIVE_SIZE, 8) &&
           verifier.EndTable();
  }
};

struct ObjectSummaryBuilder {
  typedef ObjectSummary Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ObjectId> id) {
    fbb_.AddOffset(ObjectSummary::VT_ID, id);
  }
  void add_head_revision(::flatbuffers::Offset<ContentId> head_revision) {
    fbb_.AddOffset(ObjectSummary::VT_HEAD_REVISION, head_revision);
  }
  void add_ty(DataCatalogObjectTy ty) {
    fbb_.AddElement<int16_t>(ObjectSummary::VT_TY, static_cast<int16_t>(ty), 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(ObjectSummary::VT_TIME, time, 0);
  }
  void add_acl(::flatbuffers::Offset<ObjectId> acl) {
    fbb_.AddOffset(ObjectSummary::VT_ACL, acl);
  }
  void add_drive_size(uint64_t drive_size) {
    fbb_.AddElement<uint64_t>(ObjectSummary::VT_DRIVE_SIZE, drive_size, 0);
  }
  explicit ObjectSummaryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectSummary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectSummary>(end);
    fbb_.Required(o, ObjectSummary::VT_ID);
    fbb_.Required(o, ObjectSummary::VT_HEAD_REVISION);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectSummary> CreateObjectSummary(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    ::flatbuffers::Offset<ContentId> head_revision = 0,
    DataCatalogObjectTy ty = DataCatalogObjectTy::Invalid,
    uint64_t time = 0,
    ::flatbuffers::Offset<ObjectId> acl = 0,
    uint64_t drive_size = 0) {
  ObjectSummaryBuilder builder_(_fbb);
  builder_.add_drive_size(drive_size);
  builder_.add_time(time);
  builder_.add_acl(acl);
  builder_.add_head_revision(head_revision);
  builder_.add_id(id);
  builder_.add_ty(ty);
  return builder_.Finish();
}

struct ObjectSummary::Traits {
  using type = ObjectSummary;
  static auto constexpr Create = CreateObjectSummary;
};

struct ObjectSummaryList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectSummaryListBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAIRS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectSummary>> *pairs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectSummary>> *>(VT_PAIRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PAIRS) &&
           verifier.VerifyVector(pairs()) &&
           verifier.VerifyVectorOfTables(pairs()) &&
           verifier.EndTable();
  }
};

struct ObjectSummaryListBuilder {
  typedef ObjectSummaryList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pairs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectSummary>>> pairs) {
    fbb_.AddOffset(ObjectSummaryList::VT_PAIRS, pairs);
  }
  explicit ObjectSummaryListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectSummaryList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectSummaryList>(end);
    fbb_.Required(o, ObjectSummaryList::VT_PAIRS);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectSummaryList> CreateObjectSummaryList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectSummary>>> pairs = 0) {
  ObjectSummaryListBuilder builder_(_fbb);
  builder_.add_pairs(pairs);
  return builder_.Finish();
}

struct ObjectSummaryList::Traits {
  using type = ObjectSummaryList;
  static auto constexpr Create = CreateObjectSummaryList;
};

inline ::flatbuffers::Offset<ObjectSummaryList> CreateObjectSummaryListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ObjectSummary>> *pairs = nullptr) {
  auto pairs__ = pairs ? _fbb.CreateVector<::flatbuffers::Offset<ObjectSummary>>(*pairs) : 0;
  return CreateObjectSummaryList(
      _fbb,
      pairs__);
}

struct ObjectIdList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectIdListBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *ids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *>(VT_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_IDS) &&
           verifier.VerifyVector(ids()) &&
           verifier.VerifyVectorOfTables(ids()) &&
           verifier.EndTable();
  }
};

struct ObjectIdListBuilder {
  typedef ObjectIdList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> ids) {
    fbb_.AddOffset(ObjectIdList::VT_IDS, ids);
  }
  explicit ObjectIdListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectIdList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectIdList>(end);
    fbb_.Required(o, ObjectIdList::VT_IDS);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectIdList> CreateObjectIdList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> ids = 0) {
  ObjectIdListBuilder builder_(_fbb);
  builder_.add_ids(ids);
  return builder_.Finish();
}

struct ObjectIdList::Traits {
  using type = ObjectIdList;
  static auto constexpr Create = CreateObjectIdList;
};

inline ::flatbuffers::Offset<ObjectIdList> CreateObjectIdListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ObjectId>> *ids = nullptr) {
  auto ids__ = ids ? _fbb.CreateVector<::flatbuffers::Offset<ObjectId>>(*ids) : 0;
  return CreateObjectIdList(
      _fbb,
      ids__);
}

struct ObjectIdPair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectIdPairBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_OBJECT = 6
  };
  const ObjectId *id() const {
    return GetPointer<const ObjectId *>(VT_ID);
  }
  const ::flatbuffers::Vector<uint8_t> *object() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OBJECT);
  }
  const DataCatalogObject *object_nested_root() const {
    const auto _f = object();
    return _f ? ::flatbuffers::GetRoot<DataCatalogObject>(_f->Data())
              : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           verifier.VerifyVector(object()) &&
           verifier.VerifyNestedFlatBuffer<DataCatalogObject>(object(), nullptr) &&
           verifier.EndTable();
  }
};

struct ObjectIdPairBuilder {
  typedef ObjectIdPair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ObjectId> id) {
    fbb_.AddOffset(ObjectIdPair::VT_ID, id);
  }
  void add_object(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> object) {
    fbb_.AddOffset(ObjectIdPair::VT_OBJECT, object);
  }
  explicit ObjectIdPairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectIdPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectIdPair>(end);
    fbb_.Required(o, ObjectIdPair::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectIdPair> CreateObjectIdPair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> object = 0) {
  ObjectIdPairBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ObjectIdPair::Traits {
  using type = ObjectIdPair;
  static auto constexpr Create = CreateObjectIdPair;
};

inline ::flatbuffers::Offset<ObjectIdPair> CreateObjectIdPairDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    const std::vector<uint8_t> *object = nullptr) {
  auto object__ = object ? _fbb.CreateVector<uint8_t>(*object) : 0;
  return CreateObjectIdPair(
      _fbb,
      id,
      object__);
}

struct ObjectIdPairList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectIdPairListBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAIRS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectIdPair>> *pairs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectIdPair>> *>(VT_PAIRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PAIRS) &&
           verifier.VerifyVector(pairs()) &&
           verifier.VerifyVectorOfTables(pairs()) &&
           verifier.EndTable();
  }
};

struct ObjectIdPairListBuilder {
  typedef ObjectIdPairList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pairs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectIdPair>>> pairs) {
    fbb_.AddOffset(ObjectIdPairList::VT_PAIRS, pairs);
  }
  explicit ObjectIdPairListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectIdPairList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectIdPairList>(end);
    fbb_.Required(o, ObjectIdPairList::VT_PAIRS);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectIdPairList> CreateObjectIdPairList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectIdPair>>> pairs = 0) {
  ObjectIdPairListBuilder builder_(_fbb);
  builder_.add_pairs(pairs);
  return builder_.Finish();
}

struct ObjectIdPairList::Traits {
  using type = ObjectIdPairList;
  static auto constexpr Create = CreateObjectIdPairList;
};

inline ::flatbuffers::Offset<ObjectIdPairList> CreateObjectIdPairListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ObjectIdPair>> *pairs = nullptr) {
  auto pairs__ = pairs ? _fbb.CreateVector<::flatbuffers::Offset<ObjectIdPair>>(*pairs) : 0;
  return CreateObjectIdPairList(
      _fbb,
      pairs__);
}

inline const DataCatalogObject *GetDataCatalogObject(const void *buf) {
  return ::flatbuffers::GetRoot<DataCatalogObject>(buf);
}

inline const DataCatalogObject *GetSizePrefixedDataCatalogObject(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DataCatalogObject>(buf);
}

inline bool VerifyDataCatalogObjectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DataCatalogObject>(nullptr);
}

inline bool VerifySizePrefixedDataCatalogObjectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DataCatalogObject>(nullptr);
}

inline void FinishDataCatalogObjectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DataCatalogObject> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDataCatalogObjectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DataCatalogObject> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_OBJECT_H_
