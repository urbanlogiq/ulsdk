// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FS_H_
#define FLATBUFFERS_GENERATED_FS_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"
#include "flatbuffers/flex_flat_util.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "crypto_generated.h"
#include "id_generated.h"
#include "object_generated.h"
#include "value_generated.h"

struct Attr;
struct AttrBuilder;

struct ObjectRef;
struct ObjectRefBuilder;

struct TopLevelDirectory;
struct TopLevelDirectoryBuilder;

struct Chunk;
struct ChunkBuilder;

struct File;
struct FileBuilder;

struct Slot;
struct SlotBuilder;

struct Directory;
struct DirectoryBuilder;

struct DirectoryEntry;
struct DirectoryEntryBuilder;

struct ListDirectory;
struct ListDirectoryBuilder;

struct ListFile;
struct ListFileBuilder;

struct ListObject;
struct ListObjectBuilder;

struct ListSlot;
struct ListSlotBuilder;

struct DirectoryList;
struct DirectoryListBuilder;

struct NewLink;
struct NewLinkBuilder;

struct MoveRequest;
struct MoveRequestBuilder;

enum class EntryTy : uint32_t {
  File = 0,
  Directory = 1,
  Object = 2,
  TopLevelDirectory = 3,
  MIN = File,
  MAX = TopLevelDirectory
};

inline const EntryTy (&EnumValuesEntryTy())[4] {
  static const EntryTy values[] = {
    EntryTy::File,
    EntryTy::Directory,
    EntryTy::Object,
    EntryTy::TopLevelDirectory
  };
  return values;
}

inline const char * const *EnumNamesEntryTy() {
  static const char * const names[5] = {
    "File",
    "Directory",
    "Object",
    "TopLevelDirectory",
    nullptr
  };
  return names;
}

inline const char *EnumNameEntryTy(EntryTy e) {
  if (::flatbuffers::IsOutRange(e, EntryTy::File, EntryTy::TopLevelDirectory)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEntryTy()[index];
}

enum class Entry : uint8_t {
  NONE = 0,
  File = 1,
  Directory = 2,
  ObjectRef = 3,
  MIN = NONE,
  MAX = ObjectRef
};

inline const Entry (&EnumValuesEntry())[4] {
  static const Entry values[] = {
    Entry::NONE,
    Entry::File,
    Entry::Directory,
    Entry::ObjectRef
  };
  return values;
}

inline const char * const *EnumNamesEntry() {
  static const char * const names[5] = {
    "NONE",
    "File",
    "Directory",
    "ObjectRef",
    nullptr
  };
  return names;
}

inline const char *EnumNameEntry(Entry e) {
  if (::flatbuffers::IsOutRange(e, Entry::NONE, Entry::ObjectRef)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEntry()[index];
}

template<typename T> struct EntryTraits {
  static const Entry enum_value = Entry::NONE;
};

template<> struct EntryTraits<File> {
  static const Entry enum_value = Entry::File;
};

template<> struct EntryTraits<Directory> {
  static const Entry enum_value = Entry::Directory;
};

template<> struct EntryTraits<ObjectRef> {
  static const Entry enum_value = Entry::ObjectRef;
};

bool VerifyEntry(::flatbuffers::Verifier &verifier, const void *obj, Entry type);
bool VerifyEntryVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Entry> *types);

enum class ListEntry : uint8_t {
  NONE = 0,
  ListFile = 1,
  ListDirectory = 2,
  ListObject = 3,
  TopLevelDirectory = 4,
  MIN = NONE,
  MAX = TopLevelDirectory
};

inline const ListEntry (&EnumValuesListEntry())[5] {
  static const ListEntry values[] = {
    ListEntry::NONE,
    ListEntry::ListFile,
    ListEntry::ListDirectory,
    ListEntry::ListObject,
    ListEntry::TopLevelDirectory
  };
  return values;
}

inline const char * const *EnumNamesListEntry() {
  static const char * const names[6] = {
    "NONE",
    "ListFile",
    "ListDirectory",
    "ListObject",
    "TopLevelDirectory",
    nullptr
  };
  return names;
}

inline const char *EnumNameListEntry(ListEntry e) {
  if (::flatbuffers::IsOutRange(e, ListEntry::NONE, ListEntry::TopLevelDirectory)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesListEntry()[index];
}

template<typename T> struct ListEntryTraits {
  static const ListEntry enum_value = ListEntry::NONE;
};

template<> struct ListEntryTraits<ListFile> {
  static const ListEntry enum_value = ListEntry::ListFile;
};

template<> struct ListEntryTraits<ListDirectory> {
  static const ListEntry enum_value = ListEntry::ListDirectory;
};

template<> struct ListEntryTraits<ListObject> {
  static const ListEntry enum_value = ListEntry::ListObject;
};

template<> struct ListEntryTraits<TopLevelDirectory> {
  static const ListEntry enum_value = ListEntry::TopLevelDirectory;
};

bool VerifyListEntry(::flatbuffers::Verifier &verifier, const void *obj, ListEntry type);
bool VerifyListEntryVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ListEntry> *types);

struct Attr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttrBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_V_TYPE = 6,
    VT_V = 8
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  Value v_type() const {
    return static_cast<Value>(GetField<uint8_t>(VT_V_TYPE, 0));
  }
  const void *v() const {
    return GetPointer<const void *>(VT_V);
  }
  template<typename T> const T *v_as() const;
  const VBool *v_as_VBool() const {
    return v_type() == Value::VBool ? static_cast<const VBool *>(v()) : nullptr;
  }
  const VUnit *v_as_VUnit() const {
    return v_type() == Value::VUnit ? static_cast<const VUnit *>(v()) : nullptr;
  }
  const VChar *v_as_VChar() const {
    return v_type() == Value::VChar ? static_cast<const VChar *>(v()) : nullptr;
  }
  const VNull *v_as_VNull() const {
    return v_type() == Value::VNull ? static_cast<const VNull *>(v()) : nullptr;
  }
  const VI8 *v_as_VI8() const {
    return v_type() == Value::VI8 ? static_cast<const VI8 *>(v()) : nullptr;
  }
  const VU8 *v_as_VU8() const {
    return v_type() == Value::VU8 ? static_cast<const VU8 *>(v()) : nullptr;
  }
  const VI16 *v_as_VI16() const {
    return v_type() == Value::VI16 ? static_cast<const VI16 *>(v()) : nullptr;
  }
  const VU16 *v_as_VU16() const {
    return v_type() == Value::VU16 ? static_cast<const VU16 *>(v()) : nullptr;
  }
  const VI32 *v_as_VI32() const {
    return v_type() == Value::VI32 ? static_cast<const VI32 *>(v()) : nullptr;
  }
  const VU32 *v_as_VU32() const {
    return v_type() == Value::VU32 ? static_cast<const VU32 *>(v()) : nullptr;
  }
  const VF32 *v_as_VF32() const {
    return v_type() == Value::VF32 ? static_cast<const VF32 *>(v()) : nullptr;
  }
  const VIsize *v_as_VIsize() const {
    return v_type() == Value::VIsize ? static_cast<const VIsize *>(v()) : nullptr;
  }
  const VUsize *v_as_VUsize() const {
    return v_type() == Value::VUsize ? static_cast<const VUsize *>(v()) : nullptr;
  }
  const VI64 *v_as_VI64() const {
    return v_type() == Value::VI64 ? static_cast<const VI64 *>(v()) : nullptr;
  }
  const VU64 *v_as_VU64() const {
    return v_type() == Value::VU64 ? static_cast<const VU64 *>(v()) : nullptr;
  }
  const VF64 *v_as_VF64() const {
    return v_type() == Value::VF64 ? static_cast<const VF64 *>(v()) : nullptr;
  }
  const VStr *v_as_VStr() const {
    return v_type() == Value::VStr ? static_cast<const VStr *>(v()) : nullptr;
  }
  const VBytes *v_as_VBytes() const {
    return v_type() == Value::VBytes ? static_cast<const VBytes *>(v()) : nullptr;
  }
  const VArray *v_as_VArray() const {
    return v_type() == Value::VArray ? static_cast<const VArray *>(v()) : nullptr;
  }
  const VTri2D *v_as_VTri2D() const {
    return v_type() == Value::VTri2D ? static_cast<const VTri2D *>(v()) : nullptr;
  }
  const VFixedSizeBytes *v_as_VFixedSizeBytes() const {
    return v_type() == Value::VFixedSizeBytes ? static_cast<const VFixedSizeBytes *>(v()) : nullptr;
  }
  const VTimestampMsUtc *v_as_VTimestampMsUtc() const {
    return v_type() == Value::VTimestampMsUtc ? static_cast<const VTimestampMsUtc *>(v()) : nullptr;
  }
  const VTimestampMs *v_as_VTimestampMs() const {
    return v_type() == Value::VTimestampMs ? static_cast<const VTimestampMs *>(v()) : nullptr;
  }
  const VTimestampNsUtc *v_as_VTimestampNsUtc() const {
    return v_type() == Value::VTimestampNsUtc ? static_cast<const VTimestampNsUtc *>(v()) : nullptr;
  }
  const VTimestampNs *v_as_VTimestampNs() const {
    return v_type() == Value::VTimestampNs ? static_cast<const VTimestampNs *>(v()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_V_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_V) &&
           VerifyValue(verifier, v(), v_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VBool *Attr::v_as<VBool>() const {
  return v_as_VBool();
}

template<> inline const VUnit *Attr::v_as<VUnit>() const {
  return v_as_VUnit();
}

template<> inline const VChar *Attr::v_as<VChar>() const {
  return v_as_VChar();
}

template<> inline const VNull *Attr::v_as<VNull>() const {
  return v_as_VNull();
}

template<> inline const VI8 *Attr::v_as<VI8>() const {
  return v_as_VI8();
}

template<> inline const VU8 *Attr::v_as<VU8>() const {
  return v_as_VU8();
}

template<> inline const VI16 *Attr::v_as<VI16>() const {
  return v_as_VI16();
}

template<> inline const VU16 *Attr::v_as<VU16>() const {
  return v_as_VU16();
}

template<> inline const VI32 *Attr::v_as<VI32>() const {
  return v_as_VI32();
}

template<> inline const VU32 *Attr::v_as<VU32>() const {
  return v_as_VU32();
}

template<> inline const VF32 *Attr::v_as<VF32>() const {
  return v_as_VF32();
}

template<> inline const VIsize *Attr::v_as<VIsize>() const {
  return v_as_VIsize();
}

template<> inline const VUsize *Attr::v_as<VUsize>() const {
  return v_as_VUsize();
}

template<> inline const VI64 *Attr::v_as<VI64>() const {
  return v_as_VI64();
}

template<> inline const VU64 *Attr::v_as<VU64>() const {
  return v_as_VU64();
}

template<> inline const VF64 *Attr::v_as<VF64>() const {
  return v_as_VF64();
}

template<> inline const VStr *Attr::v_as<VStr>() const {
  return v_as_VStr();
}

template<> inline const VBytes *Attr::v_as<VBytes>() const {
  return v_as_VBytes();
}

template<> inline const VArray *Attr::v_as<VArray>() const {
  return v_as_VArray();
}

template<> inline const VTri2D *Attr::v_as<VTri2D>() const {
  return v_as_VTri2D();
}

template<> inline const VFixedSizeBytes *Attr::v_as<VFixedSizeBytes>() const {
  return v_as_VFixedSizeBytes();
}

template<> inline const VTimestampMsUtc *Attr::v_as<VTimestampMsUtc>() const {
  return v_as_VTimestampMsUtc();
}

template<> inline const VTimestampMs *Attr::v_as<VTimestampMs>() const {
  return v_as_VTimestampMs();
}

template<> inline const VTimestampNsUtc *Attr::v_as<VTimestampNsUtc>() const {
  return v_as_VTimestampNsUtc();
}

template<> inline const VTimestampNs *Attr::v_as<VTimestampNs>() const {
  return v_as_VTimestampNs();
}

struct AttrBuilder {
  typedef Attr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(Attr::VT_KEY, key);
  }
  void add_v_type(Value v_type) {
    fbb_.AddElement<uint8_t>(Attr::VT_V_TYPE, static_cast<uint8_t>(v_type), 0);
  }
  void add_v(::flatbuffers::Offset<void> v) {
    fbb_.AddOffset(Attr::VT_V, v);
  }
  explicit AttrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Attr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Attr>(end);
    fbb_.Required(o, Attr::VT_KEY);
    fbb_.Required(o, Attr::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<Attr> CreateAttr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    Value v_type = Value::NONE,
    ::flatbuffers::Offset<void> v = 0) {
  AttrBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_key(key);
  builder_.add_v_type(v_type);
  return builder_.Finish();
}

struct Attr::Traits {
  using type = Attr;
  static auto constexpr Create = CreateAttr;
};

inline ::flatbuffers::Offset<Attr> CreateAttrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    Value v_type = Value::NONE,
    ::flatbuffers::Offset<void> v = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return CreateAttr(
      _fbb,
      key__,
      v_type,
      v);
}

struct ObjectRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectRefBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TY = 6
  };
  const ObjectId *id() const {
    return GetPointer<const ObjectId *>(VT_ID);
  }
  DataCatalogObjectTy ty() const {
    return static_cast<DataCatalogObjectTy>(GetField<int16_t>(VT_TY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<int16_t>(verifier, VT_TY, 2) &&
           verifier.EndTable();
  }
};

struct ObjectRefBuilder {
  typedef ObjectRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ObjectId> id) {
    fbb_.AddOffset(ObjectRef::VT_ID, id);
  }
  void add_ty(DataCatalogObjectTy ty) {
    fbb_.AddElement<int16_t>(ObjectRef::VT_TY, static_cast<int16_t>(ty), 0);
  }
  explicit ObjectRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectRef>(end);
    fbb_.Required(o, ObjectRef::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectRef> CreateObjectRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    DataCatalogObjectTy ty = DataCatalogObjectTy::Invalid) {
  ObjectRefBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_ty(ty);
  return builder_.Finish();
}

struct ObjectRef::Traits {
  using type = ObjectRef;
  static auto constexpr Create = CreateObjectRef;
};

struct TopLevelDirectory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TopLevelDirectoryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B2C_ENTITY = 4
  };
  const B2cId *b2c_entity() const {
    return GetPointer<const B2cId *>(VT_B2C_ENTITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B2C_ENTITY) &&
           verifier.VerifyTable(b2c_entity()) &&
           verifier.EndTable();
  }
};

struct TopLevelDirectoryBuilder {
  typedef TopLevelDirectory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b2c_entity(::flatbuffers::Offset<B2cId> b2c_entity) {
    fbb_.AddOffset(TopLevelDirectory::VT_B2C_ENTITY, b2c_entity);
  }
  explicit TopLevelDirectoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TopLevelDirectory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TopLevelDirectory>(end);
    fbb_.Required(o, TopLevelDirectory::VT_B2C_ENTITY);
    return o;
  }
};

inline ::flatbuffers::Offset<TopLevelDirectory> CreateTopLevelDirectory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<B2cId> b2c_entity = 0) {
  TopLevelDirectoryBuilder builder_(_fbb);
  builder_.add_b2c_entity(b2c_entity);
  return builder_.Finish();
}

struct TopLevelDirectory::Traits {
  using type = TopLevelDirectory;
  static auto constexpr Create = CreateTopLevelDirectory;
};

struct Chunk FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOB = 4,
    VT_DIGEST_TYPE = 6,
    VT_DIGEST = 8,
    VT_SIZE = 10
  };
  const GenericId *blob() const {
    return GetPointer<const GenericId *>(VT_BLOB);
  }
  Digest digest_type() const {
    return static_cast<Digest>(GetField<uint8_t>(VT_DIGEST_TYPE, 0));
  }
  const void *digest() const {
    return GetPointer<const void *>(VT_DIGEST);
  }
  template<typename T> const T *digest_as() const;
  const Sha256 *digest_as_Sha256() const {
    return digest_type() == Digest::Sha256 ? static_cast<const Sha256 *>(digest()) : nullptr;
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_BLOB) &&
           verifier.VerifyTable(blob()) &&
           VerifyField<uint8_t>(verifier, VT_DIGEST_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_DIGEST) &&
           VerifyDigest(verifier, digest(), digest_type()) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
};

template<> inline const Sha256 *Chunk::digest_as<Sha256>() const {
  return digest_as_Sha256();
}

struct ChunkBuilder {
  typedef Chunk Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blob(::flatbuffers::Offset<GenericId> blob) {
    fbb_.AddOffset(Chunk::VT_BLOB, blob);
  }
  void add_digest_type(Digest digest_type) {
    fbb_.AddElement<uint8_t>(Chunk::VT_DIGEST_TYPE, static_cast<uint8_t>(digest_type), 0);
  }
  void add_digest(::flatbuffers::Offset<void> digest) {
    fbb_.AddOffset(Chunk::VT_DIGEST, digest);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(Chunk::VT_SIZE, size, 0);
  }
  explicit ChunkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chunk>(end);
    fbb_.Required(o, Chunk::VT_BLOB);
    fbb_.Required(o, Chunk::VT_DIGEST);
    return o;
  }
};

inline ::flatbuffers::Offset<Chunk> CreateChunk(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<GenericId> blob = 0,
    Digest digest_type = Digest::NONE,
    ::flatbuffers::Offset<void> digest = 0,
    uint64_t size = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_digest(digest);
  builder_.add_blob(blob);
  builder_.add_digest_type(digest_type);
  return builder_.Finish();
}

struct Chunk::Traits {
  using type = Chunk;
  static auto constexpr Create = CreateChunk;
};

struct File FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIME = 4,
    VT_SIZE = 6,
    VT_BLOB = 8,
    VT_VIRUS = 10,
    VT_DIGEST_TYPE = 12,
    VT_DIGEST = 14,
    VT_ACCOUNT = 16,
    VT_CONTAINER = 18,
    VT_CHUNKS = 20
  };
  const ::flatbuffers::String *mime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIME);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  const GenericId *blob() const {
    return GetPointer<const GenericId *>(VT_BLOB);
  }
  const ::flatbuffers::String *virus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VIRUS);
  }
  Digest digest_type() const {
    return static_cast<Digest>(GetField<uint8_t>(VT_DIGEST_TYPE, 0));
  }
  const void *digest() const {
    return GetPointer<const void *>(VT_DIGEST);
  }
  template<typename T> const T *digest_as() const;
  const Sha256 *digest_as_Sha256() const {
    return digest_type() == Digest::Sha256 ? static_cast<const Sha256 *>(digest()) : nullptr;
  }
  const ::flatbuffers::String *account() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCOUNT);
  }
  const ::flatbuffers::String *container() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Chunk>> *chunks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Chunk>> *>(VT_CHUNKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MIME) &&
           verifier.VerifyString(mime()) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           VerifyOffset(verifier, VT_BLOB) &&
           verifier.VerifyTable(blob()) &&
           VerifyOffset(verifier, VT_VIRUS) &&
           verifier.VerifyString(virus()) &&
           VerifyField<uint8_t>(verifier, VT_DIGEST_TYPE, 1) &&
           VerifyOffset(verifier, VT_DIGEST) &&
           VerifyDigest(verifier, digest(), digest_type()) &&
           VerifyOffsetRequired(verifier, VT_ACCOUNT) &&
           verifier.VerifyString(account()) &&
           VerifyOffset(verifier, VT_CONTAINER) &&
           verifier.VerifyString(container()) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.VerifyVector(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           verifier.EndTable();
  }
};

template<> inline const Sha256 *File::digest_as<Sha256>() const {
  return digest_as_Sha256();
}

struct FileBuilder {
  typedef File Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mime(::flatbuffers::Offset<::flatbuffers::String> mime) {
    fbb_.AddOffset(File::VT_MIME, mime);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(File::VT_SIZE, size, 0);
  }
  void add_blob(::flatbuffers::Offset<GenericId> blob) {
    fbb_.AddOffset(File::VT_BLOB, blob);
  }
  void add_virus(::flatbuffers::Offset<::flatbuffers::String> virus) {
    fbb_.AddOffset(File::VT_VIRUS, virus);
  }
  void add_digest_type(Digest digest_type) {
    fbb_.AddElement<uint8_t>(File::VT_DIGEST_TYPE, static_cast<uint8_t>(digest_type), 0);
  }
  void add_digest(::flatbuffers::Offset<void> digest) {
    fbb_.AddOffset(File::VT_DIGEST, digest);
  }
  void add_account(::flatbuffers::Offset<::flatbuffers::String> account) {
    fbb_.AddOffset(File::VT_ACCOUNT, account);
  }
  void add_container(::flatbuffers::Offset<::flatbuffers::String> container) {
    fbb_.AddOffset(File::VT_CONTAINER, container);
  }
  void add_chunks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Chunk>>> chunks) {
    fbb_.AddOffset(File::VT_CHUNKS, chunks);
  }
  explicit FileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<File>(end);
    fbb_.Required(o, File::VT_MIME);
    fbb_.Required(o, File::VT_ACCOUNT);
    return o;
  }
};

inline ::flatbuffers::Offset<File> CreateFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mime = 0,
    uint64_t size = 0,
    ::flatbuffers::Offset<GenericId> blob = 0,
    ::flatbuffers::Offset<::flatbuffers::String> virus = 0,
    Digest digest_type = Digest::NONE,
    ::flatbuffers::Offset<void> digest = 0,
    ::flatbuffers::Offset<::flatbuffers::String> account = 0,
    ::flatbuffers::Offset<::flatbuffers::String> container = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Chunk>>> chunks = 0) {
  FileBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_chunks(chunks);
  builder_.add_container(container);
  builder_.add_account(account);
  builder_.add_digest(digest);
  builder_.add_virus(virus);
  builder_.add_blob(blob);
  builder_.add_mime(mime);
  builder_.add_digest_type(digest_type);
  return builder_.Finish();
}

struct File::Traits {
  using type = File;
  static auto constexpr Create = CreateFile;
};

inline ::flatbuffers::Offset<File> CreateFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mime = nullptr,
    uint64_t size = 0,
    ::flatbuffers::Offset<GenericId> blob = 0,
    const char *virus = nullptr,
    Digest digest_type = Digest::NONE,
    ::flatbuffers::Offset<void> digest = 0,
    const char *account = nullptr,
    const char *container = nullptr,
    const std::vector<::flatbuffers::Offset<Chunk>> *chunks = nullptr) {
  auto mime__ = mime ? _fbb.CreateString(mime) : 0;
  auto virus__ = virus ? _fbb.CreateString(virus) : 0;
  auto account__ = account ? _fbb.CreateString(account) : 0;
  auto container__ = container ? _fbb.CreateString(container) : 0;
  auto chunks__ = chunks ? _fbb.CreateVector<::flatbuffers::Offset<Chunk>>(*chunks) : 0;
  return CreateFile(
      _fbb,
      mime__,
      size,
      blob,
      virus__,
      digest_type,
      digest,
      account__,
      container__,
      chunks__);
}

struct Slot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SlotBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TY = 8,
    VT_ATTRIBUTES = 12
  };
  const ObjectId *id() const {
    return GetPointer<const ObjectId *>(VT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  EntryTy ty() const {
    return static_cast<EntryTy>(GetField<uint32_t>(VT_TY, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Attr>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Attr>> *>(VT_ATTRIBUTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_TY, 4) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct SlotBuilder {
  typedef Slot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ObjectId> id) {
    fbb_.AddOffset(Slot::VT_ID, id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Slot::VT_NAME, name);
  }
  void add_ty(EntryTy ty) {
    fbb_.AddElement<uint32_t>(Slot::VT_TY, static_cast<uint32_t>(ty), 0);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Attr>>> attributes) {
    fbb_.AddOffset(Slot::VT_ATTRIBUTES, attributes);
  }
  explicit SlotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Slot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Slot>(end);
    fbb_.Required(o, Slot::VT_ID);
    fbb_.Required(o, Slot::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Slot> CreateSlot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    EntryTy ty = EntryTy::File,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Attr>>> attributes = 0) {
  SlotBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_ty(ty);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

struct Slot::Traits {
  using type = Slot;
  static auto constexpr Create = CreateSlot;
};

inline ::flatbuffers::Offset<Slot> CreateSlotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    const char *name = nullptr,
    EntryTy ty = EntryTy::File,
    const std::vector<::flatbuffers::Offset<Attr>> *attributes = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<Attr>>(*attributes) : 0;
  return CreateSlot(
      _fbb,
      id,
      name__,
      ty,
      attributes__);
}

/// This Directory table holds the entries in the actual directory
struct Directory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DirectoryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOTS = 4,
    VT_NOTIFICATIONS = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Slot>> *slots() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Slot>> *>(VT_SLOTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<B2cId>> *notifications() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<B2cId>> *>(VT_NOTIFICATIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SLOTS) &&
           verifier.VerifyVector(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           VerifyOffset(verifier, VT_NOTIFICATIONS) &&
           verifier.VerifyVector(notifications()) &&
           verifier.VerifyVectorOfTables(notifications()) &&
           verifier.EndTable();
  }
};

struct DirectoryBuilder {
  typedef Directory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_slots(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Slot>>> slots) {
    fbb_.AddOffset(Directory::VT_SLOTS, slots);
  }
  void add_notifications(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<B2cId>>> notifications) {
    fbb_.AddOffset(Directory::VT_NOTIFICATIONS, notifications);
  }
  explicit DirectoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Directory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Directory>(end);
    fbb_.Required(o, Directory::VT_SLOTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Directory> CreateDirectory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Slot>>> slots = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<B2cId>>> notifications = 0) {
  DirectoryBuilder builder_(_fbb);
  builder_.add_notifications(notifications);
  builder_.add_slots(slots);
  return builder_.Finish();
}

struct Directory::Traits {
  using type = Directory;
  static auto constexpr Create = CreateDirectory;
};

inline ::flatbuffers::Offset<Directory> CreateDirectoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Slot>> *slots = nullptr,
    const std::vector<::flatbuffers::Offset<B2cId>> *notifications = nullptr) {
  auto slots__ = slots ? _fbb.CreateVector<::flatbuffers::Offset<Slot>>(*slots) : 0;
  auto notifications__ = notifications ? _fbb.CreateVector<::flatbuffers::Offset<B2cId>>(*notifications) : 0;
  return CreateDirectory(
      _fbb,
      slots__,
      notifications__);
}

struct DirectoryEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DirectoryEntryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRY_TYPE = 4,
    VT_ENTRY = 6,
    VT_PARENT = 8
  };
  Entry entry_type() const {
    return static_cast<Entry>(GetField<uint8_t>(VT_ENTRY_TYPE, 0));
  }
  const void *entry() const {
    return GetPointer<const void *>(VT_ENTRY);
  }
  template<typename T> const T *entry_as() const;
  const File *entry_as_File() const {
    return entry_type() == Entry::File ? static_cast<const File *>(entry()) : nullptr;
  }
  const Directory *entry_as_Directory() const {
    return entry_type() == Entry::Directory ? static_cast<const Directory *>(entry()) : nullptr;
  }
  const ObjectRef *entry_as_ObjectRef() const {
    return entry_type() == Entry::ObjectRef ? static_cast<const ObjectRef *>(entry()) : nullptr;
  }
  const ObjectId *parent() const {
    return GetPointer<const ObjectId *>(VT_PARENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ENTRY_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_ENTRY) &&
           VerifyEntry(verifier, entry(), entry_type()) &&
           VerifyOffsetRequired(verifier, VT_PARENT) &&
           verifier.VerifyTable(parent()) &&
           verifier.EndTable();
  }
};

template<> inline const File *DirectoryEntry::entry_as<File>() const {
  return entry_as_File();
}

template<> inline const Directory *DirectoryEntry::entry_as<Directory>() const {
  return entry_as_Directory();
}

template<> inline const ObjectRef *DirectoryEntry::entry_as<ObjectRef>() const {
  return entry_as_ObjectRef();
}

struct DirectoryEntryBuilder {
  typedef DirectoryEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entry_type(Entry entry_type) {
    fbb_.AddElement<uint8_t>(DirectoryEntry::VT_ENTRY_TYPE, static_cast<uint8_t>(entry_type), 0);
  }
  void add_entry(::flatbuffers::Offset<void> entry) {
    fbb_.AddOffset(DirectoryEntry::VT_ENTRY, entry);
  }
  void add_parent(::flatbuffers::Offset<ObjectId> parent) {
    fbb_.AddOffset(DirectoryEntry::VT_PARENT, parent);
  }
  explicit DirectoryEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DirectoryEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DirectoryEntry>(end);
    fbb_.Required(o, DirectoryEntry::VT_ENTRY);
    fbb_.Required(o, DirectoryEntry::VT_PARENT);
    return o;
  }
};

inline ::flatbuffers::Offset<DirectoryEntry> CreateDirectoryEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Entry entry_type = Entry::NONE,
    ::flatbuffers::Offset<void> entry = 0,
    ::flatbuffers::Offset<ObjectId> parent = 0) {
  DirectoryEntryBuilder builder_(_fbb);
  builder_.add_parent(parent);
  builder_.add_entry(entry);
  builder_.add_entry_type(entry_type);
  return builder_.Finish();
}

struct DirectoryEntry::Traits {
  using type = DirectoryEntry;
  static auto constexpr Create = CreateDirectoryEntry;
};

struct ListDirectory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListDirectoryBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ListDirectoryBuilder {
  typedef ListDirectory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ListDirectoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListDirectory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListDirectory>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListDirectory> CreateListDirectory(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ListDirectoryBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ListDirectory::Traits {
  using type = ListDirectory;
  static auto constexpr Create = CreateListDirectory;
};

struct ListFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListFileBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIME = 4,
    VT_VIRUS = 6,
    VT_SIZE = 8
  };
  const ::flatbuffers::String *mime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIME);
  }
  const ::flatbuffers::String *virus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VIRUS);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MIME) &&
           verifier.VerifyString(mime()) &&
           VerifyOffset(verifier, VT_VIRUS) &&
           verifier.VerifyString(virus()) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
};

struct ListFileBuilder {
  typedef ListFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mime(::flatbuffers::Offset<::flatbuffers::String> mime) {
    fbb_.AddOffset(ListFile::VT_MIME, mime);
  }
  void add_virus(::flatbuffers::Offset<::flatbuffers::String> virus) {
    fbb_.AddOffset(ListFile::VT_VIRUS, virus);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(ListFile::VT_SIZE, size, 0);
  }
  explicit ListFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListFile>(end);
    fbb_.Required(o, ListFile::VT_MIME);
    return o;
  }
};

inline ::flatbuffers::Offset<ListFile> CreateListFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> mime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> virus = 0,
    uint64_t size = 0) {
  ListFileBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_virus(virus);
  builder_.add_mime(mime);
  return builder_.Finish();
}

struct ListFile::Traits {
  using type = ListFile;
  static auto constexpr Create = CreateListFile;
};

inline ::flatbuffers::Offset<ListFile> CreateListFileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *mime = nullptr,
    const char *virus = nullptr,
    uint64_t size = 0) {
  auto mime__ = mime ? _fbb.CreateString(mime) : 0;
  auto virus__ = virus ? _fbb.CreateString(virus) : 0;
  return CreateListFile(
      _fbb,
      mime__,
      virus__,
      size);
}

struct ListObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListObjectBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TY = 6,
    VT_SIZE = 8
  };
  const ObjectId *id() const {
    return GetPointer<const ObjectId *>(VT_ID);
  }
  DataCatalogObjectTy ty() const {
    return static_cast<DataCatalogObjectTy>(GetField<int16_t>(VT_TY, 0));
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<int16_t>(verifier, VT_TY, 2) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           verifier.EndTable();
  }
};

struct ListObjectBuilder {
  typedef ListObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ObjectId> id) {
    fbb_.AddOffset(ListObject::VT_ID, id);
  }
  void add_ty(DataCatalogObjectTy ty) {
    fbb_.AddElement<int16_t>(ListObject::VT_TY, static_cast<int16_t>(ty), 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(ListObject::VT_SIZE, size, 0);
  }
  explicit ListObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListObject>(end);
    fbb_.Required(o, ListObject::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<ListObject> CreateListObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    DataCatalogObjectTy ty = DataCatalogObjectTy::Invalid,
    uint64_t size = 0) {
  ListObjectBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_id(id);
  builder_.add_ty(ty);
  return builder_.Finish();
}

struct ListObject::Traits {
  using type = ListObject;
  static auto constexpr Create = CreateListObject;
};

struct ListSlot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListSlotBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ENTRY_TYPE = 6,
    VT_ENTRY = 8,
    VT_NAME = 10,
    VT_USER_PERMISSIONS = 12,
    VT_TIME = 14,
    VT_SIZE = 16,
    VT_ATTRIBUTES = 18,
    VT_LAST_MODIFIED_BY = 20
  };
  const ObjectId *id() const {
    return GetPointer<const ObjectId *>(VT_ID);
  }
  ListEntry entry_type() const {
    return static_cast<ListEntry>(GetField<uint8_t>(VT_ENTRY_TYPE, 0));
  }
  const void *entry() const {
    return GetPointer<const void *>(VT_ENTRY);
  }
  template<typename T> const T *entry_as() const;
  const ListFile *entry_as_ListFile() const {
    return entry_type() == ListEntry::ListFile ? static_cast<const ListFile *>(entry()) : nullptr;
  }
  const ListDirectory *entry_as_ListDirectory() const {
    return entry_type() == ListEntry::ListDirectory ? static_cast<const ListDirectory *>(entry()) : nullptr;
  }
  const ListObject *entry_as_ListObject() const {
    return entry_type() == ListEntry::ListObject ? static_cast<const ListObject *>(entry()) : nullptr;
  }
  const TopLevelDirectory *entry_as_TopLevelDirectory() const {
    return entry_type() == ListEntry::TopLevelDirectory ? static_cast<const TopLevelDirectory *>(entry()) : nullptr;
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t user_permissions() const {
    return GetField<uint32_t>(VT_USER_PERMISSIONS, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Attr>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Attr>> *>(VT_ATTRIBUTES);
  }
  const B2cId *last_modified_by() const {
    return GetPointer<const B2cId *>(VT_LAST_MODIFIED_BY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyField<uint8_t>(verifier, VT_ENTRY_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_ENTRY) &&
           VerifyListEntry(verifier, entry(), entry_type()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_USER_PERMISSIONS, 4) &&
           VerifyField<uint64_t>(verifier, VT_TIME, 8) &&
           VerifyField<uint64_t>(verifier, VT_SIZE, 8) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_LAST_MODIFIED_BY) &&
           verifier.VerifyTable(last_modified_by()) &&
           verifier.EndTable();
  }
};

template<> inline const ListFile *ListSlot::entry_as<ListFile>() const {
  return entry_as_ListFile();
}

template<> inline const ListDirectory *ListSlot::entry_as<ListDirectory>() const {
  return entry_as_ListDirectory();
}

template<> inline const ListObject *ListSlot::entry_as<ListObject>() const {
  return entry_as_ListObject();
}

template<> inline const TopLevelDirectory *ListSlot::entry_as<TopLevelDirectory>() const {
  return entry_as_TopLevelDirectory();
}

struct ListSlotBuilder {
  typedef ListSlot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ObjectId> id) {
    fbb_.AddOffset(ListSlot::VT_ID, id);
  }
  void add_entry_type(ListEntry entry_type) {
    fbb_.AddElement<uint8_t>(ListSlot::VT_ENTRY_TYPE, static_cast<uint8_t>(entry_type), 0);
  }
  void add_entry(::flatbuffers::Offset<void> entry) {
    fbb_.AddOffset(ListSlot::VT_ENTRY, entry);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ListSlot::VT_NAME, name);
  }
  void add_user_permissions(uint32_t user_permissions) {
    fbb_.AddElement<uint32_t>(ListSlot::VT_USER_PERMISSIONS, user_permissions, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(ListSlot::VT_TIME, time, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(ListSlot::VT_SIZE, size, 0);
  }
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Attr>>> attributes) {
    fbb_.AddOffset(ListSlot::VT_ATTRIBUTES, attributes);
  }
  void add_last_modified_by(::flatbuffers::Offset<B2cId> last_modified_by) {
    fbb_.AddOffset(ListSlot::VT_LAST_MODIFIED_BY, last_modified_by);
  }
  explicit ListSlotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListSlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListSlot>(end);
    fbb_.Required(o, ListSlot::VT_ID);
    fbb_.Required(o, ListSlot::VT_ENTRY);
    fbb_.Required(o, ListSlot::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<ListSlot> CreateListSlot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    ListEntry entry_type = ListEntry::NONE,
    ::flatbuffers::Offset<void> entry = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t user_permissions = 0,
    uint64_t time = 0,
    uint64_t size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Attr>>> attributes = 0,
    ::flatbuffers::Offset<B2cId> last_modified_by = 0) {
  ListSlotBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_time(time);
  builder_.add_last_modified_by(last_modified_by);
  builder_.add_attributes(attributes);
  builder_.add_user_permissions(user_permissions);
  builder_.add_name(name);
  builder_.add_entry(entry);
  builder_.add_id(id);
  builder_.add_entry_type(entry_type);
  return builder_.Finish();
}

struct ListSlot::Traits {
  using type = ListSlot;
  static auto constexpr Create = CreateListSlot;
};

inline ::flatbuffers::Offset<ListSlot> CreateListSlotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> id = 0,
    ListEntry entry_type = ListEntry::NONE,
    ::flatbuffers::Offset<void> entry = 0,
    const char *name = nullptr,
    uint32_t user_permissions = 0,
    uint64_t time = 0,
    uint64_t size = 0,
    const std::vector<::flatbuffers::Offset<Attr>> *attributes = nullptr,
    ::flatbuffers::Offset<B2cId> last_modified_by = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<Attr>>(*attributes) : 0;
  return CreateListSlot(
      _fbb,
      id,
      entry_type,
      entry,
      name__,
      user_permissions,
      time,
      size,
      attributes__,
      last_modified_by);
}

struct DirectoryList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DirectoryListBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ListSlot>> *slots() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ListSlot>> *>(VT_SLOTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SLOTS) &&
           verifier.VerifyVector(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           verifier.EndTable();
  }
};

struct DirectoryListBuilder {
  typedef DirectoryList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_slots(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ListSlot>>> slots) {
    fbb_.AddOffset(DirectoryList::VT_SLOTS, slots);
  }
  explicit DirectoryListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DirectoryList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DirectoryList>(end);
    fbb_.Required(o, DirectoryList::VT_SLOTS);
    return o;
  }
};

inline ::flatbuffers::Offset<DirectoryList> CreateDirectoryList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ListSlot>>> slots = 0) {
  DirectoryListBuilder builder_(_fbb);
  builder_.add_slots(slots);
  return builder_.Finish();
}

struct DirectoryList::Traits {
  using type = DirectoryList;
  static auto constexpr Create = CreateDirectoryList;
};

inline ::flatbuffers::Offset<DirectoryList> CreateDirectoryListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ListSlot>> *slots = nullptr) {
  auto slots__ = slots ? _fbb.CreateVector<::flatbuffers::Offset<ListSlot>>(*slots) : 0;
  return CreateDirectoryList(
      _fbb,
      slots__);
}

/// Body parameter for PUT drive/<object>
struct NewLink FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NewLinkBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJ = 4,
    VT_NAME = 6
  };
  const ObjectId *obj() const {
    return GetPointer<const ObjectId *>(VT_OBJ);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_OBJ) &&
           verifier.VerifyTable(obj()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct NewLinkBuilder {
  typedef NewLink Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_obj(::flatbuffers::Offset<ObjectId> obj) {
    fbb_.AddOffset(NewLink::VT_OBJ, obj);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NewLink::VT_NAME, name);
  }
  explicit NewLinkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NewLink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NewLink>(end);
    fbb_.Required(o, NewLink::VT_OBJ);
    fbb_.Required(o, NewLink::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<NewLink> CreateNewLink(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> obj = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  NewLinkBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_obj(obj);
  return builder_.Finish();
}

struct NewLink::Traits {
  using type = NewLink;
  static auto constexpr Create = CreateNewLink;
};

inline ::flatbuffers::Offset<NewLink> CreateNewLinkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> obj = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateNewLink(
      _fbb,
      obj,
      name__);
}

struct MoveRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveRequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRY = 4,
    VT_DEST_ROOT = 6,
    VT_DEST_NAME = 8,
    VT_OVERWRITE = 10
  };
  const ObjectId *entry() const {
    return GetPointer<const ObjectId *>(VT_ENTRY);
  }
  const ObjectId *dest_root() const {
    return GetPointer<const ObjectId *>(VT_DEST_ROOT);
  }
  const ::flatbuffers::String *dest_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEST_NAME);
  }
  bool overwrite() const {
    return GetField<uint8_t>(VT_OVERWRITE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ENTRY) &&
           verifier.VerifyTable(entry()) &&
           VerifyOffset(verifier, VT_DEST_ROOT) &&
           verifier.VerifyTable(dest_root()) &&
           VerifyOffset(verifier, VT_DEST_NAME) &&
           verifier.VerifyString(dest_name()) &&
           VerifyField<uint8_t>(verifier, VT_OVERWRITE, 1) &&
           verifier.EndTable();
  }
};

struct MoveRequestBuilder {
  typedef MoveRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entry(::flatbuffers::Offset<ObjectId> entry) {
    fbb_.AddOffset(MoveRequest::VT_ENTRY, entry);
  }
  void add_dest_root(::flatbuffers::Offset<ObjectId> dest_root) {
    fbb_.AddOffset(MoveRequest::VT_DEST_ROOT, dest_root);
  }
  void add_dest_name(::flatbuffers::Offset<::flatbuffers::String> dest_name) {
    fbb_.AddOffset(MoveRequest::VT_DEST_NAME, dest_name);
  }
  void add_overwrite(bool overwrite) {
    fbb_.AddElement<uint8_t>(MoveRequest::VT_OVERWRITE, static_cast<uint8_t>(overwrite), 0);
  }
  explicit MoveRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveRequest>(end);
    fbb_.Required(o, MoveRequest::VT_ENTRY);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveRequest> CreateMoveRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> entry = 0,
    ::flatbuffers::Offset<ObjectId> dest_root = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dest_name = 0,
    bool overwrite = false) {
  MoveRequestBuilder builder_(_fbb);
  builder_.add_dest_name(dest_name);
  builder_.add_dest_root(dest_root);
  builder_.add_entry(entry);
  builder_.add_overwrite(overwrite);
  return builder_.Finish();
}

struct MoveRequest::Traits {
  using type = MoveRequest;
  static auto constexpr Create = CreateMoveRequest;
};

inline ::flatbuffers::Offset<MoveRequest> CreateMoveRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> entry = 0,
    ::flatbuffers::Offset<ObjectId> dest_root = 0,
    const char *dest_name = nullptr,
    bool overwrite = false) {
  auto dest_name__ = dest_name ? _fbb.CreateString(dest_name) : 0;
  return CreateMoveRequest(
      _fbb,
      entry,
      dest_root,
      dest_name__,
      overwrite);
}

inline bool VerifyEntry(::flatbuffers::Verifier &verifier, const void *obj, Entry type) {
  switch (type) {
    case Entry::NONE: {
      return true;
    }
    case Entry::File: {
      auto ptr = reinterpret_cast<const File *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Entry::Directory: {
      auto ptr = reinterpret_cast<const Directory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Entry::ObjectRef: {
      auto ptr = reinterpret_cast<const ObjectRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEntryVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Entry> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEntry(
        verifier,  values->Get(i), types->GetEnum<Entry>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyListEntry(::flatbuffers::Verifier &verifier, const void *obj, ListEntry type) {
  switch (type) {
    case ListEntry::NONE: {
      return true;
    }
    case ListEntry::ListFile: {
      auto ptr = reinterpret_cast<const ListFile *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ListEntry::ListDirectory: {
      auto ptr = reinterpret_cast<const ListDirectory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ListEntry::ListObject: {
      auto ptr = reinterpret_cast<const ListObject *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ListEntry::TopLevelDirectory: {
      auto ptr = reinterpret_cast<const TopLevelDirectory *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyListEntryVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ListEntry> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyListEntry(
        verifier,  values->Get(i), types->GetEnum<ListEntry>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_FS_H_
