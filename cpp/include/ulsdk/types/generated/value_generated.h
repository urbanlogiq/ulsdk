// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VALUE_H_
#define FLATBUFFERS_GENERATED_VALUE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct VBool;
struct VBoolBuilder;

struct VUnit;
struct VUnitBuilder;

struct VChar;
struct VCharBuilder;

struct VNull;
struct VNullBuilder;

struct VI8;
struct VI8Builder;

struct VU8;
struct VU8Builder;

struct VI16;
struct VI16Builder;

struct VU16;
struct VU16Builder;

struct VI32;
struct VI32Builder;

struct VU32;
struct VU32Builder;

struct VF32;
struct VF32Builder;

struct VIsize;
struct VIsizeBuilder;

struct VUsize;
struct VUsizeBuilder;

struct VI64;
struct VI64Builder;

struct VU64;
struct VU64Builder;

struct VF64;
struct VF64Builder;

struct VTimestampMsUtc;
struct VTimestampMsUtcBuilder;

struct VTimestampMs;
struct VTimestampMsBuilder;

struct VTimestampNsUtc;
struct VTimestampNsUtcBuilder;

struct VTimestampNs;
struct VTimestampNsBuilder;

struct VStr;
struct VStrBuilder;

struct VBytes;
struct VBytesBuilder;

struct VFixedSizeBytes;
struct VFixedSizeBytesBuilder;

struct Point2D;

struct Tri2D;

struct VTri2D;
struct VTri2DBuilder;

struct VArray;
struct VArrayBuilder;

struct ValueInstance;
struct ValueInstanceBuilder;

enum class Value : uint8_t {
  NONE = 0,
  VBool = 1,
  VUnit = 2,
  VChar = 3,
  VNull = 4,
  VI8 = 5,
  VU8 = 6,
  VI16 = 7,
  VU16 = 8,
  VI32 = 9,
  VU32 = 10,
  VF32 = 11,
  VIsize = 12,
  VUsize = 13,
  VI64 = 14,
  VU64 = 15,
  VF64 = 16,
  VStr = 17,
  VBytes = 18,
  VArray = 19,
  VTri2D = 20,
  VFixedSizeBytes = 21,
  VTimestampMsUtc = 22,
  VTimestampMs = 23,
  VTimestampNsUtc = 24,
  VTimestampNs = 25,
  MIN = NONE,
  MAX = VTimestampNs
};

inline const Value (&EnumValuesValue())[26] {
  static const Value values[] = {
    Value::NONE,
    Value::VBool,
    Value::VUnit,
    Value::VChar,
    Value::VNull,
    Value::VI8,
    Value::VU8,
    Value::VI16,
    Value::VU16,
    Value::VI32,
    Value::VU32,
    Value::VF32,
    Value::VIsize,
    Value::VUsize,
    Value::VI64,
    Value::VU64,
    Value::VF64,
    Value::VStr,
    Value::VBytes,
    Value::VArray,
    Value::VTri2D,
    Value::VFixedSizeBytes,
    Value::VTimestampMsUtc,
    Value::VTimestampMs,
    Value::VTimestampNsUtc,
    Value::VTimestampNs
  };
  return values;
}

inline const char * const *EnumNamesValue() {
  static const char * const names[27] = {
    "NONE",
    "VBool",
    "VUnit",
    "VChar",
    "VNull",
    "VI8",
    "VU8",
    "VI16",
    "VU16",
    "VI32",
    "VU32",
    "VF32",
    "VIsize",
    "VUsize",
    "VI64",
    "VU64",
    "VF64",
    "VStr",
    "VBytes",
    "VArray",
    "VTri2D",
    "VFixedSizeBytes",
    "VTimestampMsUtc",
    "VTimestampMs",
    "VTimestampNsUtc",
    "VTimestampNs",
    nullptr
  };
  return names;
}

inline const char *EnumNameValue(Value e) {
  if (::flatbuffers::IsOutRange(e, Value::NONE, Value::VTimestampNs)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValue()[index];
}

template<typename T> struct ValueTraits {
  static const Value enum_value = Value::NONE;
};

template<> struct ValueTraits<VBool> {
  static const Value enum_value = Value::VBool;
};

template<> struct ValueTraits<VUnit> {
  static const Value enum_value = Value::VUnit;
};

template<> struct ValueTraits<VChar> {
  static const Value enum_value = Value::VChar;
};

template<> struct ValueTraits<VNull> {
  static const Value enum_value = Value::VNull;
};

template<> struct ValueTraits<VI8> {
  static const Value enum_value = Value::VI8;
};

template<> struct ValueTraits<VU8> {
  static const Value enum_value = Value::VU8;
};

template<> struct ValueTraits<VI16> {
  static const Value enum_value = Value::VI16;
};

template<> struct ValueTraits<VU16> {
  static const Value enum_value = Value::VU16;
};

template<> struct ValueTraits<VI32> {
  static const Value enum_value = Value::VI32;
};

template<> struct ValueTraits<VU32> {
  static const Value enum_value = Value::VU32;
};

template<> struct ValueTraits<VF32> {
  static const Value enum_value = Value::VF32;
};

template<> struct ValueTraits<VIsize> {
  static const Value enum_value = Value::VIsize;
};

template<> struct ValueTraits<VUsize> {
  static const Value enum_value = Value::VUsize;
};

template<> struct ValueTraits<VI64> {
  static const Value enum_value = Value::VI64;
};

template<> struct ValueTraits<VU64> {
  static const Value enum_value = Value::VU64;
};

template<> struct ValueTraits<VF64> {
  static const Value enum_value = Value::VF64;
};

template<> struct ValueTraits<VStr> {
  static const Value enum_value = Value::VStr;
};

template<> struct ValueTraits<VBytes> {
  static const Value enum_value = Value::VBytes;
};

template<> struct ValueTraits<VArray> {
  static const Value enum_value = Value::VArray;
};

template<> struct ValueTraits<VTri2D> {
  static const Value enum_value = Value::VTri2D;
};

template<> struct ValueTraits<VFixedSizeBytes> {
  static const Value enum_value = Value::VFixedSizeBytes;
};

template<> struct ValueTraits<VTimestampMsUtc> {
  static const Value enum_value = Value::VTimestampMsUtc;
};

template<> struct ValueTraits<VTimestampMs> {
  static const Value enum_value = Value::VTimestampMs;
};

template<> struct ValueTraits<VTimestampNsUtc> {
  static const Value enum_value = Value::VTimestampNsUtc;
};

template<> struct ValueTraits<VTimestampNs> {
  static const Value enum_value = Value::VTimestampNs;
};

bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type);
bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Value> *types);

enum class ValueTy : uint8_t {
  Bool = 0,
  Unit = 1,
  Char = 2,
  Null = 3,
  I8 = 4,
  U8 = 5,
  I16 = 6,
  U16 = 7,
  I32 = 8,
  U32 = 9,
  F32 = 10,
  Isize = 11,
  Usize = 12,
  I64 = 13,
  U64 = 14,
  F64 = 15,
  Str = 16,
  Bytes = 17,
  Array = 18,
  Tri2D = 19,
  FixedSizeBytes = 20,
  TimestampMsUtc = 21,
  TimestampMs = 22,
  TimestampNsUtc = 23,
  TimestampNs = 24,
  MIN = Bool,
  MAX = TimestampNs
};

inline const ValueTy (&EnumValuesValueTy())[25] {
  static const ValueTy values[] = {
    ValueTy::Bool,
    ValueTy::Unit,
    ValueTy::Char,
    ValueTy::Null,
    ValueTy::I8,
    ValueTy::U8,
    ValueTy::I16,
    ValueTy::U16,
    ValueTy::I32,
    ValueTy::U32,
    ValueTy::F32,
    ValueTy::Isize,
    ValueTy::Usize,
    ValueTy::I64,
    ValueTy::U64,
    ValueTy::F64,
    ValueTy::Str,
    ValueTy::Bytes,
    ValueTy::Array,
    ValueTy::Tri2D,
    ValueTy::FixedSizeBytes,
    ValueTy::TimestampMsUtc,
    ValueTy::TimestampMs,
    ValueTy::TimestampNsUtc,
    ValueTy::TimestampNs
  };
  return values;
}

inline const char * const *EnumNamesValueTy() {
  static const char * const names[26] = {
    "Bool",
    "Unit",
    "Char",
    "Null",
    "I8",
    "U8",
    "I16",
    "U16",
    "I32",
    "U32",
    "F32",
    "Isize",
    "Usize",
    "I64",
    "U64",
    "F64",
    "Str",
    "Bytes",
    "Array",
    "Tri2D",
    "FixedSizeBytes",
    "TimestampMsUtc",
    "TimestampMs",
    "TimestampNsUtc",
    "TimestampNs",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueTy(ValueTy e) {
  if (::flatbuffers::IsOutRange(e, ValueTy::Bool, ValueTy::TimestampNs)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueTy()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point2D FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  struct Traits;
  Point2D()
      : x_(0),
        y_(0) {
  }
  Point2D(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Point2D, 8);

struct Point2D::Traits {
  using type = Point2D;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Tri2D FLATBUFFERS_FINAL_CLASS {
 private:
  Point2D p0_;
  Point2D p1_;
  Point2D p2_;

 public:
  struct Traits;
  Tri2D()
      : p0_(),
        p1_(),
        p2_() {
  }
  Tri2D(const Point2D &_p0, const Point2D &_p1, const Point2D &_p2)
      : p0_(_p0),
        p1_(_p1),
        p2_(_p2) {
  }
  const Point2D &p0() const {
    return p0_;
  }
  const Point2D &p1() const {
    return p1_;
  }
  const Point2D &p2() const {
    return p2_;
  }
};
FLATBUFFERS_STRUCT_END(Tri2D, 24);

struct Tri2D::Traits {
  using type = Tri2D;
};

struct VBool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VBoolBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  bool v() const {
    return GetField<uint8_t>(VT_V, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_V, 1) &&
           verifier.EndTable();
  }
};

struct VBoolBuilder {
  typedef VBool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(bool v) {
    fbb_.AddElement<uint8_t>(VBool::VT_V, static_cast<uint8_t>(v), 0);
  }
  explicit VBoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VBool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VBool> CreateVBool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool v = false) {
  VBoolBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VBool::Traits {
  using type = VBool;
  static auto constexpr Create = CreateVBool;
};

struct VUnit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VUnitBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VUnitBuilder {
  typedef VUnit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit VUnitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VUnit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VUnit> CreateVUnit(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  VUnitBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VUnit::Traits {
  using type = VUnit;
  static auto constexpr Create = CreateVUnit;
};

struct VChar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VCharBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  uint32_t v() const {
    return GetField<uint32_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_V, 4) &&
           verifier.EndTable();
  }
};

struct VCharBuilder {
  typedef VChar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(uint32_t v) {
    fbb_.AddElement<uint32_t>(VChar::VT_V, v, 0);
  }
  explicit VCharBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VChar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VChar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VChar> CreateVChar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t v = 0) {
  VCharBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VChar::Traits {
  using type = VChar;
  static auto constexpr Create = CreateVChar;
};

struct VNull FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VNullBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VNullBuilder {
  typedef VNull Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit VNullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VNull> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VNull>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VNull> CreateVNull(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  VNullBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VNull::Traits {
  using type = VNull;
  static auto constexpr Create = CreateVNull;
};

struct VI8 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VI8Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int8_t v() const {
    return GetField<int8_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_V, 1) &&
           verifier.EndTable();
  }
};

struct VI8Builder {
  typedef VI8 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int8_t v) {
    fbb_.AddElement<int8_t>(VI8::VT_V, v, 0);
  }
  explicit VI8Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VI8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VI8>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VI8> CreateVI8(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t v = 0) {
  VI8Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VI8::Traits {
  using type = VI8;
  static auto constexpr Create = CreateVI8;
};

struct VU8 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VU8Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  uint8_t v() const {
    return GetField<uint8_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_V, 1) &&
           verifier.EndTable();
  }
};

struct VU8Builder {
  typedef VU8 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(uint8_t v) {
    fbb_.AddElement<uint8_t>(VU8::VT_V, v, 0);
  }
  explicit VU8Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VU8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VU8>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VU8> CreateVU8(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t v = 0) {
  VU8Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VU8::Traits {
  using type = VU8;
  static auto constexpr Create = CreateVU8;
};

struct VI16 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VI16Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int16_t v() const {
    return GetField<int16_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_V, 2) &&
           verifier.EndTable();
  }
};

struct VI16Builder {
  typedef VI16 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int16_t v) {
    fbb_.AddElement<int16_t>(VI16::VT_V, v, 0);
  }
  explicit VI16Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VI16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VI16>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VI16> CreateVI16(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t v = 0) {
  VI16Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VI16::Traits {
  using type = VI16;
  static auto constexpr Create = CreateVI16;
};

struct VU16 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VU16Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  uint16_t v() const {
    return GetField<uint16_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_V, 2) &&
           verifier.EndTable();
  }
};

struct VU16Builder {
  typedef VU16 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(uint16_t v) {
    fbb_.AddElement<uint16_t>(VU16::VT_V, v, 0);
  }
  explicit VU16Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VU16> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VU16>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VU16> CreateVU16(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t v = 0) {
  VU16Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VU16::Traits {
  using type = VU16;
  static auto constexpr Create = CreateVU16;
};

struct VI32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VI32Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int32_t v() const {
    return GetField<int32_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_V, 4) &&
           verifier.EndTable();
  }
};

struct VI32Builder {
  typedef VI32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int32_t v) {
    fbb_.AddElement<int32_t>(VI32::VT_V, v, 0);
  }
  explicit VI32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VI32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VI32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VI32> CreateVI32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t v = 0) {
  VI32Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VI32::Traits {
  using type = VI32;
  static auto constexpr Create = CreateVI32;
};

struct VU32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VU32Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  uint32_t v() const {
    return GetField<uint32_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_V, 4) &&
           verifier.EndTable();
  }
};

struct VU32Builder {
  typedef VU32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(uint32_t v) {
    fbb_.AddElement<uint32_t>(VU32::VT_V, v, 0);
  }
  explicit VU32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VU32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VU32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VU32> CreateVU32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t v = 0) {
  VU32Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VU32::Traits {
  using type = VU32;
  static auto constexpr Create = CreateVU32;
};

struct VF32 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VF32Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  float v() const {
    return GetField<float>(VT_V, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_V, 4) &&
           verifier.EndTable();
  }
};

struct VF32Builder {
  typedef VF32 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(float v) {
    fbb_.AddElement<float>(VF32::VT_V, v, 0.0f);
  }
  explicit VF32Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VF32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VF32>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VF32> CreateVF32(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float v = 0.0f) {
  VF32Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VF32::Traits {
  using type = VF32;
  static auto constexpr Create = CreateVF32;
};

struct VIsize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VIsizeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int64_t v() const {
    return GetField<int64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VIsizeBuilder {
  typedef VIsize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int64_t v) {
    fbb_.AddElement<int64_t>(VIsize::VT_V, v, 0);
  }
  explicit VIsizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VIsize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VIsize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VIsize> CreateVIsize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v = 0) {
  VIsizeBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VIsize::Traits {
  using type = VIsize;
  static auto constexpr Create = CreateVIsize;
};

struct VUsize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VUsizeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  uint64_t v() const {
    return GetField<uint64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VUsizeBuilder {
  typedef VUsize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(uint64_t v) {
    fbb_.AddElement<uint64_t>(VUsize::VT_V, v, 0);
  }
  explicit VUsizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VUsize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VUsize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VUsize> CreateVUsize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t v = 0) {
  VUsizeBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VUsize::Traits {
  using type = VUsize;
  static auto constexpr Create = CreateVUsize;
};

struct VI64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VI64Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int64_t v() const {
    return GetField<int64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VI64Builder {
  typedef VI64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int64_t v) {
    fbb_.AddElement<int64_t>(VI64::VT_V, v, 0);
  }
  explicit VI64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VI64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VI64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VI64> CreateVI64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v = 0) {
  VI64Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VI64::Traits {
  using type = VI64;
  static auto constexpr Create = CreateVI64;
};

struct VU64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VU64Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  uint64_t v() const {
    return GetField<uint64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VU64Builder {
  typedef VU64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(uint64_t v) {
    fbb_.AddElement<uint64_t>(VU64::VT_V, v, 0);
  }
  explicit VU64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VU64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VU64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VU64> CreateVU64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t v = 0) {
  VU64Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VU64::Traits {
  using type = VU64;
  static auto constexpr Create = CreateVU64;
};

struct VF64 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VF64Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  double v() const {
    return GetField<double>(VT_V, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VF64Builder {
  typedef VF64 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(double v) {
    fbb_.AddElement<double>(VF64::VT_V, v, 0.0);
  }
  explicit VF64Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VF64> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VF64>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VF64> CreateVF64(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double v = 0.0) {
  VF64Builder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VF64::Traits {
  using type = VF64;
  static auto constexpr Create = CreateVF64;
};

struct VTimestampMsUtc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VTimestampMsUtcBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int64_t v() const {
    return GetField<int64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VTimestampMsUtcBuilder {
  typedef VTimestampMsUtc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int64_t v) {
    fbb_.AddElement<int64_t>(VTimestampMsUtc::VT_V, v, 0);
  }
  explicit VTimestampMsUtcBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VTimestampMsUtc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VTimestampMsUtc>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VTimestampMsUtc> CreateVTimestampMsUtc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v = 0) {
  VTimestampMsUtcBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VTimestampMsUtc::Traits {
  using type = VTimestampMsUtc;
  static auto constexpr Create = CreateVTimestampMsUtc;
};

struct VTimestampMs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VTimestampMsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int64_t v() const {
    return GetField<int64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VTimestampMsBuilder {
  typedef VTimestampMs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int64_t v) {
    fbb_.AddElement<int64_t>(VTimestampMs::VT_V, v, 0);
  }
  explicit VTimestampMsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VTimestampMs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VTimestampMs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VTimestampMs> CreateVTimestampMs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v = 0) {
  VTimestampMsBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VTimestampMs::Traits {
  using type = VTimestampMs;
  static auto constexpr Create = CreateVTimestampMs;
};

struct VTimestampNsUtc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VTimestampNsUtcBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int64_t v() const {
    return GetField<int64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VTimestampNsUtcBuilder {
  typedef VTimestampNsUtc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int64_t v) {
    fbb_.AddElement<int64_t>(VTimestampNsUtc::VT_V, v, 0);
  }
  explicit VTimestampNsUtcBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VTimestampNsUtc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VTimestampNsUtc>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VTimestampNsUtc> CreateVTimestampNsUtc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v = 0) {
  VTimestampNsUtcBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VTimestampNsUtc::Traits {
  using type = VTimestampNsUtc;
  static auto constexpr Create = CreateVTimestampNsUtc;
};

struct VTimestampNs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VTimestampNsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  int64_t v() const {
    return GetField<int64_t>(VT_V, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct VTimestampNsBuilder {
  typedef VTimestampNs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(int64_t v) {
    fbb_.AddElement<int64_t>(VTimestampNs::VT_V, v, 0);
  }
  explicit VTimestampNsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VTimestampNs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VTimestampNs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VTimestampNs> CreateVTimestampNs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t v = 0) {
  VTimestampNsBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VTimestampNs::Traits {
  using type = VTimestampNs;
  static auto constexpr Create = CreateVTimestampNs;
};

struct VStr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VStrBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  const ::flatbuffers::String *v() const {
    return GetPointer<const ::flatbuffers::String *>(VT_V);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_V) &&
           verifier.VerifyString(v()) &&
           verifier.EndTable();
  }
};

struct VStrBuilder {
  typedef VStr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(::flatbuffers::Offset<::flatbuffers::String> v) {
    fbb_.AddOffset(VStr::VT_V, v);
  }
  explicit VStrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VStr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VStr>(end);
    fbb_.Required(o, VStr::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<VStr> CreateVStr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> v = 0) {
  VStrBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VStr::Traits {
  using type = VStr;
  static auto constexpr Create = CreateVStr;
};

inline ::flatbuffers::Offset<VStr> CreateVStrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *v = nullptr) {
  auto v__ = v ? _fbb.CreateString(v) : 0;
  return CreateVStr(
      _fbb,
      v__);
}

struct VBytes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VBytesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  const ::flatbuffers::Vector<uint8_t> *v() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_V);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_V) &&
           verifier.VerifyVector(v()) &&
           verifier.EndTable();
  }
};

struct VBytesBuilder {
  typedef VBytes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> v) {
    fbb_.AddOffset(VBytes::VT_V, v);
  }
  explicit VBytesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VBytes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VBytes>(end);
    fbb_.Required(o, VBytes::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<VBytes> CreateVBytes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> v = 0) {
  VBytesBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VBytes::Traits {
  using type = VBytes;
  static auto constexpr Create = CreateVBytes;
};

inline ::flatbuffers::Offset<VBytes> CreateVBytesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *v = nullptr) {
  auto v__ = v ? _fbb.CreateVector<uint8_t>(*v) : 0;
  return CreateVBytes(
      _fbb,
      v__);
}

struct VFixedSizeBytes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VFixedSizeBytesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4,
    VT_SZ = 6
  };
  const ::flatbuffers::Vector<uint8_t> *v() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_V);
  }
  int32_t sz() const {
    return GetField<int32_t>(VT_SZ, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_V) &&
           verifier.VerifyVector(v()) &&
           VerifyField<int32_t>(verifier, VT_SZ, 4) &&
           verifier.EndTable();
  }
};

struct VFixedSizeBytesBuilder {
  typedef VFixedSizeBytes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> v) {
    fbb_.AddOffset(VFixedSizeBytes::VT_V, v);
  }
  void add_sz(int32_t sz) {
    fbb_.AddElement<int32_t>(VFixedSizeBytes::VT_SZ, sz, 0);
  }
  explicit VFixedSizeBytesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VFixedSizeBytes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VFixedSizeBytes>(end);
    fbb_.Required(o, VFixedSizeBytes::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<VFixedSizeBytes> CreateVFixedSizeBytes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> v = 0,
    int32_t sz = 0) {
  VFixedSizeBytesBuilder builder_(_fbb);
  builder_.add_sz(sz);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VFixedSizeBytes::Traits {
  using type = VFixedSizeBytes;
  static auto constexpr Create = CreateVFixedSizeBytes;
};

inline ::flatbuffers::Offset<VFixedSizeBytes> CreateVFixedSizeBytesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *v = nullptr,
    int32_t sz = 0) {
  auto v__ = v ? _fbb.CreateVector<uint8_t>(*v) : 0;
  return CreateVFixedSizeBytes(
      _fbb,
      v__,
      sz);
}

struct VTri2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VTri2DBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  const Tri2D *v() const {
    return GetStruct<const Tri2D *>(VT_V);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Tri2D>(verifier, VT_V, 4) &&
           verifier.EndTable();
  }
};

struct VTri2DBuilder {
  typedef VTri2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(const Tri2D *v) {
    fbb_.AddStruct(VTri2D::VT_V, v);
  }
  explicit VTri2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VTri2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VTri2D>(end);
    fbb_.Required(o, VTri2D::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<VTri2D> CreateVTri2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Tri2D *v = nullptr) {
  VTri2DBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VTri2D::Traits {
  using type = VTri2D;
  static auto constexpr Create = CreateVTri2D;
};

struct VArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VArrayBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>> *v() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>> *>(VT_V);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_V) &&
           verifier.VerifyVector(v()) &&
           verifier.VerifyVectorOfTables(v()) &&
           verifier.EndTable();
  }
};

struct VArrayBuilder {
  typedef VArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>>> v) {
    fbb_.AddOffset(VArray::VT_V, v);
  }
  explicit VArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VArray>(end);
    fbb_.Required(o, VArray::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<VArray> CreateVArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ValueInstance>>> v = 0) {
  VArrayBuilder builder_(_fbb);
  builder_.add_v(v);
  return builder_.Finish();
}

struct VArray::Traits {
  using type = VArray;
  static auto constexpr Create = CreateVArray;
};

inline ::flatbuffers::Offset<VArray> CreateVArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ValueInstance>> *v = nullptr) {
  auto v__ = v ? _fbb.CreateVector<::flatbuffers::Offset<ValueInstance>>(*v) : 0;
  return CreateVArray(
      _fbb,
      v__);
}

struct ValueInstance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueInstanceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_V_TYPE = 4,
    VT_V = 6
  };
  Value v_type() const {
    return static_cast<Value>(GetField<uint8_t>(VT_V_TYPE, 0));
  }
  const void *v() const {
    return GetPointer<const void *>(VT_V);
  }
  template<typename T> const T *v_as() const;
  const VBool *v_as_VBool() const {
    return v_type() == Value::VBool ? static_cast<const VBool *>(v()) : nullptr;
  }
  const VUnit *v_as_VUnit() const {
    return v_type() == Value::VUnit ? static_cast<const VUnit *>(v()) : nullptr;
  }
  const VChar *v_as_VChar() const {
    return v_type() == Value::VChar ? static_cast<const VChar *>(v()) : nullptr;
  }
  const VNull *v_as_VNull() const {
    return v_type() == Value::VNull ? static_cast<const VNull *>(v()) : nullptr;
  }
  const VI8 *v_as_VI8() const {
    return v_type() == Value::VI8 ? static_cast<const VI8 *>(v()) : nullptr;
  }
  const VU8 *v_as_VU8() const {
    return v_type() == Value::VU8 ? static_cast<const VU8 *>(v()) : nullptr;
  }
  const VI16 *v_as_VI16() const {
    return v_type() == Value::VI16 ? static_cast<const VI16 *>(v()) : nullptr;
  }
  const VU16 *v_as_VU16() const {
    return v_type() == Value::VU16 ? static_cast<const VU16 *>(v()) : nullptr;
  }
  const VI32 *v_as_VI32() const {
    return v_type() == Value::VI32 ? static_cast<const VI32 *>(v()) : nullptr;
  }
  const VU32 *v_as_VU32() const {
    return v_type() == Value::VU32 ? static_cast<const VU32 *>(v()) : nullptr;
  }
  const VF32 *v_as_VF32() const {
    return v_type() == Value::VF32 ? static_cast<const VF32 *>(v()) : nullptr;
  }
  const VIsize *v_as_VIsize() const {
    return v_type() == Value::VIsize ? static_cast<const VIsize *>(v()) : nullptr;
  }
  const VUsize *v_as_VUsize() const {
    return v_type() == Value::VUsize ? static_cast<const VUsize *>(v()) : nullptr;
  }
  const VI64 *v_as_VI64() const {
    return v_type() == Value::VI64 ? static_cast<const VI64 *>(v()) : nullptr;
  }
  const VU64 *v_as_VU64() const {
    return v_type() == Value::VU64 ? static_cast<const VU64 *>(v()) : nullptr;
  }
  const VF64 *v_as_VF64() const {
    return v_type() == Value::VF64 ? static_cast<const VF64 *>(v()) : nullptr;
  }
  const VStr *v_as_VStr() const {
    return v_type() == Value::VStr ? static_cast<const VStr *>(v()) : nullptr;
  }
  const VBytes *v_as_VBytes() const {
    return v_type() == Value::VBytes ? static_cast<const VBytes *>(v()) : nullptr;
  }
  const VArray *v_as_VArray() const {
    return v_type() == Value::VArray ? static_cast<const VArray *>(v()) : nullptr;
  }
  const VTri2D *v_as_VTri2D() const {
    return v_type() == Value::VTri2D ? static_cast<const VTri2D *>(v()) : nullptr;
  }
  const VFixedSizeBytes *v_as_VFixedSizeBytes() const {
    return v_type() == Value::VFixedSizeBytes ? static_cast<const VFixedSizeBytes *>(v()) : nullptr;
  }
  const VTimestampMsUtc *v_as_VTimestampMsUtc() const {
    return v_type() == Value::VTimestampMsUtc ? static_cast<const VTimestampMsUtc *>(v()) : nullptr;
  }
  const VTimestampMs *v_as_VTimestampMs() const {
    return v_type() == Value::VTimestampMs ? static_cast<const VTimestampMs *>(v()) : nullptr;
  }
  const VTimestampNsUtc *v_as_VTimestampNsUtc() const {
    return v_type() == Value::VTimestampNsUtc ? static_cast<const VTimestampNsUtc *>(v()) : nullptr;
  }
  const VTimestampNs *v_as_VTimestampNs() const {
    return v_type() == Value::VTimestampNs ? static_cast<const VTimestampNs *>(v()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_V_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_V) &&
           VerifyValue(verifier, v(), v_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VBool *ValueInstance::v_as<VBool>() const {
  return v_as_VBool();
}

template<> inline const VUnit *ValueInstance::v_as<VUnit>() const {
  return v_as_VUnit();
}

template<> inline const VChar *ValueInstance::v_as<VChar>() const {
  return v_as_VChar();
}

template<> inline const VNull *ValueInstance::v_as<VNull>() const {
  return v_as_VNull();
}

template<> inline const VI8 *ValueInstance::v_as<VI8>() const {
  return v_as_VI8();
}

template<> inline const VU8 *ValueInstance::v_as<VU8>() const {
  return v_as_VU8();
}

template<> inline const VI16 *ValueInstance::v_as<VI16>() const {
  return v_as_VI16();
}

template<> inline const VU16 *ValueInstance::v_as<VU16>() const {
  return v_as_VU16();
}

template<> inline const VI32 *ValueInstance::v_as<VI32>() const {
  return v_as_VI32();
}

template<> inline const VU32 *ValueInstance::v_as<VU32>() const {
  return v_as_VU32();
}

template<> inline const VF32 *ValueInstance::v_as<VF32>() const {
  return v_as_VF32();
}

template<> inline const VIsize *ValueInstance::v_as<VIsize>() const {
  return v_as_VIsize();
}

template<> inline const VUsize *ValueInstance::v_as<VUsize>() const {
  return v_as_VUsize();
}

template<> inline const VI64 *ValueInstance::v_as<VI64>() const {
  return v_as_VI64();
}

template<> inline const VU64 *ValueInstance::v_as<VU64>() const {
  return v_as_VU64();
}

template<> inline const VF64 *ValueInstance::v_as<VF64>() const {
  return v_as_VF64();
}

template<> inline const VStr *ValueInstance::v_as<VStr>() const {
  return v_as_VStr();
}

template<> inline const VBytes *ValueInstance::v_as<VBytes>() const {
  return v_as_VBytes();
}

template<> inline const VArray *ValueInstance::v_as<VArray>() const {
  return v_as_VArray();
}

template<> inline const VTri2D *ValueInstance::v_as<VTri2D>() const {
  return v_as_VTri2D();
}

template<> inline const VFixedSizeBytes *ValueInstance::v_as<VFixedSizeBytes>() const {
  return v_as_VFixedSizeBytes();
}

template<> inline const VTimestampMsUtc *ValueInstance::v_as<VTimestampMsUtc>() const {
  return v_as_VTimestampMsUtc();
}

template<> inline const VTimestampMs *ValueInstance::v_as<VTimestampMs>() const {
  return v_as_VTimestampMs();
}

template<> inline const VTimestampNsUtc *ValueInstance::v_as<VTimestampNsUtc>() const {
  return v_as_VTimestampNsUtc();
}

template<> inline const VTimestampNs *ValueInstance::v_as<VTimestampNs>() const {
  return v_as_VTimestampNs();
}

struct ValueInstanceBuilder {
  typedef ValueInstance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_v_type(Value v_type) {
    fbb_.AddElement<uint8_t>(ValueInstance::VT_V_TYPE, static_cast<uint8_t>(v_type), 0);
  }
  void add_v(::flatbuffers::Offset<void> v) {
    fbb_.AddOffset(ValueInstance::VT_V, v);
  }
  explicit ValueInstanceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueInstance>(end);
    fbb_.Required(o, ValueInstance::VT_V);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueInstance> CreateValueInstance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Value v_type = Value::NONE,
    ::flatbuffers::Offset<void> v = 0) {
  ValueInstanceBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_v_type(v_type);
  return builder_.Finish();
}

struct ValueInstance::Traits {
  using type = ValueInstance;
  static auto constexpr Create = CreateValueInstance;
};

inline bool VerifyValue(::flatbuffers::Verifier &verifier, const void *obj, Value type) {
  switch (type) {
    case Value::NONE: {
      return true;
    }
    case Value::VBool: {
      auto ptr = reinterpret_cast<const VBool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VUnit: {
      auto ptr = reinterpret_cast<const VUnit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VChar: {
      auto ptr = reinterpret_cast<const VChar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VNull: {
      auto ptr = reinterpret_cast<const VNull *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VI8: {
      auto ptr = reinterpret_cast<const VI8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VU8: {
      auto ptr = reinterpret_cast<const VU8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VI16: {
      auto ptr = reinterpret_cast<const VI16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VU16: {
      auto ptr = reinterpret_cast<const VU16 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VI32: {
      auto ptr = reinterpret_cast<const VI32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VU32: {
      auto ptr = reinterpret_cast<const VU32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VF32: {
      auto ptr = reinterpret_cast<const VF32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VIsize: {
      auto ptr = reinterpret_cast<const VIsize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VUsize: {
      auto ptr = reinterpret_cast<const VUsize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VI64: {
      auto ptr = reinterpret_cast<const VI64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VU64: {
      auto ptr = reinterpret_cast<const VU64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VF64: {
      auto ptr = reinterpret_cast<const VF64 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VStr: {
      auto ptr = reinterpret_cast<const VStr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VBytes: {
      auto ptr = reinterpret_cast<const VBytes *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VArray: {
      auto ptr = reinterpret_cast<const VArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VTri2D: {
      auto ptr = reinterpret_cast<const VTri2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VFixedSizeBytes: {
      auto ptr = reinterpret_cast<const VFixedSizeBytes *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VTimestampMsUtc: {
      auto ptr = reinterpret_cast<const VTimestampMsUtc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VTimestampMs: {
      auto ptr = reinterpret_cast<const VTimestampMs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VTimestampNsUtc: {
      auto ptr = reinterpret_cast<const VTimestampNsUtc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Value::VTimestampNs: {
      auto ptr = reinterpret_cast<const VTimestampNs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Value> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValue(
        verifier,  values->Get(i), types->GetEnum<Value>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_VALUE_H_
