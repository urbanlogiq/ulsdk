// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_USERPROJECT_H_
#define FLATBUFFERS_GENERATED_USERPROJECT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "entity_generated.h"
#include "id_generated.h"

struct CategoryFilter;
struct CategoryFilterBuilder;

struct RangeFilter;
struct RangeFilterBuilder;

struct RelationshipRangeFilter;
struct RelationshipRangeFilterBuilder;

struct FieldFilter;
struct FieldFilterBuilder;

struct ColumnGroup;
struct ColumnGroupBuilder;

struct UserLayerDataState;
struct UserLayerDataStateBuilder;

struct DeprecatedDataStateJoin;
struct DeprecatedDataStateJoinBuilder;

struct DataStateGeometrySource;
struct DataStateGeometrySourceBuilder;

struct RawGeometrySourceGeom;
struct RawGeometrySourceGeomBuilder;

struct RawGeometrySource;
struct RawGeometrySourceBuilder;

struct JoinStackEntry;
struct JoinStackEntryBuilder;

struct StackableDataStateJoin;
struct StackableDataStateJoinBuilder;

struct UserLayer;
struct UserLayerBuilder;

struct UserProject;
struct UserProjectBuilder;

enum class FieldComparator : uint32_t {
  Greater = 0,
  GreaterEqual = 1,
  Less = 2,
  LessEqual = 3,
  Equal = 4,
  NotEqual = 5,
  MIN = Greater,
  MAX = NotEqual
};

inline const FieldComparator (&EnumValuesFieldComparator())[6] {
  static const FieldComparator values[] = {
    FieldComparator::Greater,
    FieldComparator::GreaterEqual,
    FieldComparator::Less,
    FieldComparator::LessEqual,
    FieldComparator::Equal,
    FieldComparator::NotEqual
  };
  return values;
}

inline const char * const *EnumNamesFieldComparator() {
  static const char * const names[7] = {
    "Greater",
    "GreaterEqual",
    "Less",
    "LessEqual",
    "Equal",
    "NotEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameFieldComparator(FieldComparator e) {
  if (::flatbuffers::IsOutRange(e, FieldComparator::Greater, FieldComparator::NotEqual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFieldComparator()[index];
}

enum class AggregateOp : uint32_t {
  Average = 0,
  Relative = 1,
  MIN = Average,
  MAX = Relative
};

inline const AggregateOp (&EnumValuesAggregateOp())[2] {
  static const AggregateOp values[] = {
    AggregateOp::Average,
    AggregateOp::Relative
  };
  return values;
}

inline const char * const *EnumNamesAggregateOp() {
  static const char * const names[3] = {
    "Average",
    "Relative",
    nullptr
  };
  return names;
}

inline const char *EnumNameAggregateOp(AggregateOp e) {
  if (::flatbuffers::IsOutRange(e, AggregateOp::Average, AggregateOp::Relative)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAggregateOp()[index];
}

enum class Filter : uint8_t {
  NONE = 0,
  CategoryFilter = 1,
  RangeFilter = 2,
  RelationshipRangeFilter = 3,
  MIN = NONE,
  MAX = RelationshipRangeFilter
};

inline const Filter (&EnumValuesFilter())[4] {
  static const Filter values[] = {
    Filter::NONE,
    Filter::CategoryFilter,
    Filter::RangeFilter,
    Filter::RelationshipRangeFilter
  };
  return values;
}

inline const char * const *EnumNamesFilter() {
  static const char * const names[5] = {
    "NONE",
    "CategoryFilter",
    "RangeFilter",
    "RelationshipRangeFilter",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilter(Filter e) {
  if (::flatbuffers::IsOutRange(e, Filter::NONE, Filter::RelationshipRangeFilter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilter()[index];
}

template<typename T> struct FilterTraits {
  static const Filter enum_value = Filter::NONE;
};

template<> struct FilterTraits<CategoryFilter> {
  static const Filter enum_value = Filter::CategoryFilter;
};

template<> struct FilterTraits<RangeFilter> {
  static const Filter enum_value = Filter::RangeFilter;
};

template<> struct FilterTraits<RelationshipRangeFilter> {
  static const Filter enum_value = Filter::RelationshipRangeFilter;
};

bool VerifyFilter(::flatbuffers::Verifier &verifier, const void *obj, Filter type);
bool VerifyFilterVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Filter> *types);

enum class ColumnGroupType : uint32_t {
  None = 0,
  Relationship = 1,
  Column = 2,
  MIN = None,
  MAX = Column
};

inline const ColumnGroupType (&EnumValuesColumnGroupType())[3] {
  static const ColumnGroupType values[] = {
    ColumnGroupType::None,
    ColumnGroupType::Relationship,
    ColumnGroupType::Column
  };
  return values;
}

inline const char * const *EnumNamesColumnGroupType() {
  static const char * const names[4] = {
    "None",
    "Relationship",
    "Column",
    nullptr
  };
  return names;
}

inline const char *EnumNameColumnGroupType(ColumnGroupType e) {
  if (::flatbuffers::IsOutRange(e, ColumnGroupType::None, ColumnGroupType::Column)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColumnGroupType()[index];
}

enum class JoinOperation : uint32_t {
  Intersect = 0,
  Disjoint = 1,
  BufferedIntersection = 2,
  MIN = Intersect,
  MAX = BufferedIntersection
};

inline const JoinOperation (&EnumValuesJoinOperation())[3] {
  static const JoinOperation values[] = {
    JoinOperation::Intersect,
    JoinOperation::Disjoint,
    JoinOperation::BufferedIntersection
  };
  return values;
}

inline const char * const *EnumNamesJoinOperation() {
  static const char * const names[4] = {
    "Intersect",
    "Disjoint",
    "BufferedIntersection",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinOperation(JoinOperation e) {
  if (::flatbuffers::IsOutRange(e, JoinOperation::Intersect, JoinOperation::BufferedIntersection)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinOperation()[index];
}

enum class LayerCombineMode : uint32_t {
  Union = 0,
  Difference = 1,
  MIN = Union,
  MAX = Difference
};

inline const LayerCombineMode (&EnumValuesLayerCombineMode())[2] {
  static const LayerCombineMode values[] = {
    LayerCombineMode::Union,
    LayerCombineMode::Difference
  };
  return values;
}

inline const char * const *EnumNamesLayerCombineMode() {
  static const char * const names[3] = {
    "Union",
    "Difference",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerCombineMode(LayerCombineMode e) {
  if (::flatbuffers::IsOutRange(e, LayerCombineMode::Union, LayerCombineMode::Difference)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerCombineMode()[index];
}

enum class JoinType : int8_t {
  Inner = 0,
  Outer = 1,
  MIN = Inner,
  MAX = Outer
};

inline const JoinType (&EnumValuesJoinType())[2] {
  static const JoinType values[] = {
    JoinType::Inner,
    JoinType::Outer
  };
  return values;
}

inline const char * const *EnumNamesJoinType() {
  static const char * const names[3] = {
    "Inner",
    "Outer",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinType(JoinType e) {
  if (::flatbuffers::IsOutRange(e, JoinType::Inner, JoinType::Outer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinType()[index];
}

enum class JoinStackEntryGeometrySourceUnion : uint8_t {
  NONE = 0,
  DataStateGeometrySource = 1,
  RawGeometrySource = 2,
  MIN = NONE,
  MAX = RawGeometrySource
};

inline const JoinStackEntryGeometrySourceUnion (&EnumValuesJoinStackEntryGeometrySourceUnion())[3] {
  static const JoinStackEntryGeometrySourceUnion values[] = {
    JoinStackEntryGeometrySourceUnion::NONE,
    JoinStackEntryGeometrySourceUnion::DataStateGeometrySource,
    JoinStackEntryGeometrySourceUnion::RawGeometrySource
  };
  return values;
}

inline const char * const *EnumNamesJoinStackEntryGeometrySourceUnion() {
  static const char * const names[4] = {
    "NONE",
    "DataStateGeometrySource",
    "RawGeometrySource",
    nullptr
  };
  return names;
}

inline const char *EnumNameJoinStackEntryGeometrySourceUnion(JoinStackEntryGeometrySourceUnion e) {
  if (::flatbuffers::IsOutRange(e, JoinStackEntryGeometrySourceUnion::NONE, JoinStackEntryGeometrySourceUnion::RawGeometrySource)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJoinStackEntryGeometrySourceUnion()[index];
}

template<typename T> struct JoinStackEntryGeometrySourceUnionTraits {
  static const JoinStackEntryGeometrySourceUnion enum_value = JoinStackEntryGeometrySourceUnion::NONE;
};

template<> struct JoinStackEntryGeometrySourceUnionTraits<DataStateGeometrySource> {
  static const JoinStackEntryGeometrySourceUnion enum_value = JoinStackEntryGeometrySourceUnion::DataStateGeometrySource;
};

template<> struct JoinStackEntryGeometrySourceUnionTraits<RawGeometrySource> {
  static const JoinStackEntryGeometrySourceUnion enum_value = JoinStackEntryGeometrySourceUnion::RawGeometrySource;
};

bool VerifyJoinStackEntryGeometrySourceUnion(::flatbuffers::Verifier &verifier, const void *obj, JoinStackEntryGeometrySourceUnion type);
bool VerifyJoinStackEntryGeometrySourceUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<JoinStackEntryGeometrySourceUnion> *types);

struct CategoryFilter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CategoryFilterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN_GROUP_ID = 4,
    VT_VALUES = 6,
    VT_COMPARATOR = 8,
    VT_INCLUDE_NULLS = 10
  };
  const ColumnGroupId *column_group_id() const {
    return GetPointer<const ColumnGroupId *>(VT_COLUMN_GROUP_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUES);
  }
  FieldComparator comparator() const {
    return static_cast<FieldComparator>(GetField<uint32_t>(VT_COMPARATOR, 0));
  }
  bool include_nulls() const {
    return GetField<uint8_t>(VT_INCLUDE_NULLS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLUMN_GROUP_ID) &&
           verifier.VerifyTable(column_group_id()) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfStrings(values()) &&
           VerifyField<uint32_t>(verifier, VT_COMPARATOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_NULLS, 1) &&
           verifier.EndTable();
  }
};

struct CategoryFilterBuilder {
  typedef CategoryFilter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_column_group_id(::flatbuffers::Offset<ColumnGroupId> column_group_id) {
    fbb_.AddOffset(CategoryFilter::VT_COLUMN_GROUP_ID, column_group_id);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values) {
    fbb_.AddOffset(CategoryFilter::VT_VALUES, values);
  }
  void add_comparator(FieldComparator comparator) {
    fbb_.AddElement<uint32_t>(CategoryFilter::VT_COMPARATOR, static_cast<uint32_t>(comparator), 0);
  }
  void add_include_nulls(bool include_nulls) {
    fbb_.AddElement<uint8_t>(CategoryFilter::VT_INCLUDE_NULLS, static_cast<uint8_t>(include_nulls), 0);
  }
  explicit CategoryFilterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CategoryFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CategoryFilter>(end);
    fbb_.Required(o, CategoryFilter::VT_COLUMN_GROUP_ID);
    fbb_.Required(o, CategoryFilter::VT_VALUES);
    return o;
  }
};

inline ::flatbuffers::Offset<CategoryFilter> CreateCategoryFilter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ColumnGroupId> column_group_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values = 0,
    FieldComparator comparator = FieldComparator::Greater,
    bool include_nulls = false) {
  CategoryFilterBuilder builder_(_fbb);
  builder_.add_comparator(comparator);
  builder_.add_values(values);
  builder_.add_column_group_id(column_group_id);
  builder_.add_include_nulls(include_nulls);
  return builder_.Finish();
}

struct CategoryFilter::Traits {
  using type = CategoryFilter;
  static auto constexpr Create = CreateCategoryFilter;
};

inline ::flatbuffers::Offset<CategoryFilter> CreateCategoryFilterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ColumnGroupId> column_group_id = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *values = nullptr,
    FieldComparator comparator = FieldComparator::Greater,
    bool include_nulls = false) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*values) : 0;
  return CreateCategoryFilter(
      _fbb,
      column_group_id,
      values__,
      comparator,
      include_nulls);
}

struct RangeFilter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeFilterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN_GROUP_ID = 4,
    VT_MIN = 6,
    VT_MAX = 8,
    VT_INCLUDE_NULLS = 10
  };
  const ColumnGroupId *column_group_id() const {
    return GetPointer<const ColumnGroupId *>(VT_COLUMN_GROUP_ID);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  bool include_nulls() const {
    return GetField<uint8_t>(VT_INCLUDE_NULLS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLUMN_GROUP_ID) &&
           verifier.VerifyTable(column_group_id()) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_NULLS, 1) &&
           verifier.EndTable();
  }
};

struct RangeFilterBuilder {
  typedef RangeFilter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_column_group_id(::flatbuffers::Offset<ColumnGroupId> column_group_id) {
    fbb_.AddOffset(RangeFilter::VT_COLUMN_GROUP_ID, column_group_id);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(RangeFilter::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(RangeFilter::VT_MAX, max, 0.0f);
  }
  void add_include_nulls(bool include_nulls) {
    fbb_.AddElement<uint8_t>(RangeFilter::VT_INCLUDE_NULLS, static_cast<uint8_t>(include_nulls), 0);
  }
  explicit RangeFilterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RangeFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RangeFilter>(end);
    fbb_.Required(o, RangeFilter::VT_COLUMN_GROUP_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<RangeFilter> CreateRangeFilter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ColumnGroupId> column_group_id = 0,
    float min = 0.0f,
    float max = 0.0f,
    bool include_nulls = false) {
  RangeFilterBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_column_group_id(column_group_id);
  builder_.add_include_nulls(include_nulls);
  return builder_.Finish();
}

struct RangeFilter::Traits {
  using type = RangeFilter;
  static auto constexpr Create = CreateRangeFilter;
};

struct RelationshipRangeFilter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RelationshipRangeFilterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN_GROUP_ID = 4,
    VT_AGGREGATE_OP = 6,
    VT_COLUMNS = 8,
    VT_MIN = 10,
    VT_MAX = 12,
    VT_INCLUDE_NULLS = 14
  };
  const ColumnGroupId *column_group_id() const {
    return GetPointer<const ColumnGroupId *>(VT_COLUMN_GROUP_ID);
  }
  AggregateOp aggregate_op() const {
    return static_cast<AggregateOp>(GetField<uint32_t>(VT_AGGREGATE_OP, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *columns() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COLUMNS);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  bool include_nulls() const {
    return GetField<uint8_t>(VT_INCLUDE_NULLS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLUMN_GROUP_ID) &&
           verifier.VerifyTable(column_group_id()) &&
           VerifyField<uint32_t>(verifier, VT_AGGREGATE_OP, 4) &&
           VerifyOffsetRequired(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfStrings(columns()) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_NULLS, 1) &&
           verifier.EndTable();
  }
};

struct RelationshipRangeFilterBuilder {
  typedef RelationshipRangeFilter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_column_group_id(::flatbuffers::Offset<ColumnGroupId> column_group_id) {
    fbb_.AddOffset(RelationshipRangeFilter::VT_COLUMN_GROUP_ID, column_group_id);
  }
  void add_aggregate_op(AggregateOp aggregate_op) {
    fbb_.AddElement<uint32_t>(RelationshipRangeFilter::VT_AGGREGATE_OP, static_cast<uint32_t>(aggregate_op), 0);
  }
  void add_columns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> columns) {
    fbb_.AddOffset(RelationshipRangeFilter::VT_COLUMNS, columns);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(RelationshipRangeFilter::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(RelationshipRangeFilter::VT_MAX, max, 0.0f);
  }
  void add_include_nulls(bool include_nulls) {
    fbb_.AddElement<uint8_t>(RelationshipRangeFilter::VT_INCLUDE_NULLS, static_cast<uint8_t>(include_nulls), 0);
  }
  explicit RelationshipRangeFilterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RelationshipRangeFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RelationshipRangeFilter>(end);
    fbb_.Required(o, RelationshipRangeFilter::VT_COLUMN_GROUP_ID);
    fbb_.Required(o, RelationshipRangeFilter::VT_COLUMNS);
    return o;
  }
};

inline ::flatbuffers::Offset<RelationshipRangeFilter> CreateRelationshipRangeFilter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ColumnGroupId> column_group_id = 0,
    AggregateOp aggregate_op = AggregateOp::Average,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> columns = 0,
    float min = 0.0f,
    float max = 0.0f,
    bool include_nulls = false) {
  RelationshipRangeFilterBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_columns(columns);
  builder_.add_aggregate_op(aggregate_op);
  builder_.add_column_group_id(column_group_id);
  builder_.add_include_nulls(include_nulls);
  return builder_.Finish();
}

struct RelationshipRangeFilter::Traits {
  using type = RelationshipRangeFilter;
  static auto constexpr Create = CreateRelationshipRangeFilter;
};

inline ::flatbuffers::Offset<RelationshipRangeFilter> CreateRelationshipRangeFilterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ColumnGroupId> column_group_id = 0,
    AggregateOp aggregate_op = AggregateOp::Average,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *columns = nullptr,
    float min = 0.0f,
    float max = 0.0f,
    bool include_nulls = false) {
  auto columns__ = columns ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*columns) : 0;
  return CreateRelationshipRangeFilter(
      _fbb,
      column_group_id,
      aggregate_op,
      columns__,
      min,
      max,
      include_nulls);
}

struct FieldFilter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldFilterBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILTER_TYPE = 4,
    VT_FILTER = 6
  };
  Filter filter_type() const {
    return static_cast<Filter>(GetField<uint8_t>(VT_FILTER_TYPE, 0));
  }
  const void *filter() const {
    return GetPointer<const void *>(VT_FILTER);
  }
  template<typename T> const T *filter_as() const;
  const CategoryFilter *filter_as_CategoryFilter() const {
    return filter_type() == Filter::CategoryFilter ? static_cast<const CategoryFilter *>(filter()) : nullptr;
  }
  const RangeFilter *filter_as_RangeFilter() const {
    return filter_type() == Filter::RangeFilter ? static_cast<const RangeFilter *>(filter()) : nullptr;
  }
  const RelationshipRangeFilter *filter_as_RelationshipRangeFilter() const {
    return filter_type() == Filter::RelationshipRangeFilter ? static_cast<const RelationshipRangeFilter *>(filter()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FILTER_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_FILTER) &&
           VerifyFilter(verifier, filter(), filter_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CategoryFilter *FieldFilter::filter_as<CategoryFilter>() const {
  return filter_as_CategoryFilter();
}

template<> inline const RangeFilter *FieldFilter::filter_as<RangeFilter>() const {
  return filter_as_RangeFilter();
}

template<> inline const RelationshipRangeFilter *FieldFilter::filter_as<RelationshipRangeFilter>() const {
  return filter_as_RelationshipRangeFilter();
}

struct FieldFilterBuilder {
  typedef FieldFilter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filter_type(Filter filter_type) {
    fbb_.AddElement<uint8_t>(FieldFilter::VT_FILTER_TYPE, static_cast<uint8_t>(filter_type), 0);
  }
  void add_filter(::flatbuffers::Offset<void> filter) {
    fbb_.AddOffset(FieldFilter::VT_FILTER, filter);
  }
  explicit FieldFilterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldFilter>(end);
    fbb_.Required(o, FieldFilter::VT_FILTER);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldFilter> CreateFieldFilter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Filter filter_type = Filter::NONE,
    ::flatbuffers::Offset<void> filter = 0) {
  FieldFilterBuilder builder_(_fbb);
  builder_.add_filter(filter);
  builder_.add_filter_type(filter_type);
  return builder_.Finish();
}

struct FieldFilter::Traits {
  using type = FieldFilter;
  static auto constexpr Create = CreateFieldFilter;
};

struct ColumnGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColumnGroupBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DISPLAY_NAME = 6,
    VT_TY = 8,
    VT_COLUMNS = 10,
    VT_STREAM_ID = 12
  };
  const ColumnGroupId *id() const {
    return GetPointer<const ColumnGroupId *>(VT_ID);
  }
  const ::flatbuffers::String *display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  ColumnGroupType ty() const {
    return static_cast<ColumnGroupType>(GetField<uint32_t>(VT_TY, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *columns() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COLUMNS);
  }
  const StreamId *stream_id() const {
    return GetPointer<const StreamId *>(VT_STREAM_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffsetRequired(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyField<uint32_t>(verifier, VT_TY, 4) &&
           VerifyOffsetRequired(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfStrings(columns()) &&
           VerifyOffset(verifier, VT_STREAM_ID) &&
           verifier.VerifyTable(stream_id()) &&
           verifier.EndTable();
  }
};

struct ColumnGroupBuilder {
  typedef ColumnGroup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<ColumnGroupId> id) {
    fbb_.AddOffset(ColumnGroup::VT_ID, id);
  }
  void add_display_name(::flatbuffers::Offset<::flatbuffers::String> display_name) {
    fbb_.AddOffset(ColumnGroup::VT_DISPLAY_NAME, display_name);
  }
  void add_ty(ColumnGroupType ty) {
    fbb_.AddElement<uint32_t>(ColumnGroup::VT_TY, static_cast<uint32_t>(ty), 0);
  }
  void add_columns(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> columns) {
    fbb_.AddOffset(ColumnGroup::VT_COLUMNS, columns);
  }
  void add_stream_id(::flatbuffers::Offset<StreamId> stream_id) {
    fbb_.AddOffset(ColumnGroup::VT_STREAM_ID, stream_id);
  }
  explicit ColumnGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColumnGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColumnGroup>(end);
    fbb_.Required(o, ColumnGroup::VT_ID);
    fbb_.Required(o, ColumnGroup::VT_DISPLAY_NAME);
    fbb_.Required(o, ColumnGroup::VT_COLUMNS);
    return o;
  }
};

inline ::flatbuffers::Offset<ColumnGroup> CreateColumnGroup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ColumnGroupId> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> display_name = 0,
    ColumnGroupType ty = ColumnGroupType::None,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> columns = 0,
    ::flatbuffers::Offset<StreamId> stream_id = 0) {
  ColumnGroupBuilder builder_(_fbb);
  builder_.add_stream_id(stream_id);
  builder_.add_columns(columns);
  builder_.add_ty(ty);
  builder_.add_display_name(display_name);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ColumnGroup::Traits {
  using type = ColumnGroup;
  static auto constexpr Create = CreateColumnGroup;
};

inline ::flatbuffers::Offset<ColumnGroup> CreateColumnGroupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ColumnGroupId> id = 0,
    const char *display_name = nullptr,
    ColumnGroupType ty = ColumnGroupType::None,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *columns = nullptr,
    ::flatbuffers::Offset<StreamId> stream_id = 0) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto columns__ = columns ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*columns) : 0;
  return CreateColumnGroup(
      _fbb,
      id,
      display_name__,
      ty,
      columns__,
      stream_id);
}

struct UserLayerDataState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserLayerDataStateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_ID = 4,
    VT_DATA_STATE_ID = 6,
    VT_ACTIVE_FIELDS = 8,
    VT_FILTERS = 10
  };
  const StreamId *stream_id() const {
    return GetPointer<const StreamId *>(VT_STREAM_ID);
  }
  const DataStateId *data_state_id() const {
    return GetPointer<const DataStateId *>(VT_DATA_STATE_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ColumnGroup>> *active_fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ColumnGroup>> *>(VT_ACTIVE_FIELDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FieldFilter>> *filters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FieldFilter>> *>(VT_FILTERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_STREAM_ID) &&
           verifier.VerifyTable(stream_id()) &&
           VerifyOffsetRequired(verifier, VT_DATA_STATE_ID) &&
           verifier.VerifyTable(data_state_id()) &&
           VerifyOffsetRequired(verifier, VT_ACTIVE_FIELDS) &&
           verifier.VerifyVector(active_fields()) &&
           verifier.VerifyVectorOfTables(active_fields()) &&
           VerifyOffsetRequired(verifier, VT_FILTERS) &&
           verifier.VerifyVector(filters()) &&
           verifier.VerifyVectorOfTables(filters()) &&
           verifier.EndTable();
  }
};

struct UserLayerDataStateBuilder {
  typedef UserLayerDataState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stream_id(::flatbuffers::Offset<StreamId> stream_id) {
    fbb_.AddOffset(UserLayerDataState::VT_STREAM_ID, stream_id);
  }
  void add_data_state_id(::flatbuffers::Offset<DataStateId> data_state_id) {
    fbb_.AddOffset(UserLayerDataState::VT_DATA_STATE_ID, data_state_id);
  }
  void add_active_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ColumnGroup>>> active_fields) {
    fbb_.AddOffset(UserLayerDataState::VT_ACTIVE_FIELDS, active_fields);
  }
  void add_filters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FieldFilter>>> filters) {
    fbb_.AddOffset(UserLayerDataState::VT_FILTERS, filters);
  }
  explicit UserLayerDataStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserLayerDataState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserLayerDataState>(end);
    fbb_.Required(o, UserLayerDataState::VT_STREAM_ID);
    fbb_.Required(o, UserLayerDataState::VT_DATA_STATE_ID);
    fbb_.Required(o, UserLayerDataState::VT_ACTIVE_FIELDS);
    fbb_.Required(o, UserLayerDataState::VT_FILTERS);
    return o;
  }
};

inline ::flatbuffers::Offset<UserLayerDataState> CreateUserLayerDataState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<StreamId> stream_id = 0,
    ::flatbuffers::Offset<DataStateId> data_state_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ColumnGroup>>> active_fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FieldFilter>>> filters = 0) {
  UserLayerDataStateBuilder builder_(_fbb);
  builder_.add_filters(filters);
  builder_.add_active_fields(active_fields);
  builder_.add_data_state_id(data_state_id);
  builder_.add_stream_id(stream_id);
  return builder_.Finish();
}

struct UserLayerDataState::Traits {
  using type = UserLayerDataState;
  static auto constexpr Create = CreateUserLayerDataState;
};

inline ::flatbuffers::Offset<UserLayerDataState> CreateUserLayerDataStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<StreamId> stream_id = 0,
    ::flatbuffers::Offset<DataStateId> data_state_id = 0,
    const std::vector<::flatbuffers::Offset<ColumnGroup>> *active_fields = nullptr,
    const std::vector<::flatbuffers::Offset<FieldFilter>> *filters = nullptr) {
  auto active_fields__ = active_fields ? _fbb.CreateVector<::flatbuffers::Offset<ColumnGroup>>(*active_fields) : 0;
  auto filters__ = filters ? _fbb.CreateVector<::flatbuffers::Offset<FieldFilter>>(*filters) : 0;
  return CreateUserLayerDataState(
      _fbb,
      stream_id,
      data_state_id,
      active_fields__,
      filters__);
}

struct DeprecatedDataStateJoin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DeprecatedDataStateJoinBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FROM = 4,
    VT_TO = 6,
    VT_OPERATION = 8,
    VT_DISTANCE = 10
  };
  const DataStateId *from() const {
    return GetPointer<const DataStateId *>(VT_FROM);
  }
  const DataStateId *to() const {
    return GetPointer<const DataStateId *>(VT_TO);
  }
  JoinOperation operation() const {
    return static_cast<JoinOperation>(GetField<uint32_t>(VT_OPERATION, 0));
  }
  float distance() const {
    return GetField<float>(VT_DISTANCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FROM) &&
           verifier.VerifyTable(from()) &&
           VerifyOffsetRequired(verifier, VT_TO) &&
           verifier.VerifyTable(to()) &&
           VerifyField<uint32_t>(verifier, VT_OPERATION, 4) &&
           VerifyField<float>(verifier, VT_DISTANCE, 4) &&
           verifier.EndTable();
  }
};

struct DeprecatedDataStateJoinBuilder {
  typedef DeprecatedDataStateJoin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_from(::flatbuffers::Offset<DataStateId> from) {
    fbb_.AddOffset(DeprecatedDataStateJoin::VT_FROM, from);
  }
  void add_to(::flatbuffers::Offset<DataStateId> to) {
    fbb_.AddOffset(DeprecatedDataStateJoin::VT_TO, to);
  }
  void add_operation(JoinOperation operation) {
    fbb_.AddElement<uint32_t>(DeprecatedDataStateJoin::VT_OPERATION, static_cast<uint32_t>(operation), 0);
  }
  void add_distance(float distance) {
    fbb_.AddElement<float>(DeprecatedDataStateJoin::VT_DISTANCE, distance, 0.0f);
  }
  explicit DeprecatedDataStateJoinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeprecatedDataStateJoin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeprecatedDataStateJoin>(end);
    fbb_.Required(o, DeprecatedDataStateJoin::VT_FROM);
    fbb_.Required(o, DeprecatedDataStateJoin::VT_TO);
    return o;
  }
};

inline ::flatbuffers::Offset<DeprecatedDataStateJoin> CreateDeprecatedDataStateJoin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<DataStateId> from = 0,
    ::flatbuffers::Offset<DataStateId> to = 0,
    JoinOperation operation = JoinOperation::Intersect,
    float distance = 0.0f) {
  DeprecatedDataStateJoinBuilder builder_(_fbb);
  builder_.add_distance(distance);
  builder_.add_operation(operation);
  builder_.add_to(to);
  builder_.add_from(from);
  return builder_.Finish();
}

struct DeprecatedDataStateJoin::Traits {
  using type = DeprecatedDataStateJoin;
  static auto constexpr Create = CreateDeprecatedDataStateJoin;
};

struct DataStateGeometrySource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataStateGeometrySourceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_STATE_ID = 4
  };
  const DataStateId *data_state_id() const {
    return GetPointer<const DataStateId *>(VT_DATA_STATE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA_STATE_ID) &&
           verifier.VerifyTable(data_state_id()) &&
           verifier.EndTable();
  }
};

struct DataStateGeometrySourceBuilder {
  typedef DataStateGeometrySource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_state_id(::flatbuffers::Offset<DataStateId> data_state_id) {
    fbb_.AddOffset(DataStateGeometrySource::VT_DATA_STATE_ID, data_state_id);
  }
  explicit DataStateGeometrySourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataStateGeometrySource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataStateGeometrySource>(end);
    fbb_.Required(o, DataStateGeometrySource::VT_DATA_STATE_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<DataStateGeometrySource> CreateDataStateGeometrySource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<DataStateId> data_state_id = 0) {
  DataStateGeometrySourceBuilder builder_(_fbb);
  builder_.add_data_state_id(data_state_id);
  return builder_.Finish();
}

struct DataStateGeometrySource::Traits {
  using type = DataStateGeometrySource;
  static auto constexpr Create = CreateDataStateGeometrySource;
};

struct RawGeometrySourceGeom FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RawGeometrySourceGeomBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOM_TYPE = 4,
    VT_GEOM = 6
  };
  Geometry geom_type() const {
    return static_cast<Geometry>(GetField<uint8_t>(VT_GEOM_TYPE, 0));
  }
  const void *geom() const {
    return GetPointer<const void *>(VT_GEOM);
  }
  template<typename T> const T *geom_as() const;
  const Point *geom_as_Point() const {
    return geom_type() == Geometry::Point ? static_cast<const Point *>(geom()) : nullptr;
  }
  const Line *geom_as_Line() const {
    return geom_type() == Geometry::Line ? static_cast<const Line *>(geom()) : nullptr;
  }
  const MultiLine *geom_as_MultiLine() const {
    return geom_type() == Geometry::MultiLine ? static_cast<const MultiLine *>(geom()) : nullptr;
  }
  const Polygon *geom_as_Polygon() const {
    return geom_type() == Geometry::Polygon ? static_cast<const Polygon *>(geom()) : nullptr;
  }
  const MultiPolygon *geom_as_MultiPolygon() const {
    return geom_type() == Geometry::MultiPolygon ? static_cast<const MultiPolygon *>(geom()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GEOM_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_GEOM) &&
           VerifyGeometry(verifier, geom(), geom_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Point *RawGeometrySourceGeom::geom_as<Point>() const {
  return geom_as_Point();
}

template<> inline const Line *RawGeometrySourceGeom::geom_as<Line>() const {
  return geom_as_Line();
}

template<> inline const MultiLine *RawGeometrySourceGeom::geom_as<MultiLine>() const {
  return geom_as_MultiLine();
}

template<> inline const Polygon *RawGeometrySourceGeom::geom_as<Polygon>() const {
  return geom_as_Polygon();
}

template<> inline const MultiPolygon *RawGeometrySourceGeom::geom_as<MultiPolygon>() const {
  return geom_as_MultiPolygon();
}

struct RawGeometrySourceGeomBuilder {
  typedef RawGeometrySourceGeom Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_geom_type(Geometry geom_type) {
    fbb_.AddElement<uint8_t>(RawGeometrySourceGeom::VT_GEOM_TYPE, static_cast<uint8_t>(geom_type), 0);
  }
  void add_geom(::flatbuffers::Offset<void> geom) {
    fbb_.AddOffset(RawGeometrySourceGeom::VT_GEOM, geom);
  }
  explicit RawGeometrySourceGeomBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RawGeometrySourceGeom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RawGeometrySourceGeom>(end);
    fbb_.Required(o, RawGeometrySourceGeom::VT_GEOM);
    return o;
  }
};

inline ::flatbuffers::Offset<RawGeometrySourceGeom> CreateRawGeometrySourceGeom(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Geometry geom_type = Geometry::NONE,
    ::flatbuffers::Offset<void> geom = 0) {
  RawGeometrySourceGeomBuilder builder_(_fbb);
  builder_.add_geom(geom);
  builder_.add_geom_type(geom_type);
  return builder_.Finish();
}

struct RawGeometrySourceGeom::Traits {
  using type = RawGeometrySourceGeom;
  static auto constexpr Create = CreateRawGeometrySourceGeom;
};

struct RawGeometrySource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RawGeometrySourceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<RawGeometrySourceGeom>> *geoms() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<RawGeometrySourceGeom>> *>(VT_GEOMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GEOMS) &&
           verifier.VerifyVector(geoms()) &&
           verifier.VerifyVectorOfTables(geoms()) &&
           verifier.EndTable();
  }
};

struct RawGeometrySourceBuilder {
  typedef RawGeometrySource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_geoms(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RawGeometrySourceGeom>>> geoms) {
    fbb_.AddOffset(RawGeometrySource::VT_GEOMS, geoms);
  }
  explicit RawGeometrySourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RawGeometrySource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RawGeometrySource>(end);
    fbb_.Required(o, RawGeometrySource::VT_GEOMS);
    return o;
  }
};

inline ::flatbuffers::Offset<RawGeometrySource> CreateRawGeometrySource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RawGeometrySourceGeom>>> geoms = 0) {
  RawGeometrySourceBuilder builder_(_fbb);
  builder_.add_geoms(geoms);
  return builder_.Finish();
}

struct RawGeometrySource::Traits {
  using type = RawGeometrySource;
  static auto constexpr Create = CreateRawGeometrySource;
};

inline ::flatbuffers::Offset<RawGeometrySource> CreateRawGeometrySourceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<RawGeometrySourceGeom>> *geoms = nullptr) {
  auto geoms__ = geoms ? _fbb.CreateVector<::flatbuffers::Offset<RawGeometrySourceGeom>>(*geoms) : 0;
  return CreateRawGeometrySource(
      _fbb,
      geoms__);
}

struct JoinStackEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JoinStackEntryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPRECATED_DATA_STATE_ID_DO_NOT_USE = 4,
    VT_MODE = 6,
    VT_BUFFER = 8,
    VT_GEOMETRY_SOURCE_TYPE = 10,
    VT_GEOMETRY_SOURCE = 12
  };
  const DataStateId *deprecated_data_state_id_do_not_use() const {
    return GetPointer<const DataStateId *>(VT_DEPRECATED_DATA_STATE_ID_DO_NOT_USE);
  }
  LayerCombineMode mode() const {
    return static_cast<LayerCombineMode>(GetField<uint32_t>(VT_MODE, 0));
  }
  float buffer() const {
    return GetField<float>(VT_BUFFER, 0.0f);
  }
  JoinStackEntryGeometrySourceUnion geometry_source_type() const {
    return static_cast<JoinStackEntryGeometrySourceUnion>(GetField<uint8_t>(VT_GEOMETRY_SOURCE_TYPE, 0));
  }
  const void *geometry_source() const {
    return GetPointer<const void *>(VT_GEOMETRY_SOURCE);
  }
  template<typename T> const T *geometry_source_as() const;
  const DataStateGeometrySource *geometry_source_as_DataStateGeometrySource() const {
    return geometry_source_type() == JoinStackEntryGeometrySourceUnion::DataStateGeometrySource ? static_cast<const DataStateGeometrySource *>(geometry_source()) : nullptr;
  }
  const RawGeometrySource *geometry_source_as_RawGeometrySource() const {
    return geometry_source_type() == JoinStackEntryGeometrySourceUnion::RawGeometrySource ? static_cast<const RawGeometrySource *>(geometry_source()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEPRECATED_DATA_STATE_ID_DO_NOT_USE) &&
           verifier.VerifyTable(deprecated_data_state_id_do_not_use()) &&
           VerifyField<uint32_t>(verifier, VT_MODE, 4) &&
           VerifyField<float>(verifier, VT_BUFFER, 4) &&
           VerifyField<uint8_t>(verifier, VT_GEOMETRY_SOURCE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_GEOMETRY_SOURCE) &&
           VerifyJoinStackEntryGeometrySourceUnion(verifier, geometry_source(), geometry_source_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DataStateGeometrySource *JoinStackEntry::geometry_source_as<DataStateGeometrySource>() const {
  return geometry_source_as_DataStateGeometrySource();
}

template<> inline const RawGeometrySource *JoinStackEntry::geometry_source_as<RawGeometrySource>() const {
  return geometry_source_as_RawGeometrySource();
}

struct JoinStackEntryBuilder {
  typedef JoinStackEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_deprecated_data_state_id_do_not_use(::flatbuffers::Offset<DataStateId> deprecated_data_state_id_do_not_use) {
    fbb_.AddOffset(JoinStackEntry::VT_DEPRECATED_DATA_STATE_ID_DO_NOT_USE, deprecated_data_state_id_do_not_use);
  }
  void add_mode(LayerCombineMode mode) {
    fbb_.AddElement<uint32_t>(JoinStackEntry::VT_MODE, static_cast<uint32_t>(mode), 0);
  }
  void add_buffer(float buffer) {
    fbb_.AddElement<float>(JoinStackEntry::VT_BUFFER, buffer, 0.0f);
  }
  void add_geometry_source_type(JoinStackEntryGeometrySourceUnion geometry_source_type) {
    fbb_.AddElement<uint8_t>(JoinStackEntry::VT_GEOMETRY_SOURCE_TYPE, static_cast<uint8_t>(geometry_source_type), 0);
  }
  void add_geometry_source(::flatbuffers::Offset<void> geometry_source) {
    fbb_.AddOffset(JoinStackEntry::VT_GEOMETRY_SOURCE, geometry_source);
  }
  explicit JoinStackEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JoinStackEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JoinStackEntry>(end);
    fbb_.Required(o, JoinStackEntry::VT_GEOMETRY_SOURCE);
    return o;
  }
};

inline ::flatbuffers::Offset<JoinStackEntry> CreateJoinStackEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<DataStateId> deprecated_data_state_id_do_not_use = 0,
    LayerCombineMode mode = LayerCombineMode::Union,
    float buffer = 0.0f,
    JoinStackEntryGeometrySourceUnion geometry_source_type = JoinStackEntryGeometrySourceUnion::NONE,
    ::flatbuffers::Offset<void> geometry_source = 0) {
  JoinStackEntryBuilder builder_(_fbb);
  builder_.add_geometry_source(geometry_source);
  builder_.add_buffer(buffer);
  builder_.add_mode(mode);
  builder_.add_deprecated_data_state_id_do_not_use(deprecated_data_state_id_do_not_use);
  builder_.add_geometry_source_type(geometry_source_type);
  return builder_.Finish();
}

struct JoinStackEntry::Traits {
  using type = JoinStackEntry;
  static auto constexpr Create = CreateJoinStackEntry;
};

struct StackableDataStateJoin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StackableDataStateJoinBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOIN_STACK = 4,
    VT_TARGET = 6,
    VT_OP = 8,
    VT_BUFFER = 10,
    VT_TYPE = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<JoinStackEntry>> *join_stack() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<JoinStackEntry>> *>(VT_JOIN_STACK);
  }
  const DataStateId *target() const {
    return GetPointer<const DataStateId *>(VT_TARGET);
  }
  JoinOperation op() const {
    return static_cast<JoinOperation>(GetField<uint32_t>(VT_OP, 0));
  }
  float buffer() const {
    return GetField<float>(VT_BUFFER, 0.0f);
  }
  JoinType type() const {
    return static_cast<JoinType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_JOIN_STACK) &&
           verifier.VerifyVector(join_stack()) &&
           verifier.VerifyVectorOfTables(join_stack()) &&
           VerifyOffsetRequired(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyField<uint32_t>(verifier, VT_OP, 4) &&
           VerifyField<float>(verifier, VT_BUFFER, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct StackableDataStateJoinBuilder {
  typedef StackableDataStateJoin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_join_stack(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<JoinStackEntry>>> join_stack) {
    fbb_.AddOffset(StackableDataStateJoin::VT_JOIN_STACK, join_stack);
  }
  void add_target(::flatbuffers::Offset<DataStateId> target) {
    fbb_.AddOffset(StackableDataStateJoin::VT_TARGET, target);
  }
  void add_op(JoinOperation op) {
    fbb_.AddElement<uint32_t>(StackableDataStateJoin::VT_OP, static_cast<uint32_t>(op), 0);
  }
  void add_buffer(float buffer) {
    fbb_.AddElement<float>(StackableDataStateJoin::VT_BUFFER, buffer, 0.0f);
  }
  void add_type(JoinType type) {
    fbb_.AddElement<int8_t>(StackableDataStateJoin::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit StackableDataStateJoinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StackableDataStateJoin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StackableDataStateJoin>(end);
    fbb_.Required(o, StackableDataStateJoin::VT_JOIN_STACK);
    fbb_.Required(o, StackableDataStateJoin::VT_TARGET);
    return o;
  }
};

inline ::flatbuffers::Offset<StackableDataStateJoin> CreateStackableDataStateJoin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<JoinStackEntry>>> join_stack = 0,
    ::flatbuffers::Offset<DataStateId> target = 0,
    JoinOperation op = JoinOperation::Intersect,
    float buffer = 0.0f,
    JoinType type = JoinType::Inner) {
  StackableDataStateJoinBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_op(op);
  builder_.add_target(target);
  builder_.add_join_stack(join_stack);
  builder_.add_type(type);
  return builder_.Finish();
}

struct StackableDataStateJoin::Traits {
  using type = StackableDataStateJoin;
  static auto constexpr Create = CreateStackableDataStateJoin;
};

inline ::flatbuffers::Offset<StackableDataStateJoin> CreateStackableDataStateJoinDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<JoinStackEntry>> *join_stack = nullptr,
    ::flatbuffers::Offset<DataStateId> target = 0,
    JoinOperation op = JoinOperation::Intersect,
    float buffer = 0.0f,
    JoinType type = JoinType::Inner) {
  auto join_stack__ = join_stack ? _fbb.CreateVector<::flatbuffers::Offset<JoinStackEntry>>(*join_stack) : 0;
  return CreateStackableDataStateJoin(
      _fbb,
      join_stack__,
      target,
      op,
      buffer,
      type);
}

struct UserLayer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserLayerBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA_STATES = 6,
    VT_DEPRECATED_DATA_JOINS_DO_NOT_USE = 8,
    VT_VISIBLE = 10,
    VT_JOINS = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<UserLayerDataState>> *data_states() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<UserLayerDataState>> *>(VT_DATA_STATES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedDataStateJoin>> *deprecated_data_joins_do_not_use() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedDataStateJoin>> *>(VT_DEPRECATED_DATA_JOINS_DO_NOT_USE);
  }
  bool visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 1) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<StackableDataStateJoin>> *joins() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StackableDataStateJoin>> *>(VT_JOINS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_DATA_STATES) &&
           verifier.VerifyVector(data_states()) &&
           verifier.VerifyVectorOfTables(data_states()) &&
           VerifyOffset(verifier, VT_DEPRECATED_DATA_JOINS_DO_NOT_USE) &&
           verifier.VerifyVector(deprecated_data_joins_do_not_use()) &&
           verifier.VerifyVectorOfTables(deprecated_data_joins_do_not_use()) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE, 1) &&
           VerifyOffsetRequired(verifier, VT_JOINS) &&
           verifier.VerifyVector(joins()) &&
           verifier.VerifyVectorOfTables(joins()) &&
           verifier.EndTable();
  }
};

struct UserLayerBuilder {
  typedef UserLayer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(UserLayer::VT_NAME, name);
  }
  void add_data_states(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UserLayerDataState>>> data_states) {
    fbb_.AddOffset(UserLayer::VT_DATA_STATES, data_states);
  }
  void add_deprecated_data_joins_do_not_use(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedDataStateJoin>>> deprecated_data_joins_do_not_use) {
    fbb_.AddOffset(UserLayer::VT_DEPRECATED_DATA_JOINS_DO_NOT_USE, deprecated_data_joins_do_not_use);
  }
  void add_visible(bool visible) {
    fbb_.AddElement<uint8_t>(UserLayer::VT_VISIBLE, static_cast<uint8_t>(visible), 1);
  }
  void add_joins(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StackableDataStateJoin>>> joins) {
    fbb_.AddOffset(UserLayer::VT_JOINS, joins);
  }
  explicit UserLayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserLayer>(end);
    fbb_.Required(o, UserLayer::VT_DATA_STATES);
    fbb_.Required(o, UserLayer::VT_JOINS);
    return o;
  }
};

inline ::flatbuffers::Offset<UserLayer> CreateUserLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UserLayerDataState>>> data_states = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeprecatedDataStateJoin>>> deprecated_data_joins_do_not_use = 0,
    bool visible = true,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StackableDataStateJoin>>> joins = 0) {
  UserLayerBuilder builder_(_fbb);
  builder_.add_joins(joins);
  builder_.add_deprecated_data_joins_do_not_use(deprecated_data_joins_do_not_use);
  builder_.add_data_states(data_states);
  builder_.add_name(name);
  builder_.add_visible(visible);
  return builder_.Finish();
}

struct UserLayer::Traits {
  using type = UserLayer;
  static auto constexpr Create = CreateUserLayer;
};

inline ::flatbuffers::Offset<UserLayer> CreateUserLayerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<UserLayerDataState>> *data_states = nullptr,
    const std::vector<::flatbuffers::Offset<DeprecatedDataStateJoin>> *deprecated_data_joins_do_not_use = nullptr,
    bool visible = true,
    const std::vector<::flatbuffers::Offset<StackableDataStateJoin>> *joins = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data_states__ = data_states ? _fbb.CreateVector<::flatbuffers::Offset<UserLayerDataState>>(*data_states) : 0;
  auto deprecated_data_joins_do_not_use__ = deprecated_data_joins_do_not_use ? _fbb.CreateVector<::flatbuffers::Offset<DeprecatedDataStateJoin>>(*deprecated_data_joins_do_not_use) : 0;
  auto joins__ = joins ? _fbb.CreateVector<::flatbuffers::Offset<StackableDataStateJoin>>(*joins) : 0;
  return CreateUserLayer(
      _fbb,
      name__,
      data_states__,
      deprecated_data_joins_do_not_use__,
      visible,
      joins__);
}

struct UserProject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserProjectBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_LAYERS = 8
  };
  const GenericId *id() const {
    return GetPointer<const GenericId *>(VT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<UserLayer>> *layers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<UserLayer>> *>(VT_LAYERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_LAYERS) &&
           verifier.VerifyVector(layers()) &&
           verifier.VerifyVectorOfTables(layers()) &&
           verifier.EndTable();
  }
};

struct UserProjectBuilder {
  typedef UserProject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<GenericId> id) {
    fbb_.AddOffset(UserProject::VT_ID, id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(UserProject::VT_NAME, name);
  }
  void add_layers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UserLayer>>> layers) {
    fbb_.AddOffset(UserProject::VT_LAYERS, layers);
  }
  explicit UserProjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserProject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserProject>(end);
    fbb_.Required(o, UserProject::VT_ID);
    fbb_.Required(o, UserProject::VT_LAYERS);
    return o;
  }
};

inline ::flatbuffers::Offset<UserProject> CreateUserProject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<GenericId> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UserLayer>>> layers = 0) {
  UserProjectBuilder builder_(_fbb);
  builder_.add_layers(layers);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

struct UserProject::Traits {
  using type = UserProject;
  static auto constexpr Create = CreateUserProject;
};

inline ::flatbuffers::Offset<UserProject> CreateUserProjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<GenericId> id = 0,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<UserLayer>> *layers = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto layers__ = layers ? _fbb.CreateVector<::flatbuffers::Offset<UserLayer>>(*layers) : 0;
  return CreateUserProject(
      _fbb,
      id,
      name__,
      layers__);
}

inline bool VerifyFilter(::flatbuffers::Verifier &verifier, const void *obj, Filter type) {
  switch (type) {
    case Filter::NONE: {
      return true;
    }
    case Filter::CategoryFilter: {
      auto ptr = reinterpret_cast<const CategoryFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Filter::RangeFilter: {
      auto ptr = reinterpret_cast<const RangeFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Filter::RelationshipRangeFilter: {
      auto ptr = reinterpret_cast<const RelationshipRangeFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFilterVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Filter> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFilter(
        verifier,  values->Get(i), types->GetEnum<Filter>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyJoinStackEntryGeometrySourceUnion(::flatbuffers::Verifier &verifier, const void *obj, JoinStackEntryGeometrySourceUnion type) {
  switch (type) {
    case JoinStackEntryGeometrySourceUnion::NONE: {
      return true;
    }
    case JoinStackEntryGeometrySourceUnion::DataStateGeometrySource: {
      auto ptr = reinterpret_cast<const DataStateGeometrySource *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case JoinStackEntryGeometrySourceUnion::RawGeometrySource: {
      auto ptr = reinterpret_cast<const RawGeometrySource *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyJoinStackEntryGeometrySourceUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<JoinStackEntryGeometrySourceUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyJoinStackEntryGeometrySourceUnion(
        verifier,  values->Get(i), types->GetEnum<JoinStackEntryGeometrySourceUnion>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_USERPROJECT_H_
