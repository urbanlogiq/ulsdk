// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INGEST_H_
#define FLATBUFFERS_GENERATED_INGEST_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "id_generated.h"
#include "query_generated.h"
#include "value_generated.h"

struct DefaultValue;
struct DefaultValueBuilder;

struct Ingestion;
struct IngestionBuilder;

enum class Transform : uint8_t {
  NONE = 0,
  Query = 1,
  MIN = NONE,
  MAX = Query
};

inline const Transform (&EnumValuesTransform())[2] {
  static const Transform values[] = {
    Transform::NONE,
    Transform::Query
  };
  return values;
}

inline const char * const *EnumNamesTransform() {
  static const char * const names[3] = {
    "NONE",
    "Query",
    nullptr
  };
  return names;
}

inline const char *EnumNameTransform(Transform e) {
  if (::flatbuffers::IsOutRange(e, Transform::NONE, Transform::Query)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTransform()[index];
}

template<typename T> struct TransformTraits {
  static const Transform enum_value = Transform::NONE;
};

template<> struct TransformTraits<Query> {
  static const Transform enum_value = Transform::Query;
};

bool VerifyTransform(::flatbuffers::Verifier &verifier, const void *obj, Transform type);
bool VerifyTransformVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Transform> *types);

struct DefaultValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DefaultValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *field() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIELD);
  }
  Value value_type() const {
    return static_cast<Value>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const VBool *value_as_VBool() const {
    return value_type() == Value::VBool ? static_cast<const VBool *>(value()) : nullptr;
  }
  const VUnit *value_as_VUnit() const {
    return value_type() == Value::VUnit ? static_cast<const VUnit *>(value()) : nullptr;
  }
  const VChar *value_as_VChar() const {
    return value_type() == Value::VChar ? static_cast<const VChar *>(value()) : nullptr;
  }
  const VNull *value_as_VNull() const {
    return value_type() == Value::VNull ? static_cast<const VNull *>(value()) : nullptr;
  }
  const VI8 *value_as_VI8() const {
    return value_type() == Value::VI8 ? static_cast<const VI8 *>(value()) : nullptr;
  }
  const VU8 *value_as_VU8() const {
    return value_type() == Value::VU8 ? static_cast<const VU8 *>(value()) : nullptr;
  }
  const VI16 *value_as_VI16() const {
    return value_type() == Value::VI16 ? static_cast<const VI16 *>(value()) : nullptr;
  }
  const VU16 *value_as_VU16() const {
    return value_type() == Value::VU16 ? static_cast<const VU16 *>(value()) : nullptr;
  }
  const VI32 *value_as_VI32() const {
    return value_type() == Value::VI32 ? static_cast<const VI32 *>(value()) : nullptr;
  }
  const VU32 *value_as_VU32() const {
    return value_type() == Value::VU32 ? static_cast<const VU32 *>(value()) : nullptr;
  }
  const VF32 *value_as_VF32() const {
    return value_type() == Value::VF32 ? static_cast<const VF32 *>(value()) : nullptr;
  }
  const VIsize *value_as_VIsize() const {
    return value_type() == Value::VIsize ? static_cast<const VIsize *>(value()) : nullptr;
  }
  const VUsize *value_as_VUsize() const {
    return value_type() == Value::VUsize ? static_cast<const VUsize *>(value()) : nullptr;
  }
  const VI64 *value_as_VI64() const {
    return value_type() == Value::VI64 ? static_cast<const VI64 *>(value()) : nullptr;
  }
  const VU64 *value_as_VU64() const {
    return value_type() == Value::VU64 ? static_cast<const VU64 *>(value()) : nullptr;
  }
  const VF64 *value_as_VF64() const {
    return value_type() == Value::VF64 ? static_cast<const VF64 *>(value()) : nullptr;
  }
  const VStr *value_as_VStr() const {
    return value_type() == Value::VStr ? static_cast<const VStr *>(value()) : nullptr;
  }
  const VBytes *value_as_VBytes() const {
    return value_type() == Value::VBytes ? static_cast<const VBytes *>(value()) : nullptr;
  }
  const VArray *value_as_VArray() const {
    return value_type() == Value::VArray ? static_cast<const VArray *>(value()) : nullptr;
  }
  const VTri2D *value_as_VTri2D() const {
    return value_type() == Value::VTri2D ? static_cast<const VTri2D *>(value()) : nullptr;
  }
  const VFixedSizeBytes *value_as_VFixedSizeBytes() const {
    return value_type() == Value::VFixedSizeBytes ? static_cast<const VFixedSizeBytes *>(value()) : nullptr;
  }
  const VTimestampMsUtc *value_as_VTimestampMsUtc() const {
    return value_type() == Value::VTimestampMsUtc ? static_cast<const VTimestampMsUtc *>(value()) : nullptr;
  }
  const VTimestampMs *value_as_VTimestampMs() const {
    return value_type() == Value::VTimestampMs ? static_cast<const VTimestampMs *>(value()) : nullptr;
  }
  const VTimestampNsUtc *value_as_VTimestampNsUtc() const {
    return value_type() == Value::VTimestampNsUtc ? static_cast<const VTimestampNsUtc *>(value()) : nullptr;
  }
  const VTimestampNs *value_as_VTimestampNs() const {
    return value_type() == Value::VTimestampNs ? static_cast<const VTimestampNs *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FIELD) &&
           verifier.VerifyString(field()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VBool *DefaultValue::value_as<VBool>() const {
  return value_as_VBool();
}

template<> inline const VUnit *DefaultValue::value_as<VUnit>() const {
  return value_as_VUnit();
}

template<> inline const VChar *DefaultValue::value_as<VChar>() const {
  return value_as_VChar();
}

template<> inline const VNull *DefaultValue::value_as<VNull>() const {
  return value_as_VNull();
}

template<> inline const VI8 *DefaultValue::value_as<VI8>() const {
  return value_as_VI8();
}

template<> inline const VU8 *DefaultValue::value_as<VU8>() const {
  return value_as_VU8();
}

template<> inline const VI16 *DefaultValue::value_as<VI16>() const {
  return value_as_VI16();
}

template<> inline const VU16 *DefaultValue::value_as<VU16>() const {
  return value_as_VU16();
}

template<> inline const VI32 *DefaultValue::value_as<VI32>() const {
  return value_as_VI32();
}

template<> inline const VU32 *DefaultValue::value_as<VU32>() const {
  return value_as_VU32();
}

template<> inline const VF32 *DefaultValue::value_as<VF32>() const {
  return value_as_VF32();
}

template<> inline const VIsize *DefaultValue::value_as<VIsize>() const {
  return value_as_VIsize();
}

template<> inline const VUsize *DefaultValue::value_as<VUsize>() const {
  return value_as_VUsize();
}

template<> inline const VI64 *DefaultValue::value_as<VI64>() const {
  return value_as_VI64();
}

template<> inline const VU64 *DefaultValue::value_as<VU64>() const {
  return value_as_VU64();
}

template<> inline const VF64 *DefaultValue::value_as<VF64>() const {
  return value_as_VF64();
}

template<> inline const VStr *DefaultValue::value_as<VStr>() const {
  return value_as_VStr();
}

template<> inline const VBytes *DefaultValue::value_as<VBytes>() const {
  return value_as_VBytes();
}

template<> inline const VArray *DefaultValue::value_as<VArray>() const {
  return value_as_VArray();
}

template<> inline const VTri2D *DefaultValue::value_as<VTri2D>() const {
  return value_as_VTri2D();
}

template<> inline const VFixedSizeBytes *DefaultValue::value_as<VFixedSizeBytes>() const {
  return value_as_VFixedSizeBytes();
}

template<> inline const VTimestampMsUtc *DefaultValue::value_as<VTimestampMsUtc>() const {
  return value_as_VTimestampMsUtc();
}

template<> inline const VTimestampMs *DefaultValue::value_as<VTimestampMs>() const {
  return value_as_VTimestampMs();
}

template<> inline const VTimestampNsUtc *DefaultValue::value_as<VTimestampNsUtc>() const {
  return value_as_VTimestampNsUtc();
}

template<> inline const VTimestampNs *DefaultValue::value_as<VTimestampNs>() const {
  return value_as_VTimestampNs();
}

struct DefaultValueBuilder {
  typedef DefaultValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field(::flatbuffers::Offset<::flatbuffers::String> field) {
    fbb_.AddOffset(DefaultValue::VT_FIELD, field);
  }
  void add_value_type(Value value_type) {
    fbb_.AddElement<uint8_t>(DefaultValue::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(DefaultValue::VT_VALUE, value);
  }
  explicit DefaultValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DefaultValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DefaultValue>(end);
    fbb_.Required(o, DefaultValue::VT_FIELD);
    fbb_.Required(o, DefaultValue::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<DefaultValue> CreateDefaultValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> field = 0,
    Value value_type = Value::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  DefaultValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_field(field);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct DefaultValue::Traits {
  using type = DefaultValue;
  static auto constexpr Create = CreateDefaultValue;
};

inline ::flatbuffers::Offset<DefaultValue> CreateDefaultValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *field = nullptr,
    Value value_type = Value::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto field__ = field ? _fbb.CreateString(field) : 0;
  return CreateDefaultValue(
      _fbb,
      field__,
      value_type,
      value);
}

struct Ingestion FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IngestionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_LOG = 6,
    VT_TRANSFORM_TYPE = 8,
    VT_TRANSFORM = 10,
    VT_DEFAULTS = 12
  };
  /// The target into which we ingest the data. This may be a stream or
  /// even another Ingestion object.
  const ObjectId *target() const {
    return GetPointer<const ObjectId *>(VT_TARGET);
  }
  /// Drive directory into which we store the ingestion log
  const ObjectId *log() const {
    return GetPointer<const ObjectId *>(VT_LOG);
  }
  Transform transform_type() const {
    return static_cast<Transform>(GetField<uint8_t>(VT_TRANSFORM_TYPE, 0));
  }
  /// The data transformation to apply to the inbound data.
  const void *transform() const {
    return GetPointer<const void *>(VT_TRANSFORM);
  }
  template<typename T> const T *transform_as() const;
  const Query *transform_as_Query() const {
    return transform_type() == Transform::Query ? static_cast<const Query *>(transform()) : nullptr;
  }
  /// If the incoming data may be missing, we can specify the default
  /// value here so that the transform can succeed.
  const ::flatbuffers::Vector<::flatbuffers::Offset<DefaultValue>> *defaults() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DefaultValue>> *>(VT_DEFAULTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           VerifyOffset(verifier, VT_LOG) &&
           verifier.VerifyTable(log()) &&
           VerifyField<uint8_t>(verifier, VT_TRANSFORM_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORM) &&
           VerifyTransform(verifier, transform(), transform_type()) &&
           VerifyOffset(verifier, VT_DEFAULTS) &&
           verifier.VerifyVector(defaults()) &&
           verifier.VerifyVectorOfTables(defaults()) &&
           verifier.EndTable();
  }
};

template<> inline const Query *Ingestion::transform_as<Query>() const {
  return transform_as_Query();
}

struct IngestionBuilder {
  typedef Ingestion Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<ObjectId> target) {
    fbb_.AddOffset(Ingestion::VT_TARGET, target);
  }
  void add_log(::flatbuffers::Offset<ObjectId> log) {
    fbb_.AddOffset(Ingestion::VT_LOG, log);
  }
  void add_transform_type(Transform transform_type) {
    fbb_.AddElement<uint8_t>(Ingestion::VT_TRANSFORM_TYPE, static_cast<uint8_t>(transform_type), 0);
  }
  void add_transform(::flatbuffers::Offset<void> transform) {
    fbb_.AddOffset(Ingestion::VT_TRANSFORM, transform);
  }
  void add_defaults(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DefaultValue>>> defaults) {
    fbb_.AddOffset(Ingestion::VT_DEFAULTS, defaults);
  }
  explicit IngestionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Ingestion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Ingestion>(end);
    fbb_.Required(o, Ingestion::VT_TARGET);
    fbb_.Required(o, Ingestion::VT_TRANSFORM);
    return o;
  }
};

inline ::flatbuffers::Offset<Ingestion> CreateIngestion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> target = 0,
    ::flatbuffers::Offset<ObjectId> log = 0,
    Transform transform_type = Transform::NONE,
    ::flatbuffers::Offset<void> transform = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DefaultValue>>> defaults = 0) {
  IngestionBuilder builder_(_fbb);
  builder_.add_defaults(defaults);
  builder_.add_transform(transform);
  builder_.add_log(log);
  builder_.add_target(target);
  builder_.add_transform_type(transform_type);
  return builder_.Finish();
}

struct Ingestion::Traits {
  using type = Ingestion;
  static auto constexpr Create = CreateIngestion;
};

inline ::flatbuffers::Offset<Ingestion> CreateIngestionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ObjectId> target = 0,
    ::flatbuffers::Offset<ObjectId> log = 0,
    Transform transform_type = Transform::NONE,
    ::flatbuffers::Offset<void> transform = 0,
    const std::vector<::flatbuffers::Offset<DefaultValue>> *defaults = nullptr) {
  auto defaults__ = defaults ? _fbb.CreateVector<::flatbuffers::Offset<DefaultValue>>(*defaults) : 0;
  return CreateIngestion(
      _fbb,
      target,
      log,
      transform_type,
      transform,
      defaults__);
}

inline bool VerifyTransform(::flatbuffers::Verifier &verifier, const void *obj, Transform type) {
  switch (type) {
    case Transform::NONE: {
      return true;
    }
    case Transform::Query: {
      auto ptr = reinterpret_cast<const Query *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTransformVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Transform> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyTransform(
        verifier,  values->Get(i), types->GetEnum<Transform>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_INGEST_H_
