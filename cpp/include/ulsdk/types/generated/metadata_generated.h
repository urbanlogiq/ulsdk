// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_METADATA_H_
#define FLATBUFFERS_GENERATED_METADATA_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"
#include "flatbuffers/flex_flat_util.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "Schema_generated.h"
#include "data_generated.h"
#include "entity_generated.h"
#include "graph_generated.h"
#include "id_generated.h"
#include "value_generated.h"

struct FloatBucket;

struct FloatAggregate;
struct FloatAggregateBuilder;

struct IntBucket;

struct IntAggregate;
struct IntAggregateBuilder;

struct UIntBucket;

struct UIntAggregate;
struct UIntAggregateBuilder;

struct StringAggregate;
struct StringAggregateBuilder;

struct StringCategories;
struct StringCategoriesBuilder;

struct NestedStringCategoryNode;
struct NestedStringCategoryNodeBuilder;

struct NestedStringCategories;
struct NestedStringCategoriesBuilder;

struct NumericalFieldFormat;
struct NumericalFieldFormatBuilder;

struct IntRange;
struct IntRangeBuilder;

struct IntegerDisplayString;
struct IntegerDisplayStringBuilder;

struct FloatRange;
struct FloatRangeBuilder;

struct TimeInterval;
struct TimeIntervalBuilder;

struct DatetimeRange;
struct DatetimeRangeBuilder;

struct Dates;
struct DatesBuilder;

struct ContactInfo;
struct ContactInfoBuilder;

struct Document;
struct DocumentBuilder;

struct Documents;
struct DocumentsBuilder;

struct RawGeom;
struct RawGeomBuilder;

struct GeometryData;
struct GeometryDataBuilder;

struct UlField;
struct UlFieldBuilder;

struct HierarchicalRelationship;
struct HierarchicalRelationshipBuilder;

struct HierarchyRelationshipData;
struct HierarchyRelationshipDataBuilder;

struct CategoryRelationshipData;
struct CategoryRelationshipDataBuilder;

struct NestedCategoryRelationshipNode;
struct NestedCategoryRelationshipNodeBuilder;

struct NestedCategoryRelationshipData;
struct NestedCategoryRelationshipDataBuilder;

struct NestedHierarchyRelationshipNode;
struct NestedHierarchyRelationshipNodeBuilder;

struct NestedHierarchyRelationshipData;
struct NestedHierarchyRelationshipDataBuilder;

struct UlFieldRelationship;
struct UlFieldRelationshipBuilder;

struct DatasetSource;
struct DatasetSourceBuilder;

struct NoGeometry;
struct NoGeometryBuilder;

struct DatacatalogGeometry;
struct DatacatalogGeometryBuilder;

struct WorldGraphGeometry;
struct WorldGraphGeometryBuilder;

struct Metadata;
struct MetadataBuilder;

enum class FieldFlags : uint32_t {
  Filterable = 1,
  Category = 2,
  Rangeable = 4,
  Editable = 8,
  Nullable = 16,
  Aggregated = 32,
  RequiredForFilter = 64,
  DoNotIncludeInAreaReport = 128,
  AggregateIntoIntegerBuckets = 256,
  Readonly = 512,
  NONE = 0,
  ANY = 1023
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(FieldFlags, uint32_t)

inline const FieldFlags (&EnumValuesFieldFlags())[10] {
  static const FieldFlags values[] = {
    FieldFlags::Filterable,
    FieldFlags::Category,
    FieldFlags::Rangeable,
    FieldFlags::Editable,
    FieldFlags::Nullable,
    FieldFlags::Aggregated,
    FieldFlags::RequiredForFilter,
    FieldFlags::DoNotIncludeInAreaReport,
    FieldFlags::AggregateIntoIntegerBuckets,
    FieldFlags::Readonly
  };
  return values;
}

inline const char *EnumNameFieldFlags(FieldFlags e) {
  switch (e) {
    case FieldFlags::Filterable: return "Filterable";
    case FieldFlags::Category: return "Category";
    case FieldFlags::Rangeable: return "Rangeable";
    case FieldFlags::Editable: return "Editable";
    case FieldFlags::Nullable: return "Nullable";
    case FieldFlags::Aggregated: return "Aggregated";
    case FieldFlags::RequiredForFilter: return "RequiredForFilter";
    case FieldFlags::DoNotIncludeInAreaReport: return "DoNotIncludeInAreaReport";
    case FieldFlags::AggregateIntoIntegerBuckets: return "AggregateIntoIntegerBuckets";
    case FieldFlags::Readonly: return "Readonly";
    default: return "";
  }
}

enum class FieldUnit : uint32_t {
  U_INVALID = 0,
  U_METRES = 1,
  U_DEGREES_CELSIUS = 2,
  U_KILOGRAMS = 3,
  U_SECONDS = 4,
  U_DOLLARS_CAD = 5,
  U_DOLLARS_USD = 6,
  U_DEGREES = 7,
  U_KPH = 8,
  U_MPH = 9,
  U_PERCENTAGE = 10,
  U_ACRES = 11,
  U_SQUARE_FEET = 12,
  U_MILES = 13,
  MIN = U_INVALID,
  MAX = U_MILES
};

inline const FieldUnit (&EnumValuesFieldUnit())[14] {
  static const FieldUnit values[] = {
    FieldUnit::U_INVALID,
    FieldUnit::U_METRES,
    FieldUnit::U_DEGREES_CELSIUS,
    FieldUnit::U_KILOGRAMS,
    FieldUnit::U_SECONDS,
    FieldUnit::U_DOLLARS_CAD,
    FieldUnit::U_DOLLARS_USD,
    FieldUnit::U_DEGREES,
    FieldUnit::U_KPH,
    FieldUnit::U_MPH,
    FieldUnit::U_PERCENTAGE,
    FieldUnit::U_ACRES,
    FieldUnit::U_SQUARE_FEET,
    FieldUnit::U_MILES
  };
  return values;
}

inline const char * const *EnumNamesFieldUnit() {
  static const char * const names[15] = {
    "U_INVALID",
    "U_METRES",
    "U_DEGREES_CELSIUS",
    "U_KILOGRAMS",
    "U_SECONDS",
    "U_DOLLARS_CAD",
    "U_DOLLARS_USD",
    "U_DEGREES",
    "U_KPH",
    "U_MPH",
    "U_PERCENTAGE",
    "U_ACRES",
    "U_SQUARE_FEET",
    "U_MILES",
    nullptr
  };
  return names;
}

inline const char *EnumNameFieldUnit(FieldUnit e) {
  if (::flatbuffers::IsOutRange(e, FieldUnit::U_INVALID, FieldUnit::U_MILES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFieldUnit()[index];
}

enum class NumericalFieldValueType : uint32_t {
  None = 0,
  Percent = 1,
  Ratio = 2,
  MIN = None,
  MAX = Ratio
};

inline const NumericalFieldValueType (&EnumValuesNumericalFieldValueType())[3] {
  static const NumericalFieldValueType values[] = {
    NumericalFieldValueType::None,
    NumericalFieldValueType::Percent,
    NumericalFieldValueType::Ratio
  };
  return values;
}

inline const char * const *EnumNamesNumericalFieldValueType() {
  static const char * const names[4] = {
    "None",
    "Percent",
    "Ratio",
    nullptr
  };
  return names;
}

inline const char *EnumNameNumericalFieldValueType(NumericalFieldValueType e) {
  if (::flatbuffers::IsOutRange(e, NumericalFieldValueType::None, NumericalFieldValueType::Ratio)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNumericalFieldValueType()[index];
}

enum class AggregationFunction : uint32_t {
  Any = 0,
  Sum = 1,
  Average = 2,
  Min = 3,
  Max = 4,
  Latest = 5,
  MIN = Any,
  MAX = Latest
};

inline const AggregationFunction (&EnumValuesAggregationFunction())[6] {
  static const AggregationFunction values[] = {
    AggregationFunction::Any,
    AggregationFunction::Sum,
    AggregationFunction::Average,
    AggregationFunction::Min,
    AggregationFunction::Max,
    AggregationFunction::Latest
  };
  return values;
}

inline const char * const *EnumNamesAggregationFunction() {
  static const char * const names[7] = {
    "Any",
    "Sum",
    "Average",
    "Min",
    "Max",
    "Latest",
    nullptr
  };
  return names;
}

inline const char *EnumNameAggregationFunction(AggregationFunction e) {
  if (::flatbuffers::IsOutRange(e, AggregationFunction::Any, AggregationFunction::Latest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAggregationFunction()[index];
}

enum class ComponentData : uint8_t {
  NONE = 0,
  StringCategories = 1,
  IntRange = 2,
  FloatRange = 3,
  DatetimeRange = 4,
  Dates = 5,
  NestedStringCategories = 6,
  MIN = NONE,
  MAX = NestedStringCategories
};

inline const ComponentData (&EnumValuesComponentData())[7] {
  static const ComponentData values[] = {
    ComponentData::NONE,
    ComponentData::StringCategories,
    ComponentData::IntRange,
    ComponentData::FloatRange,
    ComponentData::DatetimeRange,
    ComponentData::Dates,
    ComponentData::NestedStringCategories
  };
  return values;
}

inline const char * const *EnumNamesComponentData() {
  static const char * const names[8] = {
    "NONE",
    "StringCategories",
    "IntRange",
    "FloatRange",
    "DatetimeRange",
    "Dates",
    "NestedStringCategories",
    nullptr
  };
  return names;
}

inline const char *EnumNameComponentData(ComponentData e) {
  if (::flatbuffers::IsOutRange(e, ComponentData::NONE, ComponentData::NestedStringCategories)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComponentData()[index];
}

template<typename T> struct ComponentDataTraits {
  static const ComponentData enum_value = ComponentData::NONE;
};

template<> struct ComponentDataTraits<StringCategories> {
  static const ComponentData enum_value = ComponentData::StringCategories;
};

template<> struct ComponentDataTraits<IntRange> {
  static const ComponentData enum_value = ComponentData::IntRange;
};

template<> struct ComponentDataTraits<FloatRange> {
  static const ComponentData enum_value = ComponentData::FloatRange;
};

template<> struct ComponentDataTraits<DatetimeRange> {
  static const ComponentData enum_value = ComponentData::DatetimeRange;
};

template<> struct ComponentDataTraits<Dates> {
  static const ComponentData enum_value = ComponentData::Dates;
};

template<> struct ComponentDataTraits<NestedStringCategories> {
  static const ComponentData enum_value = ComponentData::NestedStringCategories;
};

bool VerifyComponentData(::flatbuffers::Verifier &verifier, const void *obj, ComponentData type);
bool VerifyComponentDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ComponentData> *types);

/// The update cadence of the dataset. This looks at the maximum timestamp/observation date in the data,
/// and not when the pipeline ran because we can run a pipeline today that only ingests data from 2020.
enum class UpdateCadence : uint32_t {
  UC_UNSET = 0,
  UC_IRREGULAR = 1,
  UC_DAILY = 2,
  UC_WEEKLY = 3,
  UC_BI_WEEKLY = 4,
  UC_MONTHLY = 5,
  MIN = UC_UNSET,
  MAX = UC_MONTHLY
};

inline const UpdateCadence (&EnumValuesUpdateCadence())[6] {
  static const UpdateCadence values[] = {
    UpdateCadence::UC_UNSET,
    UpdateCadence::UC_IRREGULAR,
    UpdateCadence::UC_DAILY,
    UpdateCadence::UC_WEEKLY,
    UpdateCadence::UC_BI_WEEKLY,
    UpdateCadence::UC_MONTHLY
  };
  return values;
}

inline const char * const *EnumNamesUpdateCadence() {
  static const char * const names[7] = {
    "UC_UNSET",
    "UC_IRREGULAR",
    "UC_DAILY",
    "UC_WEEKLY",
    "UC_BI_WEEKLY",
    "UC_MONTHLY",
    nullptr
  };
  return names;
}

inline const char *EnumNameUpdateCadence(UpdateCadence e) {
  if (::flatbuffers::IsOutRange(e, UpdateCadence::UC_UNSET, UpdateCadence::UC_MONTHLY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUpdateCadence()[index];
}

enum class UlFieldType : uint32_t {
  FT_UNKNOWN = 0,
  FT_INT = 1,
  FT_FLOAT = 2,
  FT_STRING = 3,
  FT_UUID = 4,
  FT_POINT = 5,
  FT_REGION = 6,
  FT_DATETIME = 7,
  FT_CURRENCY = 8,
  FT_BOOLEAN = 9,
  FT_DOCUMENT = 10,
  FT_GEOMETRY = 11,
  FT_JSON = 12,
  FT_DATE = 13,
  FT_EXTERNAL_URL = 14,
  FT_CONTACT_INFO = 15,
  FT_AGGREGATE_FLOAT = 16,
  FT_AGGREGATE_UINT = 17,
  FT_AGGREGATE_INT = 18,
  FT_AGGREGATE_STRING = 19,
  FT_AGGREGATE_FLOAT32 = 20,
  FT_AGGREGATE_DATETIME = 21,
  FT_BINARY = 22,
  FT_TIME = 23,
  FT_GEOMETRY_OR_NODE = 24,
  MIN = FT_UNKNOWN,
  MAX = FT_GEOMETRY_OR_NODE
};

inline const UlFieldType (&EnumValuesUlFieldType())[25] {
  static const UlFieldType values[] = {
    UlFieldType::FT_UNKNOWN,
    UlFieldType::FT_INT,
    UlFieldType::FT_FLOAT,
    UlFieldType::FT_STRING,
    UlFieldType::FT_UUID,
    UlFieldType::FT_POINT,
    UlFieldType::FT_REGION,
    UlFieldType::FT_DATETIME,
    UlFieldType::FT_CURRENCY,
    UlFieldType::FT_BOOLEAN,
    UlFieldType::FT_DOCUMENT,
    UlFieldType::FT_GEOMETRY,
    UlFieldType::FT_JSON,
    UlFieldType::FT_DATE,
    UlFieldType::FT_EXTERNAL_URL,
    UlFieldType::FT_CONTACT_INFO,
    UlFieldType::FT_AGGREGATE_FLOAT,
    UlFieldType::FT_AGGREGATE_UINT,
    UlFieldType::FT_AGGREGATE_INT,
    UlFieldType::FT_AGGREGATE_STRING,
    UlFieldType::FT_AGGREGATE_FLOAT32,
    UlFieldType::FT_AGGREGATE_DATETIME,
    UlFieldType::FT_BINARY,
    UlFieldType::FT_TIME,
    UlFieldType::FT_GEOMETRY_OR_NODE
  };
  return values;
}

inline const char * const *EnumNamesUlFieldType() {
  static const char * const names[26] = {
    "FT_UNKNOWN",
    "FT_INT",
    "FT_FLOAT",
    "FT_STRING",
    "FT_UUID",
    "FT_POINT",
    "FT_REGION",
    "FT_DATETIME",
    "FT_CURRENCY",
    "FT_BOOLEAN",
    "FT_DOCUMENT",
    "FT_GEOMETRY",
    "FT_JSON",
    "FT_DATE",
    "FT_EXTERNAL_URL",
    "FT_CONTACT_INFO",
    "FT_AGGREGATE_FLOAT",
    "FT_AGGREGATE_UINT",
    "FT_AGGREGATE_INT",
    "FT_AGGREGATE_STRING",
    "FT_AGGREGATE_FLOAT32",
    "FT_AGGREGATE_DATETIME",
    "FT_BINARY",
    "FT_TIME",
    "FT_GEOMETRY_OR_NODE",
    nullptr
  };
  return names;
}

inline const char *EnumNameUlFieldType(UlFieldType e) {
  if (::flatbuffers::IsOutRange(e, UlFieldType::FT_UNKNOWN, UlFieldType::FT_GEOMETRY_OR_NODE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUlFieldType()[index];
}

enum class GeometryDataUnion : uint8_t {
  NONE = 0,
  RawGeom = 1,
  NodeIdPair = 2,
  MIN = NONE,
  MAX = NodeIdPair
};

inline const GeometryDataUnion (&EnumValuesGeometryDataUnion())[3] {
  static const GeometryDataUnion values[] = {
    GeometryDataUnion::NONE,
    GeometryDataUnion::RawGeom,
    GeometryDataUnion::NodeIdPair
  };
  return values;
}

inline const char * const *EnumNamesGeometryDataUnion() {
  static const char * const names[4] = {
    "NONE",
    "RawGeom",
    "NodeIdPair",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometryDataUnion(GeometryDataUnion e) {
  if (::flatbuffers::IsOutRange(e, GeometryDataUnion::NONE, GeometryDataUnion::NodeIdPair)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometryDataUnion()[index];
}

template<typename T> struct GeometryDataUnionTraits {
  static const GeometryDataUnion enum_value = GeometryDataUnion::NONE;
};

template<> struct GeometryDataUnionTraits<RawGeom> {
  static const GeometryDataUnion enum_value = GeometryDataUnion::RawGeom;
};

template<> struct GeometryDataUnionTraits<NodeIdPair> {
  static const GeometryDataUnion enum_value = GeometryDataUnion::NodeIdPair;
};

bool VerifyGeometryDataUnion(::flatbuffers::Verifier &verifier, const void *obj, GeometryDataUnion type);
bool VerifyGeometryDataUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<GeometryDataUnion> *types);

enum class UlFieldRelationshipData : uint8_t {
  NONE = 0,
  HierarchyRelationshipData = 1,
  CategoryRelationshipData = 2,
  NestedCategoryRelationshipData = 3,
  NestedHierarchyRelationshipData = 4,
  MIN = NONE,
  MAX = NestedHierarchyRelationshipData
};

inline const UlFieldRelationshipData (&EnumValuesUlFieldRelationshipData())[5] {
  static const UlFieldRelationshipData values[] = {
    UlFieldRelationshipData::NONE,
    UlFieldRelationshipData::HierarchyRelationshipData,
    UlFieldRelationshipData::CategoryRelationshipData,
    UlFieldRelationshipData::NestedCategoryRelationshipData,
    UlFieldRelationshipData::NestedHierarchyRelationshipData
  };
  return values;
}

inline const char * const *EnumNamesUlFieldRelationshipData() {
  static const char * const names[6] = {
    "NONE",
    "HierarchyRelationshipData",
    "CategoryRelationshipData",
    "NestedCategoryRelationshipData",
    "NestedHierarchyRelationshipData",
    nullptr
  };
  return names;
}

inline const char *EnumNameUlFieldRelationshipData(UlFieldRelationshipData e) {
  if (::flatbuffers::IsOutRange(e, UlFieldRelationshipData::NONE, UlFieldRelationshipData::NestedHierarchyRelationshipData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUlFieldRelationshipData()[index];
}

template<typename T> struct UlFieldRelationshipDataTraits {
  static const UlFieldRelationshipData enum_value = UlFieldRelationshipData::NONE;
};

template<> struct UlFieldRelationshipDataTraits<HierarchyRelationshipData> {
  static const UlFieldRelationshipData enum_value = UlFieldRelationshipData::HierarchyRelationshipData;
};

template<> struct UlFieldRelationshipDataTraits<CategoryRelationshipData> {
  static const UlFieldRelationshipData enum_value = UlFieldRelationshipData::CategoryRelationshipData;
};

template<> struct UlFieldRelationshipDataTraits<NestedCategoryRelationshipData> {
  static const UlFieldRelationshipData enum_value = UlFieldRelationshipData::NestedCategoryRelationshipData;
};

template<> struct UlFieldRelationshipDataTraits<NestedHierarchyRelationshipData> {
  static const UlFieldRelationshipData enum_value = UlFieldRelationshipData::NestedHierarchyRelationshipData;
};

bool VerifyUlFieldRelationshipData(::flatbuffers::Verifier &verifier, const void *obj, UlFieldRelationshipData type);
bool VerifyUlFieldRelationshipDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<UlFieldRelationshipData> *types);

enum class DatasetCategory : uint32_t {
  DC_BUSINESSES = 0,
  DC_DEMOGRAPHICS = 1,
  DC_ECONOMICS = 2,
  DC_EVENTS = 3,
  DC_INFRASTRUCTURE = 4,
  DC_LAND_USE = 5,
  DC_MOBILITY = 6,
  DC_WEATHER = 7,
  DC_BOUNDARY = 8,
  DC_HEALTH = 9,
  DC_HIDDEN = 4294967295,
  MIN = DC_BUSINESSES,
  MAX = DC_HIDDEN
};

inline const DatasetCategory (&EnumValuesDatasetCategory())[11] {
  static const DatasetCategory values[] = {
    DatasetCategory::DC_BUSINESSES,
    DatasetCategory::DC_DEMOGRAPHICS,
    DatasetCategory::DC_ECONOMICS,
    DatasetCategory::DC_EVENTS,
    DatasetCategory::DC_INFRASTRUCTURE,
    DatasetCategory::DC_LAND_USE,
    DatasetCategory::DC_MOBILITY,
    DatasetCategory::DC_WEATHER,
    DatasetCategory::DC_BOUNDARY,
    DatasetCategory::DC_HEALTH,
    DatasetCategory::DC_HIDDEN
  };
  return values;
}

inline const char *EnumNameDatasetCategory(DatasetCategory e) {
  switch (e) {
    case DatasetCategory::DC_BUSINESSES: return "DC_BUSINESSES";
    case DatasetCategory::DC_DEMOGRAPHICS: return "DC_DEMOGRAPHICS";
    case DatasetCategory::DC_ECONOMICS: return "DC_ECONOMICS";
    case DatasetCategory::DC_EVENTS: return "DC_EVENTS";
    case DatasetCategory::DC_INFRASTRUCTURE: return "DC_INFRASTRUCTURE";
    case DatasetCategory::DC_LAND_USE: return "DC_LAND_USE";
    case DatasetCategory::DC_MOBILITY: return "DC_MOBILITY";
    case DatasetCategory::DC_WEATHER: return "DC_WEATHER";
    case DatasetCategory::DC_BOUNDARY: return "DC_BOUNDARY";
    case DatasetCategory::DC_HEALTH: return "DC_HEALTH";
    case DatasetCategory::DC_HIDDEN: return "DC_HIDDEN";
    default: return "";
  }
}

enum class GeometrySource : uint8_t {
  NONE = 0,
  NoGeometry = 1,
  DatacatalogGeometry = 2,
  WorldGraphGeometry = 3,
  MIN = NONE,
  MAX = WorldGraphGeometry
};

inline const GeometrySource (&EnumValuesGeometrySource())[4] {
  static const GeometrySource values[] = {
    GeometrySource::NONE,
    GeometrySource::NoGeometry,
    GeometrySource::DatacatalogGeometry,
    GeometrySource::WorldGraphGeometry
  };
  return values;
}

inline const char * const *EnumNamesGeometrySource() {
  static const char * const names[5] = {
    "NONE",
    "NoGeometry",
    "DatacatalogGeometry",
    "WorldGraphGeometry",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometrySource(GeometrySource e) {
  if (::flatbuffers::IsOutRange(e, GeometrySource::NONE, GeometrySource::WorldGraphGeometry)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometrySource()[index];
}

template<typename T> struct GeometrySourceTraits {
  static const GeometrySource enum_value = GeometrySource::NONE;
};

template<> struct GeometrySourceTraits<NoGeometry> {
  static const GeometrySource enum_value = GeometrySource::NoGeometry;
};

template<> struct GeometrySourceTraits<DatacatalogGeometry> {
  static const GeometrySource enum_value = GeometrySource::DatacatalogGeometry;
};

template<> struct GeometrySourceTraits<WorldGraphGeometry> {
  static const GeometrySource enum_value = GeometrySource::WorldGraphGeometry;
};

bool VerifyGeometrySource(::flatbuffers::Verifier &verifier, const void *obj, GeometrySource type);
bool VerifyGeometrySourceVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<GeometrySource> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) FloatBucket FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t count_;
  double max_;

 public:
  struct Traits;
  FloatBucket()
      : count_(0),
        max_(0) {
  }
  FloatBucket(uint64_t _count, double _max)
      : count_(::flatbuffers::EndianScalar(_count)),
        max_(::flatbuffers::EndianScalar(_max)) {
  }
  uint64_t count() const {
    return ::flatbuffers::EndianScalar(count_);
  }
  double max() const {
    return ::flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(FloatBucket, 16);

struct FloatBucket::Traits {
  using type = FloatBucket;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) IntBucket FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t count_;
  int64_t max_;

 public:
  struct Traits;
  IntBucket()
      : count_(0),
        max_(0) {
  }
  IntBucket(uint64_t _count, int64_t _max)
      : count_(::flatbuffers::EndianScalar(_count)),
        max_(::flatbuffers::EndianScalar(_max)) {
  }
  uint64_t count() const {
    return ::flatbuffers::EndianScalar(count_);
  }
  int64_t max() const {
    return ::flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(IntBucket, 16);

struct IntBucket::Traits {
  using type = IntBucket;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) UIntBucket FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t count_;
  uint64_t max_;

 public:
  struct Traits;
  UIntBucket()
      : count_(0),
        max_(0) {
  }
  UIntBucket(uint64_t _count, uint64_t _max)
      : count_(::flatbuffers::EndianScalar(_count)),
        max_(::flatbuffers::EndianScalar(_max)) {
  }
  uint64_t count() const {
    return ::flatbuffers::EndianScalar(count_);
  }
  uint64_t max() const {
    return ::flatbuffers::EndianScalar(max_);
  }
};
FLATBUFFERS_STRUCT_END(UIntBucket, 16);

struct UIntBucket::Traits {
  using type = UIntBucket;
};

struct FloatAggregate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatAggregateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_MEAN = 8,
    VT_COUNT = 10,
    VT_SUM = 12,
    VT_VARIANCE = 14,
    VT_HISTO = 16
  };
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  double mean() const {
    return GetField<double>(VT_MEAN, 0.0);
  }
  uint64_t count() const {
    return GetField<uint64_t>(VT_COUNT, 0);
  }
  double sum() const {
    return GetField<double>(VT_SUM, 0.0);
  }
  double variance() const {
    return GetField<double>(VT_VARIANCE, 0.0);
  }
  const ::flatbuffers::Vector<const FloatBucket *> *histo() const {
    return GetPointer<const ::flatbuffers::Vector<const FloatBucket *> *>(VT_HISTO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MIN, 8) &&
           VerifyField<double>(verifier, VT_MAX, 8) &&
           VerifyField<double>(verifier, VT_MEAN, 8) &&
           VerifyField<uint64_t>(verifier, VT_COUNT, 8) &&
           VerifyField<double>(verifier, VT_SUM, 8) &&
           VerifyField<double>(verifier, VT_VARIANCE, 8) &&
           VerifyOffset(verifier, VT_HISTO) &&
           verifier.VerifyVector(histo()) &&
           verifier.EndTable();
  }
};

struct FloatAggregateBuilder {
  typedef FloatAggregate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(double min) {
    fbb_.AddElement<double>(FloatAggregate::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(FloatAggregate::VT_MAX, max, 0.0);
  }
  void add_mean(double mean) {
    fbb_.AddElement<double>(FloatAggregate::VT_MEAN, mean, 0.0);
  }
  void add_count(uint64_t count) {
    fbb_.AddElement<uint64_t>(FloatAggregate::VT_COUNT, count, 0);
  }
  void add_sum(double sum) {
    fbb_.AddElement<double>(FloatAggregate::VT_SUM, sum, 0.0);
  }
  void add_variance(double variance) {
    fbb_.AddElement<double>(FloatAggregate::VT_VARIANCE, variance, 0.0);
  }
  void add_histo(::flatbuffers::Offset<::flatbuffers::Vector<const FloatBucket *>> histo) {
    fbb_.AddOffset(FloatAggregate::VT_HISTO, histo);
  }
  explicit FloatAggregateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatAggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatAggregate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatAggregate> CreateFloatAggregate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double min = 0.0,
    double max = 0.0,
    double mean = 0.0,
    uint64_t count = 0,
    double sum = 0.0,
    double variance = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const FloatBucket *>> histo = 0) {
  FloatAggregateBuilder builder_(_fbb);
  builder_.add_variance(variance);
  builder_.add_sum(sum);
  builder_.add_count(count);
  builder_.add_mean(mean);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_histo(histo);
  return builder_.Finish();
}

struct FloatAggregate::Traits {
  using type = FloatAggregate;
  static auto constexpr Create = CreateFloatAggregate;
};

inline ::flatbuffers::Offset<FloatAggregate> CreateFloatAggregateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double min = 0.0,
    double max = 0.0,
    double mean = 0.0,
    uint64_t count = 0,
    double sum = 0.0,
    double variance = 0.0,
    const std::vector<FloatBucket> *histo = nullptr) {
  auto histo__ = histo ? _fbb.CreateVectorOfStructs<FloatBucket>(*histo) : 0;
  return CreateFloatAggregate(
      _fbb,
      min,
      max,
      mean,
      count,
      sum,
      variance,
      histo__);
}

struct IntAggregate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntAggregateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_MEAN = 8,
    VT_COUNT = 10,
    VT_SUM = 12,
    VT_VARIANCE = 14,
    VT_HISTO = 16
  };
  int64_t min() const {
    return GetField<int64_t>(VT_MIN, 0);
  }
  int64_t max() const {
    return GetField<int64_t>(VT_MAX, 0);
  }
  int64_t mean() const {
    return GetField<int64_t>(VT_MEAN, 0);
  }
  uint64_t count() const {
    return GetField<uint64_t>(VT_COUNT, 0);
  }
  int64_t sum() const {
    return GetField<int64_t>(VT_SUM, 0);
  }
  int64_t variance() const {
    return GetField<int64_t>(VT_VARIANCE, 0);
  }
  const ::flatbuffers::Vector<const UIntBucket *> *histo() const {
    return GetPointer<const ::flatbuffers::Vector<const UIntBucket *> *>(VT_HISTO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_MIN, 8) &&
           VerifyField<int64_t>(verifier, VT_MAX, 8) &&
           VerifyField<int64_t>(verifier, VT_MEAN, 8) &&
           VerifyField<uint64_t>(verifier, VT_COUNT, 8) &&
           VerifyField<int64_t>(verifier, VT_SUM, 8) &&
           VerifyField<int64_t>(verifier, VT_VARIANCE, 8) &&
           VerifyOffset(verifier, VT_HISTO) &&
           verifier.VerifyVector(histo()) &&
           verifier.EndTable();
  }
};

struct IntAggregateBuilder {
  typedef IntAggregate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(int64_t min) {
    fbb_.AddElement<int64_t>(IntAggregate::VT_MIN, min, 0);
  }
  void add_max(int64_t max) {
    fbb_.AddElement<int64_t>(IntAggregate::VT_MAX, max, 0);
  }
  void add_mean(int64_t mean) {
    fbb_.AddElement<int64_t>(IntAggregate::VT_MEAN, mean, 0);
  }
  void add_count(uint64_t count) {
    fbb_.AddElement<uint64_t>(IntAggregate::VT_COUNT, count, 0);
  }
  void add_sum(int64_t sum) {
    fbb_.AddElement<int64_t>(IntAggregate::VT_SUM, sum, 0);
  }
  void add_variance(int64_t variance) {
    fbb_.AddElement<int64_t>(IntAggregate::VT_VARIANCE, variance, 0);
  }
  void add_histo(::flatbuffers::Offset<::flatbuffers::Vector<const UIntBucket *>> histo) {
    fbb_.AddOffset(IntAggregate::VT_HISTO, histo);
  }
  explicit IntAggregateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntAggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntAggregate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntAggregate> CreateIntAggregate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    int64_t mean = 0,
    uint64_t count = 0,
    int64_t sum = 0,
    int64_t variance = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const UIntBucket *>> histo = 0) {
  IntAggregateBuilder builder_(_fbb);
  builder_.add_variance(variance);
  builder_.add_sum(sum);
  builder_.add_count(count);
  builder_.add_mean(mean);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_histo(histo);
  return builder_.Finish();
}

struct IntAggregate::Traits {
  using type = IntAggregate;
  static auto constexpr Create = CreateIntAggregate;
};

inline ::flatbuffers::Offset<IntAggregate> CreateIntAggregateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    int64_t mean = 0,
    uint64_t count = 0,
    int64_t sum = 0,
    int64_t variance = 0,
    const std::vector<UIntBucket> *histo = nullptr) {
  auto histo__ = histo ? _fbb.CreateVectorOfStructs<UIntBucket>(*histo) : 0;
  return CreateIntAggregate(
      _fbb,
      min,
      max,
      mean,
      count,
      sum,
      variance,
      histo__);
}

struct UIntAggregate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UIntAggregateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_MEAN = 8,
    VT_COUNT = 10,
    VT_SUM = 12,
    VT_VARIANCE = 14,
    VT_HISTO = 16
  };
  uint64_t min() const {
    return GetField<uint64_t>(VT_MIN, 0);
  }
  uint64_t max() const {
    return GetField<uint64_t>(VT_MAX, 0);
  }
  uint64_t mean() const {
    return GetField<uint64_t>(VT_MEAN, 0);
  }
  uint64_t count() const {
    return GetField<uint64_t>(VT_COUNT, 0);
  }
  uint64_t sum() const {
    return GetField<uint64_t>(VT_SUM, 0);
  }
  uint64_t variance() const {
    return GetField<uint64_t>(VT_VARIANCE, 0);
  }
  const ::flatbuffers::Vector<const UIntBucket *> *histo() const {
    return GetPointer<const ::flatbuffers::Vector<const UIntBucket *> *>(VT_HISTO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MIN, 8) &&
           VerifyField<uint64_t>(verifier, VT_MAX, 8) &&
           VerifyField<uint64_t>(verifier, VT_MEAN, 8) &&
           VerifyField<uint64_t>(verifier, VT_COUNT, 8) &&
           VerifyField<uint64_t>(verifier, VT_SUM, 8) &&
           VerifyField<uint64_t>(verifier, VT_VARIANCE, 8) &&
           VerifyOffset(verifier, VT_HISTO) &&
           verifier.VerifyVector(histo()) &&
           verifier.EndTable();
  }
};

struct UIntAggregateBuilder {
  typedef UIntAggregate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(uint64_t min) {
    fbb_.AddElement<uint64_t>(UIntAggregate::VT_MIN, min, 0);
  }
  void add_max(uint64_t max) {
    fbb_.AddElement<uint64_t>(UIntAggregate::VT_MAX, max, 0);
  }
  void add_mean(uint64_t mean) {
    fbb_.AddElement<uint64_t>(UIntAggregate::VT_MEAN, mean, 0);
  }
  void add_count(uint64_t count) {
    fbb_.AddElement<uint64_t>(UIntAggregate::VT_COUNT, count, 0);
  }
  void add_sum(uint64_t sum) {
    fbb_.AddElement<uint64_t>(UIntAggregate::VT_SUM, sum, 0);
  }
  void add_variance(uint64_t variance) {
    fbb_.AddElement<uint64_t>(UIntAggregate::VT_VARIANCE, variance, 0);
  }
  void add_histo(::flatbuffers::Offset<::flatbuffers::Vector<const UIntBucket *>> histo) {
    fbb_.AddOffset(UIntAggregate::VT_HISTO, histo);
  }
  explicit UIntAggregateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UIntAggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UIntAggregate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UIntAggregate> CreateUIntAggregate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t min = 0,
    uint64_t max = 0,
    uint64_t mean = 0,
    uint64_t count = 0,
    uint64_t sum = 0,
    uint64_t variance = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const UIntBucket *>> histo = 0) {
  UIntAggregateBuilder builder_(_fbb);
  builder_.add_variance(variance);
  builder_.add_sum(sum);
  builder_.add_count(count);
  builder_.add_mean(mean);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_histo(histo);
  return builder_.Finish();
}

struct UIntAggregate::Traits {
  using type = UIntAggregate;
  static auto constexpr Create = CreateUIntAggregate;
};

inline ::flatbuffers::Offset<UIntAggregate> CreateUIntAggregateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t min = 0,
    uint64_t max = 0,
    uint64_t mean = 0,
    uint64_t count = 0,
    uint64_t sum = 0,
    uint64_t variance = 0,
    const std::vector<UIntBucket> *histo = nullptr) {
  auto histo__ = histo ? _fbb.CreateVectorOfStructs<UIntBucket>(*histo) : 0;
  return CreateUIntAggregate(
      _fbb,
      min,
      max,
      mean,
      count,
      sum,
      variance,
      histo__);
}

struct StringAggregate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringAggregateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STR = 4,
    VT_COUNT = 6
  };
  const ::flatbuffers::String *str() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STR);
  }
  uint64_t count() const {
    return GetField<uint64_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.VerifyString(str()) &&
           VerifyField<uint64_t>(verifier, VT_COUNT, 8) &&
           verifier.EndTable();
  }
};

struct StringAggregateBuilder {
  typedef StringAggregate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_str(::flatbuffers::Offset<::flatbuffers::String> str) {
    fbb_.AddOffset(StringAggregate::VT_STR, str);
  }
  void add_count(uint64_t count) {
    fbb_.AddElement<uint64_t>(StringAggregate::VT_COUNT, count, 0);
  }
  explicit StringAggregateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringAggregate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringAggregate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringAggregate> CreateStringAggregate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> str = 0,
    uint64_t count = 0) {
  StringAggregateBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_str(str);
  return builder_.Finish();
}

struct StringAggregate::Traits {
  using type = StringAggregate;
  static auto constexpr Create = CreateStringAggregate;
};

inline ::flatbuffers::Offset<StringAggregate> CreateStringAggregateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *str = nullptr,
    uint64_t count = 0) {
  auto str__ = str ? _fbb.CreateString(str) : 0;
  return CreateStringAggregate(
      _fbb,
      str__,
      count);
}

struct StringCategories FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringCategoriesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CATEGORIES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *categories() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CATEGORIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CATEGORIES) &&
           verifier.VerifyVector(categories()) &&
           verifier.VerifyVectorOfStrings(categories()) &&
           verifier.EndTable();
  }
};

struct StringCategoriesBuilder {
  typedef StringCategories Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_categories(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> categories) {
    fbb_.AddOffset(StringCategories::VT_CATEGORIES, categories);
  }
  explicit StringCategoriesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringCategories> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringCategories>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringCategories> CreateStringCategories(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> categories = 0) {
  StringCategoriesBuilder builder_(_fbb);
  builder_.add_categories(categories);
  return builder_.Finish();
}

struct StringCategories::Traits {
  using type = StringCategories;
  static auto constexpr Create = CreateStringCategories;
};

inline ::flatbuffers::Offset<StringCategories> CreateStringCategoriesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *categories = nullptr) {
  auto categories__ = categories ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*categories) : 0;
  return CreateStringCategories(
      _fbb,
      categories__);
}

struct NestedStringCategoryNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NestedStringCategoryNodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_CHILD_VALUES = 6
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *child_values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CHILD_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyOffsetRequired(verifier, VT_CHILD_VALUES) &&
           verifier.VerifyVector(child_values()) &&
           verifier.VerifyVectorOfStrings(child_values()) &&
           verifier.EndTable();
  }
};

struct NestedStringCategoryNodeBuilder {
  typedef NestedStringCategoryNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(NestedStringCategoryNode::VT_VALUE, value);
  }
  void add_child_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> child_values) {
    fbb_.AddOffset(NestedStringCategoryNode::VT_CHILD_VALUES, child_values);
  }
  explicit NestedStringCategoryNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NestedStringCategoryNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NestedStringCategoryNode>(end);
    fbb_.Required(o, NestedStringCategoryNode::VT_CHILD_VALUES);
    return o;
  }
};

inline ::flatbuffers::Offset<NestedStringCategoryNode> CreateNestedStringCategoryNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> child_values = 0) {
  NestedStringCategoryNodeBuilder builder_(_fbb);
  builder_.add_child_values(child_values);
  builder_.add_value(value);
  return builder_.Finish();
}

struct NestedStringCategoryNode::Traits {
  using type = NestedStringCategoryNode;
  static auto constexpr Create = CreateNestedStringCategoryNode;
};

inline ::flatbuffers::Offset<NestedStringCategoryNode> CreateNestedStringCategoryNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *child_values = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  auto child_values__ = child_values ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*child_values) : 0;
  return CreateNestedStringCategoryNode(
      _fbb,
      value__,
      child_values__);
}

struct NestedStringCategories FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NestedStringCategoriesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NESTING_TREE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NestedStringCategoryNode>> *nesting_tree() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NestedStringCategoryNode>> *>(VT_NESTING_TREE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NESTING_TREE) &&
           verifier.VerifyVector(nesting_tree()) &&
           verifier.VerifyVectorOfTables(nesting_tree()) &&
           verifier.EndTable();
  }
};

struct NestedStringCategoriesBuilder {
  typedef NestedStringCategories Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nesting_tree(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NestedStringCategoryNode>>> nesting_tree) {
    fbb_.AddOffset(NestedStringCategories::VT_NESTING_TREE, nesting_tree);
  }
  explicit NestedStringCategoriesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NestedStringCategories> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NestedStringCategories>(end);
    fbb_.Required(o, NestedStringCategories::VT_NESTING_TREE);
    return o;
  }
};

inline ::flatbuffers::Offset<NestedStringCategories> CreateNestedStringCategories(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NestedStringCategoryNode>>> nesting_tree = 0) {
  NestedStringCategoriesBuilder builder_(_fbb);
  builder_.add_nesting_tree(nesting_tree);
  return builder_.Finish();
}

struct NestedStringCategories::Traits {
  using type = NestedStringCategories;
  static auto constexpr Create = CreateNestedStringCategories;
};

inline ::flatbuffers::Offset<NestedStringCategories> CreateNestedStringCategoriesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NestedStringCategoryNode>> *nesting_tree = nullptr) {
  auto nesting_tree__ = nesting_tree ? _fbb.CreateVector<::flatbuffers::Offset<NestedStringCategoryNode>>(*nesting_tree) : 0;
  return CreateNestedStringCategories(
      _fbb,
      nesting_tree__);
}

struct NumericalFieldFormat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NumericalFieldFormatBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_DECIMAL_PLACES = 6,
    VT_SCALE = 8,
    VT_OFFSET = 10
  };
  NumericalFieldValueType value_type() const {
    return static_cast<NumericalFieldValueType>(GetField<uint32_t>(VT_VALUE_TYPE, 0));
  }
  uint32_t decimal_places() const {
    return GetField<uint32_t>(VT_DECIMAL_PLACES, 0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  double offset() const {
    return GetField<double>(VT_OFFSET, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE_TYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_DECIMAL_PLACES, 4) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<double>(verifier, VT_OFFSET, 8) &&
           verifier.EndTable();
  }
};

struct NumericalFieldFormatBuilder {
  typedef NumericalFieldFormat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(NumericalFieldValueType value_type) {
    fbb_.AddElement<uint32_t>(NumericalFieldFormat::VT_VALUE_TYPE, static_cast<uint32_t>(value_type), 0);
  }
  void add_decimal_places(uint32_t decimal_places) {
    fbb_.AddElement<uint32_t>(NumericalFieldFormat::VT_DECIMAL_PLACES, decimal_places, 0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(NumericalFieldFormat::VT_SCALE, scale, 0.0);
  }
  void add_offset(double offset) {
    fbb_.AddElement<double>(NumericalFieldFormat::VT_OFFSET, offset, 0.0);
  }
  explicit NumericalFieldFormatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NumericalFieldFormat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NumericalFieldFormat>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NumericalFieldFormat> CreateNumericalFieldFormat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    NumericalFieldValueType value_type = NumericalFieldValueType::None,
    uint32_t decimal_places = 0,
    double scale = 0.0,
    double offset = 0.0) {
  NumericalFieldFormatBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_scale(scale);
  builder_.add_decimal_places(decimal_places);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct NumericalFieldFormat::Traits {
  using type = NumericalFieldFormat;
  static auto constexpr Create = CreateNumericalFieldFormat;
};

struct IntRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntRangeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_FIELD_FORMAT = 8,
    VT_AGGREGATION_PROTOCOL = 10,
    VT_DISPLAY_STRINGS = 12,
    VT_ENUM_NAME = 14
  };
  int64_t min() const {
    return GetField<int64_t>(VT_MIN, 0);
  }
  int64_t max() const {
    return GetField<int64_t>(VT_MAX, 0);
  }
  const NumericalFieldFormat *field_format() const {
    return GetPointer<const NumericalFieldFormat *>(VT_FIELD_FORMAT);
  }
  AggregationFunction aggregation_protocol() const {
    return static_cast<AggregationFunction>(GetField<uint32_t>(VT_AGGREGATION_PROTOCOL, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<IntegerDisplayString>> *display_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<IntegerDisplayString>> *>(VT_DISPLAY_STRINGS);
  }
  const ::flatbuffers::String *enum_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENUM_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_MIN, 8) &&
           VerifyField<int64_t>(verifier, VT_MAX, 8) &&
           VerifyOffset(verifier, VT_FIELD_FORMAT) &&
           verifier.VerifyTable(field_format()) &&
           VerifyField<uint32_t>(verifier, VT_AGGREGATION_PROTOCOL, 4) &&
           VerifyOffset(verifier, VT_DISPLAY_STRINGS) &&
           verifier.VerifyVector(display_strings()) &&
           verifier.VerifyVectorOfTables(display_strings()) &&
           VerifyOffset(verifier, VT_ENUM_NAME) &&
           verifier.VerifyString(enum_name()) &&
           verifier.EndTable();
  }
};

struct IntRangeBuilder {
  typedef IntRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(int64_t min) {
    fbb_.AddElement<int64_t>(IntRange::VT_MIN, min, 0);
  }
  void add_max(int64_t max) {
    fbb_.AddElement<int64_t>(IntRange::VT_MAX, max, 0);
  }
  void add_field_format(::flatbuffers::Offset<NumericalFieldFormat> field_format) {
    fbb_.AddOffset(IntRange::VT_FIELD_FORMAT, field_format);
  }
  void add_aggregation_protocol(AggregationFunction aggregation_protocol) {
    fbb_.AddElement<uint32_t>(IntRange::VT_AGGREGATION_PROTOCOL, static_cast<uint32_t>(aggregation_protocol), 0);
  }
  void add_display_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IntegerDisplayString>>> display_strings) {
    fbb_.AddOffset(IntRange::VT_DISPLAY_STRINGS, display_strings);
  }
  void add_enum_name(::flatbuffers::Offset<::flatbuffers::String> enum_name) {
    fbb_.AddOffset(IntRange::VT_ENUM_NAME, enum_name);
  }
  explicit IntRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntRange> CreateIntRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    ::flatbuffers::Offset<NumericalFieldFormat> field_format = 0,
    AggregationFunction aggregation_protocol = AggregationFunction::Any,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IntegerDisplayString>>> display_strings = 0,
    ::flatbuffers::Offset<::flatbuffers::String> enum_name = 0) {
  IntRangeBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_enum_name(enum_name);
  builder_.add_display_strings(display_strings);
  builder_.add_aggregation_protocol(aggregation_protocol);
  builder_.add_field_format(field_format);
  return builder_.Finish();
}

struct IntRange::Traits {
  using type = IntRange;
  static auto constexpr Create = CreateIntRange;
};

inline ::flatbuffers::Offset<IntRange> CreateIntRangeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    ::flatbuffers::Offset<NumericalFieldFormat> field_format = 0,
    AggregationFunction aggregation_protocol = AggregationFunction::Any,
    const std::vector<::flatbuffers::Offset<IntegerDisplayString>> *display_strings = nullptr,
    const char *enum_name = nullptr) {
  auto display_strings__ = display_strings ? _fbb.CreateVector<::flatbuffers::Offset<IntegerDisplayString>>(*display_strings) : 0;
  auto enum_name__ = enum_name ? _fbb.CreateString(enum_name) : 0;
  return CreateIntRange(
      _fbb,
      min,
      max,
      field_format,
      aggregation_protocol,
      display_strings__,
      enum_name__);
}

struct IntegerDisplayString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerDisplayStringBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_DISPLAY_NAME = 6
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  const ::flatbuffers::String *display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           VerifyOffsetRequired(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           verifier.EndTable();
  }
};

struct IntegerDisplayStringBuilder {
  typedef IntegerDisplayString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(IntegerDisplayString::VT_VALUE, value, 0);
  }
  void add_display_name(::flatbuffers::Offset<::flatbuffers::String> display_name) {
    fbb_.AddOffset(IntegerDisplayString::VT_DISPLAY_NAME, display_name);
  }
  explicit IntegerDisplayStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegerDisplayString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegerDisplayString>(end);
    fbb_.Required(o, IntegerDisplayString::VT_DISPLAY_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegerDisplayString> CreateIntegerDisplayString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> display_name = 0) {
  IntegerDisplayStringBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_display_name(display_name);
  return builder_.Finish();
}

struct IntegerDisplayString::Traits {
  using type = IntegerDisplayString;
  static auto constexpr Create = CreateIntegerDisplayString;
};

inline ::flatbuffers::Offset<IntegerDisplayString> CreateIntegerDisplayStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0,
    const char *display_name = nullptr) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return CreateIntegerDisplayString(
      _fbb,
      value,
      display_name__);
}

struct FloatRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatRangeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_FIELD_FORMAT = 8,
    VT_AGGREGATION_PROTOCOL = 10
  };
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  const NumericalFieldFormat *field_format() const {
    return GetPointer<const NumericalFieldFormat *>(VT_FIELD_FORMAT);
  }
  AggregationFunction aggregation_protocol() const {
    return static_cast<AggregationFunction>(GetField<uint32_t>(VT_AGGREGATION_PROTOCOL, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MIN, 8) &&
           VerifyField<double>(verifier, VT_MAX, 8) &&
           VerifyOffset(verifier, VT_FIELD_FORMAT) &&
           verifier.VerifyTable(field_format()) &&
           VerifyField<uint32_t>(verifier, VT_AGGREGATION_PROTOCOL, 4) &&
           verifier.EndTable();
  }
};

struct FloatRangeBuilder {
  typedef FloatRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(double min) {
    fbb_.AddElement<double>(FloatRange::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(FloatRange::VT_MAX, max, 0.0);
  }
  void add_field_format(::flatbuffers::Offset<NumericalFieldFormat> field_format) {
    fbb_.AddOffset(FloatRange::VT_FIELD_FORMAT, field_format);
  }
  void add_aggregation_protocol(AggregationFunction aggregation_protocol) {
    fbb_.AddElement<uint32_t>(FloatRange::VT_AGGREGATION_PROTOCOL, static_cast<uint32_t>(aggregation_protocol), 0);
  }
  explicit FloatRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatRange> CreateFloatRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double min = 0.0,
    double max = 0.0,
    ::flatbuffers::Offset<NumericalFieldFormat> field_format = 0,
    AggregationFunction aggregation_protocol = AggregationFunction::Any) {
  FloatRangeBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_aggregation_protocol(aggregation_protocol);
  builder_.add_field_format(field_format);
  return builder_.Finish();
}

struct FloatRange::Traits {
  using type = FloatRange;
  static auto constexpr Create = CreateFloatRange;
};

struct TimeInterval FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TimeIntervalBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6
  };
  int64_t min() const {
    return GetField<int64_t>(VT_MIN, 0);
  }
  int64_t max() const {
    return GetField<int64_t>(VT_MAX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_MIN, 8) &&
           VerifyField<int64_t>(verifier, VT_MAX, 8) &&
           verifier.EndTable();
  }
};

struct TimeIntervalBuilder {
  typedef TimeInterval Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(int64_t min) {
    fbb_.AddElement<int64_t>(TimeInterval::VT_MIN, min, 0);
  }
  void add_max(int64_t max) {
    fbb_.AddElement<int64_t>(TimeInterval::VT_MAX, max, 0);
  }
  explicit TimeIntervalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TimeInterval> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TimeInterval>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TimeInterval> CreateTimeInterval(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0) {
  TimeIntervalBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

struct TimeInterval::Traits {
  using type = TimeInterval;
  static auto constexpr Create = CreateTimeInterval;
};

struct DatetimeRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DatetimeRangeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_INTERVALS = 8
  };
  int64_t min() const {
    return GetField<int64_t>(VT_MIN, 0);
  }
  int64_t max() const {
    return GetField<int64_t>(VT_MAX, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<TimeInterval>> *intervals() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<TimeInterval>> *>(VT_INTERVALS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_MIN, 8) &&
           VerifyField<int64_t>(verifier, VT_MAX, 8) &&
           VerifyOffset(verifier, VT_INTERVALS) &&
           verifier.VerifyVector(intervals()) &&
           verifier.VerifyVectorOfTables(intervals()) &&
           verifier.EndTable();
  }
};

struct DatetimeRangeBuilder {
  typedef DatetimeRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(int64_t min) {
    fbb_.AddElement<int64_t>(DatetimeRange::VT_MIN, min, 0);
  }
  void add_max(int64_t max) {
    fbb_.AddElement<int64_t>(DatetimeRange::VT_MAX, max, 0);
  }
  void add_intervals(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TimeInterval>>> intervals) {
    fbb_.AddOffset(DatetimeRange::VT_INTERVALS, intervals);
  }
  explicit DatetimeRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DatetimeRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DatetimeRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DatetimeRange> CreateDatetimeRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<TimeInterval>>> intervals = 0) {
  DatetimeRangeBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_intervals(intervals);
  return builder_.Finish();
}

struct DatetimeRange::Traits {
  using type = DatetimeRange;
  static auto constexpr Create = CreateDatetimeRange;
};

inline ::flatbuffers::Offset<DatetimeRange> CreateDatetimeRangeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    const std::vector<::flatbuffers::Offset<TimeInterval>> *intervals = nullptr) {
  auto intervals__ = intervals ? _fbb.CreateVector<::flatbuffers::Offset<TimeInterval>>(*intervals) : 0;
  return CreateDatetimeRange(
      _fbb,
      min,
      max,
      intervals__);
}

struct Dates FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DatesBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_UNIQUE_VALUES = 8,
    VT_UNIQUE_VALUE_COUNTS = 10
  };
  int64_t min() const {
    return GetField<int64_t>(VT_MIN, 0);
  }
  int64_t max() const {
    return GetField<int64_t>(VT_MAX, 0);
  }
  const ::flatbuffers::Vector<int64_t> *unique_values() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_UNIQUE_VALUES);
  }
  const ::flatbuffers::Vector<uint32_t> *unique_value_counts() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_UNIQUE_VALUE_COUNTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_MIN, 8) &&
           VerifyField<int64_t>(verifier, VT_MAX, 8) &&
           VerifyOffset(verifier, VT_UNIQUE_VALUES) &&
           verifier.VerifyVector(unique_values()) &&
           VerifyOffset(verifier, VT_UNIQUE_VALUE_COUNTS) &&
           verifier.VerifyVector(unique_value_counts()) &&
           verifier.EndTable();
  }
};

struct DatesBuilder {
  typedef Dates Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_min(int64_t min) {
    fbb_.AddElement<int64_t>(Dates::VT_MIN, min, 0);
  }
  void add_max(int64_t max) {
    fbb_.AddElement<int64_t>(Dates::VT_MAX, max, 0);
  }
  void add_unique_values(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> unique_values) {
    fbb_.AddOffset(Dates::VT_UNIQUE_VALUES, unique_values);
  }
  void add_unique_value_counts(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> unique_value_counts) {
    fbb_.AddOffset(Dates::VT_UNIQUE_VALUE_COUNTS, unique_value_counts);
  }
  explicit DatesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Dates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Dates>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Dates> CreateDates(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> unique_values = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> unique_value_counts = 0) {
  DatesBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_unique_value_counts(unique_value_counts);
  builder_.add_unique_values(unique_values);
  return builder_.Finish();
}

struct Dates::Traits {
  using type = Dates;
  static auto constexpr Create = CreateDates;
};

inline ::flatbuffers::Offset<Dates> CreateDatesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t min = 0,
    int64_t max = 0,
    const std::vector<int64_t> *unique_values = nullptr,
    const std::vector<uint32_t> *unique_value_counts = nullptr) {
  auto unique_values__ = unique_values ? _fbb.CreateVector<int64_t>(*unique_values) : 0;
  auto unique_value_counts__ = unique_value_counts ? _fbb.CreateVector<uint32_t>(*unique_value_counts) : 0;
  return CreateDates(
      _fbb,
      min,
      max,
      unique_values__,
      unique_value_counts__);
}

struct ContactInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContactInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EMAIL = 4,
    VT_URL = 6,
    VT_NAME = 8,
    VT_PHONE = 10,
    VT_ADDRESS = 12
  };
  const ::flatbuffers::String *email() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EMAIL);
  }
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *phone() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PHONE);
  }
  const ::flatbuffers::String *address() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDRESS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EMAIL) &&
           verifier.VerifyString(email()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PHONE) &&
           verifier.VerifyString(phone()) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           verifier.EndTable();
  }
};

struct ContactInfoBuilder {
  typedef ContactInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_email(::flatbuffers::Offset<::flatbuffers::String> email) {
    fbb_.AddOffset(ContactInfo::VT_EMAIL, email);
  }
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(ContactInfo::VT_URL, url);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ContactInfo::VT_NAME, name);
  }
  void add_phone(::flatbuffers::Offset<::flatbuffers::String> phone) {
    fbb_.AddOffset(ContactInfo::VT_PHONE, phone);
  }
  void add_address(::flatbuffers::Offset<::flatbuffers::String> address) {
    fbb_.AddOffset(ContactInfo::VT_ADDRESS, address);
  }
  explicit ContactInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContactInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContactInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContactInfo> CreateContactInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> email = 0,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> phone = 0,
    ::flatbuffers::Offset<::flatbuffers::String> address = 0) {
  ContactInfoBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_phone(phone);
  builder_.add_name(name);
  builder_.add_url(url);
  builder_.add_email(email);
  return builder_.Finish();
}

struct ContactInfo::Traits {
  using type = ContactInfo;
  static auto constexpr Create = CreateContactInfo;
};

inline ::flatbuffers::Offset<ContactInfo> CreateContactInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *email = nullptr,
    const char *url = nullptr,
    const char *name = nullptr,
    const char *phone = nullptr,
    const char *address = nullptr) {
  auto email__ = email ? _fbb.CreateString(email) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto phone__ = phone ? _fbb.CreateString(phone) : 0;
  auto address__ = address ? _fbb.CreateString(address) : 0;
  return CreateContactInfo(
      _fbb,
      email__,
      url__,
      name__,
      phone__,
      address__);
}

struct Document FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DocumentBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4,
    VT_URL = 6,
    VT_MIME_TYPE = 8,
    VT_DISPLAY_NAME = 10
  };
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  const ::flatbuffers::String *mime_type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIME_TYPE);
  }
  const ::flatbuffers::String *display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyOffset(verifier, VT_MIME_TYPE) &&
           verifier.VerifyString(mime_type()) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           verifier.EndTable();
  }
};

struct DocumentBuilder {
  typedef Document Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(Document::VT_FILENAME, filename);
  }
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(Document::VT_URL, url);
  }
  void add_mime_type(::flatbuffers::Offset<::flatbuffers::String> mime_type) {
    fbb_.AddOffset(Document::VT_MIME_TYPE, mime_type);
  }
  void add_display_name(::flatbuffers::Offset<::flatbuffers::String> display_name) {
    fbb_.AddOffset(Document::VT_DISPLAY_NAME, display_name);
  }
  explicit DocumentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Document> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Document>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Document> CreateDocument(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mime_type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> display_name = 0) {
  DocumentBuilder builder_(_fbb);
  builder_.add_display_name(display_name);
  builder_.add_mime_type(mime_type);
  builder_.add_url(url);
  builder_.add_filename(filename);
  return builder_.Finish();
}

struct Document::Traits {
  using type = Document;
  static auto constexpr Create = CreateDocument;
};

inline ::flatbuffers::Offset<Document> CreateDocumentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr,
    const char *url = nullptr,
    const char *mime_type = nullptr,
    const char *display_name = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  auto mime_type__ = mime_type ? _fbb.CreateString(mime_type) : 0;
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  return CreateDocument(
      _fbb,
      filename__,
      url__,
      mime_type__,
      display_name__);
}

struct Documents FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DocumentsBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOCUMENTS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Document>> *documents() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Document>> *>(VT_DOCUMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOCUMENTS) &&
           verifier.VerifyVector(documents()) &&
           verifier.VerifyVectorOfTables(documents()) &&
           verifier.EndTable();
  }
};

struct DocumentsBuilder {
  typedef Documents Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_documents(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Document>>> documents) {
    fbb_.AddOffset(Documents::VT_DOCUMENTS, documents);
  }
  explicit DocumentsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Documents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Documents>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Documents> CreateDocuments(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Document>>> documents = 0) {
  DocumentsBuilder builder_(_fbb);
  builder_.add_documents(documents);
  return builder_.Finish();
}

struct Documents::Traits {
  using type = Documents;
  static auto constexpr Create = CreateDocuments;
};

inline ::flatbuffers::Offset<Documents> CreateDocumentsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Document>> *documents = nullptr) {
  auto documents__ = documents ? _fbb.CreateVector<::flatbuffers::Offset<Document>>(*documents) : 0;
  return CreateDocuments(
      _fbb,
      documents__);
}

struct RawGeom FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RawGeomBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOM = 4
  };
  const ::flatbuffers::Vector<uint8_t> *geom() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_GEOM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GEOM) &&
           verifier.VerifyVector(geom()) &&
           verifier.EndTable();
  }
};

struct RawGeomBuilder {
  typedef RawGeom Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_geom(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> geom) {
    fbb_.AddOffset(RawGeom::VT_GEOM, geom);
  }
  explicit RawGeomBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RawGeom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RawGeom>(end);
    fbb_.Required(o, RawGeom::VT_GEOM);
    return o;
  }
};

inline ::flatbuffers::Offset<RawGeom> CreateRawGeom(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> geom = 0) {
  RawGeomBuilder builder_(_fbb);
  builder_.add_geom(geom);
  return builder_.Finish();
}

struct RawGeom::Traits {
  using type = RawGeom;
  static auto constexpr Create = CreateRawGeom;
};

inline ::flatbuffers::Offset<RawGeom> CreateRawGeomDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *geom = nullptr) {
  auto geom__ = geom ? _fbb.CreateVector<uint8_t>(*geom) : 0;
  return CreateRawGeom(
      _fbb,
      geom__);
}

struct GeometryData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GeometryDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  GeometryDataUnion data_type() const {
    return static_cast<GeometryDataUnion>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const RawGeom *data_as_RawGeom() const {
    return data_type() == GeometryDataUnion::RawGeom ? static_cast<const RawGeom *>(data()) : nullptr;
  }
  const NodeIdPair *data_as_NodeIdPair() const {
    return data_type() == GeometryDataUnion::NodeIdPair ? static_cast<const NodeIdPair *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           VerifyGeometryDataUnion(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const RawGeom *GeometryData::data_as<RawGeom>() const {
  return data_as_RawGeom();
}

template<> inline const NodeIdPair *GeometryData::data_as<NodeIdPair>() const {
  return data_as_NodeIdPair();
}

struct GeometryDataBuilder {
  typedef GeometryData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_type(GeometryDataUnion data_type) {
    fbb_.AddElement<uint8_t>(GeometryData::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(GeometryData::VT_DATA, data);
  }
  explicit GeometryDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GeometryData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GeometryData>(end);
    fbb_.Required(o, GeometryData::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<GeometryData> CreateGeometryData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GeometryDataUnion data_type = GeometryDataUnion::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  GeometryDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct GeometryData::Traits {
  using type = GeometryData;
  static auto constexpr Create = CreateGeometryData;
};

struct UlField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UlFieldBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD_NAME = 4,
    VT_DISPLAY_NAME = 6,
    VT_COMPONENT_DATA_TYPE = 8,
    VT_COMPONENT_DATA = 10,
    VT_FLAGS = 12,
    VT_UNIT = 14,
    VT_FIELD_TYPE = 16,
    VT_DESCRIPTION = 18,
    VT_BREAKDOWN_DISPLAY_NAME = 20,
    VT_DEFAULT_ = 22,
    VT_STORAGE_TYPE_TYPE = 24,
    VT_STORAGE_TYPE = 26
  };
  const ::flatbuffers::String *field_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIELD_NAME);
  }
  const ::flatbuffers::String *display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  ComponentData component_data_type() const {
    return static_cast<ComponentData>(GetField<uint8_t>(VT_COMPONENT_DATA_TYPE, 0));
  }
  const void *component_data() const {
    return GetPointer<const void *>(VT_COMPONENT_DATA);
  }
  template<typename T> const T *component_data_as() const;
  const StringCategories *component_data_as_StringCategories() const {
    return component_data_type() == ComponentData::StringCategories ? static_cast<const StringCategories *>(component_data()) : nullptr;
  }
  const IntRange *component_data_as_IntRange() const {
    return component_data_type() == ComponentData::IntRange ? static_cast<const IntRange *>(component_data()) : nullptr;
  }
  const FloatRange *component_data_as_FloatRange() const {
    return component_data_type() == ComponentData::FloatRange ? static_cast<const FloatRange *>(component_data()) : nullptr;
  }
  const DatetimeRange *component_data_as_DatetimeRange() const {
    return component_data_type() == ComponentData::DatetimeRange ? static_cast<const DatetimeRange *>(component_data()) : nullptr;
  }
  const Dates *component_data_as_Dates() const {
    return component_data_type() == ComponentData::Dates ? static_cast<const Dates *>(component_data()) : nullptr;
  }
  const NestedStringCategories *component_data_as_NestedStringCategories() const {
    return component_data_type() == ComponentData::NestedStringCategories ? static_cast<const NestedStringCategories *>(component_data()) : nullptr;
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  FieldUnit unit() const {
    return static_cast<FieldUnit>(GetField<uint32_t>(VT_UNIT, 0));
  }
  UlFieldType field_type() const {
    return static_cast<UlFieldType>(GetField<uint32_t>(VT_FIELD_TYPE, 0));
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *breakdown_display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BREAKDOWN_DISPLAY_NAME);
  }
  const ValueInstance *default_() const {
    return GetPointer<const ValueInstance *>(VT_DEFAULT_);
  }
  Type storage_type_type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_STORAGE_TYPE_TYPE, 0));
  }
  const void *storage_type() const {
    return GetPointer<const void *>(VT_STORAGE_TYPE);
  }
  template<typename T> const T *storage_type_as() const;
  const Null *storage_type_as_Null() const {
    return storage_type_type() == Type::Null ? static_cast<const Null *>(storage_type()) : nullptr;
  }
  const Int *storage_type_as_Int() const {
    return storage_type_type() == Type::Int ? static_cast<const Int *>(storage_type()) : nullptr;
  }
  const FloatingPoint *storage_type_as_FloatingPoint() const {
    return storage_type_type() == Type::FloatingPoint ? static_cast<const FloatingPoint *>(storage_type()) : nullptr;
  }
  const Binary *storage_type_as_Binary() const {
    return storage_type_type() == Type::Binary ? static_cast<const Binary *>(storage_type()) : nullptr;
  }
  const Utf8 *storage_type_as_Utf8() const {
    return storage_type_type() == Type::Utf8 ? static_cast<const Utf8 *>(storage_type()) : nullptr;
  }
  const Bool *storage_type_as_Bool() const {
    return storage_type_type() == Type::Bool ? static_cast<const Bool *>(storage_type()) : nullptr;
  }
  const Decimal *storage_type_as_Decimal() const {
    return storage_type_type() == Type::Decimal ? static_cast<const Decimal *>(storage_type()) : nullptr;
  }
  const Date *storage_type_as_Date() const {
    return storage_type_type() == Type::Date ? static_cast<const Date *>(storage_type()) : nullptr;
  }
  const Time *storage_type_as_Time() const {
    return storage_type_type() == Type::Time ? static_cast<const Time *>(storage_type()) : nullptr;
  }
  const Timestamp *storage_type_as_Timestamp() const {
    return storage_type_type() == Type::Timestamp ? static_cast<const Timestamp *>(storage_type()) : nullptr;
  }
  const Interval *storage_type_as_Interval() const {
    return storage_type_type() == Type::Interval ? static_cast<const Interval *>(storage_type()) : nullptr;
  }
  const List *storage_type_as_List() const {
    return storage_type_type() == Type::List ? static_cast<const List *>(storage_type()) : nullptr;
  }
  const Struct_ *storage_type_as_Struct_() const {
    return storage_type_type() == Type::Struct_ ? static_cast<const Struct_ *>(storage_type()) : nullptr;
  }
  const Union *storage_type_as_Union() const {
    return storage_type_type() == Type::Union ? static_cast<const Union *>(storage_type()) : nullptr;
  }
  const FixedSizeBinary *storage_type_as_FixedSizeBinary() const {
    return storage_type_type() == Type::FixedSizeBinary ? static_cast<const FixedSizeBinary *>(storage_type()) : nullptr;
  }
  const FixedSizeList *storage_type_as_FixedSizeList() const {
    return storage_type_type() == Type::FixedSizeList ? static_cast<const FixedSizeList *>(storage_type()) : nullptr;
  }
  const Map *storage_type_as_Map() const {
    return storage_type_type() == Type::Map ? static_cast<const Map *>(storage_type()) : nullptr;
  }
  const Duration *storage_type_as_Duration() const {
    return storage_type_type() == Type::Duration ? static_cast<const Duration *>(storage_type()) : nullptr;
  }
  const LargeBinary *storage_type_as_LargeBinary() const {
    return storage_type_type() == Type::LargeBinary ? static_cast<const LargeBinary *>(storage_type()) : nullptr;
  }
  const LargeUtf8 *storage_type_as_LargeUtf8() const {
    return storage_type_type() == Type::LargeUtf8 ? static_cast<const LargeUtf8 *>(storage_type()) : nullptr;
  }
  const LargeList *storage_type_as_LargeList() const {
    return storage_type_type() == Type::LargeList ? static_cast<const LargeList *>(storage_type()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD_NAME) &&
           verifier.VerifyString(field_name()) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyField<uint8_t>(verifier, VT_COMPONENT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPONENT_DATA) &&
           VerifyComponentData(verifier, component_data(), component_data_type()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNIT, 4) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_TYPE, 4) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_BREAKDOWN_DISPLAY_NAME) &&
           verifier.VerifyString(breakdown_display_name()) &&
           VerifyOffset(verifier, VT_DEFAULT_) &&
           verifier.VerifyTable(default_()) &&
           VerifyField<uint8_t>(verifier, VT_STORAGE_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_STORAGE_TYPE) &&
           VerifyType(verifier, storage_type(), storage_type_type()) &&
           verifier.EndTable();
  }
};

template<> inline const StringCategories *UlField::component_data_as<StringCategories>() const {
  return component_data_as_StringCategories();
}

template<> inline const IntRange *UlField::component_data_as<IntRange>() const {
  return component_data_as_IntRange();
}

template<> inline const FloatRange *UlField::component_data_as<FloatRange>() const {
  return component_data_as_FloatRange();
}

template<> inline const DatetimeRange *UlField::component_data_as<DatetimeRange>() const {
  return component_data_as_DatetimeRange();
}

template<> inline const Dates *UlField::component_data_as<Dates>() const {
  return component_data_as_Dates();
}

template<> inline const NestedStringCategories *UlField::component_data_as<NestedStringCategories>() const {
  return component_data_as_NestedStringCategories();
}

template<> inline const Null *UlField::storage_type_as<Null>() const {
  return storage_type_as_Null();
}

template<> inline const Int *UlField::storage_type_as<Int>() const {
  return storage_type_as_Int();
}

template<> inline const FloatingPoint *UlField::storage_type_as<FloatingPoint>() const {
  return storage_type_as_FloatingPoint();
}

template<> inline const Binary *UlField::storage_type_as<Binary>() const {
  return storage_type_as_Binary();
}

template<> inline const Utf8 *UlField::storage_type_as<Utf8>() const {
  return storage_type_as_Utf8();
}

template<> inline const Bool *UlField::storage_type_as<Bool>() const {
  return storage_type_as_Bool();
}

template<> inline const Decimal *UlField::storage_type_as<Decimal>() const {
  return storage_type_as_Decimal();
}

template<> inline const Date *UlField::storage_type_as<Date>() const {
  return storage_type_as_Date();
}

template<> inline const Time *UlField::storage_type_as<Time>() const {
  return storage_type_as_Time();
}

template<> inline const Timestamp *UlField::storage_type_as<Timestamp>() const {
  return storage_type_as_Timestamp();
}

template<> inline const Interval *UlField::storage_type_as<Interval>() const {
  return storage_type_as_Interval();
}

template<> inline const List *UlField::storage_type_as<List>() const {
  return storage_type_as_List();
}

template<> inline const Struct_ *UlField::storage_type_as<Struct_>() const {
  return storage_type_as_Struct_();
}

template<> inline const Union *UlField::storage_type_as<Union>() const {
  return storage_type_as_Union();
}

template<> inline const FixedSizeBinary *UlField::storage_type_as<FixedSizeBinary>() const {
  return storage_type_as_FixedSizeBinary();
}

template<> inline const FixedSizeList *UlField::storage_type_as<FixedSizeList>() const {
  return storage_type_as_FixedSizeList();
}

template<> inline const Map *UlField::storage_type_as<Map>() const {
  return storage_type_as_Map();
}

template<> inline const Duration *UlField::storage_type_as<Duration>() const {
  return storage_type_as_Duration();
}

template<> inline const LargeBinary *UlField::storage_type_as<LargeBinary>() const {
  return storage_type_as_LargeBinary();
}

template<> inline const LargeUtf8 *UlField::storage_type_as<LargeUtf8>() const {
  return storage_type_as_LargeUtf8();
}

template<> inline const LargeList *UlField::storage_type_as<LargeList>() const {
  return storage_type_as_LargeList();
}

struct UlFieldBuilder {
  typedef UlField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field_name(::flatbuffers::Offset<::flatbuffers::String> field_name) {
    fbb_.AddOffset(UlField::VT_FIELD_NAME, field_name);
  }
  void add_display_name(::flatbuffers::Offset<::flatbuffers::String> display_name) {
    fbb_.AddOffset(UlField::VT_DISPLAY_NAME, display_name);
  }
  void add_component_data_type(ComponentData component_data_type) {
    fbb_.AddElement<uint8_t>(UlField::VT_COMPONENT_DATA_TYPE, static_cast<uint8_t>(component_data_type), 0);
  }
  void add_component_data(::flatbuffers::Offset<void> component_data) {
    fbb_.AddOffset(UlField::VT_COMPONENT_DATA, component_data);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(UlField::VT_FLAGS, flags, 0);
  }
  void add_unit(FieldUnit unit) {
    fbb_.AddElement<uint32_t>(UlField::VT_UNIT, static_cast<uint32_t>(unit), 0);
  }
  void add_field_type(UlFieldType field_type) {
    fbb_.AddElement<uint32_t>(UlField::VT_FIELD_TYPE, static_cast<uint32_t>(field_type), 0);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(UlField::VT_DESCRIPTION, description);
  }
  void add_breakdown_display_name(::flatbuffers::Offset<::flatbuffers::String> breakdown_display_name) {
    fbb_.AddOffset(UlField::VT_BREAKDOWN_DISPLAY_NAME, breakdown_display_name);
  }
  void add_default_(::flatbuffers::Offset<ValueInstance> default_) {
    fbb_.AddOffset(UlField::VT_DEFAULT_, default_);
  }
  void add_storage_type_type(Type storage_type_type) {
    fbb_.AddElement<uint8_t>(UlField::VT_STORAGE_TYPE_TYPE, static_cast<uint8_t>(storage_type_type), 0);
  }
  void add_storage_type(::flatbuffers::Offset<void> storage_type) {
    fbb_.AddOffset(UlField::VT_STORAGE_TYPE, storage_type);
  }
  explicit UlFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UlField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UlField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UlField> CreateUlField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> field_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> display_name = 0,
    ComponentData component_data_type = ComponentData::NONE,
    ::flatbuffers::Offset<void> component_data = 0,
    uint32_t flags = 0,
    FieldUnit unit = FieldUnit::U_INVALID,
    UlFieldType field_type = UlFieldType::FT_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> breakdown_display_name = 0,
    ::flatbuffers::Offset<ValueInstance> default_ = 0,
    Type storage_type_type = Type::NONE,
    ::flatbuffers::Offset<void> storage_type = 0) {
  UlFieldBuilder builder_(_fbb);
  builder_.add_storage_type(storage_type);
  builder_.add_default_(default_);
  builder_.add_breakdown_display_name(breakdown_display_name);
  builder_.add_description(description);
  builder_.add_field_type(field_type);
  builder_.add_unit(unit);
  builder_.add_flags(flags);
  builder_.add_component_data(component_data);
  builder_.add_display_name(display_name);
  builder_.add_field_name(field_name);
  builder_.add_storage_type_type(storage_type_type);
  builder_.add_component_data_type(component_data_type);
  return builder_.Finish();
}

struct UlField::Traits {
  using type = UlField;
  static auto constexpr Create = CreateUlField;
};

inline ::flatbuffers::Offset<UlField> CreateUlFieldDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *field_name = nullptr,
    const char *display_name = nullptr,
    ComponentData component_data_type = ComponentData::NONE,
    ::flatbuffers::Offset<void> component_data = 0,
    uint32_t flags = 0,
    FieldUnit unit = FieldUnit::U_INVALID,
    UlFieldType field_type = UlFieldType::FT_UNKNOWN,
    const char *description = nullptr,
    const char *breakdown_display_name = nullptr,
    ::flatbuffers::Offset<ValueInstance> default_ = 0,
    Type storage_type_type = Type::NONE,
    ::flatbuffers::Offset<void> storage_type = 0) {
  auto field_name__ = field_name ? _fbb.CreateString(field_name) : 0;
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto breakdown_display_name__ = breakdown_display_name ? _fbb.CreateString(breakdown_display_name) : 0;
  return CreateUlField(
      _fbb,
      field_name__,
      display_name__,
      component_data_type,
      component_data,
      flags,
      unit,
      field_type,
      description__,
      breakdown_display_name__,
      default_,
      storage_type_type,
      storage_type);
}

struct HierarchicalRelationship FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HierarchicalRelationshipBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARENT = 4,
    VT_CHILDREN = 6
  };
  int32_t parent() const {
    return GetField<int32_t>(VT_PARENT, 0);
  }
  const ::flatbuffers::Vector<int32_t> *children() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PARENT, 4) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.EndTable();
  }
};

struct HierarchicalRelationshipBuilder {
  typedef HierarchicalRelationship Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_parent(int32_t parent) {
    fbb_.AddElement<int32_t>(HierarchicalRelationship::VT_PARENT, parent, 0);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> children) {
    fbb_.AddOffset(HierarchicalRelationship::VT_CHILDREN, children);
  }
  explicit HierarchicalRelationshipBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HierarchicalRelationship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HierarchicalRelationship>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HierarchicalRelationship> CreateHierarchicalRelationship(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t parent = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> children = 0) {
  HierarchicalRelationshipBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_parent(parent);
  return builder_.Finish();
}

struct HierarchicalRelationship::Traits {
  using type = HierarchicalRelationship;
  static auto constexpr Create = CreateHierarchicalRelationship;
};

inline ::flatbuffers::Offset<HierarchicalRelationship> CreateHierarchicalRelationshipDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t parent = 0,
    const std::vector<int32_t> *children = nullptr) {
  auto children__ = children ? _fbb.CreateVector<int32_t>(*children) : 0;
  return CreateHierarchicalRelationship(
      _fbb,
      parent,
      children__);
}

struct HierarchyRelationshipData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HierarchyRelationshipDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HIERARCHY = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<HierarchicalRelationship>> *hierarchy() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HierarchicalRelationship>> *>(VT_HIERARCHY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HIERARCHY) &&
           verifier.VerifyVector(hierarchy()) &&
           verifier.VerifyVectorOfTables(hierarchy()) &&
           verifier.EndTable();
  }
};

struct HierarchyRelationshipDataBuilder {
  typedef HierarchyRelationshipData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hierarchy(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HierarchicalRelationship>>> hierarchy) {
    fbb_.AddOffset(HierarchyRelationshipData::VT_HIERARCHY, hierarchy);
  }
  explicit HierarchyRelationshipDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HierarchyRelationshipData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HierarchyRelationshipData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HierarchyRelationshipData> CreateHierarchyRelationshipData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HierarchicalRelationship>>> hierarchy = 0) {
  HierarchyRelationshipDataBuilder builder_(_fbb);
  builder_.add_hierarchy(hierarchy);
  return builder_.Finish();
}

struct HierarchyRelationshipData::Traits {
  using type = HierarchyRelationshipData;
  static auto constexpr Create = CreateHierarchyRelationshipData;
};

inline ::flatbuffers::Offset<HierarchyRelationshipData> CreateHierarchyRelationshipDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<HierarchicalRelationship>> *hierarchy = nullptr) {
  auto hierarchy__ = hierarchy ? _fbb.CreateVector<::flatbuffers::Offset<HierarchicalRelationship>>(*hierarchy) : 0;
  return CreateHierarchyRelationshipData(
      _fbb,
      hierarchy__);
}

struct CategoryRelationshipData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CategoryRelationshipDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CATEGORIES = 4,
    VT_ASSOCIATED_FIELDS = 6
  };
  const ::flatbuffers::Vector<int32_t> *categories() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CATEGORIES);
  }
  const ::flatbuffers::Vector<int32_t> *associated_fields() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ASSOCIATED_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CATEGORIES) &&
           verifier.VerifyVector(categories()) &&
           VerifyOffset(verifier, VT_ASSOCIATED_FIELDS) &&
           verifier.VerifyVector(associated_fields()) &&
           verifier.EndTable();
  }
};

struct CategoryRelationshipDataBuilder {
  typedef CategoryRelationshipData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_categories(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> categories) {
    fbb_.AddOffset(CategoryRelationshipData::VT_CATEGORIES, categories);
  }
  void add_associated_fields(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> associated_fields) {
    fbb_.AddOffset(CategoryRelationshipData::VT_ASSOCIATED_FIELDS, associated_fields);
  }
  explicit CategoryRelationshipDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CategoryRelationshipData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CategoryRelationshipData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CategoryRelationshipData> CreateCategoryRelationshipData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> categories = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> associated_fields = 0) {
  CategoryRelationshipDataBuilder builder_(_fbb);
  builder_.add_associated_fields(associated_fields);
  builder_.add_categories(categories);
  return builder_.Finish();
}

struct CategoryRelationshipData::Traits {
  using type = CategoryRelationshipData;
  static auto constexpr Create = CreateCategoryRelationshipData;
};

inline ::flatbuffers::Offset<CategoryRelationshipData> CreateCategoryRelationshipDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *categories = nullptr,
    const std::vector<int32_t> *associated_fields = nullptr) {
  auto categories__ = categories ? _fbb.CreateVector<int32_t>(*categories) : 0;
  auto associated_fields__ = associated_fields ? _fbb.CreateVector<int32_t>(*associated_fields) : 0;
  return CreateCategoryRelationshipData(
      _fbb,
      categories__,
      associated_fields__);
}

struct NestedCategoryRelationshipNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NestedCategoryRelationshipNodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN = 4,
    VT_CHILD_COLUMNS = 6
  };
  int32_t column() const {
    return GetField<int32_t>(VT_COLUMN, 0);
  }
  const ::flatbuffers::Vector<int32_t> *child_columns() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CHILD_COLUMNS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COLUMN, 4) &&
           VerifyOffset(verifier, VT_CHILD_COLUMNS) &&
           verifier.VerifyVector(child_columns()) &&
           verifier.EndTable();
  }
};

struct NestedCategoryRelationshipNodeBuilder {
  typedef NestedCategoryRelationshipNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_column(int32_t column) {
    fbb_.AddElement<int32_t>(NestedCategoryRelationshipNode::VT_COLUMN, column, 0);
  }
  void add_child_columns(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> child_columns) {
    fbb_.AddOffset(NestedCategoryRelationshipNode::VT_CHILD_COLUMNS, child_columns);
  }
  explicit NestedCategoryRelationshipNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NestedCategoryRelationshipNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NestedCategoryRelationshipNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NestedCategoryRelationshipNode> CreateNestedCategoryRelationshipNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t column = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> child_columns = 0) {
  NestedCategoryRelationshipNodeBuilder builder_(_fbb);
  builder_.add_child_columns(child_columns);
  builder_.add_column(column);
  return builder_.Finish();
}

struct NestedCategoryRelationshipNode::Traits {
  using type = NestedCategoryRelationshipNode;
  static auto constexpr Create = CreateNestedCategoryRelationshipNode;
};

inline ::flatbuffers::Offset<NestedCategoryRelationshipNode> CreateNestedCategoryRelationshipNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t column = 0,
    const std::vector<int32_t> *child_columns = nullptr) {
  auto child_columns__ = child_columns ? _fbb.CreateVector<int32_t>(*child_columns) : 0;
  return CreateNestedCategoryRelationshipNode(
      _fbb,
      column,
      child_columns__);
}

struct NestedCategoryRelationshipData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NestedCategoryRelationshipDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CATEGORIES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NestedCategoryRelationshipNode>> *categories() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NestedCategoryRelationshipNode>> *>(VT_CATEGORIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CATEGORIES) &&
           verifier.VerifyVector(categories()) &&
           verifier.VerifyVectorOfTables(categories()) &&
           verifier.EndTable();
  }
};

struct NestedCategoryRelationshipDataBuilder {
  typedef NestedCategoryRelationshipData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_categories(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NestedCategoryRelationshipNode>>> categories) {
    fbb_.AddOffset(NestedCategoryRelationshipData::VT_CATEGORIES, categories);
  }
  explicit NestedCategoryRelationshipDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NestedCategoryRelationshipData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NestedCategoryRelationshipData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NestedCategoryRelationshipData> CreateNestedCategoryRelationshipData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NestedCategoryRelationshipNode>>> categories = 0) {
  NestedCategoryRelationshipDataBuilder builder_(_fbb);
  builder_.add_categories(categories);
  return builder_.Finish();
}

struct NestedCategoryRelationshipData::Traits {
  using type = NestedCategoryRelationshipData;
  static auto constexpr Create = CreateNestedCategoryRelationshipData;
};

inline ::flatbuffers::Offset<NestedCategoryRelationshipData> CreateNestedCategoryRelationshipDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NestedCategoryRelationshipNode>> *categories = nullptr) {
  auto categories__ = categories ? _fbb.CreateVector<::flatbuffers::Offset<NestedCategoryRelationshipNode>>(*categories) : 0;
  return CreateNestedCategoryRelationshipData(
      _fbb,
      categories__);
}

struct NestedHierarchyRelationshipNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NestedHierarchyRelationshipNodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_CHILD_NODES = 6,
    VT_CHILD_COLUMNS = 8
  };
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  const ::flatbuffers::Vector<int32_t> *child_nodes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CHILD_NODES);
  }
  const ::flatbuffers::Vector<int32_t> *child_columns() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_CHILD_COLUMNS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyOffset(verifier, VT_CHILD_NODES) &&
           verifier.VerifyVector(child_nodes()) &&
           VerifyOffset(verifier, VT_CHILD_COLUMNS) &&
           verifier.VerifyVector(child_columns()) &&
           verifier.EndTable();
  }
};

struct NestedHierarchyRelationshipNodeBuilder {
  typedef NestedHierarchyRelationshipNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(NestedHierarchyRelationshipNode::VT_LABEL, label);
  }
  void add_child_nodes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> child_nodes) {
    fbb_.AddOffset(NestedHierarchyRelationshipNode::VT_CHILD_NODES, child_nodes);
  }
  void add_child_columns(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> child_columns) {
    fbb_.AddOffset(NestedHierarchyRelationshipNode::VT_CHILD_COLUMNS, child_columns);
  }
  explicit NestedHierarchyRelationshipNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NestedHierarchyRelationshipNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NestedHierarchyRelationshipNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NestedHierarchyRelationshipNode> CreateNestedHierarchyRelationshipNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> child_nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> child_columns = 0) {
  NestedHierarchyRelationshipNodeBuilder builder_(_fbb);
  builder_.add_child_columns(child_columns);
  builder_.add_child_nodes(child_nodes);
  builder_.add_label(label);
  return builder_.Finish();
}

struct NestedHierarchyRelationshipNode::Traits {
  using type = NestedHierarchyRelationshipNode;
  static auto constexpr Create = CreateNestedHierarchyRelationshipNode;
};

inline ::flatbuffers::Offset<NestedHierarchyRelationshipNode> CreateNestedHierarchyRelationshipNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    const std::vector<int32_t> *child_nodes = nullptr,
    const std::vector<int32_t> *child_columns = nullptr) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto child_nodes__ = child_nodes ? _fbb.CreateVector<int32_t>(*child_nodes) : 0;
  auto child_columns__ = child_columns ? _fbb.CreateVector<int32_t>(*child_columns) : 0;
  return CreateNestedHierarchyRelationshipNode(
      _fbb,
      label__,
      child_nodes__,
      child_columns__);
}

struct NestedHierarchyRelationshipData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NestedHierarchyRelationshipDataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<NestedHierarchyRelationshipNode>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NestedHierarchyRelationshipNode>> *>(VT_NODES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
};

struct NestedHierarchyRelationshipDataBuilder {
  typedef NestedHierarchyRelationshipData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NestedHierarchyRelationshipNode>>> nodes) {
    fbb_.AddOffset(NestedHierarchyRelationshipData::VT_NODES, nodes);
  }
  explicit NestedHierarchyRelationshipDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NestedHierarchyRelationshipData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NestedHierarchyRelationshipData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NestedHierarchyRelationshipData> CreateNestedHierarchyRelationshipData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NestedHierarchyRelationshipNode>>> nodes = 0) {
  NestedHierarchyRelationshipDataBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

struct NestedHierarchyRelationshipData::Traits {
  using type = NestedHierarchyRelationshipData;
  static auto constexpr Create = CreateNestedHierarchyRelationshipData;
};

inline ::flatbuffers::Offset<NestedHierarchyRelationshipData> CreateNestedHierarchyRelationshipDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<NestedHierarchyRelationshipNode>> *nodes = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<NestedHierarchyRelationshipNode>>(*nodes) : 0;
  return CreateNestedHierarchyRelationshipData(
      _fbb,
      nodes__);
}

struct UlFieldRelationship FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UlFieldRelationshipBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RELATIONSHIP_DISPLAY_NAME = 4,
    VT_RELATIONSHIP_DATA_TYPE = 6,
    VT_RELATIONSHIP_DATA = 8
  };
  const ::flatbuffers::String *relationship_display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RELATIONSHIP_DISPLAY_NAME);
  }
  UlFieldRelationshipData relationship_data_type() const {
    return static_cast<UlFieldRelationshipData>(GetField<uint8_t>(VT_RELATIONSHIP_DATA_TYPE, 0));
  }
  const void *relationship_data() const {
    return GetPointer<const void *>(VT_RELATIONSHIP_DATA);
  }
  template<typename T> const T *relationship_data_as() const;
  const HierarchyRelationshipData *relationship_data_as_HierarchyRelationshipData() const {
    return relationship_data_type() == UlFieldRelationshipData::HierarchyRelationshipData ? static_cast<const HierarchyRelationshipData *>(relationship_data()) : nullptr;
  }
  const CategoryRelationshipData *relationship_data_as_CategoryRelationshipData() const {
    return relationship_data_type() == UlFieldRelationshipData::CategoryRelationshipData ? static_cast<const CategoryRelationshipData *>(relationship_data()) : nullptr;
  }
  const NestedCategoryRelationshipData *relationship_data_as_NestedCategoryRelationshipData() const {
    return relationship_data_type() == UlFieldRelationshipData::NestedCategoryRelationshipData ? static_cast<const NestedCategoryRelationshipData *>(relationship_data()) : nullptr;
  }
  const NestedHierarchyRelationshipData *relationship_data_as_NestedHierarchyRelationshipData() const {
    return relationship_data_type() == UlFieldRelationshipData::NestedHierarchyRelationshipData ? static_cast<const NestedHierarchyRelationshipData *>(relationship_data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RELATIONSHIP_DISPLAY_NAME) &&
           verifier.VerifyString(relationship_display_name()) &&
           VerifyField<uint8_t>(verifier, VT_RELATIONSHIP_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_RELATIONSHIP_DATA) &&
           VerifyUlFieldRelationshipData(verifier, relationship_data(), relationship_data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const HierarchyRelationshipData *UlFieldRelationship::relationship_data_as<HierarchyRelationshipData>() const {
  return relationship_data_as_HierarchyRelationshipData();
}

template<> inline const CategoryRelationshipData *UlFieldRelationship::relationship_data_as<CategoryRelationshipData>() const {
  return relationship_data_as_CategoryRelationshipData();
}

template<> inline const NestedCategoryRelationshipData *UlFieldRelationship::relationship_data_as<NestedCategoryRelationshipData>() const {
  return relationship_data_as_NestedCategoryRelationshipData();
}

template<> inline const NestedHierarchyRelationshipData *UlFieldRelationship::relationship_data_as<NestedHierarchyRelationshipData>() const {
  return relationship_data_as_NestedHierarchyRelationshipData();
}

struct UlFieldRelationshipBuilder {
  typedef UlFieldRelationship Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_relationship_display_name(::flatbuffers::Offset<::flatbuffers::String> relationship_display_name) {
    fbb_.AddOffset(UlFieldRelationship::VT_RELATIONSHIP_DISPLAY_NAME, relationship_display_name);
  }
  void add_relationship_data_type(UlFieldRelationshipData relationship_data_type) {
    fbb_.AddElement<uint8_t>(UlFieldRelationship::VT_RELATIONSHIP_DATA_TYPE, static_cast<uint8_t>(relationship_data_type), 0);
  }
  void add_relationship_data(::flatbuffers::Offset<void> relationship_data) {
    fbb_.AddOffset(UlFieldRelationship::VT_RELATIONSHIP_DATA, relationship_data);
  }
  explicit UlFieldRelationshipBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UlFieldRelationship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UlFieldRelationship>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UlFieldRelationship> CreateUlFieldRelationship(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> relationship_display_name = 0,
    UlFieldRelationshipData relationship_data_type = UlFieldRelationshipData::NONE,
    ::flatbuffers::Offset<void> relationship_data = 0) {
  UlFieldRelationshipBuilder builder_(_fbb);
  builder_.add_relationship_data(relationship_data);
  builder_.add_relationship_display_name(relationship_display_name);
  builder_.add_relationship_data_type(relationship_data_type);
  return builder_.Finish();
}

struct UlFieldRelationship::Traits {
  using type = UlFieldRelationship;
  static auto constexpr Create = CreateUlFieldRelationship;
};

inline ::flatbuffers::Offset<UlFieldRelationship> CreateUlFieldRelationshipDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *relationship_display_name = nullptr,
    UlFieldRelationshipData relationship_data_type = UlFieldRelationshipData::NONE,
    ::flatbuffers::Offset<void> relationship_data = 0) {
  auto relationship_display_name__ = relationship_display_name ? _fbb.CreateString(relationship_display_name) : 0;
  return CreateUlFieldRelationship(
      _fbb,
      relationship_display_name__,
      relationship_data_type,
      relationship_data);
}

struct DatasetSource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DatasetSourceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_URL = 6,
    VT_DATE = 8
  };
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  const ::flatbuffers::String *date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(date()) &&
           verifier.EndTable();
  }
};

struct DatasetSourceBuilder {
  typedef DatasetSource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(DatasetSource::VT_SOURCE, source);
  }
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(DatasetSource::VT_URL, url);
  }
  void add_date(::flatbuffers::Offset<::flatbuffers::String> date) {
    fbb_.AddOffset(DatasetSource::VT_DATE, date);
  }
  explicit DatasetSourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DatasetSource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DatasetSource>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DatasetSource> CreateDatasetSource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    ::flatbuffers::Offset<::flatbuffers::String> date = 0) {
  DatasetSourceBuilder builder_(_fbb);
  builder_.add_date(date);
  builder_.add_url(url);
  builder_.add_source(source);
  return builder_.Finish();
}

struct DatasetSource::Traits {
  using type = DatasetSource;
  static auto constexpr Create = CreateDatasetSource;
};

inline ::flatbuffers::Offset<DatasetSource> CreateDatasetSourceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *source = nullptr,
    const char *url = nullptr,
    const char *date = nullptr) {
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto url__ = url ? _fbb.CreateString(url) : 0;
  auto date__ = date ? _fbb.CreateString(date) : 0;
  return CreateDatasetSource(
      _fbb,
      source__,
      url__,
      date__);
}

struct NoGeometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NoGeometryBuilder Builder;
  struct Traits;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NoGeometryBuilder {
  typedef NoGeometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NoGeometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NoGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NoGeometry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NoGeometry> CreateNoGeometry(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NoGeometryBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NoGeometry::Traits {
  using type = NoGeometry;
  static auto constexpr Create = CreateNoGeometry;
};

struct DatacatalogGeometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DatacatalogGeometryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN = 4
  };
  const ::flatbuffers::String *column() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLUMN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_COLUMN) &&
           verifier.VerifyString(column()) &&
           verifier.EndTable();
  }
};

struct DatacatalogGeometryBuilder {
  typedef DatacatalogGeometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_column(::flatbuffers::Offset<::flatbuffers::String> column) {
    fbb_.AddOffset(DatacatalogGeometry::VT_COLUMN, column);
  }
  explicit DatacatalogGeometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DatacatalogGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DatacatalogGeometry>(end);
    fbb_.Required(o, DatacatalogGeometry::VT_COLUMN);
    return o;
  }
};

inline ::flatbuffers::Offset<DatacatalogGeometry> CreateDatacatalogGeometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> column = 0) {
  DatacatalogGeometryBuilder builder_(_fbb);
  builder_.add_column(column);
  return builder_.Finish();
}

struct DatacatalogGeometry::Traits {
  using type = DatacatalogGeometry;
  static auto constexpr Create = CreateDatacatalogGeometry;
};

inline ::flatbuffers::Offset<DatacatalogGeometry> CreateDatacatalogGeometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *column = nullptr) {
  auto column__ = column ? _fbb.CreateString(column) : 0;
  return CreateDatacatalogGeometry(
      _fbb,
      column__);
}

struct WorldGraphGeometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WorldGraphGeometryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EDGE_PATH = 4,
    VT_START_STREAM_ID = 6
  };
  const ::flatbuffers::Vector<EdgeTy> *edge_path() const {
    return GetPointer<const ::flatbuffers::Vector<EdgeTy> *>(VT_EDGE_PATH);
  }
  const ObjectId *start_stream_id() const {
    return GetPointer<const ObjectId *>(VT_START_STREAM_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_EDGE_PATH) &&
           verifier.VerifyVector(edge_path()) &&
           VerifyOffset(verifier, VT_START_STREAM_ID) &&
           verifier.VerifyTable(start_stream_id()) &&
           verifier.EndTable();
  }
};

struct WorldGraphGeometryBuilder {
  typedef WorldGraphGeometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_edge_path(::flatbuffers::Offset<::flatbuffers::Vector<EdgeTy>> edge_path) {
    fbb_.AddOffset(WorldGraphGeometry::VT_EDGE_PATH, edge_path);
  }
  void add_start_stream_id(::flatbuffers::Offset<ObjectId> start_stream_id) {
    fbb_.AddOffset(WorldGraphGeometry::VT_START_STREAM_ID, start_stream_id);
  }
  explicit WorldGraphGeometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WorldGraphGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WorldGraphGeometry>(end);
    fbb_.Required(o, WorldGraphGeometry::VT_EDGE_PATH);
    return o;
  }
};

inline ::flatbuffers::Offset<WorldGraphGeometry> CreateWorldGraphGeometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<EdgeTy>> edge_path = 0,
    ::flatbuffers::Offset<ObjectId> start_stream_id = 0) {
  WorldGraphGeometryBuilder builder_(_fbb);
  builder_.add_start_stream_id(start_stream_id);
  builder_.add_edge_path(edge_path);
  return builder_.Finish();
}

struct WorldGraphGeometry::Traits {
  using type = WorldGraphGeometry;
  static auto constexpr Create = CreateWorldGraphGeometry;
};

inline ::flatbuffers::Offset<WorldGraphGeometry> CreateWorldGraphGeometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<EdgeTy> *edge_path = nullptr,
    ::flatbuffers::Offset<ObjectId> start_stream_id = 0) {
  auto edge_path__ = edge_path ? _fbb.CreateVector<EdgeTy>(*edge_path) : 0;
  return CreateWorldGraphGeometry(
      _fbb,
      edge_path__,
      start_stream_id);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISPLAY_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_FIELDS = 8,
    VT_SUMMARY = 10,
    VT_DATASET_CATEGORY = 12,
    VT_FIELD_RELATIONSHIPS = 14,
    VT_SOURCE = 16,
    VT_GEOMETRY_SOURCE_TYPE = 18,
    VT_GEOMETRY_SOURCE = 20,
    VT_AREA_SELECTION = 22,
    VT_DO_NOT_FILTER_GEOMETRY_BY_VIEWPORT = 24,
    VT_ENTITY_TY = 26,
    VT_UPDATE_CADENCE = 28
  };
  const ::flatbuffers::String *display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<UlField>> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<UlField>> *>(VT_FIELDS);
  }
  const ::flatbuffers::Vector<int32_t> *summary() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SUMMARY);
  }
  DatasetCategory dataset_category() const {
    return static_cast<DatasetCategory>(GetField<uint32_t>(VT_DATASET_CATEGORY, 4294967295));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<UlFieldRelationship>> *field_relationships() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<UlFieldRelationship>> *>(VT_FIELD_RELATIONSHIPS);
  }
  const DatasetSource *source() const {
    return GetPointer<const DatasetSource *>(VT_SOURCE);
  }
  GeometrySource geometry_source_type() const {
    return static_cast<GeometrySource>(GetField<uint8_t>(VT_GEOMETRY_SOURCE_TYPE, 0));
  }
  const void *geometry_source() const {
    return GetPointer<const void *>(VT_GEOMETRY_SOURCE);
  }
  template<typename T> const T *geometry_source_as() const;
  const NoGeometry *geometry_source_as_NoGeometry() const {
    return geometry_source_type() == GeometrySource::NoGeometry ? static_cast<const NoGeometry *>(geometry_source()) : nullptr;
  }
  const DatacatalogGeometry *geometry_source_as_DatacatalogGeometry() const {
    return geometry_source_type() == GeometrySource::DatacatalogGeometry ? static_cast<const DatacatalogGeometry *>(geometry_source()) : nullptr;
  }
  const WorldGraphGeometry *geometry_source_as_WorldGraphGeometry() const {
    return geometry_source_type() == GeometrySource::WorldGraphGeometry ? static_cast<const WorldGraphGeometry *>(geometry_source()) : nullptr;
  }
  bool area_selection() const {
    return GetField<uint8_t>(VT_AREA_SELECTION, 0) != 0;
  }
  bool do_not_filter_geometry_by_viewport() const {
    return GetField<uint8_t>(VT_DO_NOT_FILTER_GEOMETRY_BY_VIEWPORT, 0) != 0;
  }
  EntityTy entity_ty() const {
    return static_cast<EntityTy>(GetField<int32_t>(VT_ENTITY_TY, 0));
  }
  UpdateCadence update_cadence() const {
    return static_cast<UpdateCadence>(GetField<uint32_t>(VT_UPDATE_CADENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyOffset(verifier, VT_SUMMARY) &&
           verifier.VerifyVector(summary()) &&
           VerifyField<uint32_t>(verifier, VT_DATASET_CATEGORY, 4) &&
           VerifyOffset(verifier, VT_FIELD_RELATIONSHIPS) &&
           verifier.VerifyVector(field_relationships()) &&
           verifier.VerifyVectorOfTables(field_relationships()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyTable(source()) &&
           VerifyField<uint8_t>(verifier, VT_GEOMETRY_SOURCE_TYPE, 1) &&
           VerifyOffset(verifier, VT_GEOMETRY_SOURCE) &&
           VerifyGeometrySource(verifier, geometry_source(), geometry_source_type()) &&
           VerifyField<uint8_t>(verifier, VT_AREA_SELECTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_DO_NOT_FILTER_GEOMETRY_BY_VIEWPORT, 1) &&
           VerifyField<int32_t>(verifier, VT_ENTITY_TY, 4) &&
           VerifyField<uint32_t>(verifier, VT_UPDATE_CADENCE, 4) &&
           verifier.EndTable();
  }
};

template<> inline const NoGeometry *Metadata::geometry_source_as<NoGeometry>() const {
  return geometry_source_as_NoGeometry();
}

template<> inline const DatacatalogGeometry *Metadata::geometry_source_as<DatacatalogGeometry>() const {
  return geometry_source_as_DatacatalogGeometry();
}

template<> inline const WorldGraphGeometry *Metadata::geometry_source_as<WorldGraphGeometry>() const {
  return geometry_source_as_WorldGraphGeometry();
}

struct MetadataBuilder {
  typedef Metadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_display_name(::flatbuffers::Offset<::flatbuffers::String> display_name) {
    fbb_.AddOffset(Metadata::VT_DISPLAY_NAME, display_name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Metadata::VT_DESCRIPTION, description);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UlField>>> fields) {
    fbb_.AddOffset(Metadata::VT_FIELDS, fields);
  }
  void add_summary(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> summary) {
    fbb_.AddOffset(Metadata::VT_SUMMARY, summary);
  }
  void add_dataset_category(DatasetCategory dataset_category) {
    fbb_.AddElement<uint32_t>(Metadata::VT_DATASET_CATEGORY, static_cast<uint32_t>(dataset_category), 4294967295);
  }
  void add_field_relationships(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UlFieldRelationship>>> field_relationships) {
    fbb_.AddOffset(Metadata::VT_FIELD_RELATIONSHIPS, field_relationships);
  }
  void add_source(::flatbuffers::Offset<DatasetSource> source) {
    fbb_.AddOffset(Metadata::VT_SOURCE, source);
  }
  void add_geometry_source_type(GeometrySource geometry_source_type) {
    fbb_.AddElement<uint8_t>(Metadata::VT_GEOMETRY_SOURCE_TYPE, static_cast<uint8_t>(geometry_source_type), 0);
  }
  void add_geometry_source(::flatbuffers::Offset<void> geometry_source) {
    fbb_.AddOffset(Metadata::VT_GEOMETRY_SOURCE, geometry_source);
  }
  void add_area_selection(bool area_selection) {
    fbb_.AddElement<uint8_t>(Metadata::VT_AREA_SELECTION, static_cast<uint8_t>(area_selection), 0);
  }
  void add_do_not_filter_geometry_by_viewport(bool do_not_filter_geometry_by_viewport) {
    fbb_.AddElement<uint8_t>(Metadata::VT_DO_NOT_FILTER_GEOMETRY_BY_VIEWPORT, static_cast<uint8_t>(do_not_filter_geometry_by_viewport), 0);
  }
  void add_entity_ty(EntityTy entity_ty) {
    fbb_.AddElement<int32_t>(Metadata::VT_ENTITY_TY, static_cast<int32_t>(entity_ty), 0);
  }
  void add_update_cadence(UpdateCadence update_cadence) {
    fbb_.AddElement<uint32_t>(Metadata::VT_UPDATE_CADENCE, static_cast<uint32_t>(update_cadence), 0);
  }
  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Metadata> CreateMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> display_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UlField>>> fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> summary = 0,
    DatasetCategory dataset_category = DatasetCategory::DC_HIDDEN,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UlFieldRelationship>>> field_relationships = 0,
    ::flatbuffers::Offset<DatasetSource> source = 0,
    GeometrySource geometry_source_type = GeometrySource::NONE,
    ::flatbuffers::Offset<void> geometry_source = 0,
    bool area_selection = false,
    bool do_not_filter_geometry_by_viewport = false,
    EntityTy entity_ty = EntityTy::T_INVALID,
    UpdateCadence update_cadence = UpdateCadence::UC_UNSET) {
  MetadataBuilder builder_(_fbb);
  builder_.add_update_cadence(update_cadence);
  builder_.add_entity_ty(entity_ty);
  builder_.add_geometry_source(geometry_source);
  builder_.add_source(source);
  builder_.add_field_relationships(field_relationships);
  builder_.add_dataset_category(dataset_category);
  builder_.add_summary(summary);
  builder_.add_fields(fields);
  builder_.add_description(description);
  builder_.add_display_name(display_name);
  builder_.add_do_not_filter_geometry_by_viewport(do_not_filter_geometry_by_viewport);
  builder_.add_area_selection(area_selection);
  builder_.add_geometry_source_type(geometry_source_type);
  return builder_.Finish();
}

struct Metadata::Traits {
  using type = Metadata;
  static auto constexpr Create = CreateMetadata;
};

inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *display_name = nullptr,
    const char *description = nullptr,
    const std::vector<::flatbuffers::Offset<UlField>> *fields = nullptr,
    const std::vector<int32_t> *summary = nullptr,
    DatasetCategory dataset_category = DatasetCategory::DC_HIDDEN,
    const std::vector<::flatbuffers::Offset<UlFieldRelationship>> *field_relationships = nullptr,
    ::flatbuffers::Offset<DatasetSource> source = 0,
    GeometrySource geometry_source_type = GeometrySource::NONE,
    ::flatbuffers::Offset<void> geometry_source = 0,
    bool area_selection = false,
    bool do_not_filter_geometry_by_viewport = false,
    EntityTy entity_ty = EntityTy::T_INVALID,
    UpdateCadence update_cadence = UpdateCadence::UC_UNSET) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto fields__ = fields ? _fbb.CreateVector<::flatbuffers::Offset<UlField>>(*fields) : 0;
  auto summary__ = summary ? _fbb.CreateVector<int32_t>(*summary) : 0;
  auto field_relationships__ = field_relationships ? _fbb.CreateVector<::flatbuffers::Offset<UlFieldRelationship>>(*field_relationships) : 0;
  return CreateMetadata(
      _fbb,
      display_name__,
      description__,
      fields__,
      summary__,
      dataset_category,
      field_relationships__,
      source,
      geometry_source_type,
      geometry_source,
      area_selection,
      do_not_filter_geometry_by_viewport,
      entity_ty,
      update_cadence);
}

inline bool VerifyComponentData(::flatbuffers::Verifier &verifier, const void *obj, ComponentData type) {
  switch (type) {
    case ComponentData::NONE: {
      return true;
    }
    case ComponentData::StringCategories: {
      auto ptr = reinterpret_cast<const StringCategories *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentData::IntRange: {
      auto ptr = reinterpret_cast<const IntRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentData::FloatRange: {
      auto ptr = reinterpret_cast<const FloatRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentData::DatetimeRange: {
      auto ptr = reinterpret_cast<const DatetimeRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentData::Dates: {
      auto ptr = reinterpret_cast<const Dates *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ComponentData::NestedStringCategories: {
      auto ptr = reinterpret_cast<const NestedStringCategories *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyComponentDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ComponentData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyComponentData(
        verifier,  values->Get(i), types->GetEnum<ComponentData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGeometryDataUnion(::flatbuffers::Verifier &verifier, const void *obj, GeometryDataUnion type) {
  switch (type) {
    case GeometryDataUnion::NONE: {
      return true;
    }
    case GeometryDataUnion::RawGeom: {
      auto ptr = reinterpret_cast<const RawGeom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometryDataUnion::NodeIdPair: {
      auto ptr = reinterpret_cast<const NodeIdPair *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGeometryDataUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<GeometryDataUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeometryDataUnion(
        verifier,  values->Get(i), types->GetEnum<GeometryDataUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyUlFieldRelationshipData(::flatbuffers::Verifier &verifier, const void *obj, UlFieldRelationshipData type) {
  switch (type) {
    case UlFieldRelationshipData::NONE: {
      return true;
    }
    case UlFieldRelationshipData::HierarchyRelationshipData: {
      auto ptr = reinterpret_cast<const HierarchyRelationshipData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UlFieldRelationshipData::CategoryRelationshipData: {
      auto ptr = reinterpret_cast<const CategoryRelationshipData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UlFieldRelationshipData::NestedCategoryRelationshipData: {
      auto ptr = reinterpret_cast<const NestedCategoryRelationshipData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UlFieldRelationshipData::NestedHierarchyRelationshipData: {
      auto ptr = reinterpret_cast<const NestedHierarchyRelationshipData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUlFieldRelationshipDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<UlFieldRelationshipData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUlFieldRelationshipData(
        verifier,  values->Get(i), types->GetEnum<UlFieldRelationshipData>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGeometrySource(::flatbuffers::Verifier &verifier, const void *obj, GeometrySource type) {
  switch (type) {
    case GeometrySource::NONE: {
      return true;
    }
    case GeometrySource::NoGeometry: {
      auto ptr = reinterpret_cast<const NoGeometry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometrySource::DatacatalogGeometry: {
      auto ptr = reinterpret_cast<const DatacatalogGeometry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case GeometrySource::WorldGraphGeometry: {
      auto ptr = reinterpret_cast<const WorldGraphGeometry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyGeometrySourceVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<GeometrySource> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeometrySource(
        verifier,  values->Get(i), types->GetEnum<GeometrySource>(i))) {
      return false;
    }
  }
  return true;
}

inline const Metadata *GetMetadata(const void *buf) {
  return ::flatbuffers::GetRoot<Metadata>(buf);
}

inline const Metadata *GetSizePrefixedMetadata(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Metadata>(buf);
}

inline bool VerifyMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Metadata>(nullptr);
}

inline bool VerifySizePrefixedMetadataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Metadata>(nullptr);
}

inline void FinishMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Metadata> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetadataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Metadata> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_METADATA_H_
