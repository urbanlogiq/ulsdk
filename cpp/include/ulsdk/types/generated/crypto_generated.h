// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CRYPTO_H_
#define FLATBUFFERS_GENERATED_CRYPTO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct Signature;
struct SignatureBuilder;

struct CryptHeader;
struct CryptHeaderBuilder;

struct EncryptedObject;
struct EncryptedObjectBuilder;

struct Sha256;
struct Sha256Builder;

enum class Digest : uint8_t {
  NONE = 0,
  Sha256 = 1,
  MIN = NONE,
  MAX = Sha256
};

inline const Digest (&EnumValuesDigest())[2] {
  static const Digest values[] = {
    Digest::NONE,
    Digest::Sha256
  };
  return values;
}

inline const char * const *EnumNamesDigest() {
  static const char * const names[3] = {
    "NONE",
    "Sha256",
    nullptr
  };
  return names;
}

inline const char *EnumNameDigest(Digest e) {
  if (::flatbuffers::IsOutRange(e, Digest::NONE, Digest::Sha256)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDigest()[index];
}

template<typename T> struct DigestTraits {
  static const Digest enum_value = Digest::NONE;
};

template<> struct DigestTraits<Sha256> {
  static const Digest enum_value = Digest::Sha256;
};

bool VerifyDigest(::flatbuffers::Verifier &verifier, const void *obj, Digest type);
bool VerifyDigestVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Digest> *types);

struct Signature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SignatureBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KID = 4,
    VT_SIG = 6
  };
  const ::flatbuffers::String *kid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KID);
  }
  const ::flatbuffers::Vector<uint8_t> *sig() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SIG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KID) &&
           verifier.VerifyString(kid()) &&
           VerifyOffsetRequired(verifier, VT_SIG) &&
           verifier.VerifyVector(sig()) &&
           verifier.EndTable();
  }
};

struct SignatureBuilder {
  typedef Signature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kid(::flatbuffers::Offset<::flatbuffers::String> kid) {
    fbb_.AddOffset(Signature::VT_KID, kid);
  }
  void add_sig(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sig) {
    fbb_.AddOffset(Signature::VT_SIG, sig);
  }
  explicit SignatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Signature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Signature>(end);
    fbb_.Required(o, Signature::VT_KID);
    fbb_.Required(o, Signature::VT_SIG);
    return o;
  }
};

inline ::flatbuffers::Offset<Signature> CreateSignature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> kid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> sig = 0) {
  SignatureBuilder builder_(_fbb);
  builder_.add_sig(sig);
  builder_.add_kid(kid);
  return builder_.Finish();
}

struct Signature::Traits {
  using type = Signature;
  static auto constexpr Create = CreateSignature;
};

inline ::flatbuffers::Offset<Signature> CreateSignatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *kid = nullptr,
    const std::vector<uint8_t> *sig = nullptr) {
  auto kid__ = kid ? _fbb.CreateString(kid) : 0;
  auto sig__ = sig ? _fbb.CreateVector<uint8_t>(*sig) : 0;
  return CreateSignature(
      _fbb,
      kid__,
      sig__);
}

struct CryptHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CryptHeaderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KID = 4,
    VT_NONCE = 6,
    VT_PLAINTEXT_LEN = 8
  };
  /// An ID for the key used to encrypt this particular encrypted object.
  const ::flatbuffers::String *kid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KID);
  }
  const ::flatbuffers::Vector<uint8_t> *nonce() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_NONCE);
  }
  uint32_t plaintext_len() const {
    return GetField<uint32_t>(VT_PLAINTEXT_LEN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KID) &&
           verifier.VerifyString(kid()) &&
           VerifyOffsetRequired(verifier, VT_NONCE) &&
           verifier.VerifyVector(nonce()) &&
           VerifyField<uint32_t>(verifier, VT_PLAINTEXT_LEN, 4) &&
           verifier.EndTable();
  }
};

struct CryptHeaderBuilder {
  typedef CryptHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kid(::flatbuffers::Offset<::flatbuffers::String> kid) {
    fbb_.AddOffset(CryptHeader::VT_KID, kid);
  }
  void add_nonce(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> nonce) {
    fbb_.AddOffset(CryptHeader::VT_NONCE, nonce);
  }
  void add_plaintext_len(uint32_t plaintext_len) {
    fbb_.AddElement<uint32_t>(CryptHeader::VT_PLAINTEXT_LEN, plaintext_len, 0);
  }
  explicit CryptHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CryptHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CryptHeader>(end);
    fbb_.Required(o, CryptHeader::VT_KID);
    fbb_.Required(o, CryptHeader::VT_NONCE);
    return o;
  }
};

inline ::flatbuffers::Offset<CryptHeader> CreateCryptHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> kid = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> nonce = 0,
    uint32_t plaintext_len = 0) {
  CryptHeaderBuilder builder_(_fbb);
  builder_.add_plaintext_len(plaintext_len);
  builder_.add_nonce(nonce);
  builder_.add_kid(kid);
  return builder_.Finish();
}

struct CryptHeader::Traits {
  using type = CryptHeader;
  static auto constexpr Create = CreateCryptHeader;
};

inline ::flatbuffers::Offset<CryptHeader> CreateCryptHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *kid = nullptr,
    const std::vector<uint8_t> *nonce = nullptr,
    uint32_t plaintext_len = 0) {
  auto kid__ = kid ? _fbb.CreateString(kid) : 0;
  auto nonce__ = nonce ? _fbb.CreateVector<uint8_t>(*nonce) : 0;
  return CreateCryptHeader(
      _fbb,
      kid__,
      nonce__,
      plaintext_len);
}

struct EncryptedObject FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EncryptedObjectBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_OBJ = 6
  };
  const CryptHeader *header() const {
    return GetPointer<const CryptHeader *>(VT_HEADER);
  }
  const ::flatbuffers::Vector<uint8_t> *obj() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OBJ);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyOffsetRequired(verifier, VT_OBJ) &&
           verifier.VerifyVector(obj()) &&
           verifier.EndTable();
  }
};

struct EncryptedObjectBuilder {
  typedef EncryptedObject Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_header(::flatbuffers::Offset<CryptHeader> header) {
    fbb_.AddOffset(EncryptedObject::VT_HEADER, header);
  }
  void add_obj(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> obj) {
    fbb_.AddOffset(EncryptedObject::VT_OBJ, obj);
  }
  explicit EncryptedObjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EncryptedObject> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EncryptedObject>(end);
    fbb_.Required(o, EncryptedObject::VT_HEADER);
    fbb_.Required(o, EncryptedObject::VT_OBJ);
    return o;
  }
};

inline ::flatbuffers::Offset<EncryptedObject> CreateEncryptedObject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CryptHeader> header = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> obj = 0) {
  EncryptedObjectBuilder builder_(_fbb);
  builder_.add_obj(obj);
  builder_.add_header(header);
  return builder_.Finish();
}

struct EncryptedObject::Traits {
  using type = EncryptedObject;
  static auto constexpr Create = CreateEncryptedObject;
};

inline ::flatbuffers::Offset<EncryptedObject> CreateEncryptedObjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CryptHeader> header = 0,
    const std::vector<uint8_t> *obj = nullptr) {
  auto obj__ = obj ? _fbb.CreateVector<uint8_t>(*obj) : 0;
  return CreateEncryptedObject(
      _fbb,
      header,
      obj__);
}

struct Sha256 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Sha256Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct Sha256Builder {
  typedef Sha256 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(Sha256::VT_B, b);
  }
  explicit Sha256Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sha256> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sha256>(end);
    fbb_.Required(o, Sha256::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<Sha256> CreateSha256(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  Sha256Builder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct Sha256::Traits {
  using type = Sha256;
  static auto constexpr Create = CreateSha256;
};

inline ::flatbuffers::Offset<Sha256> CreateSha256Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateSha256(
      _fbb,
      b__);
}

inline bool VerifyDigest(::flatbuffers::Verifier &verifier, const void *obj, Digest type) {
  switch (type) {
    case Digest::NONE: {
      return true;
    }
    case Digest::Sha256: {
      auto ptr = reinterpret_cast<const Sha256 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDigestVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Digest> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDigest(
        verifier,  values->Get(i), types->GetEnum<Digest>(i))) {
      return false;
    }
  }
  return true;
}

#endif  // FLATBUFFERS_GENERATED_CRYPTO_H_
