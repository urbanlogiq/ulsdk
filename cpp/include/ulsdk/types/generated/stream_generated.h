// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STREAM_H_
#define FLATBUFFERS_GENERATED_STREAM_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"
#include "flatbuffers/flex_flat_util.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "Schema_generated.h"
#include "id_generated.h"

struct Stream;
struct StreamBuilder;

enum class FormatFlags : uint32_t {
  OmitNodeId = 1,
  WithDescription = 2,
  WithGeom = 4,
  NONE = 0,
  ANY = 7
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(FormatFlags, uint32_t)

inline const FormatFlags (&EnumValuesFormatFlags())[3] {
  static const FormatFlags values[] = {
    FormatFlags::OmitNodeId,
    FormatFlags::WithDescription,
    FormatFlags::WithGeom
  };
  return values;
}

inline const char * const *EnumNamesFormatFlags() {
  static const char * const names[5] = {
    "OmitNodeId",
    "WithDescription",
    "",
    "WithGeom",
    nullptr
  };
  return names;
}

inline const char *EnumNameFormatFlags(FormatFlags e) {
  if (::flatbuffers::IsOutRange(e, FormatFlags::OmitNodeId, FormatFlags::WithGeom)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(FormatFlags::OmitNodeId);
  return EnumNamesFormatFlags()[index];
}

enum class StreamFlags : uint32_t {
  Dynamic = 1,
  NONE = 0,
  ANY = 1
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(StreamFlags, uint32_t)

inline const StreamFlags (&EnumValuesStreamFlags())[1] {
  static const StreamFlags values[] = {
    StreamFlags::Dynamic
  };
  return values;
}

inline const char * const *EnumNamesStreamFlags() {
  static const char * const names[2] = {
    "Dynamic",
    nullptr
  };
  return names;
}

inline const char *EnumNameStreamFlags(StreamFlags e) {
  if (::flatbuffers::IsOutRange(e, StreamFlags::Dynamic, StreamFlags::Dynamic)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(StreamFlags::Dynamic);
  return EnumNamesStreamFlags()[index];
}

enum class AxisType : uint32_t {
  AXIS_TIMESTAMP = 0,
  MIN = AXIS_TIMESTAMP,
  MAX = AXIS_TIMESTAMP
};

inline const AxisType (&EnumValuesAxisType())[1] {
  static const AxisType values[] = {
    AxisType::AXIS_TIMESTAMP
  };
  return values;
}

inline const char * const *EnumNamesAxisType() {
  static const char * const names[2] = {
    "AXIS_TIMESTAMP",
    nullptr
  };
  return names;
}

inline const char *EnumNameAxisType(AxisType e) {
  if (::flatbuffers::IsOutRange(e, AxisType::AXIS_TIMESTAMP, AxisType::AXIS_TIMESTAMP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAxisType()[index];
}

/// A Stream is an instance of a source. The main difference is the parameters
/// field is not a ParameterDesc descriptor object but the actual, serialized
/// parameter values.
///
/// Code performing the operation on the source will be able to construct a
/// stream object from this description and downstream code will be able to
/// read from it.
struct Stream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StreamBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_URL = 4,
    VT_OPTIONS = 6,
    VT_PARAMETERS = 8,
    VT_SCHEMA = 10,
    VT_METADATA = 12,
    VT_METADATA_REVISION = 14,
    VT_FLAGS = 16,
    VT_SUBSTREAMS = 22
  };
  const ::flatbuffers::String *url() const {
    return GetPointer<const ::flatbuffers::String *>(VT_URL);
  }
  const ::flatbuffers::Vector<uint8_t> *options() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OPTIONS);
  }
  flexbuffers::Reference options_flexbuffer_root() const {
    const auto _f = options();
    return _f ? flexbuffers::GetRoot(_f->Data(), _f->size())
              : flexbuffers::Reference();
  }
  const ::flatbuffers::Vector<uint8_t> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PARAMETERS);
  }
  flexbuffers::Reference parameters_flexbuffer_root() const {
    const auto _f = parameters();
    return _f ? flexbuffers::GetRoot(_f->Data(), _f->size())
              : flexbuffers::Reference();
  }
  const Schema *schema() const {
    return GetPointer<const Schema *>(VT_SCHEMA);
  }
  const ObjectId *metadata() const {
    return GetPointer<const ObjectId *>(VT_METADATA);
  }
  const ContentId *metadata_revision() const {
    return GetPointer<const ContentId *>(VT_METADATA_REVISION);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *substreams() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>> *>(VT_SUBSTREAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_URL) &&
           verifier.VerifyString(url()) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.VerifyVector(options()) &&
           flexbuffers::VerifyNestedFlexBuffer(options(), verifier) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           flexbuffers::VerifyNestedFlexBuffer(parameters(), verifier) &&
           VerifyOffsetRequired(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           VerifyOffset(verifier, VT_METADATA_REVISION) &&
           verifier.VerifyTable(metadata_revision()) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyOffset(verifier, VT_SUBSTREAMS) &&
           verifier.VerifyVector(substreams()) &&
           verifier.VerifyVectorOfTables(substreams()) &&
           verifier.EndTable();
  }
};

struct StreamBuilder {
  typedef Stream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_url(::flatbuffers::Offset<::flatbuffers::String> url) {
    fbb_.AddOffset(Stream::VT_URL, url);
  }
  void add_options(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> options) {
    fbb_.AddOffset(Stream::VT_OPTIONS, options);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters) {
    fbb_.AddOffset(Stream::VT_PARAMETERS, parameters);
  }
  void add_schema(::flatbuffers::Offset<Schema> schema) {
    fbb_.AddOffset(Stream::VT_SCHEMA, schema);
  }
  void add_metadata(::flatbuffers::Offset<ObjectId> metadata) {
    fbb_.AddOffset(Stream::VT_METADATA, metadata);
  }
  void add_metadata_revision(::flatbuffers::Offset<ContentId> metadata_revision) {
    fbb_.AddOffset(Stream::VT_METADATA_REVISION, metadata_revision);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(Stream::VT_FLAGS, flags, 0);
  }
  void add_substreams(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> substreams) {
    fbb_.AddOffset(Stream::VT_SUBSTREAMS, substreams);
  }
  explicit StreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Stream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Stream>(end);
    fbb_.Required(o, Stream::VT_URL);
    fbb_.Required(o, Stream::VT_SCHEMA);
    return o;
  }
};

inline ::flatbuffers::Offset<Stream> CreateStream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> url = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> options = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> parameters = 0,
    ::flatbuffers::Offset<Schema> schema = 0,
    ::flatbuffers::Offset<ObjectId> metadata = 0,
    ::flatbuffers::Offset<ContentId> metadata_revision = 0,
    uint32_t flags = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ObjectId>>> substreams = 0) {
  StreamBuilder builder_(_fbb);
  builder_.add_substreams(substreams);
  builder_.add_flags(flags);
  builder_.add_metadata_revision(metadata_revision);
  builder_.add_metadata(metadata);
  builder_.add_schema(schema);
  builder_.add_parameters(parameters);
  builder_.add_options(options);
  builder_.add_url(url);
  return builder_.Finish();
}

struct Stream::Traits {
  using type = Stream;
  static auto constexpr Create = CreateStream;
};

inline ::flatbuffers::Offset<Stream> CreateStreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *url = nullptr,
    const std::vector<uint8_t> *options = nullptr,
    const std::vector<uint8_t> *parameters = nullptr,
    ::flatbuffers::Offset<Schema> schema = 0,
    ::flatbuffers::Offset<ObjectId> metadata = 0,
    ::flatbuffers::Offset<ContentId> metadata_revision = 0,
    uint32_t flags = 0,
    const std::vector<::flatbuffers::Offset<ObjectId>> *substreams = nullptr) {
  auto url__ = url ? _fbb.CreateString(url) : 0;
  auto options__ = options ? _fbb.CreateVector<uint8_t>(*options) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<uint8_t>(*parameters) : 0;
  auto substreams__ = substreams ? _fbb.CreateVector<::flatbuffers::Offset<ObjectId>>(*substreams) : 0;
  return CreateStream(
      _fbb,
      url__,
      options__,
      parameters__,
      schema,
      metadata,
      metadata_revision,
      flags,
      substreams__);
}

inline const Stream *GetStream(const void *buf) {
  return ::flatbuffers::GetRoot<Stream>(buf);
}

inline const Stream *GetSizePrefixedStream(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Stream>(buf);
}

inline bool VerifyStreamBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Stream>(nullptr);
}

inline bool VerifySizePrefixedStreamBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Stream>(nullptr);
}

inline void FinishStreamBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Stream> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStreamBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Stream> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_STREAM_H_
