// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ID_H_
#define FLATBUFFERS_GENERATED_ID_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct ObjectId;
struct ObjectIdBuilder;

struct ContentId;
struct ContentIdBuilder;

struct B2cId;
struct B2cIdBuilder;

struct GenericId;
struct GenericIdBuilder;

struct DataStateId;
struct DataStateIdBuilder;

struct StreamId;
struct StreamIdBuilder;

struct ColumnGroupId;
struct ColumnGroupIdBuilder;

struct GraphNodeId;
struct GraphNodeIdBuilder;

enum class ObjectNamespace : uint16_t {
  Global = 0,
  User = 1,
  Generated = 2,
  Acl = 3,
  Evaluator = 4,
  Drive = 5,
  Notifications = 6,
  Unknown = 65535,
  MIN = Global,
  MAX = Unknown
};

inline const ObjectNamespace (&EnumValuesObjectNamespace())[8] {
  static const ObjectNamespace values[] = {
    ObjectNamespace::Global,
    ObjectNamespace::User,
    ObjectNamespace::Generated,
    ObjectNamespace::Acl,
    ObjectNamespace::Evaluator,
    ObjectNamespace::Drive,
    ObjectNamespace::Notifications,
    ObjectNamespace::Unknown
  };
  return values;
}

inline const char *EnumNameObjectNamespace(ObjectNamespace e) {
  switch (e) {
    case ObjectNamespace::Global: return "Global";
    case ObjectNamespace::User: return "User";
    case ObjectNamespace::Generated: return "Generated";
    case ObjectNamespace::Acl: return "Acl";
    case ObjectNamespace::Evaluator: return "Evaluator";
    case ObjectNamespace::Drive: return "Drive";
    case ObjectNamespace::Notifications: return "Notifications";
    case ObjectNamespace::Unknown: return "Unknown";
    default: return "";
  }
}

struct ObjectId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct ObjectIdBuilder {
  typedef ObjectId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(ObjectId::VT_B, b);
  }
  explicit ObjectIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectId>(end);
    fbb_.Required(o, ObjectId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectId> CreateObjectId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  ObjectIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct ObjectId::Traits {
  using type = ObjectId;
  static auto constexpr Create = CreateObjectId;
};

inline ::flatbuffers::Offset<ObjectId> CreateObjectIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateObjectId(
      _fbb,
      b__);
}

struct ContentId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContentIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct ContentIdBuilder {
  typedef ContentId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(ContentId::VT_B, b);
  }
  explicit ContentIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContentId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContentId>(end);
    fbb_.Required(o, ContentId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<ContentId> CreateContentId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  ContentIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct ContentId::Traits {
  using type = ContentId;
  static auto constexpr Create = CreateContentId;
};

inline ::flatbuffers::Offset<ContentId> CreateContentIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateContentId(
      _fbb,
      b__);
}

struct B2cId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef B2cIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct B2cIdBuilder {
  typedef B2cId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(B2cId::VT_B, b);
  }
  explicit B2cIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<B2cId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<B2cId>(end);
    fbb_.Required(o, B2cId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<B2cId> CreateB2cId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  B2cIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct B2cId::Traits {
  using type = B2cId;
  static auto constexpr Create = CreateB2cId;
};

inline ::flatbuffers::Offset<B2cId> CreateB2cIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateB2cId(
      _fbb,
      b__);
}

struct GenericId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GenericIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct GenericIdBuilder {
  typedef GenericId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(GenericId::VT_B, b);
  }
  explicit GenericIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GenericId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GenericId>(end);
    fbb_.Required(o, GenericId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<GenericId> CreateGenericId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  GenericIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct GenericId::Traits {
  using type = GenericId;
  static auto constexpr Create = CreateGenericId;
};

inline ::flatbuffers::Offset<GenericId> CreateGenericIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateGenericId(
      _fbb,
      b__);
}

struct DataStateId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataStateIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct DataStateIdBuilder {
  typedef DataStateId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(DataStateId::VT_B, b);
  }
  explicit DataStateIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataStateId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataStateId>(end);
    fbb_.Required(o, DataStateId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<DataStateId> CreateDataStateId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  DataStateIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct DataStateId::Traits {
  using type = DataStateId;
  static auto constexpr Create = CreateDataStateId;
};

inline ::flatbuffers::Offset<DataStateId> CreateDataStateIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateDataStateId(
      _fbb,
      b__);
}

struct StreamId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StreamIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct StreamIdBuilder {
  typedef StreamId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(StreamId::VT_B, b);
  }
  explicit StreamIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StreamId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StreamId>(end);
    fbb_.Required(o, StreamId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<StreamId> CreateStreamId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  StreamIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct StreamId::Traits {
  using type = StreamId;
  static auto constexpr Create = CreateStreamId;
};

inline ::flatbuffers::Offset<StreamId> CreateStreamIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateStreamId(
      _fbb,
      b__);
}

struct ColumnGroupId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColumnGroupIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct ColumnGroupIdBuilder {
  typedef ColumnGroupId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(ColumnGroupId::VT_B, b);
  }
  explicit ColumnGroupIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColumnGroupId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColumnGroupId>(end);
    fbb_.Required(o, ColumnGroupId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<ColumnGroupId> CreateColumnGroupId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  ColumnGroupIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct ColumnGroupId::Traits {
  using type = ColumnGroupId;
  static auto constexpr Create = CreateColumnGroupId;
};

inline ::flatbuffers::Offset<ColumnGroupId> CreateColumnGroupIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateColumnGroupId(
      _fbb,
      b__);
}

struct GraphNodeId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphNodeIdBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_B = 4
  };
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           verifier.EndTable();
  }
};

struct GraphNodeIdBuilder {
  typedef GraphNodeId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(GraphNodeId::VT_B, b);
  }
  explicit GraphNodeIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GraphNodeId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GraphNodeId>(end);
    fbb_.Required(o, GraphNodeId::VT_B);
    return o;
  }
};

inline ::flatbuffers::Offset<GraphNodeId> CreateGraphNodeId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0) {
  GraphNodeIdBuilder builder_(_fbb);
  builder_.add_b(b);
  return builder_.Finish();
}

struct GraphNodeId::Traits {
  using type = GraphNodeId;
  static auto constexpr Create = CreateGraphNodeId;
};

inline ::flatbuffers::Offset<GraphNodeId> CreateGraphNodeIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *b = nullptr) {
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  return CreateGraphNodeId(
      _fbb,
      b__);
}

#endif  // FLATBUFFERS_GENERATED_ID_H_
