// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <variant>
#include <vector>

#include "flatbuffers/flatbuffers.h"
#include "ulsdk/types/Schema.h"
#include "ulsdk/types/id.h"
#include "ulsdk/types/reflection.h"
#include "ulsdk/types/generated/data_generated.h"

namespace ul {
namespace types {

struct AttributePair;
struct DirectionAndRoadName;
struct DirectionAndRoadNames;
struct NamedParameter;
struct Source;

using ::DayOfWeek;
using ::DirectionTy;
using ::NamedParameterFlags;
using ::RoadUserTy;
using ::StatisticTy;
using ::TimeGranularity;
using ::TurnTy;
struct AttributePair {
    std::optional<std::string> key_;
    std::optional<std::string> value_;

    AttributePair();
    AttributePair(const ::AttributePair *root);
    AttributePair(const std::vector<uint8_t> &bytes);
};

struct DirectionAndRoadName {
    std::string direction_;
    std::string road_name_;

    DirectionAndRoadName();
    DirectionAndRoadName(const ::DirectionAndRoadName *root);
    DirectionAndRoadName(const std::vector<uint8_t> &bytes);
};

struct DirectionAndRoadNames {
    std::optional<std::vector<DirectionAndRoadName>> direction_and_road_names_;

    DirectionAndRoadNames();
    DirectionAndRoadNames(const ::DirectionAndRoadNames *root);
    DirectionAndRoadNames(const std::vector<uint8_t> &bytes);
};

struct NamedParameter {
    std::optional<std::string> description_;
    uint32_t flags_;
    std::string name_;
    std::optional<Schema> schema_;

    NamedParameter();
    NamedParameter(const ::NamedParameter *root);
    NamedParameter(const std::vector<uint8_t> &bytes);
};

struct Source {
    std::optional<ObjectId> metadata_;
    std::optional<ContentId> metadata_revision_;
    std::string name_;
    std::optional<std::vector<NamedParameter>> named_parameters_;
    std::optional<std::vector<uint8_t>> options_;
    std::optional<std::vector<Schema>> schemas_;
    std::string url_;

    Source();
    Source(const ::Source *root);
    Source(const std::vector<uint8_t> &bytes);
};

::flatbuffers::Offset<::AttributePair>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const AttributePair &);

::flatbuffers::Offset<::DirectionAndRoadName>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DirectionAndRoadName &);

::flatbuffers::Offset<::DirectionAndRoadNames>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DirectionAndRoadNames &);

::flatbuffers::Offset<::NamedParameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NamedParameter &);

::flatbuffers::Offset<::Source>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Source &);


std::vector<uint8_t>
to_bytes(const AttributePair &o);

std::vector<uint8_t>
to_bytes(const DirectionAndRoadName &o);

std::vector<uint8_t>
to_bytes(const DirectionAndRoadNames &o);

std::vector<uint8_t>
to_bytes(const NamedParameter &o);

std::vector<uint8_t>
to_bytes(const Source &o);


} // namespace types
} // namespace ul
