// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <variant>
#include <vector>

#include "flatbuffers/flatbuffers.h"
#include "ulsdk/types/Schema.h"
#include "ulsdk/types/api.h"
#include "ulsdk/types/data.h"
#include "ulsdk/types/entity.h"
#include "ulsdk/types/fun.h"
#include "ulsdk/types/graph.h"
#include "ulsdk/types/id.h"
#include "ulsdk/types/reflection.h"
#include "ulsdk/types/value.h"
#include "ulsdk/types/generated/metadata_generated.h"

namespace ul {
namespace types {

struct CategoryRelationshipData;
struct ContactInfo;
struct DatacatalogGeometry;
struct DatasetSource;
struct Dates;
struct DatetimeRange;
struct Document;
struct Documents;
struct FloatAggregate;
struct FloatBucket;
struct FloatRange;
struct GeometryData;
struct HierarchicalRelationship;
struct HierarchyRelationshipData;
struct IntAggregate;
struct IntBucket;
struct IntRange;
struct IntegerDisplayString;
struct Metadata;
struct NestedCategoryRelationshipData;
struct NestedCategoryRelationshipNode;
struct NestedHierarchyRelationshipData;
struct NestedHierarchyRelationshipNode;
struct NestedStringCategories;
struct NestedStringCategoryNode;
struct NoGeometry;
struct NumericalFieldFormat;
struct RawGeom;
struct StringAggregate;
struct StringCategories;
struct TimeInterval;
struct UIntAggregate;
struct UIntBucket;
struct UlField;
struct UlFieldRelationship;
struct WorldGraphGeometry;

using ::AggregationFunction;
typedef std::variant<
    std::shared_ptr<StringCategories>,
    std::shared_ptr<IntRange>,
    std::shared_ptr<FloatRange>,
    std::shared_ptr<DatetimeRange>,
    std::shared_ptr<Dates>,
    std::shared_ptr<NestedStringCategories>
> ComponentData;

using ::DatasetCategory;
using ::FieldFlags;
using ::FieldUnit;
typedef std::variant<
    std::shared_ptr<RawGeom>,
    std::shared_ptr<NodeIdPair>
> GeometryDataUnion;

typedef std::variant<
    std::shared_ptr<NoGeometry>,
    std::shared_ptr<DatacatalogGeometry>,
    std::shared_ptr<WorldGraphGeometry>
> GeometrySource;

using ::NumericalFieldValueType;
typedef std::variant<
    std::shared_ptr<HierarchyRelationshipData>,
    std::shared_ptr<CategoryRelationshipData>,
    std::shared_ptr<NestedCategoryRelationshipData>,
    std::shared_ptr<NestedHierarchyRelationshipData>
> UlFieldRelationshipData;

using ::UlFieldType;
using ::UpdateCadence;
struct StringCategories {
    std::optional<std::vector<std::string>> categories_;

    StringCategories();
    StringCategories(const ::StringCategories *root);
    StringCategories(const std::vector<uint8_t> &bytes);
};

struct NumericalFieldFormat {
    uint32_t decimal_places_;
    double offset_;
    double scale_;
    NumericalFieldValueType value_type_;

    NumericalFieldFormat();
    NumericalFieldFormat(const ::NumericalFieldFormat *root);
    NumericalFieldFormat(const std::vector<uint8_t> &bytes);
};

struct IntRange {
    AggregationFunction aggregation_protocol_;
    std::optional<std::vector<IntegerDisplayString>> display_strings_;
    std::optional<std::string> enum_name_;
    std::optional<NumericalFieldFormat> field_format_;
    int64_t max_;
    int64_t min_;

    IntRange();
    IntRange(const ::IntRange *root);
    IntRange(const std::vector<uint8_t> &bytes);
};

struct FloatRange {
    AggregationFunction aggregation_protocol_;
    std::optional<NumericalFieldFormat> field_format_;
    double max_;
    double min_;

    FloatRange();
    FloatRange(const ::FloatRange *root);
    FloatRange(const std::vector<uint8_t> &bytes);
};

struct DatetimeRange {
    std::optional<std::vector<TimeInterval>> intervals_;
    int64_t max_;
    int64_t min_;

    DatetimeRange();
    DatetimeRange(const ::DatetimeRange *root);
    DatetimeRange(const std::vector<uint8_t> &bytes);
};

struct Dates {
    int64_t max_;
    int64_t min_;
    std::optional<std::vector<uint32_t>> unique_value_counts_;
    std::optional<std::vector<int64_t>> unique_values_;

    Dates();
    Dates(const ::Dates *root);
    Dates(const std::vector<uint8_t> &bytes);
};

struct NestedStringCategories {
    std::vector<NestedStringCategoryNode> nesting_tree_;

    NestedStringCategories();
    NestedStringCategories(const ::NestedStringCategories *root);
    NestedStringCategories(const std::vector<uint8_t> &bytes);
};

struct RawGeom {
    std::vector<uint8_t> geom_;

    RawGeom();
    RawGeom(const ::RawGeom *root);
    RawGeom(const std::vector<uint8_t> &bytes);
};

struct NoGeometry {

    NoGeometry();
    NoGeometry(const ::NoGeometry *root);
    NoGeometry(const std::vector<uint8_t> &bytes);
};

struct DatacatalogGeometry {
    std::string column_;

    DatacatalogGeometry();
    DatacatalogGeometry(const ::DatacatalogGeometry *root);
    DatacatalogGeometry(const std::vector<uint8_t> &bytes);
};

struct WorldGraphGeometry {
    std::vector<EdgeTy> edge_path_;
    std::optional<ObjectId> start_stream_id_;

    WorldGraphGeometry();
    WorldGraphGeometry(const ::WorldGraphGeometry *root);
    WorldGraphGeometry(const std::vector<uint8_t> &bytes);
};

struct HierarchyRelationshipData {
    std::optional<std::vector<HierarchicalRelationship>> hierarchy_;

    HierarchyRelationshipData();
    HierarchyRelationshipData(const ::HierarchyRelationshipData *root);
    HierarchyRelationshipData(const std::vector<uint8_t> &bytes);
};

struct CategoryRelationshipData {
    std::optional<std::vector<int32_t>> associated_fields_;
    std::optional<std::vector<int32_t>> categories_;

    CategoryRelationshipData();
    CategoryRelationshipData(const ::CategoryRelationshipData *root);
    CategoryRelationshipData(const std::vector<uint8_t> &bytes);
};

struct NestedCategoryRelationshipData {
    std::optional<std::vector<NestedCategoryRelationshipNode>> categories_;

    NestedCategoryRelationshipData();
    NestedCategoryRelationshipData(const ::NestedCategoryRelationshipData *root);
    NestedCategoryRelationshipData(const std::vector<uint8_t> &bytes);
};

struct NestedHierarchyRelationshipData {
    std::optional<std::vector<NestedHierarchyRelationshipNode>> nodes_;

    NestedHierarchyRelationshipData();
    NestedHierarchyRelationshipData(const ::NestedHierarchyRelationshipData *root);
    NestedHierarchyRelationshipData(const std::vector<uint8_t> &bytes);
};

struct ContactInfo {
    std::optional<std::string> address_;
    std::optional<std::string> email_;
    std::optional<std::string> name_;
    std::optional<std::string> phone_;
    std::optional<std::string> url_;

    ContactInfo();
    ContactInfo(const ::ContactInfo *root);
    ContactInfo(const std::vector<uint8_t> &bytes);
};

struct DatasetSource {
    std::optional<std::string> date_;
    std::optional<std::string> source_;
    std::optional<std::string> url_;

    DatasetSource();
    DatasetSource(const ::DatasetSource *root);
    DatasetSource(const std::vector<uint8_t> &bytes);
};

struct Document {
    std::optional<std::string> display_name_;
    std::optional<std::string> filename_;
    std::optional<std::string> mime_type_;
    std::optional<std::string> url_;

    Document();
    Document(const ::Document *root);
    Document(const std::vector<uint8_t> &bytes);
};

struct Documents {
    std::optional<std::vector<Document>> documents_;

    Documents();
    Documents(const ::Documents *root);
    Documents(const std::vector<uint8_t> &bytes);
};

struct FloatAggregate {
    uint64_t count_;
    std::optional<std::vector<FloatBucket>> histo_;
    double max_;
    double mean_;
    double min_;
    double sum_;
    double variance_;

    FloatAggregate();
    FloatAggregate(const ::FloatAggregate *root);
    FloatAggregate(const std::vector<uint8_t> &bytes);
};

struct FloatBucket {
    uint64_t count_;
    double max_;

    FloatBucket();
    FloatBucket(const ::FloatBucket *root);
};

struct GeometryData {
    GeometryDataUnion data_;

    GeometryData();
    GeometryData(const ::GeometryData *root);
    GeometryData(const std::vector<uint8_t> &bytes);
};

struct HierarchicalRelationship {
    std::optional<std::vector<int32_t>> children_;
    int32_t parent_;

    HierarchicalRelationship();
    HierarchicalRelationship(const ::HierarchicalRelationship *root);
    HierarchicalRelationship(const std::vector<uint8_t> &bytes);
};

struct IntAggregate {
    uint64_t count_;
    std::optional<std::vector<UIntBucket>> histo_;
    int64_t max_;
    int64_t mean_;
    int64_t min_;
    int64_t sum_;
    int64_t variance_;

    IntAggregate();
    IntAggregate(const ::IntAggregate *root);
    IntAggregate(const std::vector<uint8_t> &bytes);
};

struct IntBucket {
    uint64_t count_;
    int64_t max_;

    IntBucket();
    IntBucket(const ::IntBucket *root);
};

struct IntegerDisplayString {
    std::string display_name_;
    int64_t value_;

    IntegerDisplayString();
    IntegerDisplayString(const ::IntegerDisplayString *root);
    IntegerDisplayString(const std::vector<uint8_t> &bytes);
};

struct Metadata {
    bool area_selection_;
    DatasetCategory dataset_category_;
    std::optional<std::string> description_;
    std::optional<std::string> display_name_;
    bool do_not_filter_geometry_by_viewport_;
    EntityTy entity_ty_;
    std::optional<std::vector<UlFieldRelationship>> field_relationships_;
    std::optional<std::vector<UlField>> fields_;
    std::optional<GeometrySource> geometry_source_;
    std::optional<DatasetSource> source_;
    std::optional<std::vector<int32_t>> summary_;
    UpdateCadence update_cadence_;

    Metadata();
    Metadata(const ::Metadata *root);
    Metadata(const std::vector<uint8_t> &bytes);
};

struct NestedCategoryRelationshipNode {
    std::optional<std::vector<int32_t>> child_columns_;
    int32_t column_;

    NestedCategoryRelationshipNode();
    NestedCategoryRelationshipNode(const ::NestedCategoryRelationshipNode *root);
    NestedCategoryRelationshipNode(const std::vector<uint8_t> &bytes);
};

struct NestedHierarchyRelationshipNode {
    std::optional<std::vector<int32_t>> child_columns_;
    std::optional<std::vector<int32_t>> child_nodes_;
    std::optional<std::string> label_;

    NestedHierarchyRelationshipNode();
    NestedHierarchyRelationshipNode(const ::NestedHierarchyRelationshipNode *root);
    NestedHierarchyRelationshipNode(const std::vector<uint8_t> &bytes);
};

struct NestedStringCategoryNode {
    std::vector<std::string> child_values_;
    std::optional<std::string> value_;

    NestedStringCategoryNode();
    NestedStringCategoryNode(const ::NestedStringCategoryNode *root);
    NestedStringCategoryNode(const std::vector<uint8_t> &bytes);
};

struct StringAggregate {
    uint64_t count_;
    std::optional<std::string> str_;

    StringAggregate();
    StringAggregate(const ::StringAggregate *root);
    StringAggregate(const std::vector<uint8_t> &bytes);
};

struct TimeInterval {
    int64_t max_;
    int64_t min_;

    TimeInterval();
    TimeInterval(const ::TimeInterval *root);
    TimeInterval(const std::vector<uint8_t> &bytes);
};

struct UIntAggregate {
    uint64_t count_;
    std::optional<std::vector<UIntBucket>> histo_;
    uint64_t max_;
    uint64_t mean_;
    uint64_t min_;
    uint64_t sum_;
    uint64_t variance_;

    UIntAggregate();
    UIntAggregate(const ::UIntAggregate *root);
    UIntAggregate(const std::vector<uint8_t> &bytes);
};

struct UIntBucket {
    uint64_t count_;
    uint64_t max_;

    UIntBucket();
    UIntBucket(const ::UIntBucket *root);
};

struct UlField {
    std::optional<std::string> breakdown_display_name_;
    std::optional<ComponentData> component_data_;
    std::optional<ValueInstance> default_;
    std::optional<std::string> description_;
    std::optional<std::string> display_name_;
    std::optional<std::string> field_name_;
    UlFieldType field_type_;
    uint32_t flags_;
    std::optional<Type> storage_type_;
    FieldUnit unit_;

    UlField();
    UlField(const ::UlField *root);
    UlField(const std::vector<uint8_t> &bytes);
};

struct UlFieldRelationship {
    std::optional<UlFieldRelationshipData> relationship_data_;
    std::optional<std::string> relationship_display_name_;

    UlFieldRelationship();
    UlFieldRelationship(const ::UlFieldRelationship *root);
    UlFieldRelationship(const std::vector<uint8_t> &bytes);
};

std::pair<::flatbuffers::Offset<void>, ::ComponentData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ComponentData &o);
std::pair<::flatbuffers::Offset<void>, ::GeometryDataUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GeometryDataUnion &o);
std::pair<::flatbuffers::Offset<void>, ::GeometrySource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GeometrySource &o);
std::pair<::flatbuffers::Offset<void>, ::UlFieldRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UlFieldRelationshipData &o);
::flatbuffers::Offset<::StringCategories>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const StringCategories &);

::flatbuffers::Offset<::NumericalFieldFormat>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NumericalFieldFormat &);

::flatbuffers::Offset<::IntRange>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const IntRange &);

::flatbuffers::Offset<::FloatRange>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FloatRange &);

::flatbuffers::Offset<::DatetimeRange>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DatetimeRange &);

::flatbuffers::Offset<::Dates>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Dates &);

::flatbuffers::Offset<::NestedStringCategories>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedStringCategories &);

::flatbuffers::Offset<::RawGeom>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RawGeom &);

::flatbuffers::Offset<::NoGeometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NoGeometry &);

::flatbuffers::Offset<::DatacatalogGeometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DatacatalogGeometry &);

::flatbuffers::Offset<::WorldGraphGeometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorldGraphGeometry &);

::flatbuffers::Offset<::HierarchyRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const HierarchyRelationshipData &);

::flatbuffers::Offset<::CategoryRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const CategoryRelationshipData &);

::flatbuffers::Offset<::NestedCategoryRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedCategoryRelationshipData &);

::flatbuffers::Offset<::NestedHierarchyRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedHierarchyRelationshipData &);

::flatbuffers::Offset<::ContactInfo>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ContactInfo &);

::flatbuffers::Offset<::DatasetSource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DatasetSource &);

::flatbuffers::Offset<::Document>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Document &);

::flatbuffers::Offset<::Documents>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Documents &);

::flatbuffers::Offset<::FloatAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FloatAggregate &);

::flatbuffers::Offset<::GeometryData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GeometryData &);

::flatbuffers::Offset<::HierarchicalRelationship>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const HierarchicalRelationship &);

::flatbuffers::Offset<::IntAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const IntAggregate &);

::flatbuffers::Offset<::IntegerDisplayString>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const IntegerDisplayString &);

::flatbuffers::Offset<::Metadata>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Metadata &);

::flatbuffers::Offset<::NestedCategoryRelationshipNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedCategoryRelationshipNode &);

::flatbuffers::Offset<::NestedHierarchyRelationshipNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedHierarchyRelationshipNode &);

::flatbuffers::Offset<::NestedStringCategoryNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedStringCategoryNode &);

::flatbuffers::Offset<::StringAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const StringAggregate &);

::flatbuffers::Offset<::TimeInterval>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TimeInterval &);

::flatbuffers::Offset<::UIntAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UIntAggregate &);

::flatbuffers::Offset<::UlField>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UlField &);

::flatbuffers::Offset<::UlFieldRelationship>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UlFieldRelationship &);


std::vector<uint8_t>
to_bytes(const StringCategories &o);

std::vector<uint8_t>
to_bytes(const NumericalFieldFormat &o);

std::vector<uint8_t>
to_bytes(const IntRange &o);

std::vector<uint8_t>
to_bytes(const FloatRange &o);

std::vector<uint8_t>
to_bytes(const DatetimeRange &o);

std::vector<uint8_t>
to_bytes(const Dates &o);

std::vector<uint8_t>
to_bytes(const NestedStringCategories &o);

std::vector<uint8_t>
to_bytes(const RawGeom &o);

std::vector<uint8_t>
to_bytes(const NoGeometry &o);

std::vector<uint8_t>
to_bytes(const DatacatalogGeometry &o);

std::vector<uint8_t>
to_bytes(const WorldGraphGeometry &o);

std::vector<uint8_t>
to_bytes(const HierarchyRelationshipData &o);

std::vector<uint8_t>
to_bytes(const CategoryRelationshipData &o);

std::vector<uint8_t>
to_bytes(const NestedCategoryRelationshipData &o);

std::vector<uint8_t>
to_bytes(const NestedHierarchyRelationshipData &o);

std::vector<uint8_t>
to_bytes(const ContactInfo &o);

std::vector<uint8_t>
to_bytes(const DatasetSource &o);

std::vector<uint8_t>
to_bytes(const Document &o);

std::vector<uint8_t>
to_bytes(const Documents &o);

std::vector<uint8_t>
to_bytes(const FloatAggregate &o);

std::vector<uint8_t>
to_bytes(const GeometryData &o);

std::vector<uint8_t>
to_bytes(const HierarchicalRelationship &o);

std::vector<uint8_t>
to_bytes(const IntAggregate &o);

std::vector<uint8_t>
to_bytes(const IntegerDisplayString &o);

std::vector<uint8_t>
to_bytes(const Metadata &o);

std::vector<uint8_t>
to_bytes(const NestedCategoryRelationshipNode &o);

std::vector<uint8_t>
to_bytes(const NestedHierarchyRelationshipNode &o);

std::vector<uint8_t>
to_bytes(const NestedStringCategoryNode &o);

std::vector<uint8_t>
to_bytes(const StringAggregate &o);

std::vector<uint8_t>
to_bytes(const TimeInterval &o);

std::vector<uint8_t>
to_bytes(const UIntAggregate &o);

std::vector<uint8_t>
to_bytes(const UlField &o);

std::vector<uint8_t>
to_bytes(const UlFieldRelationship &o);


} // namespace types
} // namespace ul
