// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <variant>
#include <vector>

#include "flatbuffers/flatbuffers.h"
#include "ulsdk/types/id.h"
#include "ulsdk/types/generated/entity_generated.h"

namespace ul {
namespace types {

struct GraphEdge;
struct GraphNode;
struct Line;
struct MultiLine;
struct MultiPolygon;
struct Point;
struct Polygon;

using ::EdgeTy;
using ::EntityTy;
typedef std::variant<
    std::shared_ptr<Point>,
    std::shared_ptr<Line>,
    std::shared_ptr<MultiLine>,
    std::shared_ptr<Polygon>,
    std::shared_ptr<MultiPolygon>
> Geometry;

using ::NodeTy;
struct Point {
    std::vector<float> point_geo_;

    Point();
    Point(const ::Point *root);
    Point(const std::vector<uint8_t> &bytes);
};

struct Line {
    std::vector<Point> line_geo_;

    Line();
    Line(const ::Line *root);
    Line(const std::vector<uint8_t> &bytes);
};

struct MultiLine {
    std::vector<Line> multiline_geo_;

    MultiLine();
    MultiLine(const ::MultiLine *root);
    MultiLine(const std::vector<uint8_t> &bytes);
};

struct Polygon {
    std::vector<Line> polygon_geo_;

    Polygon();
    Polygon(const ::Polygon *root);
    Polygon(const std::vector<uint8_t> &bytes);
};

struct MultiPolygon {
    std::vector<Polygon> multipolygon_geo_;

    MultiPolygon();
    MultiPolygon(const ::MultiPolygon *root);
    MultiPolygon(const std::vector<uint8_t> &bytes);
};

struct GraphEdge {
    int64_t _from_;
    EdgeTy _kind_;
    int64_t _to_;

    GraphEdge();
    GraphEdge(const ::GraphEdge *root);
    GraphEdge(const std::vector<uint8_t> &bytes);
};

struct GraphNode {
    std::optional<std::string> _description_;
    EntityTy _entity_type_;
    std::optional<Geometry> _geom_;
    std::optional<Point> _location_;
    std::optional<GenericId> _node_id_;
    NodeTy _node_type_;
    std::optional<ObjectId> _stream_;
    uint64_t _uid_;

    GraphNode();
    GraphNode(const ::GraphNode *root);
    GraphNode(const std::vector<uint8_t> &bytes);
};

std::pair<::flatbuffers::Offset<void>, ::Geometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Geometry &o);
::flatbuffers::Offset<::Point>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Point &);

::flatbuffers::Offset<::Line>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Line &);

::flatbuffers::Offset<::MultiLine>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const MultiLine &);

::flatbuffers::Offset<::Polygon>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Polygon &);

::flatbuffers::Offset<::MultiPolygon>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const MultiPolygon &);

::flatbuffers::Offset<::GraphEdge>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GraphEdge &);

::flatbuffers::Offset<::GraphNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GraphNode &);


std::vector<uint8_t>
to_bytes(const Point &o);

std::vector<uint8_t>
to_bytes(const Line &o);

std::vector<uint8_t>
to_bytes(const MultiLine &o);

std::vector<uint8_t>
to_bytes(const Polygon &o);

std::vector<uint8_t>
to_bytes(const MultiPolygon &o);

std::vector<uint8_t>
to_bytes(const GraphEdge &o);

std::vector<uint8_t>
to_bytes(const GraphNode &o);


} // namespace types
} // namespace ul
