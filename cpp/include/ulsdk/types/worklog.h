// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <variant>
#include <vector>

#include "flatbuffers/flatbuffers.h"
#include "ulsdk/types/Schema.h"
#include "ulsdk/types/data.h"
#include "ulsdk/types/id.h"
#include "ulsdk/types/job.h"
#include "ulsdk/types/reflection.h"
#include "ulsdk/types/value.h"
#include "ulsdk/types/generated/worklog_generated.h"

namespace ul {
namespace types {

struct ByteArray;
struct Layout;
struct ParameterFlags;
struct TileData;
struct TileSettings;
struct UserSettings;
struct WorkLog;
struct WorklogParameter;

using ::AggregationTy;
using ::ChartTypeTy;
typedef std::variant<
    std::shared_ptr<ByteArray>,
    std::shared_ptr<ObjectId>,
    std::shared_ptr<ParameterFlags>,
    std::shared_ptr<ValueInstance>
> ParameterValue;

using ::ValuesFormatTy;
struct ByteArray {
    std::optional<std::vector<uint8_t>> b_;

    ByteArray();
    ByteArray(const ::ByteArray *root);
    ByteArray(const std::vector<uint8_t> &bytes);
};

struct ParameterFlags {
    int64_t flags_;

    ParameterFlags();
    ParameterFlags(const ::ParameterFlags *root);
    ParameterFlags(const std::vector<uint8_t> &bytes);
};

struct Layout {
    uint32_t height_;
    uint32_t width_;
    uint32_t x_;
    uint32_t y_;

    Layout();
    Layout(const ::Layout *root);
    Layout(const std::vector<uint8_t> &bytes);
};

struct TileSettings {
    AggregationTy aggregation_;
    uint32_t category_;
    ChartTypeTy chart_type_;
    std::string field_name_;
    bool group_others_;
    bool is_record_count_tile_;
    bool is_relationship_field_;
    ObjectId metadata_id_;
    uint32_t output_stream_index_;
    std::optional<ObjectId> record_count_stream_id_;
    std::vector<std::string> selected_columns_;
    uint32_t text_tile_font_size_;
    std::string title_;
    ValuesFormatTy values_format_;

    TileSettings();
    TileSettings(const ::TileSettings *root);
    TileSettings(const std::vector<uint8_t> &bytes);
};

struct TileData {
    Layout layout_;
    TileSettings tile_settings_;

    TileData();
    TileData(const ::TileData *root);
    TileData(const std::vector<uint8_t> &bytes);
};

struct UserSettings {
    bool is_template_;
    std::vector<TileData> tile_data_;

    UserSettings();
    UserSettings(const ::UserSettings *root);
    UserSettings(const std::vector<uint8_t> &bytes);
};

struct WorkLog {
    std::optional<std::vector<ObjectId>> input_streams_;
    std::optional<ObjectId> job_id_;
    std::optional<std::string> name_;
    std::vector<ObjectId> output_streams_;
    std::vector<WorklogParameter> params_;
    std::optional<ObjectId> parent_;
    ObjectId schematic_;
    std::optional<UserSettings> user_settings_;

    WorkLog();
    WorkLog(const ::WorkLog *root);
    WorkLog(const std::vector<uint8_t> &bytes);
};

struct WorklogParameter {
    std::string key_;
    std::optional<ParameterValue> value_;

    WorklogParameter();
    WorklogParameter(const ::WorklogParameter *root);
    WorklogParameter(const std::vector<uint8_t> &bytes);
};

std::pair<::flatbuffers::Offset<void>, ::ParameterValue>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterValue &o);
::flatbuffers::Offset<::ByteArray>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ByteArray &);

::flatbuffers::Offset<::ParameterFlags>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterFlags &);

::flatbuffers::Offset<::Layout>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Layout &);

::flatbuffers::Offset<::TileSettings>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TileSettings &);

::flatbuffers::Offset<::TileData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TileData &);

::flatbuffers::Offset<::UserSettings>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UserSettings &);

::flatbuffers::Offset<::WorkLog>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorkLog &);

::flatbuffers::Offset<::WorklogParameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorklogParameter &);


std::vector<uint8_t>
to_bytes(const ByteArray &o);

std::vector<uint8_t>
to_bytes(const ParameterFlags &o);

std::vector<uint8_t>
to_bytes(const Layout &o);

std::vector<uint8_t>
to_bytes(const TileSettings &o);

std::vector<uint8_t>
to_bytes(const TileData &o);

std::vector<uint8_t>
to_bytes(const UserSettings &o);

std::vector<uint8_t>
to_bytes(const WorkLog &o);

std::vector<uint8_t>
to_bytes(const WorklogParameter &o);


} // namespace types
} // namespace ul
