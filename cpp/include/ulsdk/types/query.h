// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <variant>
#include <vector>

#include "flatbuffers/flatbuffers.h"
#include "ulsdk/types/api.h"
#include "ulsdk/types/entity.h"
#include "ulsdk/types/fun.h"
#include "ulsdk/types/graph.h"
#include "ulsdk/types/id.h"
#include "ulsdk/types/value.h"
#include "ulsdk/types/generated/query_generated.h"

namespace ul {
namespace types {

struct AllColumns;
struct Arrow;
struct BinaryQueryElement;
struct Case;
struct Column;
struct DataCatalog;
struct DeleteQueryElement;
struct Distinct;
struct Expr;
struct Function;
struct Join;
struct MvdbSubcollection;
struct NullableUint;
struct OrderByExpr;
struct Parameter;
struct ParameterInstance;
struct ParameterizedQuery;
struct Partition;
struct Query;
struct QueryElement;
struct QueryTableSource;
struct SetExpr;
struct TableOrderBy;
struct TableSource;
struct UnaryQueryElement;
struct UnsetArgument;
struct UpdateQueryElement;
struct ValueIndex;
struct Vector;
struct When;
struct Window;
struct WorklogSubcollection;

typedef std::variant<
    std::shared_ptr<ValueIndex>,
    std::shared_ptr<Column>,
    std::shared_ptr<Function>,
    std::shared_ptr<AllColumns>,
    std::shared_ptr<Case>,
    std::shared_ptr<OrderByExpr>,
    std::shared_ptr<Partition>,
    std::shared_ptr<UnsetArgument>,
    std::shared_ptr<Window>
> ExprUnion;

using ::JoinTy;
typedef std::variant<
    std::shared_ptr<Parameter>,
    std::shared_ptr<ValueInstance>
> ParameterSlot;

using ::QueryElementOp;
typedef std::variant<
    std::shared_ptr<UnaryQueryElement>,
    std::shared_ptr<BinaryQueryElement>,
    std::shared_ptr<UpdateQueryElement>,
    std::shared_ptr<DeleteQueryElement>
> QueryElementUnion;

typedef std::variant<
    std::shared_ptr<MvdbSubcollection>,
    std::shared_ptr<WorklogSubcollection>
> Subcollection;

typedef std::variant<
    std::shared_ptr<DataCatalog>,
    std::shared_ptr<Arrow>,
    std::shared_ptr<GraphQuery>,
    std::shared_ptr<QueryTableSource>,
    std::shared_ptr<Vector>
> TableSourceUnion;

using ::TypeHint;
struct ValueIndex {
    uint32_t idx_;

    ValueIndex();
    ValueIndex(const ::ValueIndex *root);
    ValueIndex(const std::vector<uint8_t> &bytes);
};

struct NullableUint {
    uint32_t v_;

    NullableUint();
    NullableUint(const ::NullableUint *root);
    NullableUint(const std::vector<uint8_t> &bytes);
};

struct Column {
    std::string name_;
    std::optional<NullableUint> source_;
    TypeHint type_hint_;

    Column();
    Column(const ::Column *root);
    Column(const std::vector<uint8_t> &bytes);
};

struct Function {
    Fn fn_;
    std::vector<Expr> parameters_;

    Function();
    Function(const ::Function *root);
    Function(const std::vector<uint8_t> &bytes);
};

struct AllColumns {
    std::optional<NullableUint> source_;

    AllColumns();
    AllColumns(const ::AllColumns *root);
    AllColumns(const std::vector<uint8_t> &bytes);
};

struct Expr {
    ExprUnion exprs_;

    Expr();
    Expr(const ::Expr *root);
    Expr(const std::vector<uint8_t> &bytes);
};

struct Case {
    std::optional<Expr> else_;
    std::vector<When> when_;

    Case();
    Case(const ::Case *root);
    Case(const std::vector<uint8_t> &bytes);
};

struct OrderByExpr {
    std::vector<OrderBy> order_by_;

    OrderByExpr();
    OrderByExpr(const ::OrderByExpr *root);
    OrderByExpr(const std::vector<uint8_t> &bytes);
};

struct Partition {
    Expr expr_;

    Partition();
    Partition(const ::Partition *root);
    Partition(const std::vector<uint8_t> &bytes);
};

struct UnsetArgument {

    UnsetArgument();
    UnsetArgument(const ::UnsetArgument *root);
    UnsetArgument(const std::vector<uint8_t> &bytes);
};

struct Window {
    Function fun_;
    std::optional<std::vector<OrderBy>> order_by_;
    std::optional<std::vector<Expr>> partition_;

    Window();
    Window(const ::Window *root);
    Window(const std::vector<uint8_t> &bytes);
};

struct Parameter {
    TypeHint hint_;
    std::string name_;
    ValueTy ty_;

    Parameter();
    Parameter(const ::Parameter *root);
    Parameter(const std::vector<uint8_t> &bytes);
};

struct Distinct {
    std::optional<std::vector<Expr>> on_;

    Distinct();
    Distinct(const ::Distinct *root);
    Distinct(const std::vector<uint8_t> &bytes);
};

struct UnaryQueryElement {
    std::optional<Distinct> distinct_;
    std::optional<std::vector<Expr>> fields_;
    std::optional<Function> filter_;
    std::optional<std::vector<Expr>> group_by_;
    std::optional<std::vector<Join>> joins_;
    uint32_t limit_;
    std::optional<std::vector<TableOrderBy>> order_by_;
    std::vector<TableSource> sources_;

    UnaryQueryElement();
    UnaryQueryElement(const ::UnaryQueryElement *root);
    UnaryQueryElement(const std::vector<uint8_t> &bytes);
};

struct QueryElement {
    std::optional<QueryElementUnion> q_;

    QueryElement();
    QueryElement(const ::QueryElement *root);
    QueryElement(const std::vector<uint8_t> &bytes);
};

struct BinaryQueryElement {
    QueryElement lhs_;
    QueryElementOp op_;
    QueryElement rhs_;

    BinaryQueryElement();
    BinaryQueryElement(const ::BinaryQueryElement *root);
    BinaryQueryElement(const std::vector<uint8_t> &bytes);
};

struct MvdbSubcollection {
    std::string subcollection_;

    MvdbSubcollection();
    MvdbSubcollection(const ::MvdbSubcollection *root);
    MvdbSubcollection(const std::vector<uint8_t> &bytes);
};

struct WorklogSubcollection {
    uint32_t idx_;

    WorklogSubcollection();
    WorklogSubcollection(const ::WorklogSubcollection *root);
    WorklogSubcollection(const std::vector<uint8_t> &bytes);
};

struct DataCatalog {
    ObjectId id_;
    std::optional<ContentId> revision_;
    std::optional<Subcollection> subcollection_;

    DataCatalog();
    DataCatalog(const ::DataCatalog *root);
    DataCatalog(const std::vector<uint8_t> &bytes);
};

struct Arrow {
    std::vector<uint8_t> value_;

    Arrow();
    Arrow(const ::Arrow *root);
    Arrow(const std::vector<uint8_t> &bytes);
};

struct Query {
    uint32_t limit_;
    QueryElement query_;
    std::optional<std::vector<ValueInstance>> values_;

    Query();
    Query(const ::Query *root);
    Query(const std::vector<uint8_t> &bytes);
};

struct QueryTableSource {
    Query q_;

    QueryTableSource();
    QueryTableSource(const ::QueryTableSource *root);
    QueryTableSource(const std::vector<uint8_t> &bytes);
};

struct Vector {
    std::vector<ObjectId> ids_;
    std::optional<NullableUint> limit_;
    float max_distance_;
    std::string query_;

    Vector();
    Vector(const ::Vector *root);
    Vector(const std::vector<uint8_t> &bytes);
};

struct UpdateQueryElement {
    std::optional<Function> filter_;
    std::vector<SetExpr> sets_;
    TableSourceUnion source_;

    UpdateQueryElement();
    UpdateQueryElement(const ::UpdateQueryElement *root);
    UpdateQueryElement(const std::vector<uint8_t> &bytes);
};

struct DeleteQueryElement {
    std::optional<Function> filter_;
    TableSourceUnion source_;

    DeleteQueryElement();
    DeleteQueryElement(const ::DeleteQueryElement *root);
    DeleteQueryElement(const std::vector<uint8_t> &bytes);
};

struct Join {
    std::optional<std::string> dest_col_;
    uint32_t dest_idx_;
    std::optional<std::string> src_col_;
    uint32_t src_idx_;
    JoinTy ty_;

    Join();
    Join(const ::Join *root);
    Join(const std::vector<uint8_t> &bytes);
};

struct ParameterInstance {
    ParameterSlot p_;

    ParameterInstance();
    ParameterInstance(const ::ParameterInstance *root);
    ParameterInstance(const std::vector<uint8_t> &bytes);
};

struct ParameterizedQuery {
    uint32_t limit_;
    std::optional<std::vector<ParameterInstance>> parameters_;
    QueryElement query_;

    ParameterizedQuery();
    ParameterizedQuery(const ::ParameterizedQuery *root);
    ParameterizedQuery(const std::vector<uint8_t> &bytes);
};

struct SetExpr {
    std::string col_;
    Expr expr_;

    SetExpr();
    SetExpr(const ::SetExpr *root);
    SetExpr(const std::vector<uint8_t> &bytes);
};

struct TableOrderBy {
    OrderBy order_by_;
    uint32_t source_;
    bool use_source_;

    TableOrderBy();
    TableOrderBy(const ::TableOrderBy *root);
    TableOrderBy(const std::vector<uint8_t> &bytes);
};

struct TableSource {
    std::optional<std::vector<Expr>> fields_;
    std::optional<Function> filter_;
    std::optional<std::vector<Expr>> group_by_;
    std::optional<std::vector<OrderBy>> order_by_;
    TableSourceUnion t_;

    TableSource();
    TableSource(const ::TableSource *root);
    TableSource(const std::vector<uint8_t> &bytes);
};

struct When {
    Expr cond_;
    Expr value_;

    When();
    When(const ::When *root);
    When(const std::vector<uint8_t> &bytes);
};

std::pair<::flatbuffers::Offset<void>, ::ExprUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ExprUnion &o);
std::pair<::flatbuffers::Offset<void>, ::ParameterSlot>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterSlot &o);
std::pair<::flatbuffers::Offset<void>, ::QueryElementUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryElementUnion &o);
std::pair<::flatbuffers::Offset<void>, ::Subcollection>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Subcollection &o);
std::pair<::flatbuffers::Offset<void>, ::TableSourceUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TableSourceUnion &o);
::flatbuffers::Offset<::ValueIndex>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ValueIndex &);

::flatbuffers::Offset<::NullableUint>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NullableUint &);

::flatbuffers::Offset<::Column>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Column &);

::flatbuffers::Offset<::Function>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Function &);

::flatbuffers::Offset<::AllColumns>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const AllColumns &);

::flatbuffers::Offset<::Expr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Expr &);

::flatbuffers::Offset<::Case>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Case &);

::flatbuffers::Offset<::OrderByExpr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const OrderByExpr &);

::flatbuffers::Offset<::Partition>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Partition &);

::flatbuffers::Offset<::UnsetArgument>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UnsetArgument &);

::flatbuffers::Offset<::Window>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Window &);

::flatbuffers::Offset<::Parameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Parameter &);

::flatbuffers::Offset<::Distinct>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Distinct &);

::flatbuffers::Offset<::UnaryQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UnaryQueryElement &);

::flatbuffers::Offset<::QueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryElement &);

::flatbuffers::Offset<::BinaryQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const BinaryQueryElement &);

::flatbuffers::Offset<::MvdbSubcollection>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const MvdbSubcollection &);

::flatbuffers::Offset<::WorklogSubcollection>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorklogSubcollection &);

::flatbuffers::Offset<::DataCatalog>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DataCatalog &);

::flatbuffers::Offset<::Arrow>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Arrow &);

::flatbuffers::Offset<::Query>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Query &);

::flatbuffers::Offset<::QueryTableSource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryTableSource &);

::flatbuffers::Offset<::Vector>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Vector &);

::flatbuffers::Offset<::UpdateQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UpdateQueryElement &);

::flatbuffers::Offset<::DeleteQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DeleteQueryElement &);

::flatbuffers::Offset<::Join>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Join &);

::flatbuffers::Offset<::ParameterInstance>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterInstance &);

::flatbuffers::Offset<::ParameterizedQuery>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterizedQuery &);

::flatbuffers::Offset<::SetExpr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const SetExpr &);

::flatbuffers::Offset<::TableOrderBy>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TableOrderBy &);

::flatbuffers::Offset<::TableSource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TableSource &);

::flatbuffers::Offset<::When>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const When &);


std::vector<uint8_t>
to_bytes(const ValueIndex &o);

std::vector<uint8_t>
to_bytes(const NullableUint &o);

std::vector<uint8_t>
to_bytes(const Column &o);

std::vector<uint8_t>
to_bytes(const Function &o);

std::vector<uint8_t>
to_bytes(const AllColumns &o);

std::vector<uint8_t>
to_bytes(const Expr &o);

std::vector<uint8_t>
to_bytes(const Case &o);

std::vector<uint8_t>
to_bytes(const OrderByExpr &o);

std::vector<uint8_t>
to_bytes(const Partition &o);

std::vector<uint8_t>
to_bytes(const UnsetArgument &o);

std::vector<uint8_t>
to_bytes(const Window &o);

std::vector<uint8_t>
to_bytes(const Parameter &o);

std::vector<uint8_t>
to_bytes(const Distinct &o);

std::vector<uint8_t>
to_bytes(const UnaryQueryElement &o);

std::vector<uint8_t>
to_bytes(const QueryElement &o);

std::vector<uint8_t>
to_bytes(const BinaryQueryElement &o);

std::vector<uint8_t>
to_bytes(const MvdbSubcollection &o);

std::vector<uint8_t>
to_bytes(const WorklogSubcollection &o);

std::vector<uint8_t>
to_bytes(const DataCatalog &o);

std::vector<uint8_t>
to_bytes(const Arrow &o);

std::vector<uint8_t>
to_bytes(const Query &o);

std::vector<uint8_t>
to_bytes(const QueryTableSource &o);

std::vector<uint8_t>
to_bytes(const Vector &o);

std::vector<uint8_t>
to_bytes(const UpdateQueryElement &o);

std::vector<uint8_t>
to_bytes(const DeleteQueryElement &o);

std::vector<uint8_t>
to_bytes(const Join &o);

std::vector<uint8_t>
to_bytes(const ParameterInstance &o);

std::vector<uint8_t>
to_bytes(const ParameterizedQuery &o);

std::vector<uint8_t>
to_bytes(const SetExpr &o);

std::vector<uint8_t>
to_bytes(const TableOrderBy &o);

std::vector<uint8_t>
to_bytes(const TableSource &o);

std::vector<uint8_t>
to_bytes(const When &o);


} // namespace types
} // namespace ul
