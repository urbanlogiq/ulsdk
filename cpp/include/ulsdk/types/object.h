// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#pragma once

#include <cstdint>
#include <memory>
#include <optional>
#include <variant>
#include <vector>

#include "flatbuffers/flatbuffers.h"
#include "ulsdk/types/Schema.h"
#include "ulsdk/types/data.h"
#include "ulsdk/types/id.h"
#include "ulsdk/types/job.h"
#include "ulsdk/types/reflection.h"
#include "ulsdk/types/stream.h"
#include "ulsdk/types/value.h"
#include "ulsdk/types/worklog.h"
#include "ulsdk/types/generated/object_generated.h"

namespace ul {
namespace types {

struct DataCatalogObject;
struct ObjectIdList;
struct ObjectIdPair;
struct ObjectIdPairList;
struct ObjectSummary;
struct ObjectSummaryList;

using ::DataCatalogObjectFlags;
using ::DataCatalogObjectTy;
struct DataCatalogObject {
    std::optional<std::vector<AttributePair>> attributes_;
    std::optional<std::string> comment_;
    uint32_t default_mode_;
    uint32_t flags_;
    std::vector<uint8_t> obj_;
    std::vector<ContentId> parents_;
    std::optional<std::vector<uint8_t>> signature_;
    std::optional<std::vector<std::string>> tags_;
    uint64_t time_;
    DataCatalogObjectTy ty_;
    B2cId user_;
    uint32_t version_;

    DataCatalogObject();
    DataCatalogObject(const ::DataCatalogObject *root);
    DataCatalogObject(const std::vector<uint8_t> &bytes);
};

struct ObjectIdList {
    std::vector<ObjectId> ids_;

    ObjectIdList();
    ObjectIdList(const ::ObjectIdList *root);
    ObjectIdList(const std::vector<uint8_t> &bytes);
};

struct ObjectIdPair {
    ObjectId id_;
    std::optional<std::vector<uint8_t>> object_;

    ObjectIdPair();
    ObjectIdPair(const ::ObjectIdPair *root);
    ObjectIdPair(const std::vector<uint8_t> &bytes);
};

struct ObjectIdPairList {
    std::vector<ObjectIdPair> pairs_;

    ObjectIdPairList();
    ObjectIdPairList(const ::ObjectIdPairList *root);
    ObjectIdPairList(const std::vector<uint8_t> &bytes);
};

struct ObjectSummary {
    std::optional<ObjectId> acl_;
    uint64_t drive_size_;
    ContentId head_revision_;
    ObjectId id_;
    uint64_t time_;
    DataCatalogObjectTy ty_;

    ObjectSummary();
    ObjectSummary(const ::ObjectSummary *root);
    ObjectSummary(const std::vector<uint8_t> &bytes);
};

struct ObjectSummaryList {
    std::vector<ObjectSummary> pairs_;

    ObjectSummaryList();
    ObjectSummaryList(const ::ObjectSummaryList *root);
    ObjectSummaryList(const std::vector<uint8_t> &bytes);
};

::flatbuffers::Offset<::DataCatalogObject>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DataCatalogObject &);

::flatbuffers::Offset<::ObjectIdList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectIdList &);

::flatbuffers::Offset<::ObjectIdPair>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectIdPair &);

::flatbuffers::Offset<::ObjectIdPairList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectIdPairList &);

::flatbuffers::Offset<::ObjectSummary>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectSummary &);

::flatbuffers::Offset<::ObjectSummaryList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectSummaryList &);


std::vector<uint8_t>
to_bytes(const DataCatalogObject &o);

std::vector<uint8_t>
to_bytes(const ObjectIdList &o);

std::vector<uint8_t>
to_bytes(const ObjectIdPair &o);

std::vector<uint8_t>
to_bytes(const ObjectIdPairList &o);

std::vector<uint8_t>
to_bytes(const ObjectSummary &o);

std::vector<uint8_t>
to_bytes(const ObjectSummaryList &o);


} // namespace types
} // namespace ul
