// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#pragma once

#include <cstdint>
#include <optional>

#include "ulsdk/external/json.h"
#include "ulsdk/request_context.h"
#include "ulsdk/types/id.h"
#include "ulsdk/types/metadata.h"
#include "ulsdk/types/object.h"
#include "ulsdk/types/query.h"
#include "ulsdk/types/table.h"
#include "ulsdk/ulsdk.h"

struct json_value_s;
namespace arrow {
class RecordBatch;
} // namespace arrow


namespace ul {
namespace api {
namespace datacatalog {

/**
 * Fetch an object at a given content ID revision
 * @param object_id The ID of the object to fetch content from
 * @param content_id The ID of the content to fetch
 * @return The datacatalog object
 */
Result<::ul::types::DataCatalogObject>
get_object_at_revision(
    ul::RequestContext &ctx,
    const Uuid &object_id,
    const Uuid &content_id
);

/**
 * Fetch the ID of the ACL object associated with the given object ID
 * @param id The ID of the object to fetch the ACL for
 * @return The ID of the object's ACL
 */
Result<::ul::types::ObjectId>
get_acl(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the head revision of the object with the given ID
 * @param id The ID of the object to fetch the head revision for
 * @return 
 */
Result<::ul::types::ObjectSummary>
get_head_revision(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the object with the given ID at its head revision
 * @param id The ID of the object to fetch
 * @return Object content
 */
Result<::ul::types::DataCatalogObject>
get_object(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Update the object with the given ID
 * @param id The ID of the object to update
 * @param object Object contents with which to update the specified object
 */
Result<Void>
update_object(
    ul::RequestContext &ctx,
    const Uuid &id,
    const ::ul::types::DataCatalogObject &object
);

/**
 * Update the attributes of the object with the given ID
 * @param id The ID of the object whose attributes will be updated
 * @param overwrite True to overwrite existing attributes or false to fail if there is a conflict.
 * @param attributes A string:string json map with the new attributes
 */
Result<Void>
update_attribute(
    ul::RequestContext &ctx,
    const Uuid &id,
    bool overwrite,
    const std::map<std::string, ul::JsonValue> &attributes
);

/**
 * Delete the attribute with the given key from the object with the given ID
 * @param id The ID of the object whose attribute will be deleted
 * @param key The key of the attribute to delete
 */
Result<Void>
delete_attribute(
    ul::RequestContext &ctx,
    const Uuid &id,
    const std::string &key
);

/**
 * Fetch a list of object summaries
 * @param object_ids A list of object IDs to fetch summaries for
 * @return A list of object summaries
 */
Result<::ul::types::ObjectSummaryList>
get_object_summaries(
    ul::RequestContext &ctx,
    const ::ul::types::ObjectIdList &object_ids
);

/**
 * Given a list of object IDs, fetch their contents in bulk
 * @param object_ids A list of object IDs to fetch summaries for
 * @return A list of object contents with their IDs
 */
Result<::ul::types::ObjectIdPairList>
bulk_fetch_objects(
    ul::RequestContext &ctx,
    const ::ul::types::ObjectIdList &object_ids
);

/**
 * Create a new, empty object
 * @return The object summary of the newly created object
 */
Result<::ul::types::ObjectSummaryList>
create_object(
    ul::RequestContext &ctx
);

/**
 * INTERNAL
 * @param columns Comma separated list of columns to aggregate
 * @param query INTERNAL
 * @return 
 */
Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_numeric(
    ul::RequestContext &ctx,
    const std::string &columns,
    const ::ul::types::Query &query
);

/**
 * INTERNAL
 * @param columns Comma separated list of columns to aggregate
 * @param query INTERNAL
 * @return 
 */
Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_string(
    ul::RequestContext &ctx,
    const std::string &columns,
    const ::ul::types::Query &query
);

/**
 * INTERNAL
 * @param buckets Number of buckets
 * @param columns Comma separated list of columns to aggregate
 * @param query INTERNAL
 * @return 
 */
Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_histo(
    ul::RequestContext &ctx,
    int64_t buckets,
    const std::string &columns,
    const ::ul::types::Query &query
);

/**
 * INTERNAL
 * @param buckets Number of buckets
 * @param numerator_columns Comma separated list of columns to aggregate for the numerator value
 * @param denominator_columns Comma separated list of columns to aggregate for the denominator value
 * @param query INTERNAL
 * @return 
 */
Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_relative_histo(
    ul::RequestContext &ctx,
    int64_t buckets,
    const std::string &numerator_columns,
    const std::string &denominator_columns,
    const ::ul::types::Query &query
);

/**
 * Fetch the stream with the given ID
 * @param id The ID of the stream to fetch
 * @return Stream data as requested
 */
Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
stream_get_arrow(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the stream with the given ID
 * @param id The ID of the stream to fetch
 * @return Stream data as requested
 */
Result<std::vector<uint8_t>>
stream_get_parquet(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the stream with the given ID
 * @param id The ID of the stream to fetch
 * @return Stream data as requested
 */
Result<std::vector<uint8_t>>
stream_get_csv(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the stream with the given ID
 * @param id The ID of the stream to fetch
 * @return Stream data as requested
 */
Result<std::vector<uint8_t>>
stream_get_xlsx(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the stream with the given ID
 * @param id The ID of the stream to fetch
 * @return Stream data as requested
 */
Result<std::vector<uint8_t>>
stream_get_json(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the stream with the given ID
 * @param id The ID of the stream to fetch
 * @return Stream data as requested
 */
Result<std::vector<uint8_t>>
stream_get_text(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the stream with the given ID
 * @param id The ID of the stream to fetch
 * @return Stream data as requested
 */
Result<std::vector<uint8_t>>
stream_get_html(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Append data, in Apache Arrow format, to the specified stream
 * @param id The ID of the stream to append data to
 * @param subcollection Subcollection to append data to, if necessary
 * @param data The Arrow record batches to append
 */
Result<Void>
stream_put_arrow(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection,
    const std::vector<std::shared_ptr<::arrow::RecordBatch>> &data
);

/**
 * Append a diffstream to the specified stream
 * @param id The ID of the stream to append data to
 * @param subcollection Subcollection to append data to, if necessary
 * @param data The Arrow record batches to append
 */
Result<Void>
stream_put_diffstream(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection,
    const ::ul::types::DiffStream &data
);

/**
 * Append JSON data to the specified stream
 * @param id The ID of the stream to append data to
 * @param subcollection Subcollection to append data to, if necessary
 * @param data The Arrow record batches to append
 */
Result<Void>
stream_put_json(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection,
    const std::vector<std::map<std::string, ul::JsonValue>> &data
);

/**
 * Generate metadata for the specified stream
 * @param id The ID of the stream to generate metadata for
 * @return The metadata as generated from the stream data
 */
Result<::ul::types::Metadata>
generate_metadata(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Given a stream ID and metadata, update the stream metadata to a combination of:
- the existing metadata
- the provided metadata
- the generated metadata
Also, update the stream object to point to the updated metadata and to have an updated schema.
 * @param id The ID of the stream to update metadata for
 * @param metadata The metadata to update the stream with
 */
Result<Void>
update_metadata(
    ul::RequestContext &ctx,
    const Uuid &id,
    const std::optional<::ul::types::Metadata> &metadata
);

/**
 * Compact the specified stream
 * @param id The ID of the stream to compact
 * @param subcollection Subcollection to append data to, if necessary
 */
Result<Void>
stream_compact(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection
);

/**
 * Fetch the history of a row in a table
 * @param id The ID of the table to fetch the row history from
 * @param row The ID of the row to fetch the history for
 * @return The history of the row
 */
Result<::ul::types::History>
table_row_history(
    ul::RequestContext &ctx,
    const Uuid &id,
    const Uuid &row
);

/**
 * Fetch the history of a table
 * @param id The ID of the table to fetch the history from
 * @return The history of the table
 */
Result<::ul::types::History>
table_history(
    ul::RequestContext &ctx,
    const Uuid &id
);

/**
 * Fetch the directory ID for a row's file attachments location
 * @param id The ID of the table to fetch the attachments directory ID from
 * @param row The ID of the row to fetch the attachments directory ID for
 * @return The directory ID for the row's attachments
 */
Result<::ul::types::ObjectId>
get_table_attachments_directory(
    ul::RequestContext &ctx,
    const Uuid &id,
    const Uuid &row
);

/**
 * Fetch the directory ID for a row's file attachments location, creating it if it doesn't exist
 * @param id The ID of the table to fetch the attachments directory ID from
 * @param row The ID of the row to fetch the attachments directory ID for
 * @return The directory ID for the row's attachments
 */
Result<::ul::types::ObjectId>
get_or_create_table_attachments_directory(
    ul::RequestContext &ctx,
    const Uuid &id,
    const Uuid &row
);

/**
 * Create a new table in the provided directory
 * @param id The ID of the directory to create the table in
 * @param new_table New table creation details
 * @return The ID of the newly created table
 */
Result<::ul::types::ObjectId>
create_table(
    ul::RequestContext &ctx,
    const Uuid &id,
    const ::ul::types::NewTable &new_table
);

/**
 * Query the datacatalog, returning data in Apache Arrow IPC Stream format
 * @param query The query to execute
 * @return The result of the query
 */
Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_arrow(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
);

/**
 * Query the datacatalog, returning data in Apache Parquet format
 * @param query The query to execute
 * @return The result of the query
 */
Result<std::vector<uint8_t>>
query_parquet(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
);

/**
 * Query the datacatalog, returning data in CSV format
 * @param query The query to execute
 * @return The result of the query
 */
Result<std::vector<uint8_t>>
query_csv(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
);

/**
 * Query the datacatalog, returning data in Excel (XLSX) format
 * @param query The query to execute
 * @return The result of the query
 */
Result<std::vector<uint8_t>>
query_xlsx(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
);

/**
 * Query the datacatalog, returning data JSON
 * @param query The query to execute
 * @return The result of the query
 */
Result<std::vector<uint8_t>>
query_json(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
);

/**
 * Query the datacatalog, returning data in plain text
 * @param query The query to execute
 * @return The result of the query
 */
Result<std::vector<uint8_t>>
query_text(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
);

/**
 * Query the datacatalog, returning data in HTML
 * @param query The query to execute
 * @return The result of the query
 */
Result<std::vector<uint8_t>>
query_html(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
);

} // namespace datacatalog
} // namespace api
} // namespace ul
