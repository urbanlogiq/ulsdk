// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include "ulsdk/types/query.h"

#include "test.h"

bool
test_all_columns() {
    ::ul::types::AllColumns t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::AllColumns deserialized = ::ul::types::AllColumns(bytes);
    return true;
}

TypeTest test_all_columns_obj(test_all_columns, "AllColumns");

bool
test_arrow() {
    ::ul::types::Arrow t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Arrow deserialized = ::ul::types::Arrow(bytes);
    return true;
}

TypeTest test_arrow_obj(test_arrow, "Arrow");

bool
test_binary_query_element() {
    ::ul::types::BinaryQueryElement t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::BinaryQueryElement deserialized = ::ul::types::BinaryQueryElement(bytes);
    return true;
}

TypeTest test_binary_query_element_obj(test_binary_query_element, "BinaryQueryElement");

bool
test_case() {
    ::ul::types::Case t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Case deserialized = ::ul::types::Case(bytes);
    return true;
}

TypeTest test_case_obj(test_case, "Case");

bool
test_column() {
    ::ul::types::Column t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Column deserialized = ::ul::types::Column(bytes);
    return true;
}

TypeTest test_column_obj(test_column, "Column");

bool
test_data_catalog() {
    ::ul::types::DataCatalog t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::DataCatalog deserialized = ::ul::types::DataCatalog(bytes);
    return true;
}

TypeTest test_data_catalog_obj(test_data_catalog, "DataCatalog");

bool
test_delete_query_element() {
    ::ul::types::DeleteQueryElement t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::DeleteQueryElement deserialized = ::ul::types::DeleteQueryElement(bytes);
    return true;
}

TypeTest test_delete_query_element_obj(test_delete_query_element, "DeleteQueryElement");

bool
test_distinct() {
    ::ul::types::Distinct t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Distinct deserialized = ::ul::types::Distinct(bytes);
    return true;
}

TypeTest test_distinct_obj(test_distinct, "Distinct");

bool
test_expr() {
    ::ul::types::Expr t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Expr deserialized = ::ul::types::Expr(bytes);
    return true;
}

TypeTest test_expr_obj(test_expr, "Expr");

bool
test_function() {
    ::ul::types::Function t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Function deserialized = ::ul::types::Function(bytes);
    return true;
}

TypeTest test_function_obj(test_function, "Function");

bool
test_join() {
    ::ul::types::Join t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Join deserialized = ::ul::types::Join(bytes);
    return true;
}

TypeTest test_join_obj(test_join, "Join");

bool
test_mvdb_subcollection() {
    ::ul::types::MvdbSubcollection t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::MvdbSubcollection deserialized = ::ul::types::MvdbSubcollection(bytes);
    return true;
}

TypeTest test_mvdb_subcollection_obj(test_mvdb_subcollection, "MvdbSubcollection");

bool
test_nullable_uint() {
    ::ul::types::NullableUint t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NullableUint deserialized = ::ul::types::NullableUint(bytes);
    return true;
}

TypeTest test_nullable_uint_obj(test_nullable_uint, "NullableUint");

bool
test_order_by_expr() {
    ::ul::types::OrderByExpr t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::OrderByExpr deserialized = ::ul::types::OrderByExpr(bytes);
    return true;
}

TypeTest test_order_by_expr_obj(test_order_by_expr, "OrderByExpr");

bool
test_parameter() {
    ::ul::types::Parameter t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Parameter deserialized = ::ul::types::Parameter(bytes);
    return true;
}

TypeTest test_parameter_obj(test_parameter, "Parameter");

bool
test_parameter_instance() {
    ::ul::types::ParameterInstance t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::ParameterInstance deserialized = ::ul::types::ParameterInstance(bytes);
    return true;
}

TypeTest test_parameter_instance_obj(test_parameter_instance, "ParameterInstance");

bool
test_parameterized_query() {
    ::ul::types::ParameterizedQuery t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::ParameterizedQuery deserialized = ::ul::types::ParameterizedQuery(bytes);
    return true;
}

TypeTest test_parameterized_query_obj(test_parameterized_query, "ParameterizedQuery");

bool
test_partition() {
    ::ul::types::Partition t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Partition deserialized = ::ul::types::Partition(bytes);
    return true;
}

TypeTest test_partition_obj(test_partition, "Partition");

bool
test_query() {
    ::ul::types::Query t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Query deserialized = ::ul::types::Query(bytes);
    return true;
}

TypeTest test_query_obj(test_query, "Query");

bool
test_query_element() {
    ::ul::types::QueryElement t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::QueryElement deserialized = ::ul::types::QueryElement(bytes);
    return true;
}

TypeTest test_query_element_obj(test_query_element, "QueryElement");

bool
test_query_table_source() {
    ::ul::types::QueryTableSource t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::QueryTableSource deserialized = ::ul::types::QueryTableSource(bytes);
    return true;
}

TypeTest test_query_table_source_obj(test_query_table_source, "QueryTableSource");

bool
test_set_expr() {
    ::ul::types::SetExpr t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::SetExpr deserialized = ::ul::types::SetExpr(bytes);
    return true;
}

TypeTest test_set_expr_obj(test_set_expr, "SetExpr");

bool
test_table_order_by() {
    ::ul::types::TableOrderBy t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::TableOrderBy deserialized = ::ul::types::TableOrderBy(bytes);
    return true;
}

TypeTest test_table_order_by_obj(test_table_order_by, "TableOrderBy");

bool
test_table_source() {
    ::ul::types::TableSource t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::TableSource deserialized = ::ul::types::TableSource(bytes);
    return true;
}

TypeTest test_table_source_obj(test_table_source, "TableSource");

bool
test_unary_query_element() {
    ::ul::types::UnaryQueryElement t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::UnaryQueryElement deserialized = ::ul::types::UnaryQueryElement(bytes);
    return true;
}

TypeTest test_unary_query_element_obj(test_unary_query_element, "UnaryQueryElement");

bool
test_unset_argument() {
    ::ul::types::UnsetArgument t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::UnsetArgument deserialized = ::ul::types::UnsetArgument(bytes);
    return true;
}

TypeTest test_unset_argument_obj(test_unset_argument, "UnsetArgument");

bool
test_update_query_element() {
    ::ul::types::UpdateQueryElement t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::UpdateQueryElement deserialized = ::ul::types::UpdateQueryElement(bytes);
    return true;
}

TypeTest test_update_query_element_obj(test_update_query_element, "UpdateQueryElement");

bool
test_value_index() {
    ::ul::types::ValueIndex t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::ValueIndex deserialized = ::ul::types::ValueIndex(bytes);
    return true;
}

TypeTest test_value_index_obj(test_value_index, "ValueIndex");

bool
test_vector() {
    ::ul::types::Vector t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Vector deserialized = ::ul::types::Vector(bytes);
    return true;
}

TypeTest test_vector_obj(test_vector, "Vector");

bool
test_when() {
    ::ul::types::When t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::When deserialized = ::ul::types::When(bytes);
    return true;
}

TypeTest test_when_obj(test_when, "When");

bool
test_window() {
    ::ul::types::Window t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Window deserialized = ::ul::types::Window(bytes);
    return true;
}

TypeTest test_window_obj(test_window, "Window");

bool
test_worklog_subcollection() {
    ::ul::types::WorklogSubcollection t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::WorklogSubcollection deserialized = ::ul::types::WorklogSubcollection(bytes);
    return true;
}

TypeTest test_worklog_subcollection_obj(test_worklog_subcollection, "WorklogSubcollection");
