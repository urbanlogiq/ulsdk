// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include "ulsdk/types/metadata.h"

#include "test.h"

bool
test_category_relationship_data() {
    ::ul::types::CategoryRelationshipData t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::CategoryRelationshipData deserialized = ::ul::types::CategoryRelationshipData(bytes);
    return true;
}

TypeTest test_category_relationship_data_obj(test_category_relationship_data, "CategoryRelationshipData");

bool
test_contact_info() {
    ::ul::types::ContactInfo t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::ContactInfo deserialized = ::ul::types::ContactInfo(bytes);
    return true;
}

TypeTest test_contact_info_obj(test_contact_info, "ContactInfo");

bool
test_datacatalog_geometry() {
    ::ul::types::DatacatalogGeometry t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::DatacatalogGeometry deserialized = ::ul::types::DatacatalogGeometry(bytes);
    return true;
}

TypeTest test_datacatalog_geometry_obj(test_datacatalog_geometry, "DatacatalogGeometry");

bool
test_dataset_source() {
    ::ul::types::DatasetSource t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::DatasetSource deserialized = ::ul::types::DatasetSource(bytes);
    return true;
}

TypeTest test_dataset_source_obj(test_dataset_source, "DatasetSource");

bool
test_dates() {
    ::ul::types::Dates t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Dates deserialized = ::ul::types::Dates(bytes);
    return true;
}

TypeTest test_dates_obj(test_dates, "Dates");

bool
test_datetime_range() {
    ::ul::types::DatetimeRange t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::DatetimeRange deserialized = ::ul::types::DatetimeRange(bytes);
    return true;
}

TypeTest test_datetime_range_obj(test_datetime_range, "DatetimeRange");

bool
test_document() {
    ::ul::types::Document t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Document deserialized = ::ul::types::Document(bytes);
    return true;
}

TypeTest test_document_obj(test_document, "Document");

bool
test_documents() {
    ::ul::types::Documents t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Documents deserialized = ::ul::types::Documents(bytes);
    return true;
}

TypeTest test_documents_obj(test_documents, "Documents");

bool
test_float_aggregate() {
    ::ul::types::FloatAggregate t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::FloatAggregate deserialized = ::ul::types::FloatAggregate(bytes);
    return true;
}

TypeTest test_float_aggregate_obj(test_float_aggregate, "FloatAggregate");

bool
test_float_range() {
    ::ul::types::FloatRange t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::FloatRange deserialized = ::ul::types::FloatRange(bytes);
    return true;
}

TypeTest test_float_range_obj(test_float_range, "FloatRange");

bool
test_geometry_data() {
    ::ul::types::GeometryData t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::GeometryData deserialized = ::ul::types::GeometryData(bytes);
    return true;
}

TypeTest test_geometry_data_obj(test_geometry_data, "GeometryData");

bool
test_hierarchical_relationship() {
    ::ul::types::HierarchicalRelationship t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::HierarchicalRelationship deserialized = ::ul::types::HierarchicalRelationship(bytes);
    return true;
}

TypeTest test_hierarchical_relationship_obj(test_hierarchical_relationship, "HierarchicalRelationship");

bool
test_hierarchy_relationship_data() {
    ::ul::types::HierarchyRelationshipData t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::HierarchyRelationshipData deserialized = ::ul::types::HierarchyRelationshipData(bytes);
    return true;
}

TypeTest test_hierarchy_relationship_data_obj(test_hierarchy_relationship_data, "HierarchyRelationshipData");

bool
test_int_aggregate() {
    ::ul::types::IntAggregate t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::IntAggregate deserialized = ::ul::types::IntAggregate(bytes);
    return true;
}

TypeTest test_int_aggregate_obj(test_int_aggregate, "IntAggregate");

bool
test_int_range() {
    ::ul::types::IntRange t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::IntRange deserialized = ::ul::types::IntRange(bytes);
    return true;
}

TypeTest test_int_range_obj(test_int_range, "IntRange");

bool
test_integer_display_string() {
    ::ul::types::IntegerDisplayString t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::IntegerDisplayString deserialized = ::ul::types::IntegerDisplayString(bytes);
    return true;
}

TypeTest test_integer_display_string_obj(test_integer_display_string, "IntegerDisplayString");

bool
test_metadata() {
    ::ul::types::Metadata t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::Metadata deserialized = ::ul::types::Metadata(bytes);
    return true;
}

TypeTest test_metadata_obj(test_metadata, "Metadata");

bool
test_nested_category_relationship_data() {
    ::ul::types::NestedCategoryRelationshipData t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NestedCategoryRelationshipData deserialized = ::ul::types::NestedCategoryRelationshipData(bytes);
    return true;
}

TypeTest test_nested_category_relationship_data_obj(test_nested_category_relationship_data, "NestedCategoryRelationshipData");

bool
test_nested_category_relationship_node() {
    ::ul::types::NestedCategoryRelationshipNode t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NestedCategoryRelationshipNode deserialized = ::ul::types::NestedCategoryRelationshipNode(bytes);
    return true;
}

TypeTest test_nested_category_relationship_node_obj(test_nested_category_relationship_node, "NestedCategoryRelationshipNode");

bool
test_nested_hierarchy_relationship_data() {
    ::ul::types::NestedHierarchyRelationshipData t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NestedHierarchyRelationshipData deserialized = ::ul::types::NestedHierarchyRelationshipData(bytes);
    return true;
}

TypeTest test_nested_hierarchy_relationship_data_obj(test_nested_hierarchy_relationship_data, "NestedHierarchyRelationshipData");

bool
test_nested_hierarchy_relationship_node() {
    ::ul::types::NestedHierarchyRelationshipNode t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NestedHierarchyRelationshipNode deserialized = ::ul::types::NestedHierarchyRelationshipNode(bytes);
    return true;
}

TypeTest test_nested_hierarchy_relationship_node_obj(test_nested_hierarchy_relationship_node, "NestedHierarchyRelationshipNode");

bool
test_nested_string_categories() {
    ::ul::types::NestedStringCategories t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NestedStringCategories deserialized = ::ul::types::NestedStringCategories(bytes);
    return true;
}

TypeTest test_nested_string_categories_obj(test_nested_string_categories, "NestedStringCategories");

bool
test_nested_string_category_node() {
    ::ul::types::NestedStringCategoryNode t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NestedStringCategoryNode deserialized = ::ul::types::NestedStringCategoryNode(bytes);
    return true;
}

TypeTest test_nested_string_category_node_obj(test_nested_string_category_node, "NestedStringCategoryNode");

bool
test_no_geometry() {
    ::ul::types::NoGeometry t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NoGeometry deserialized = ::ul::types::NoGeometry(bytes);
    return true;
}

TypeTest test_no_geometry_obj(test_no_geometry, "NoGeometry");

bool
test_numerical_field_format() {
    ::ul::types::NumericalFieldFormat t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::NumericalFieldFormat deserialized = ::ul::types::NumericalFieldFormat(bytes);
    return true;
}

TypeTest test_numerical_field_format_obj(test_numerical_field_format, "NumericalFieldFormat");

bool
test_raw_geom() {
    ::ul::types::RawGeom t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::RawGeom deserialized = ::ul::types::RawGeom(bytes);
    return true;
}

TypeTest test_raw_geom_obj(test_raw_geom, "RawGeom");

bool
test_string_aggregate() {
    ::ul::types::StringAggregate t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::StringAggregate deserialized = ::ul::types::StringAggregate(bytes);
    return true;
}

TypeTest test_string_aggregate_obj(test_string_aggregate, "StringAggregate");

bool
test_string_categories() {
    ::ul::types::StringCategories t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::StringCategories deserialized = ::ul::types::StringCategories(bytes);
    return true;
}

TypeTest test_string_categories_obj(test_string_categories, "StringCategories");

bool
test_time_interval() {
    ::ul::types::TimeInterval t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::TimeInterval deserialized = ::ul::types::TimeInterval(bytes);
    return true;
}

TypeTest test_time_interval_obj(test_time_interval, "TimeInterval");

bool
test_u_int_aggregate() {
    ::ul::types::UIntAggregate t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::UIntAggregate deserialized = ::ul::types::UIntAggregate(bytes);
    return true;
}

TypeTest test_u_int_aggregate_obj(test_u_int_aggregate, "UIntAggregate");

bool
test_ul_field() {
    ::ul::types::UlField t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::UlField deserialized = ::ul::types::UlField(bytes);
    return true;
}

TypeTest test_ul_field_obj(test_ul_field, "UlField");

bool
test_ul_field_relationship() {
    ::ul::types::UlFieldRelationship t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::UlFieldRelationship deserialized = ::ul::types::UlFieldRelationship(bytes);
    return true;
}

TypeTest test_ul_field_relationship_obj(test_ul_field_relationship, "UlFieldRelationship");

bool
test_world_graph_geometry() {
    ::ul::types::WorldGraphGeometry t;
    const std::vector<uint8_t> bytes = ::ul::types::to_bytes(t);
    ::ul::types::WorldGraphGeometry deserialized = ::ul::types::WorldGraphGeometry(bytes);
    return true;
}

TypeTest test_world_graph_geometry_obj(test_world_graph_geometry, "WorldGraphGeometry");
