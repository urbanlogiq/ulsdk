// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <cassert>
#include <cstring>
#include <cstdlib>
#include <sstream>
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif
#include <arrow/record_batch.h>
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#include "ulsdk/ulsdk.h"
#include "ulsdk/external/json.h"
#include "ulsdk/api/gate.h"

namespace ul {
namespace api {
namespace gate {

AdUser::AdUser(const struct json_value_s *root)
    : display_name_(std::string())
    , id_(std::string())
    , user_principal_name_(std::string())
    , other_mails_()
    , department_(std::nullopt)
    , created_date_time_(std::string()) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "userPrincipalName") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *user_principal_name__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            user_principal_name_ = std::string(user_principal_name__str->string);
        } else if (std::strcmp(e->name->string, "otherMails") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *other_mails__array = static_cast<const struct json_array_s *>(ad_user_value->payload);
            const struct json_array_element_s *other_mails__element = other_mails__array->start;
            std::vector<std::string> other_mails__vec = std::vector<std::string>();
            while (other_mails__element != nullptr) {
                const struct json_value_s *ad_user_value_0 = other_mails__element->value;
                std::string other_mails__value;
            if (ad_user_value_0->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *other_mails__value_str = static_cast<const struct json_string_s *>(ad_user_value_0->payload);
            other_mails__value = std::string(other_mails__value_str->string);
                other_mails__vec.push_back(other_mails__value);
                other_mails__element = other_mails__element->next;
            }
            other_mails_ = other_mails__vec;
        } else if (std::strcmp(e->name->string, "department") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type == json_type_null) {
                department_ = std::nullopt;
            } else {
                if (ad_user_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *department__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
                department_ = std::string(department__str->string);
            }
        } else if (std::strcmp(e->name->string, "createdDateTime") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *created_date_time__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            created_date_time_ = std::string(created_date_time__str->string);
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const AdUser &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    ss << "\"userPrincipalName\":";
    ss << "\"" << o.user_principal_name_ << "\"";
    ss << ",";

    ss << "\"otherMails\":";
    for (const auto &i : o.other_mails_) {
        ss << "\"" << i << "\"";
    }
    ss << ",";

    if (o.department_.has_value()) {
        ss << "\"department\":";
        const auto &department__value = o.department_.value();
        ss << "\"" << department__value << "\"";
        ss << ",";
    }

    ss << "\"createdDateTime\":";
    ss << "\"" << o.created_date_time_ << "\"";
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

AdGroup::AdGroup(const struct json_value_s *root)
    : id_(std::string())
    , display_name_(std::string())
    , description_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *ad_group_value = e->value;

            if (ad_group_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(ad_group_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *ad_group_value = e->value;

            if (ad_group_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(ad_group_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "description") == 0) {
            const struct json_value_s *ad_group_value = e->value;

            if (ad_group_value->type == json_type_null) {
                description_ = std::nullopt;
            } else {
                if (ad_group_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *description__str = static_cast<const struct json_string_s *>(ad_group_value->payload);
                description_ = std::string(description__str->string);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const AdGroup &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    if (o.description_.has_value()) {
        ss << "\"description\":";
        const auto &description__value = o.description_.value();
        ss << "\"" << description__value << "\"";
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

Bootstrap::Bootstrap(const struct json_value_s *root)
    : user_(AdUser())
    , groups_()
    , v_2groups_()
    , client_secrets_(nullptr) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "user") == 0) {
            const struct json_value_s *bootstrap_value = e->value;

            if (bootstrap_value->type != json_type_object) {
                throw std::runtime_error("expected field to be of type object");
            }
            
            user_ = AdUser(bootstrap_value);
        } else if (std::strcmp(e->name->string, "groups") == 0) {
            const struct json_value_s *bootstrap_value = e->value;

            if (bootstrap_value->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *groups__array = static_cast<const struct json_array_s *>(bootstrap_value->payload);
            const struct json_array_element_s *groups__element = groups__array->start;
            std::vector<AdGroup> groups__vec = std::vector<AdGroup>();
            while (groups__element != nullptr) {
                const struct json_value_s *bootstrap_value_0 = groups__element->value;
                AdGroup groups__value;
            if (bootstrap_value_0->type != json_type_object) {
                throw std::runtime_error("expected field to be of type object");
            }
            
            groups__value = AdGroup(bootstrap_value_0);
                groups__vec.push_back(groups__value);
                groups__element = groups__element->next;
            }
            groups_ = groups__vec;
        } else if (std::strcmp(e->name->string, "v2groups") == 0) {
            const struct json_value_s *bootstrap_value = e->value;

            if (bootstrap_value->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *v_2groups__array = static_cast<const struct json_array_s *>(bootstrap_value->payload);
            const struct json_array_element_s *v_2groups__element = v_2groups__array->start;
            std::vector<AdGroup> v_2groups__vec = std::vector<AdGroup>();
            while (v_2groups__element != nullptr) {
                const struct json_value_s *bootstrap_value_0 = v_2groups__element->value;
                AdGroup v_2groups__value;
            if (bootstrap_value_0->type != json_type_object) {
                throw std::runtime_error("expected field to be of type object");
            }
            
            v_2groups__value = AdGroup(bootstrap_value_0);
                v_2groups__vec.push_back(v_2groups__value);
                v_2groups__element = v_2groups__element->next;
            }
            v_2groups_ = v_2groups__vec;
        } else if (std::strcmp(e->name->string, "clientSecrets") == 0) {
            const struct json_value_s *bootstrap_value = e->value;

            if (bootstrap_value->type != json_type_object) {
                throw std::runtime_error("expected field to be of type object");
            }
            
            client_secrets_ = json_extract_value(bootstrap_value);
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const Bootstrap &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"user\":";
    const std::vector<uint8_t> user__serialized = to_bytes(o.user_);
    const std::string user__str = std::string(user__serialized.begin(), user__serialized.end());
    ss << user__str;
    ss << ",";

    ss << "\"groups\":";
    for (const auto &i : o.groups_) {
        const std::vector<uint8_t> i_serialized = to_bytes(i);
        const std::string i_str = std::string(i_serialized.begin(), i_serialized.end());
        ss << i_str;
    }
    ss << ",";

    ss << "\"v2groups\":";
    for (const auto &i : o.v_2groups_) {
        const std::vector<uint8_t> i_serialized = to_bytes(i);
        const std::string i_str = std::string(i_serialized.begin(), i_serialized.end());
        ss << i_str;
    }
    ss << ",";

    ss << "\"clientSecrets\":";
    throw new std::runtime_error("cannot serialize type map at this time");
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

Result<Bootstrap>
bootstrap(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/bootstrap/";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Bootstrap>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<Bootstrap>(Error("failed to parse JSON"));
    }
    return Bootstrap(root.get());
}

} // namespace gate
} // namespace api
} // namespace ul
