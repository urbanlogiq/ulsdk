// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <cassert>
#include <cstring>
#include <cstdlib>
#include <sstream>
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif
#include <arrow/record_batch.h>
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#include "ulsdk/ulsdk.h"
#include "ulsdk/external/json.h"
#include "ulsdk/api/drive.h"

namespace ul {
namespace api {
namespace drive {

Result<::ul::types::DirectoryList>
ls(
    ul::RequestContext &ctx,
    const std::string &root,
    const std::string &tail
) {
    std::string path = "/v1/api/ulv2/drive/:root/*tail";
    const size_t root_idx = path.find(":root");
    path.replace(root_idx, 2, root);
    const size_t tail_idx = path.find("*tail");
    const std::string encoded_tail = ::ul::url_encode(tail);
    path.replace(tail_idx, 2, encoded_tail);

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::DirectoryList>(error);
    }
    return ::ul::types::DirectoryList(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectSummary>
create_entry(
    ul::RequestContext &ctx,
    const std::string &root,
    const std::string &tail,
    const std::string &ty,
    const std::string &mime,
    int64_t chunks
) {
    std::string path = "/v1/api/ulv2/drive/:root/*tail";
    const size_t root_idx = path.find(":root");
    path.replace(root_idx, 2, root);
    const size_t tail_idx = path.find("*tail");
    const std::string encoded_tail = ::ul::url_encode(tail);
    path.replace(tail_idx, 2, encoded_tail);

    std::map<std::string, std::string> params;
    params["ty"] = ty;
    params["mime"] = mime;
    params["chunks"] = std::to_string(chunks);

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body;
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "text/plain", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectSummary>(error);
    }
    return ::ul::types::ObjectSummary(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::DirectoryList>
get_roots(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/ulv2/drive";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::DirectoryList>(error);
    }
    return ::ul::types::DirectoryList(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::DirectoryList>
post_file(
    ul::RequestContext &ctx,
    const std::string &root,
    bool force,
    const std::vector<ul::File> &files
) {
    std::string path = "/v1/api/ulv2/drive/:root";
    const size_t root_idx = path.find(":root");
    path.replace(root_idx, 2, root);

    std::map<std::string, std::string> params;
    params["force"] = force ? "true" : "false";

    std::map<std::string, std::string> headers;
    const auto body = files;
    const Result<std::vector<uint8_t>> res = ctx.upload(path, body);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::DirectoryList>(error);
    }
    return ::ul::types::DirectoryList(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::DirectoryList>
unlink(
    ul::RequestContext &ctx,
    const std::string &entry
) {
    std::string path = "/v1/api/ulv2/drive/:entry";
    const size_t entry_idx = path.find(":entry");
    path.replace(entry_idx, 2, entry);

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const auto res = ctx.del(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::DirectoryList>(error);
    }
    return ::ul::types::DirectoryList(std::get<std::vector<uint8_t>>(res));
}

Result<Void>
move(
    ul::RequestContext &ctx,
    const ::ul::types::MoveRequest &move_request
) {
    std::string path = "/v1/api/ulv2/drive/move";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(move_request);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
copy(
    ul::RequestContext &ctx,
    const ::ul::types::MoveRequest &copy_request
) {
    std::string path = "/v1/api/ulv2/drive/copy";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(copy_request);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<std::vector<uint8_t>>
get_file(
    ul::RequestContext &ctx,
    const std::string &id
) {
    std::string path = "/v1/api/ulv2/drive/file/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id);

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    return res;
}

Result<Void>
put_file_chunk(
    ul::RequestContext &ctx,
    const std::string &file_id,
    int64_t idx,
    const std::string &hash,
    const std::vector<uint8_t> &chunk
) {
    std::string path = "/v1/api/ulv2/drive/file/:file_id/:idx";
    const size_t file_id_idx = path.find(":file_id");
    path.replace(file_id_idx, 2, file_id);
    const size_t idx_idx = path.find(":idx");
    path.replace(idx_idx, 2, std::to_string(idx));

    std::map<std::string, std::string> params;
    params["hash"] = hash;

    std::map<std::string, std::string> headers;
    const auto body = chunk;
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<::ul::types::ObjectId>
get_root_id(
    ul::RequestContext &ctx,
    const std::string &b_2cid
) {
    std::string path = "/v1/api/ulv2/drive/root/:b2cid";
    const size_t b2cid_idx = path.find(":b2cid");
    path.replace(b2cid_idx, 2, b_2cid);

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectId>(error);
    }
    return ::ul::types::ObjectId(std::get<std::vector<uint8_t>>(res));
}

} // namespace drive
} // namespace api
} // namespace ul
