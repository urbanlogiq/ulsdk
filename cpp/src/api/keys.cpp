// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <cassert>
#include <cstring>
#include <cstdlib>
#include <sstream>
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif
#include <arrow/record_batch.h>
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#include "ulsdk/ulsdk.h"
#include "ulsdk/external/json.h"
#include "ulsdk/api/keys.h"

namespace ul {
namespace api {
namespace keys {

Key::Key(const struct json_value_s *root)
    : id_(std::string())
    , pubkey_(std::nullopt)
    , created_(0)
    , last_(std::nullopt)
    , expiry_(std::nullopt)
    , comment_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *key_value = e->value;

            if (key_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(key_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "pubkey") == 0) {
            const struct json_value_s *key_value = e->value;

            if (key_value->type == json_type_null) {
                pubkey_ = std::nullopt;
            } else {
                if (key_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *pubkey__str = static_cast<const struct json_string_s *>(key_value->payload);
                pubkey_ = std::string(pubkey__str->string);
            }
        } else if (std::strcmp(e->name->string, "created") == 0) {
            const struct json_value_s *key_value = e->value;

            if (key_value->type != json_type_number) {
                throw std::runtime_error("expected field to be of type number");
            }
            
            const struct json_number_s *created__num = static_cast<const struct json_number_s *>(key_value->payload);
            created_ = std::stoll(created__num->number);
        } else if (std::strcmp(e->name->string, "last") == 0) {
            const struct json_value_s *key_value = e->value;

            if (key_value->type == json_type_null) {
                last_ = std::nullopt;
            } else {
                if (key_value->type != json_type_number) {
                    throw std::runtime_error("expected field to be of type number");
                }
                
                const struct json_number_s *last__num = static_cast<const struct json_number_s *>(key_value->payload);
                last_ = std::stoll(last__num->number);
            }
        } else if (std::strcmp(e->name->string, "expiry") == 0) {
            const struct json_value_s *key_value = e->value;

            if (key_value->type == json_type_null) {
                expiry_ = std::nullopt;
            } else {
                if (key_value->type != json_type_number) {
                    throw std::runtime_error("expected field to be of type number");
                }
                
                const struct json_number_s *expiry__num = static_cast<const struct json_number_s *>(key_value->payload);
                expiry_ = std::stoll(expiry__num->number);
            }
        } else if (std::strcmp(e->name->string, "comment") == 0) {
            const struct json_value_s *key_value = e->value;

            if (key_value->type == json_type_null) {
                comment_ = std::nullopt;
            } else {
                if (key_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *comment__str = static_cast<const struct json_string_s *>(key_value->payload);
                comment_ = std::string(comment__str->string);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const Key &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    if (o.pubkey_.has_value()) {
        ss << "\"pubkey\":";
        const auto &pubkey__value = o.pubkey_.value();
        ss << "\"" << pubkey__value << "\"";
        ss << ",";
    }

    ss << "\"created\":";
    ss << o.created_;
    ss << ",";

    if (o.last_.has_value()) {
        ss << "\"last\":";
        const auto &last__value = o.last_.value();
        ss << last__value;
        ss << ",";
    }

    if (o.expiry_.has_value()) {
        ss << "\"expiry\":";
        const auto &expiry__value = o.expiry_.value();
        ss << expiry__value;
        ss << ",";
    }

    if (o.comment_.has_value()) {
        ss << "\"comment\":";
        const auto &comment__value = o.comment_.value();
        ss << "\"" << comment__value << "\"";
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

GetKeys::GetKeys(const struct json_value_s *root)
    : keys_() {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "keys") == 0) {
            const struct json_value_s *get_keys_value = e->value;

            if (get_keys_value->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *keys__array = static_cast<const struct json_array_s *>(get_keys_value->payload);
            const struct json_array_element_s *keys__element = keys__array->start;
            std::vector<Key> keys__vec = std::vector<Key>();
            while (keys__element != nullptr) {
                const struct json_value_s *get_keys_value_0 = keys__element->value;
                Key keys__value;
            if (get_keys_value_0->type != json_type_object) {
                throw std::runtime_error("expected field to be of type object");
            }
            
            keys__value = Key(get_keys_value_0);
                keys__vec.push_back(keys__value);
                keys__element = keys__element->next;
            }
            keys_ = keys__vec;
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const GetKeys &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"keys\":";
    for (const auto &i : o.keys_) {
        const std::vector<uint8_t> i_serialized = to_bytes(i);
        const std::string i_str = std::string(i_serialized.begin(), i_serialized.end());
        ss << i_str;
    }
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

CreateKey::CreateKey(const struct json_value_s *root)
    : id_(std::string())
    , secret_key_(std::string()) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *create_key_value = e->value;

            if (create_key_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(create_key_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "secretKey") == 0) {
            const struct json_value_s *create_key_value = e->value;

            if (create_key_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *secret_key__str = static_cast<const struct json_string_s *>(create_key_value->payload);
            secret_key_ = std::string(secret_key__str->string);
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const CreateKey &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    ss << "\"secretKey\":";
    ss << "\"" << o.secret_key_ << "\"";
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

UpdateKey::UpdateKey(const struct json_value_s *root)
    : comment_(std::nullopt)
    , expiry_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "comment") == 0) {
            const struct json_value_s *update_key_value = e->value;

            if (update_key_value->type == json_type_null) {
                comment_ = std::nullopt;
            } else {
                if (update_key_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *comment__str = static_cast<const struct json_string_s *>(update_key_value->payload);
                comment_ = std::string(comment__str->string);
            }
        } else if (std::strcmp(e->name->string, "expiry") == 0) {
            const struct json_value_s *update_key_value = e->value;

            if (update_key_value->type == json_type_null) {
                expiry_ = std::nullopt;
            } else {
                if (update_key_value->type != json_type_number) {
                    throw std::runtime_error("expected field to be of type number");
                }
                
                const struct json_number_s *expiry__num = static_cast<const struct json_number_s *>(update_key_value->payload);
                expiry_ = std::stoll(expiry__num->number);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const UpdateKey &o) {
    std::stringstream ss;
    ss << "{";
    if (o.comment_.has_value()) {
        ss << "\"comment\":";
        const auto &comment__value = o.comment_.value();
        ss << "\"" << comment__value << "\"";
        ss << ",";
    }

    if (o.expiry_.has_value()) {
        ss << "\"expiry\":";
        const auto &expiry__value = o.expiry_.value();
        ss << expiry__value;
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

Result<GetKeys>
get_keys(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/uldirectory/v1/keys/";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<GetKeys>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<GetKeys>(Error("failed to parse JSON"));
    }
    return GetKeys(root.get());
}

Result<CreateKey>
create_key(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/uldirectory/v1/keys/";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body;
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "text/plain", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<CreateKey>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<CreateKey>(Error("failed to parse JSON"));
    }
    return CreateKey(root.get());
}

Result<Void>
update_key(
    ul::RequestContext &ctx,
    const Uuid &id,
    const UpdateKey &update_key
) {
    std::string path = "/v1/api/uldirectory/v1/keys/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
        const std::vector<uint8_t> body = to_bytes(update_key);
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "application/json", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Key>
get_key(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/uldirectory/v1/keys/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Key>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<Key>(Error("failed to parse JSON"));
    }
    return Key(root.get());
}

Result<Void>
delete_key(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/uldirectory/v1/keys/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const auto res = ctx.del(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

} // namespace keys
} // namespace api
} // namespace ul
