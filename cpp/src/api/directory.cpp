// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <cassert>
#include <cstring>
#include <cstdlib>
#include <sstream>
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif
#include <arrow/record_batch.h>
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#include "ulsdk/ulsdk.h"
#include "ulsdk/external/json.h"
#include "ulsdk/api/directory.h"

namespace ul {
namespace api {
namespace directory {

Principal::Principal(const struct json_value_s *root)
    : principal_type_(std::string())
    , display_name_(std::string())
    , id_(std::string())
    , email_(std::nullopt)
    , description_(std::nullopt)
    , department_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "principalType") == 0) {
            const struct json_value_s *principal_value = e->value;

            if (principal_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *principal_type__str = static_cast<const struct json_string_s *>(principal_value->payload);
            principal_type_ = std::string(principal_type__str->string);
        } else if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *principal_value = e->value;

            if (principal_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(principal_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *principal_value = e->value;

            if (principal_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(principal_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "email") == 0) {
            const struct json_value_s *principal_value = e->value;

            if (principal_value->type == json_type_null) {
                email_ = std::nullopt;
            } else {
                if (principal_value->type != json_type_array) {
                    throw std::runtime_error("expected field to be of type array");
                }
                
                const struct json_array_s *email__array = static_cast<const struct json_array_s *>(principal_value->payload);
                const struct json_array_element_s *email__element = email__array->start;
                std::vector<std::string> email__vec = std::vector<std::string>();
                while (email__element != nullptr) {
                    const struct json_value_s *principal_value_1 = email__element->value;
                    std::string email__value;
                    if (principal_value_1->type != json_type_string) {
                        throw std::runtime_error("expected field to be of type string");
                    }
                    
                    const struct json_string_s *email__value_str = static_cast<const struct json_string_s *>(principal_value_1->payload);
                    email__value = std::string(email__value_str->string);
                    email__vec.push_back(email__value);
                    email__element = email__element->next;
                }
                email_ = email__vec;
            }
        } else if (std::strcmp(e->name->string, "description") == 0) {
            const struct json_value_s *principal_value = e->value;

            if (principal_value->type == json_type_null) {
                description_ = std::nullopt;
            } else {
                if (principal_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *description__str = static_cast<const struct json_string_s *>(principal_value->payload);
                description_ = std::string(description__str->string);
            }
        } else if (std::strcmp(e->name->string, "department") == 0) {
            const struct json_value_s *principal_value = e->value;

            if (principal_value->type == json_type_null) {
                department_ = std::nullopt;
            } else {
                if (principal_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *department__str = static_cast<const struct json_string_s *>(principal_value->payload);
                department_ = std::string(department__str->string);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const Principal &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"principalType\":";
    ss << "\"" << o.principal_type_ << "\"";
    ss << ",";

    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    if (o.email_.has_value()) {
        ss << "\"email\":";
        const auto &email__value = o.email_.value();
        for (const auto &i : email__value) {
            ss << "\"" << i << "\"";
        }
        ss << ",";
    }

    if (o.description_.has_value()) {
        ss << "\"description\":";
        const auto &description__value = o.description_.value();
        ss << "\"" << description__value << "\"";
        ss << ",";
    }

    if (o.department_.has_value()) {
        ss << "\"department\":";
        const auto &department__value = o.department_.value();
        ss << "\"" << department__value << "\"";
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

AdUser::AdUser(const struct json_value_s *root)
    : display_name_(std::string())
    , id_(std::string())
    , user_principal_name_(std::string())
    , other_mails_()
    , department_(std::nullopt)
    , created_date_time_(std::string()) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "userPrincipalName") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *user_principal_name__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            user_principal_name_ = std::string(user_principal_name__str->string);
        } else if (std::strcmp(e->name->string, "otherMails") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *other_mails__array = static_cast<const struct json_array_s *>(ad_user_value->payload);
            const struct json_array_element_s *other_mails__element = other_mails__array->start;
            std::vector<std::string> other_mails__vec = std::vector<std::string>();
            while (other_mails__element != nullptr) {
                const struct json_value_s *ad_user_value_0 = other_mails__element->value;
                std::string other_mails__value;
            if (ad_user_value_0->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *other_mails__value_str = static_cast<const struct json_string_s *>(ad_user_value_0->payload);
            other_mails__value = std::string(other_mails__value_str->string);
                other_mails__vec.push_back(other_mails__value);
                other_mails__element = other_mails__element->next;
            }
            other_mails_ = other_mails__vec;
        } else if (std::strcmp(e->name->string, "department") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type == json_type_null) {
                department_ = std::nullopt;
            } else {
                if (ad_user_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *department__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
                department_ = std::string(department__str->string);
            }
        } else if (std::strcmp(e->name->string, "createdDateTime") == 0) {
            const struct json_value_s *ad_user_value = e->value;

            if (ad_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *created_date_time__str = static_cast<const struct json_string_s *>(ad_user_value->payload);
            created_date_time_ = std::string(created_date_time__str->string);
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const AdUser &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    ss << "\"userPrincipalName\":";
    ss << "\"" << o.user_principal_name_ << "\"";
    ss << ",";

    ss << "\"otherMails\":";
    for (const auto &i : o.other_mails_) {
        ss << "\"" << i << "\"";
    }
    ss << ",";

    if (o.department_.has_value()) {
        ss << "\"department\":";
        const auto &department__value = o.department_.value();
        ss << "\"" << department__value << "\"";
        ss << ",";
    }

    ss << "\"createdDateTime\":";
    ss << "\"" << o.created_date_time_ << "\"";
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

DisplayNames::DisplayNames(const struct json_value_s *root)
    : display_name_(std::string())
    , id_(std::string()) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *display_names_value = e->value;

            if (display_names_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(display_names_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *display_names_value = e->value;

            if (display_names_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(display_names_value->payload);
            id_ = std::string(id__str->string);
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const DisplayNames &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

DeviceDetail::DeviceDetail(const struct json_value_s *root)
    : device_id_(std::nullopt)
    , operating_system_(std::nullopt)
    , browser_(std::nullopt)
    , is_compliant_(std::nullopt)
    , is_managed_(std::nullopt)
    , trust_type_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "deviceId") == 0) {
            const struct json_value_s *device_detail_value = e->value;

            if (device_detail_value->type == json_type_null) {
                device_id_ = std::nullopt;
            } else {
                if (device_detail_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *device_id__str = static_cast<const struct json_string_s *>(device_detail_value->payload);
                device_id_ = std::string(device_id__str->string);
            }
        } else if (std::strcmp(e->name->string, "operatingSystem") == 0) {
            const struct json_value_s *device_detail_value = e->value;

            if (device_detail_value->type == json_type_null) {
                operating_system_ = std::nullopt;
            } else {
                if (device_detail_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *operating_system__str = static_cast<const struct json_string_s *>(device_detail_value->payload);
                operating_system_ = std::string(operating_system__str->string);
            }
        } else if (std::strcmp(e->name->string, "browser") == 0) {
            const struct json_value_s *device_detail_value = e->value;

            if (device_detail_value->type == json_type_null) {
                browser_ = std::nullopt;
            } else {
                if (device_detail_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *browser__str = static_cast<const struct json_string_s *>(device_detail_value->payload);
                browser_ = std::string(browser__str->string);
            }
        } else if (std::strcmp(e->name->string, "isCompliant") == 0) {
            const struct json_value_s *device_detail_value = e->value;

            if (device_detail_value->type == json_type_null) {
                is_compliant_ = std::nullopt;
            } else {
                if (device_detail_value->type == json_type_true) {
                    is_compliant_ = true;
                } else if (device_detail_value->type == json_type_false) {
                    is_compliant_ = false;
                } else {
                    throw std::runtime_error("expected field to be of type bool");
                }
            }
        } else if (std::strcmp(e->name->string, "isManaged") == 0) {
            const struct json_value_s *device_detail_value = e->value;

            if (device_detail_value->type == json_type_null) {
                is_managed_ = std::nullopt;
            } else {
                if (device_detail_value->type == json_type_true) {
                    is_managed_ = true;
                } else if (device_detail_value->type == json_type_false) {
                    is_managed_ = false;
                } else {
                    throw std::runtime_error("expected field to be of type bool");
                }
            }
        } else if (std::strcmp(e->name->string, "trustType") == 0) {
            const struct json_value_s *device_detail_value = e->value;

            if (device_detail_value->type == json_type_null) {
                trust_type_ = std::nullopt;
            } else {
                if (device_detail_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *trust_type__str = static_cast<const struct json_string_s *>(device_detail_value->payload);
                trust_type_ = std::string(trust_type__str->string);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const DeviceDetail &o) {
    std::stringstream ss;
    ss << "{";
    if (o.device_id_.has_value()) {
        ss << "\"deviceId\":";
        const auto &device_id__value = o.device_id_.value();
        ss << "\"" << device_id__value << "\"";
        ss << ",";
    }

    if (o.operating_system_.has_value()) {
        ss << "\"operatingSystem\":";
        const auto &operating_system__value = o.operating_system_.value();
        ss << "\"" << operating_system__value << "\"";
        ss << ",";
    }

    if (o.browser_.has_value()) {
        ss << "\"browser\":";
        const auto &browser__value = o.browser_.value();
        ss << "\"" << browser__value << "\"";
        ss << ",";
    }

    if (o.is_compliant_.has_value()) {
        ss << "\"isCompliant\":";
        const auto &is_compliant__value = o.is_compliant_.value();
        ss << is_compliant__value;
        ss << ",";
    }

    if (o.is_managed_.has_value()) {
        ss << "\"isManaged\":";
        const auto &is_managed__value = o.is_managed_.value();
        ss << is_managed__value;
        ss << ",";
    }

    if (o.trust_type_.has_value()) {
        ss << "\"trustType\":";
        const auto &trust_type__value = o.trust_type_.value();
        ss << "\"" << trust_type__value << "\"";
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

Coordinates::Coordinates(const struct json_value_s *root)
    : latitude_(std::nullopt)
    , longitude_(std::nullopt)
    , altitude_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "latitude") == 0) {
            const struct json_value_s *coordinates_value = e->value;

            if (coordinates_value->type == json_type_null) {
                latitude_ = std::nullopt;
            } else {
                if (coordinates_value->type != json_type_number) {
                    throw std::runtime_error("expected field to be of type number");
                }
                
                const struct json_number_s *latitude__num = static_cast<const struct json_number_s *>(coordinates_value->payload);
                latitude_ = std::stod(latitude__num->number);
            }
        } else if (std::strcmp(e->name->string, "longitude") == 0) {
            const struct json_value_s *coordinates_value = e->value;

            if (coordinates_value->type == json_type_null) {
                longitude_ = std::nullopt;
            } else {
                if (coordinates_value->type != json_type_number) {
                    throw std::runtime_error("expected field to be of type number");
                }
                
                const struct json_number_s *longitude__num = static_cast<const struct json_number_s *>(coordinates_value->payload);
                longitude_ = std::stod(longitude__num->number);
            }
        } else if (std::strcmp(e->name->string, "altitude") == 0) {
            const struct json_value_s *coordinates_value = e->value;

            if (coordinates_value->type == json_type_null) {
                altitude_ = std::nullopt;
            } else {
                if (coordinates_value->type != json_type_number) {
                    throw std::runtime_error("expected field to be of type number");
                }
                
                const struct json_number_s *altitude__num = static_cast<const struct json_number_s *>(coordinates_value->payload);
                altitude_ = std::stod(altitude__num->number);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const Coordinates &o) {
    std::stringstream ss;
    ss << "{";
    if (o.latitude_.has_value()) {
        ss << "\"latitude\":";
        const auto &latitude__value = o.latitude_.value();
        ss << latitude__value;
        ss << ",";
    }

    if (o.longitude_.has_value()) {
        ss << "\"longitude\":";
        const auto &longitude__value = o.longitude_.value();
        ss << longitude__value;
        ss << ",";
    }

    if (o.altitude_.has_value()) {
        ss << "\"altitude\":";
        const auto &altitude__value = o.altitude_.value();
        ss << altitude__value;
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

Location::Location(const struct json_value_s *root)
    : city_(std::nullopt)
    , state_(std::nullopt)
    , country_or_region_(std::nullopt)
    , geo_coordinates_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "city") == 0) {
            const struct json_value_s *location_value = e->value;

            if (location_value->type == json_type_null) {
                city_ = std::nullopt;
            } else {
                if (location_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *city__str = static_cast<const struct json_string_s *>(location_value->payload);
                city_ = std::string(city__str->string);
            }
        } else if (std::strcmp(e->name->string, "state") == 0) {
            const struct json_value_s *location_value = e->value;

            if (location_value->type == json_type_null) {
                state_ = std::nullopt;
            } else {
                if (location_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *state__str = static_cast<const struct json_string_s *>(location_value->payload);
                state_ = std::string(state__str->string);
            }
        } else if (std::strcmp(e->name->string, "countryOrRegion") == 0) {
            const struct json_value_s *location_value = e->value;

            if (location_value->type == json_type_null) {
                country_or_region_ = std::nullopt;
            } else {
                if (location_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *country_or_region__str = static_cast<const struct json_string_s *>(location_value->payload);
                country_or_region_ = std::string(country_or_region__str->string);
            }
        } else if (std::strcmp(e->name->string, "geoCoordinates") == 0) {
            const struct json_value_s *location_value = e->value;

            if (location_value->type == json_type_null) {
                geo_coordinates_ = std::nullopt;
            } else {
                if (location_value->type != json_type_object) {
                    throw std::runtime_error("expected field to be of type object");
                }
                
                geo_coordinates_ = Coordinates(location_value);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const Location &o) {
    std::stringstream ss;
    ss << "{";
    if (o.city_.has_value()) {
        ss << "\"city\":";
        const auto &city__value = o.city_.value();
        ss << "\"" << city__value << "\"";
        ss << ",";
    }

    if (o.state_.has_value()) {
        ss << "\"state\":";
        const auto &state__value = o.state_.value();
        ss << "\"" << state__value << "\"";
        ss << ",";
    }

    if (o.country_or_region_.has_value()) {
        ss << "\"countryOrRegion\":";
        const auto &country_or_region__value = o.country_or_region_.value();
        ss << "\"" << country_or_region__value << "\"";
        ss << ",";
    }

    if (o.geo_coordinates_.has_value()) {
        ss << "\"geoCoordinates\":";
        const auto &geo_coordinates__value = o.geo_coordinates_.value();
        const std::vector<uint8_t> geo_coordinates__value_serialized = to_bytes(geo_coordinates__value);
        const std::string geo_coordinates__value_str = std::string(geo_coordinates__value_serialized.begin(), geo_coordinates__value_serialized.end());
        ss << geo_coordinates__value_str;
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

AuditLogEntry::AuditLogEntry(const struct json_value_s *root)
    : id_(std::nullopt)
    , user_principal_name_(std::nullopt)
    , user_id_(std::nullopt)
    , created_date_time_(std::nullopt)
    , ip_address_(std::nullopt)
    , device_detail_(std::nullopt)
    , location_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *audit_log_entry_value = e->value;

            if (audit_log_entry_value->type == json_type_null) {
                id_ = std::nullopt;
            } else {
                if (audit_log_entry_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *id__str = static_cast<const struct json_string_s *>(audit_log_entry_value->payload);
                id_ = std::string(id__str->string);
            }
        } else if (std::strcmp(e->name->string, "userPrincipalName") == 0) {
            const struct json_value_s *audit_log_entry_value = e->value;

            if (audit_log_entry_value->type == json_type_null) {
                user_principal_name_ = std::nullopt;
            } else {
                if (audit_log_entry_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *user_principal_name__str = static_cast<const struct json_string_s *>(audit_log_entry_value->payload);
                user_principal_name_ = std::string(user_principal_name__str->string);
            }
        } else if (std::strcmp(e->name->string, "userId") == 0) {
            const struct json_value_s *audit_log_entry_value = e->value;

            if (audit_log_entry_value->type == json_type_null) {
                user_id_ = std::nullopt;
            } else {
                if (audit_log_entry_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *user_id__str = static_cast<const struct json_string_s *>(audit_log_entry_value->payload);
                user_id_ = std::string(user_id__str->string);
            }
        } else if (std::strcmp(e->name->string, "createdDateTime") == 0) {
            const struct json_value_s *audit_log_entry_value = e->value;

            if (audit_log_entry_value->type == json_type_null) {
                created_date_time_ = std::nullopt;
            } else {
                if (audit_log_entry_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *created_date_time__str = static_cast<const struct json_string_s *>(audit_log_entry_value->payload);
                created_date_time_ = std::string(created_date_time__str->string);
            }
        } else if (std::strcmp(e->name->string, "ipAddress") == 0) {
            const struct json_value_s *audit_log_entry_value = e->value;

            if (audit_log_entry_value->type == json_type_null) {
                ip_address_ = std::nullopt;
            } else {
                if (audit_log_entry_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *ip_address__str = static_cast<const struct json_string_s *>(audit_log_entry_value->payload);
                ip_address_ = std::string(ip_address__str->string);
            }
        } else if (std::strcmp(e->name->string, "deviceDetail") == 0) {
            const struct json_value_s *audit_log_entry_value = e->value;

            if (audit_log_entry_value->type == json_type_null) {
                device_detail_ = std::nullopt;
            } else {
                if (audit_log_entry_value->type != json_type_object) {
                    throw std::runtime_error("expected field to be of type object");
                }
                
                device_detail_ = DeviceDetail(audit_log_entry_value);
            }
        } else if (std::strcmp(e->name->string, "location") == 0) {
            const struct json_value_s *audit_log_entry_value = e->value;

            if (audit_log_entry_value->type == json_type_null) {
                location_ = std::nullopt;
            } else {
                if (audit_log_entry_value->type != json_type_object) {
                    throw std::runtime_error("expected field to be of type object");
                }
                
                location_ = Location(audit_log_entry_value);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const AuditLogEntry &o) {
    std::stringstream ss;
    ss << "{";
    if (o.id_.has_value()) {
        ss << "\"id\":";
        const auto &id__value = o.id_.value();
        ss << "\"" << id__value << "\"";
        ss << ",";
    }

    if (o.user_principal_name_.has_value()) {
        ss << "\"userPrincipalName\":";
        const auto &user_principal_name__value = o.user_principal_name_.value();
        ss << "\"" << user_principal_name__value << "\"";
        ss << ",";
    }

    if (o.user_id_.has_value()) {
        ss << "\"userId\":";
        const auto &user_id__value = o.user_id_.value();
        ss << "\"" << user_id__value << "\"";
        ss << ",";
    }

    if (o.created_date_time_.has_value()) {
        ss << "\"createdDateTime\":";
        const auto &created_date_time__value = o.created_date_time_.value();
        ss << "\"" << created_date_time__value << "\"";
        ss << ",";
    }

    if (o.ip_address_.has_value()) {
        ss << "\"ipAddress\":";
        const auto &ip_address__value = o.ip_address_.value();
        ss << "\"" << ip_address__value << "\"";
        ss << ",";
    }

    if (o.device_detail_.has_value()) {
        ss << "\"deviceDetail\":";
        const auto &device_detail__value = o.device_detail_.value();
        const std::vector<uint8_t> device_detail__value_serialized = to_bytes(device_detail__value);
        const std::string device_detail__value_str = std::string(device_detail__value_serialized.begin(), device_detail__value_serialized.end());
        ss << device_detail__value_str;
        ss << ",";
    }

    if (o.location_.has_value()) {
        ss << "\"location\":";
        const auto &location__value = o.location_.value();
        const std::vector<uint8_t> location__value_serialized = to_bytes(location__value);
        const std::string location__value_str = std::string(location__value_serialized.begin(), location__value_serialized.end());
        ss << location__value_str;
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

AuditLog::AuditLog(const struct json_value_s *root)
    : value_() {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "value") == 0) {
            const struct json_value_s *audit_log_value = e->value;

            if (audit_log_value->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *value__array = static_cast<const struct json_array_s *>(audit_log_value->payload);
            const struct json_array_element_s *value__element = value__array->start;
            std::vector<std::vector<AuditLogEntry>> value__vec = std::vector<std::vector<AuditLogEntry>>();
            while (value__element != nullptr) {
                const struct json_value_s *audit_log_value_0 = value__element->value;
                std::vector<AuditLogEntry> value__value;
            if (audit_log_value_0->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *value__value_array = static_cast<const struct json_array_s *>(audit_log_value_0->payload);
            const struct json_array_element_s *value__value_element = value__value_array->start;
            std::vector<AuditLogEntry> value__value_vec = std::vector<AuditLogEntry>();
            while (value__value_element != nullptr) {
                const struct json_value_s *audit_log_value_0_0 = value__value_element->value;
                AuditLogEntry value__value_value;
            if (audit_log_value_0_0->type != json_type_object) {
                throw std::runtime_error("expected field to be of type object");
            }
            
            value__value_value = AuditLogEntry(audit_log_value_0_0);
                value__value_vec.push_back(value__value_value);
                value__value_element = value__value_element->next;
            }
            value__value = value__value_vec;
                value__vec.push_back(value__value);
                value__element = value__element->next;
            }
            value_ = value__vec;
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const AuditLog &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"value\":";
    for (const auto &i : o.value_) {
        for (const auto &i : i) {
                const std::vector<uint8_t> i_serialized = to_bytes(i);
                const std::string i_str = std::string(i_serialized.begin(), i_serialized.end());
                ss << i_str;
        }
    }
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

AdUserWithAuditLog::AdUserWithAuditLog(const struct json_value_s *root)
    : display_name_(std::string())
    , id_(std::string())
    , user_principal_name_(std::string())
    , other_mails_()
    , department_(std::nullopt)
    , created_date_time_(std::string())
    , audit_log_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *ad_user_with_audit_log_value = e->value;

            if (ad_user_with_audit_log_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(ad_user_with_audit_log_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *ad_user_with_audit_log_value = e->value;

            if (ad_user_with_audit_log_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(ad_user_with_audit_log_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "userPrincipalName") == 0) {
            const struct json_value_s *ad_user_with_audit_log_value = e->value;

            if (ad_user_with_audit_log_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *user_principal_name__str = static_cast<const struct json_string_s *>(ad_user_with_audit_log_value->payload);
            user_principal_name_ = std::string(user_principal_name__str->string);
        } else if (std::strcmp(e->name->string, "otherMails") == 0) {
            const struct json_value_s *ad_user_with_audit_log_value = e->value;

            if (ad_user_with_audit_log_value->type != json_type_array) {
                throw std::runtime_error("expected field to be of type array");
            }
            
            const struct json_array_s *other_mails__array = static_cast<const struct json_array_s *>(ad_user_with_audit_log_value->payload);
            const struct json_array_element_s *other_mails__element = other_mails__array->start;
            std::vector<std::string> other_mails__vec = std::vector<std::string>();
            while (other_mails__element != nullptr) {
                const struct json_value_s *ad_user_with_audit_log_value_0 = other_mails__element->value;
                std::string other_mails__value;
            if (ad_user_with_audit_log_value_0->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *other_mails__value_str = static_cast<const struct json_string_s *>(ad_user_with_audit_log_value_0->payload);
            other_mails__value = std::string(other_mails__value_str->string);
                other_mails__vec.push_back(other_mails__value);
                other_mails__element = other_mails__element->next;
            }
            other_mails_ = other_mails__vec;
        } else if (std::strcmp(e->name->string, "department") == 0) {
            const struct json_value_s *ad_user_with_audit_log_value = e->value;

            if (ad_user_with_audit_log_value->type == json_type_null) {
                department_ = std::nullopt;
            } else {
                if (ad_user_with_audit_log_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *department__str = static_cast<const struct json_string_s *>(ad_user_with_audit_log_value->payload);
                department_ = std::string(department__str->string);
            }
        } else if (std::strcmp(e->name->string, "createdDateTime") == 0) {
            const struct json_value_s *ad_user_with_audit_log_value = e->value;

            if (ad_user_with_audit_log_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *created_date_time__str = static_cast<const struct json_string_s *>(ad_user_with_audit_log_value->payload);
            created_date_time_ = std::string(created_date_time__str->string);
        } else if (std::strcmp(e->name->string, "auditLog") == 0) {
            const struct json_value_s *ad_user_with_audit_log_value = e->value;

            if (ad_user_with_audit_log_value->type == json_type_null) {
                audit_log_ = std::nullopt;
            } else {
                if (ad_user_with_audit_log_value->type != json_type_object) {
                    throw std::runtime_error("expected field to be of type object");
                }
                
                audit_log_ = AuditLog(ad_user_with_audit_log_value);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const AdUserWithAuditLog &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    ss << "\"userPrincipalName\":";
    ss << "\"" << o.user_principal_name_ << "\"";
    ss << ",";

    ss << "\"otherMails\":";
    for (const auto &i : o.other_mails_) {
        ss << "\"" << i << "\"";
    }
    ss << ",";

    if (o.department_.has_value()) {
        ss << "\"department\":";
        const auto &department__value = o.department_.value();
        ss << "\"" << department__value << "\"";
        ss << ",";
    }

    ss << "\"createdDateTime\":";
    ss << "\"" << o.created_date_time_ << "\"";
    ss << ",";

    if (o.audit_log_.has_value()) {
        ss << "\"auditLog\":";
        const auto &audit_log__value = o.audit_log_.value();
        const std::vector<uint8_t> audit_log__value_serialized = to_bytes(audit_log__value);
        const std::string audit_log__value_str = std::string(audit_log__value_serialized.begin(), audit_log__value_serialized.end());
        ss << audit_log__value_str;
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

CreateUser::CreateUser(const struct json_value_s *root)
    : user_(AdUser())
    , password_(std::string()) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "user") == 0) {
            const struct json_value_s *create_user_value = e->value;

            if (create_user_value->type != json_type_object) {
                throw std::runtime_error("expected field to be of type object");
            }
            
            user_ = AdUser(create_user_value);
        } else if (std::strcmp(e->name->string, "password") == 0) {
            const struct json_value_s *create_user_value = e->value;

            if (create_user_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *password__str = static_cast<const struct json_string_s *>(create_user_value->payload);
            password_ = std::string(password__str->string);
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const CreateUser &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"user\":";
    const std::vector<uint8_t> user__serialized = to_bytes(o.user_);
    const std::string user__str = std::string(user__serialized.begin(), user__serialized.end());
    ss << user__str;
    ss << ",";

    ss << "\"password\":";
    ss << "\"" << o.password_ << "\"";
    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

UpdateCurrentUser::UpdateCurrentUser(const struct json_value_s *root)
    : display_name_(std::nullopt)
    , other_mails_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *update_current_user_value = e->value;

            if (update_current_user_value->type == json_type_null) {
                display_name_ = std::nullopt;
            } else {
                if (update_current_user_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(update_current_user_value->payload);
                display_name_ = std::string(display_name__str->string);
            }
        } else if (std::strcmp(e->name->string, "otherMails") == 0) {
            const struct json_value_s *update_current_user_value = e->value;

            if (update_current_user_value->type == json_type_null) {
                other_mails_ = std::nullopt;
            } else {
                if (update_current_user_value->type != json_type_array) {
                    throw std::runtime_error("expected field to be of type array");
                }
                
                const struct json_array_s *other_mails__array = static_cast<const struct json_array_s *>(update_current_user_value->payload);
                const struct json_array_element_s *other_mails__element = other_mails__array->start;
                std::vector<std::string> other_mails__vec = std::vector<std::string>();
                while (other_mails__element != nullptr) {
                    const struct json_value_s *update_current_user_value_1 = other_mails__element->value;
                    std::string other_mails__value;
                    if (update_current_user_value_1->type != json_type_string) {
                        throw std::runtime_error("expected field to be of type string");
                    }
                    
                    const struct json_string_s *other_mails__value_str = static_cast<const struct json_string_s *>(update_current_user_value_1->payload);
                    other_mails__value = std::string(other_mails__value_str->string);
                    other_mails__vec.push_back(other_mails__value);
                    other_mails__element = other_mails__element->next;
                }
                other_mails_ = other_mails__vec;
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const UpdateCurrentUser &o) {
    std::stringstream ss;
    ss << "{";
    if (o.display_name_.has_value()) {
        ss << "\"displayName\":";
        const auto &display_name__value = o.display_name_.value();
        ss << "\"" << display_name__value << "\"";
        ss << ",";
    }

    if (o.other_mails_.has_value()) {
        ss << "\"otherMails\":";
        const auto &other_mails__value = o.other_mails_.value();
        for (const auto &i : other_mails__value) {
            ss << "\"" << i << "\"";
        }
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

UpdateUser::UpdateUser(const struct json_value_s *root)
    : display_name_(std::nullopt)
    , other_mails_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *update_user_value = e->value;

            if (update_user_value->type == json_type_null) {
                display_name_ = std::nullopt;
            } else {
                if (update_user_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(update_user_value->payload);
                display_name_ = std::string(display_name__str->string);
            }
        } else if (std::strcmp(e->name->string, "otherMails") == 0) {
            const struct json_value_s *update_user_value = e->value;

            if (update_user_value->type == json_type_null) {
                other_mails_ = std::nullopt;
            } else {
                if (update_user_value->type != json_type_array) {
                    throw std::runtime_error("expected field to be of type array");
                }
                
                const struct json_array_s *other_mails__array = static_cast<const struct json_array_s *>(update_user_value->payload);
                const struct json_array_element_s *other_mails__element = other_mails__array->start;
                std::vector<std::string> other_mails__vec = std::vector<std::string>();
                while (other_mails__element != nullptr) {
                    const struct json_value_s *update_user_value_1 = other_mails__element->value;
                    std::string other_mails__value;
                    if (update_user_value_1->type != json_type_string) {
                        throw std::runtime_error("expected field to be of type string");
                    }
                    
                    const struct json_string_s *other_mails__value_str = static_cast<const struct json_string_s *>(update_user_value_1->payload);
                    other_mails__value = std::string(other_mails__value_str->string);
                    other_mails__vec.push_back(other_mails__value);
                    other_mails__element = other_mails__element->next;
                }
                other_mails_ = other_mails__vec;
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const UpdateUser &o) {
    std::stringstream ss;
    ss << "{";
    if (o.display_name_.has_value()) {
        ss << "\"displayName\":";
        const auto &display_name__value = o.display_name_.value();
        ss << "\"" << display_name__value << "\"";
        ss << ",";
    }

    if (o.other_mails_.has_value()) {
        ss << "\"otherMails\":";
        const auto &other_mails__value = o.other_mails_.value();
        for (const auto &i : other_mails__value) {
            ss << "\"" << i << "\"";
        }
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

AdGroup::AdGroup(const struct json_value_s *root)
    : id_(std::string())
    , display_name_(std::string())
    , description_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *ad_group_value = e->value;

            if (ad_group_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(ad_group_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *ad_group_value = e->value;

            if (ad_group_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(ad_group_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "description") == 0) {
            const struct json_value_s *ad_group_value = e->value;

            if (ad_group_value->type == json_type_null) {
                description_ = std::nullopt;
            } else {
                if (ad_group_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *description__str = static_cast<const struct json_string_s *>(ad_group_value->payload);
                description_ = std::string(description__str->string);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const AdGroup &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    if (o.description_.has_value()) {
        ss << "\"description\":";
        const auto &description__value = o.description_.value();
        ss << "\"" << description__value << "\"";
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

CreateGroup::CreateGroup(const struct json_value_s *root)
    : display_name_(std::string())
    , description_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *create_group_value = e->value;

            if (create_group_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(create_group_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "description") == 0) {
            const struct json_value_s *create_group_value = e->value;

            if (create_group_value->type == json_type_null) {
                description_ = std::nullopt;
            } else {
                if (create_group_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *description__str = static_cast<const struct json_string_s *>(create_group_value->payload);
                description_ = std::string(description__str->string);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const CreateGroup &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    if (o.description_.has_value()) {
        ss << "\"description\":";
        const auto &description__value = o.description_.value();
        ss << "\"" << description__value << "\"";
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

GroupMembership::GroupMembership(const struct json_value_s *root)
    : id_(std::string())
    , object_type_(std::string())
    , display_name_(std::string())
    , other_mails_(std::nullopt)
    , department_(std::nullopt)
    , created_date_time_(std::nullopt) {
    if (root->type != json_type_object) {
        throw std::runtime_error("expected json value to be of type object");
    }

    const struct json_object_s *object = static_cast<const struct json_object_s *>(root->payload);
    const struct json_object_element_s *e = object->start;

    while (e != nullptr) {
        if (std::strcmp(e->name->string, "id") == 0) {
            const struct json_value_s *group_membership_value = e->value;

            if (group_membership_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *id__str = static_cast<const struct json_string_s *>(group_membership_value->payload);
            id_ = std::string(id__str->string);
        } else if (std::strcmp(e->name->string, "objectType") == 0) {
            const struct json_value_s *group_membership_value = e->value;

            if (group_membership_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *object_type__str = static_cast<const struct json_string_s *>(group_membership_value->payload);
            object_type_ = std::string(object_type__str->string);
        } else if (std::strcmp(e->name->string, "displayName") == 0) {
            const struct json_value_s *group_membership_value = e->value;

            if (group_membership_value->type != json_type_string) {
                throw std::runtime_error("expected field to be of type string");
            }
            
            const struct json_string_s *display_name__str = static_cast<const struct json_string_s *>(group_membership_value->payload);
            display_name_ = std::string(display_name__str->string);
        } else if (std::strcmp(e->name->string, "otherMails") == 0) {
            const struct json_value_s *group_membership_value = e->value;

            if (group_membership_value->type == json_type_null) {
                other_mails_ = std::nullopt;
            } else {
                if (group_membership_value->type != json_type_array) {
                    throw std::runtime_error("expected field to be of type array");
                }
                
                const struct json_array_s *other_mails__array = static_cast<const struct json_array_s *>(group_membership_value->payload);
                const struct json_array_element_s *other_mails__element = other_mails__array->start;
                std::vector<std::string> other_mails__vec = std::vector<std::string>();
                while (other_mails__element != nullptr) {
                    const struct json_value_s *group_membership_value_1 = other_mails__element->value;
                    std::string other_mails__value;
                    if (group_membership_value_1->type != json_type_string) {
                        throw std::runtime_error("expected field to be of type string");
                    }
                    
                    const struct json_string_s *other_mails__value_str = static_cast<const struct json_string_s *>(group_membership_value_1->payload);
                    other_mails__value = std::string(other_mails__value_str->string);
                    other_mails__vec.push_back(other_mails__value);
                    other_mails__element = other_mails__element->next;
                }
                other_mails_ = other_mails__vec;
            }
        } else if (std::strcmp(e->name->string, "department") == 0) {
            const struct json_value_s *group_membership_value = e->value;

            if (group_membership_value->type == json_type_null) {
                department_ = std::nullopt;
            } else {
                if (group_membership_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *department__str = static_cast<const struct json_string_s *>(group_membership_value->payload);
                department_ = std::string(department__str->string);
            }
        } else if (std::strcmp(e->name->string, "createdDateTime") == 0) {
            const struct json_value_s *group_membership_value = e->value;

            if (group_membership_value->type == json_type_null) {
                created_date_time_ = std::nullopt;
            } else {
                if (group_membership_value->type != json_type_string) {
                    throw std::runtime_error("expected field to be of type string");
                }
                
                const struct json_string_s *created_date_time__str = static_cast<const struct json_string_s *>(group_membership_value->payload);
                created_date_time_ = std::string(created_date_time__str->string);
            }
        }

        e = e->next;
    }
}

std::vector<uint8_t>
to_bytes(const GroupMembership &o) {
    std::stringstream ss;
    ss << "{";
    ss << "\"id\":";
    ss << "\"" << o.id_ << "\"";
    ss << ",";

    ss << "\"objectType\":";
    ss << "\"" << o.object_type_ << "\"";
    ss << ",";

    ss << "\"displayName\":";
    ss << "\"" << o.display_name_ << "\"";
    ss << ",";

    if (o.other_mails_.has_value()) {
        ss << "\"otherMails\":";
        const auto &other_mails__value = o.other_mails_.value();
        for (const auto &i : other_mails__value) {
            ss << "\"" << i << "\"";
        }
        ss << ",";
    }

    if (o.department_.has_value()) {
        ss << "\"department\":";
        const auto &department__value = o.department_.value();
        ss << "\"" << department__value << "\"";
        ss << ",";
    }

    if (o.created_date_time_.has_value()) {
        ss << "\"createdDateTime\":";
        const auto &created_date_time__value = o.created_date_time_.value();
        ss << "\"" << created_date_time__value << "\"";
    }

    std::string str = ss.str();
    if (str.back() == ',') {
        str.pop_back();
    }
    str.push_back('}');
    return std::vector<uint8_t>(str.begin(), str.end());
}

Result<Principal>
get_principal(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/uldirectory/v1/principal/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Principal>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<Principal>(Error("failed to parse JSON"));
    }
    return Principal(root.get());
}

Result<std::vector<Principal>>
get_principals(
    ul::RequestContext &ctx,
    const std::string &ids
) {
    std::string path = "/v1/api/uldirectory/v1/principal/:ids";
    const size_t ids_idx = path.find(":ids");
    path.replace(ids_idx, 4, ids);

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<Principal>>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<std::vector<Principal>>(Error("failed to parse JSON"));
    }
    std::vector<Principal> result;
    if (root->type != json_type_array) {
        return Result<std::vector<Principal>>(Error("expected JSON array"));
    }
    const struct json_array_s *array = static_cast<const struct json_array_s *>(root->payload);
    const struct json_array_element_s *element = array->start;
    while (element != nullptr) {
        if (element->value->type != json_type_object) {
            return Result<std::vector<Principal>>(Error("expected JSON object"));
        }
        result.push_back(Principal(element->value));
        element = element->next;
    }
    return Result<std::vector<Principal>>(result);
}

Result<std::vector<Principal>>
query_principals(
    ul::RequestContext &ctx,
    const std::string &query
) {
    std::string path = "/v1/api/uldirectory/v1/principals/:query";
    const size_t query_idx = path.find(":query");
    path.replace(query_idx, 6, query);

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<Principal>>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<std::vector<Principal>>(Error("failed to parse JSON"));
    }
    std::vector<Principal> result;
    if (root->type != json_type_array) {
        return Result<std::vector<Principal>>(Error("expected JSON array"));
    }
    const struct json_array_s *array = static_cast<const struct json_array_s *>(root->payload);
    const struct json_array_element_s *element = array->start;
    while (element != nullptr) {
        if (element->value->type != json_type_object) {
            return Result<std::vector<Principal>>(Error("expected JSON object"));
        }
        result.push_back(Principal(element->value));
        element = element->next;
    }
    return Result<std::vector<Principal>>(result);
}

Result<std::vector<AdUser>>
get_users(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/uldirectory/v1/users";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<AdUser>>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<std::vector<AdUser>>(Error("failed to parse JSON"));
    }
    std::vector<AdUser> result;
    if (root->type != json_type_array) {
        return Result<std::vector<AdUser>>(Error("expected JSON array"));
    }
    const struct json_array_s *array = static_cast<const struct json_array_s *>(root->payload);
    const struct json_array_element_s *element = array->start;
    while (element != nullptr) {
        if (element->value->type != json_type_object) {
            return Result<std::vector<AdUser>>(Error("expected JSON object"));
        }
        result.push_back(AdUser(element->value));
        element = element->next;
    }
    return Result<std::vector<AdUser>>(result);
}

Result<std::vector<DisplayNames>>
get_users_display_names(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/uldirectory/v1/users/display_names";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<DisplayNames>>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<std::vector<DisplayNames>>(Error("failed to parse JSON"));
    }
    std::vector<DisplayNames> result;
    if (root->type != json_type_array) {
        return Result<std::vector<DisplayNames>>(Error("expected JSON array"));
    }
    const struct json_array_s *array = static_cast<const struct json_array_s *>(root->payload);
    const struct json_array_element_s *element = array->start;
    while (element != nullptr) {
        if (element->value->type != json_type_object) {
            return Result<std::vector<DisplayNames>>(Error("expected JSON object"));
        }
        result.push_back(DisplayNames(element->value));
        element = element->next;
    }
    return Result<std::vector<DisplayNames>>(result);
}

Result<AdUserWithAuditLog>
get_current_user(
    ul::RequestContext &ctx,
    std::optional<bool> audit_log
) {
    std::string path = "/v1/api/uldirectory/v1/user";

    std::map<std::string, std::string> params;
    if (audit_log.has_value()) {
        const auto audit_log_value = audit_log.value();
        params["audit_log"] = audit_log_value ? "true" : "false";
    }

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<AdUserWithAuditLog>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<AdUserWithAuditLog>(Error("failed to parse JSON"));
    }
    return AdUserWithAuditLog(root.get());
}

Result<CreateUser>
create_user(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/uldirectory/v1/user";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body;
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "text/plain", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<CreateUser>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<CreateUser>(Error("failed to parse JSON"));
    }
    return CreateUser(root.get());
}

Result<Void>
update_current_user(
    ul::RequestContext &ctx,
    const UpdateCurrentUser &update_user_request
) {
    std::string path = "/v1/api/uldirectory/v1/user";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
        const std::vector<uint8_t> body = to_bytes(update_user_request);
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "application/json", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<AdUserWithAuditLog>
get_user(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<bool> audit_log
) {
    std::string path = "/v1/api/uldirectory/v1/user/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;
    if (audit_log.has_value()) {
        const auto audit_log_value = audit_log.value();
        params["audit_log"] = audit_log_value ? "true" : "false";
    }

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<AdUserWithAuditLog>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<AdUserWithAuditLog>(Error("failed to parse JSON"));
    }
    return AdUserWithAuditLog(root.get());
}

Result<Void>
update_user(
    ul::RequestContext &ctx,
    const Uuid &id,
    const UpdateUser &update_user_request
) {
    std::string path = "/v1/api/uldirectory/v1/user/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
        const std::vector<uint8_t> body = to_bytes(update_user_request);
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "application/json", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
delete_user(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/uldirectory/v1/user/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const auto res = ctx.del(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<std::vector<AdGroup>>
get_groups(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/uldirectory/v1/group";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<AdGroup>>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<std::vector<AdGroup>>(Error("failed to parse JSON"));
    }
    std::vector<AdGroup> result;
    if (root->type != json_type_array) {
        return Result<std::vector<AdGroup>>(Error("expected JSON array"));
    }
    const struct json_array_s *array = static_cast<const struct json_array_s *>(root->payload);
    const struct json_array_element_s *element = array->start;
    while (element != nullptr) {
        if (element->value->type != json_type_object) {
            return Result<std::vector<AdGroup>>(Error("expected JSON object"));
        }
        result.push_back(AdGroup(element->value));
        element = element->next;
    }
    return Result<std::vector<AdGroup>>(result);
}

Result<AdGroup>
create_group(
    ul::RequestContext &ctx,
    const CreateGroup &create_group_request
) {
    std::string path = "/v1/api/uldirectory/v1/group";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
        const std::vector<uint8_t> body = to_bytes(create_group_request);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/json", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<AdGroup>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<AdGroup>(Error("failed to parse JSON"));
    }
    return AdGroup(root.get());
}

Result<std::vector<GroupMembership>>
get_group_members(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/uldirectory/v1/group/:id/members";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<GroupMembership>>(error);
    }
    const std::vector<uint8_t> res_bytes = std::get<std::vector<uint8_t>>(res);
    const ul::AutoRelease<struct json_value_s> root = ul::AutoRelease(json_parse_ex(res_bytes.data(), res_bytes.size(), json_parse_flags_allow_json5, NULL, NULL, NULL));
    if (root == nullptr) {
        return Result<std::vector<GroupMembership>>(Error("failed to parse JSON"));
    }
    std::vector<GroupMembership> result;
    if (root->type != json_type_array) {
        return Result<std::vector<GroupMembership>>(Error("expected JSON array"));
    }
    const struct json_array_s *array = static_cast<const struct json_array_s *>(root->payload);
    const struct json_array_element_s *element = array->start;
    while (element != nullptr) {
        if (element->value->type != json_type_object) {
            return Result<std::vector<GroupMembership>>(Error("expected JSON object"));
        }
        result.push_back(GroupMembership(element->value));
        element = element->next;
    }
    return Result<std::vector<GroupMembership>>(result);
}

Result<Void>
delete_group(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/uldirectory/v1/group/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 3, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const auto res = ctx.del(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
add_group_member(
    ul::RequestContext &ctx,
    const Uuid &group,
    const Uuid &member
) {
    std::string path = "/v1/api/uldirectory/v1/group/:group/:member";
    const size_t group_idx = path.find(":group");
    path.replace(group_idx, 6, group.to_string());
    const size_t member_idx = path.find(":member");
    path.replace(member_idx, 7, member.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body;
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "text/plain", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
remove_group_member(
    ul::RequestContext &ctx,
    const Uuid &group,
    const Uuid &member
) {
    std::string path = "/v1/api/uldirectory/v1/group/:group/:member";
    const size_t group_idx = path.find(":group");
    path.replace(group_idx, 6, group.to_string());
    const size_t member_idx = path.find(":member");
    path.replace(member_idx, 7, member.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const auto res = ctx.del(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

} // namespace directory
} // namespace api
} // namespace ul
