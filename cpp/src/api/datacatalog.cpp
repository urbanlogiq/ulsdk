// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <cassert>
#include <cstring>
#include <cstdlib>
#include <sstream>
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#endif
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif
#include <arrow/record_batch.h>
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#include "ulsdk/ulsdk.h"
#include "ulsdk/external/json.h"
#include "ulsdk/api/datacatalog.h"

namespace ul {
namespace api {
namespace datacatalog {

Result<::ul::types::DataCatalogObject>
get_object_at_revision(
    ul::RequestContext &ctx,
    const Uuid &object_id,
    const Uuid &content_id
) {
    std::string path = "/v1/api/ulv2/datacatalog/content/:object_id/:content_id";
    const size_t object_id_idx = path.find(":object_id");
    path.replace(object_id_idx, 2, object_id.to_string());
    const size_t content_id_idx = path.find(":content_id");
    path.replace(content_id_idx, 2, content_id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::DataCatalogObject>(error);
    }
    return ::ul::types::DataCatalogObject(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectId>
get_acl(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/object/acl/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectId>(error);
    }
    return ::ul::types::ObjectId(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectSummary>
get_head_revision(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/object/head/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectSummary>(error);
    }
    return ::ul::types::ObjectSummary(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::DataCatalogObject>
get_object(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/object/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::DataCatalogObject>(error);
    }
    return ::ul::types::DataCatalogObject(std::get<std::vector<uint8_t>>(res));
}

Result<Void>
update_object(
    ul::RequestContext &ctx,
    const Uuid &id,
    const ::ul::types::DataCatalogObject &object
) {
    std::string path = "/v1/api/ulv2/datacatalog/object/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(object);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
update_attribute(
    ul::RequestContext &ctx,
    const Uuid &id,
    bool overwrite,
    const std::map<std::string, ul::JsonValue> &attributes
) {
    std::string path = "/v1/api/ulv2/datacatalog/object/:id/attributes";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;
    params["overwrite"] = overwrite ? "true" : "false";

    std::map<std::string, std::string> headers;
        std::stringstream body_ss;
        body_ss << "{";
        for (const auto &[k, v] : attributes) {
            body_ss << "\"" << k << "\":";
            if (std::holds_alternative<std::string>(v)) {
                body_ss << "\"" << std::get<std::string>(v) << "\"";
            } else if (std::holds_alternative<int64_t>(v)) {
                body_ss << std::get<int64_t>(v);
            } else if (std::holds_alternative<double>(v)) {
                body_ss << std::get<double>(v);
            } else if (std::holds_alternative<bool>(v)) {
                body_ss << (std::get<bool>(v) ? "true" : "false");
            } else {
                throw std::runtime_error("unsupported json type");
            }
            body_ss << ",";
        }
        body_ss.seekp(-1, std::ios_base::end);
        body_ss << "}";
        const std::string body_str = body_ss.str();
        const std::vector<uint8_t> body = std::vector<uint8_t>(body_str.begin(), body_str.end());
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/json", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
delete_attribute(
    ul::RequestContext &ctx,
    const Uuid &id,
    const std::string &key
) {
    std::string path = "/v1/api/ulv2/datacatalog/object/:id/attributes/:key";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());
    const size_t key_idx = path.find(":key");
    path.replace(key_idx, 2, key);

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const auto res = ctx.del(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<::ul::types::ObjectSummaryList>
get_object_summaries(
    ul::RequestContext &ctx,
    const ::ul::types::ObjectIdList &object_ids
) {
    std::string path = "/v1/api/ulv2/datacatalog/object_summaries";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(object_ids);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectSummaryList>(error);
    }
    return ::ul::types::ObjectSummaryList(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectIdPairList>
bulk_fetch_objects(
    ul::RequestContext &ctx,
    const ::ul::types::ObjectIdList &object_ids
) {
    std::string path = "/v1/api/ulv2/datacatalog/object_list";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(object_ids);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectIdPairList>(error);
    }
    return ::ul::types::ObjectIdPairList(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectSummaryList>
create_object(
    ul::RequestContext &ctx
) {
    std::string path = "/v1/api/ulv2/datacatalog/objects";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body;
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "text/plain", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectSummaryList>(error);
    }
    return ::ul::types::ObjectSummaryList(std::get<std::vector<uint8_t>>(res));
}

Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_numeric(
    ul::RequestContext &ctx,
    const std::string &columns,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query/aggregate/numeric";

    std::map<std::string, std::string> params;
    params["columns"] = columns;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>(error);
    }

    std::vector<uint8_t> data = std::get<std::vector<uint8_t>>(res);
    return ul::to_arrow(data);
}

Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_string(
    ul::RequestContext &ctx,
    const std::string &columns,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query/aggregate/string";

    std::map<std::string, std::string> params;
    params["columns"] = columns;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>(error);
    }

    std::vector<uint8_t> data = std::get<std::vector<uint8_t>>(res);
    return ul::to_arrow(data);
}

Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_histo(
    ul::RequestContext &ctx,
    int64_t buckets,
    const std::string &columns,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query/aggregate/histo";

    std::map<std::string, std::string> params;
    params["buckets"] = std::to_string(buckets);
    params["columns"] = columns;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>(error);
    }

    std::vector<uint8_t> data = std::get<std::vector<uint8_t>>(res);
    return ul::to_arrow(data);
}

Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_aggregate_relative_histo(
    ul::RequestContext &ctx,
    int64_t buckets,
    const std::string &numerator_columns,
    const std::string &denominator_columns,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query/aggregate/relative_histo";

    std::map<std::string, std::string> params;
    params["buckets"] = std::to_string(buckets);
    params["numerator_columns"] = numerator_columns;
    params["denominator_columns"] = denominator_columns;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>(error);
    }

    std::vector<uint8_t> data = std::get<std::vector<uint8_t>>(res);
    return ul::to_arrow(data);
}

Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
stream_get_arrow(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/vnd.apache.arrow.stream";
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>(error);
    }

    std::vector<uint8_t> data = std::get<std::vector<uint8_t>>(res);
    return ul::to_arrow(data);
}

Result<std::vector<uint8_t>>
stream_get_parquet(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/vnd.apache.parquet";
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    return res;
}

Result<std::vector<uint8_t>>
stream_get_csv(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "text/csv";
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    return res;
}

Result<std::vector<uint8_t>>
stream_get_xlsx(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    return res;
}

Result<std::vector<uint8_t>>
stream_get_json(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/json";
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    return res;
}

Result<std::vector<uint8_t>>
stream_get_text(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "text/plain";
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    return res;
}

Result<std::vector<uint8_t>>
stream_get_html(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "text/html";
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    return res;
}

Result<Void>
stream_put_arrow(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection,
    const std::vector<std::shared_ptr<::arrow::RecordBatch>> &data
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;
    if (subcollection.has_value()) {
        const auto subcollection_value = subcollection.value();
        params["subcollection"] = subcollection_value;
    }

    std::map<std::string, std::string> headers;
    std::vector<uint8_t> body = ul::to_bytes(data);
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "application/vnd.apache.arrow.stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
stream_put_diffstream(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection,
    const ::ul::types::DiffStream &data
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;
    if (subcollection.has_value()) {
        const auto subcollection_value = subcollection.value();
        params["subcollection"] = subcollection_value;
    }

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(data);
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
stream_put_json(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection,
    const std::vector<std::map<std::string, ul::JsonValue>> &data
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;
    if (subcollection.has_value()) {
        const auto subcollection_value = subcollection.value();
        params["subcollection"] = subcollection_value;
    }

    std::map<std::string, std::string> headers;
        std::stringstream body_ss;
        body_ss << "[";
        for (const auto &body_i : data) {
            std::stringstream body_var_ss;
            body_var_ss << "{";
            for (const auto &[k, v] : body_i) {
                body_var_ss << "\"" << k << "\":";
                if (std::holds_alternative<std::string>(v)) {
                    body_var_ss << "\"" << std::get<std::string>(v) << "\"";
                } else if (std::holds_alternative<int64_t>(v)) {
                    body_var_ss << std::get<int64_t>(v);
                } else if (std::holds_alternative<double>(v)) {
                    body_var_ss << std::get<double>(v);
                } else if (std::holds_alternative<bool>(v)) {
                    body_var_ss << (std::get<bool>(v) ? "true" : "false");
                } else {
                    throw std::runtime_error("unsupported json type");
                }
                body_var_ss << ",";
            }
            body_var_ss.seekp(-1, std::ios_base::end);
            body_var_ss << "}";
            const std::string body_var_str = body_var_ss.str();
            const std::vector<uint8_t> body_var = std::vector<uint8_t>(body_var_str.begin(), body_var_str.end());
            const std::string body_str = std::string(body_var.begin(), body_var.end());
            body_ss << body_var_str << ",";
        }
        body_ss.seekp(-1, std::ios_base::end);
        body_ss << "]";
        const std::string body_str = body_ss.str();
        const std::vector<uint8_t> body = std::vector<uint8_t>(body_str.begin(), body_str.end());
    const Result<std::vector<uint8_t>> res = ctx.put(path, body, "application/json", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<::ul::types::Metadata>
generate_metadata(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id/generated/metadata";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::Metadata>(error);
    }
    return ::ul::types::Metadata(std::get<std::vector<uint8_t>>(res));
}

Result<Void>
update_metadata(
    ul::RequestContext &ctx,
    const Uuid &id,
    const std::optional<::ul::types::Metadata> &metadata
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id/metadata";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    std::vector<uint8_t> body;
    if (metadata.has_value()) {
        const auto &metadata_value = metadata.value();
        const std::vector<uint8_t> body = ::ul::types::to_bytes(metadata_value);
    }
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<Void>
stream_compact(
    ul::RequestContext &ctx,
    const Uuid &id,
    std::optional<std::string> subcollection
) {
    std::string path = "/v1/api/ulv2/datacatalog/stream/:id/compact";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;
    if (subcollection.has_value()) {
        const auto subcollection_value = subcollection.value();
        params["subcollection"] = subcollection_value;
    }

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body;
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "text/plain", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<Void>(error);
    }
    return Result<Void>();
}

Result<::ul::types::History>
table_row_history(
    ul::RequestContext &ctx,
    const Uuid &id,
    const Uuid &row
) {
    std::string path = "/v1/api/ulv2/datacatalog/table/:id/history/:row";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());
    const size_t row_idx = path.find(":row");
    path.replace(row_idx, 2, row.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::History>(error);
    }
    return ::ul::types::History(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::History>
table_history(
    ul::RequestContext &ctx,
    const Uuid &id
) {
    std::string path = "/v1/api/ulv2/datacatalog/table/:id/history";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::History>(error);
    }
    return ::ul::types::History(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectId>
get_table_attachments_directory(
    ul::RequestContext &ctx,
    const Uuid &id,
    const Uuid &row
) {
    std::string path = "/v1/api/ulv2/datacatalog/table/:id/attachments/:row";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());
    const size_t row_idx = path.find(":row");
    path.replace(row_idx, 2, row.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const Result<std::vector<uint8_t>> res = ctx.get(path, params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectId>(error);
    }
    return ::ul::types::ObjectId(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectId>
get_or_create_table_attachments_directory(
    ul::RequestContext &ctx,
    const Uuid &id,
    const Uuid &row
) {
    std::string path = "/v1/api/ulv2/datacatalog/table/:id/attachments/:row";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());
    const size_t row_idx = path.find(":row");
    path.replace(row_idx, 2, row.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body;
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "text/plain", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectId>(error);
    }
    return ::ul::types::ObjectId(std::get<std::vector<uint8_t>>(res));
}

Result<::ul::types::ObjectId>
create_table(
    ul::RequestContext &ctx,
    const Uuid &id,
    const ::ul::types::NewTable &new_table
) {
    std::string path = "/v1/api/ulv2/datacatalog/table/:id";
    const size_t id_idx = path.find(":id");
    path.replace(id_idx, 2, id.to_string());

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    const std::vector<uint8_t> body = ::ul::types::to_bytes(new_table);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<::ul::types::ObjectId>(error);
    }
    return ::ul::types::ObjectId(std::get<std::vector<uint8_t>>(res));
}

Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>
query_arrow(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/vnd.apache.arrow.stream";
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    if (std::holds_alternative<Error>(res)) {
        const auto error = std::get<Error>(res);
        return Result<std::vector<std::shared_ptr<::arrow::RecordBatch>>>(error);
    }

    std::vector<uint8_t> data = std::get<std::vector<uint8_t>>(res);
    return ul::to_arrow(data);
}

Result<std::vector<uint8_t>>
query_parquet(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/vnd.apache.parquet";
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    return res;
}

Result<std::vector<uint8_t>>
query_csv(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "text/csv";
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    return res;
}

Result<std::vector<uint8_t>>
query_xlsx(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    return res;
}

Result<std::vector<uint8_t>>
query_json(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "application/json";
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    return res;
}

Result<std::vector<uint8_t>>
query_text(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "text/plain";
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    return res;
}

Result<std::vector<uint8_t>>
query_html(
    ul::RequestContext &ctx,
    const ::ul::types::Query &query
) {
    std::string path = "/v1/api/ulv2/datacatalog/query";

    std::map<std::string, std::string> params;

    std::map<std::string, std::string> headers;
    headers["Accept"] = "text/html";
    const std::vector<uint8_t> body = ::ul::types::to_bytes(query);
    const Result<std::vector<uint8_t>> res = ctx.post(path, body, "application/octet-stream", params, headers);
    return res;
}

} // namespace datacatalog
} // namespace api
} // namespace ul
