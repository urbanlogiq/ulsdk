// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/user_project.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::Filter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Filter &o) {
    if (std::holds_alternative<std::shared_ptr<CategoryFilter>>(o)) {
        const std::shared_ptr<CategoryFilter> &v = std::get<std::shared_ptr<CategoryFilter>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Filter::CategoryFilter);
    } else if (std::holds_alternative<std::shared_ptr<RangeFilter>>(o)) {
        const std::shared_ptr<RangeFilter> &v = std::get<std::shared_ptr<RangeFilter>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Filter::RangeFilter);
    } else if (std::holds_alternative<std::shared_ptr<RelationshipRangeFilter>>(o)) {
        const std::shared_ptr<RelationshipRangeFilter> &v = std::get<std::shared_ptr<RelationshipRangeFilter>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Filter::RelationshipRangeFilter);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::JoinStackEntryGeometrySourceUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const JoinStackEntryGeometrySourceUnion &o) {
    if (std::holds_alternative<std::shared_ptr<DataStateGeometrySource>>(o)) {
        const std::shared_ptr<DataStateGeometrySource> &v = std::get<std::shared_ptr<DataStateGeometrySource>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::JoinStackEntryGeometrySourceUnion::DataStateGeometrySource);
    } else if (std::holds_alternative<std::shared_ptr<RawGeometrySource>>(o)) {
        const std::shared_ptr<RawGeometrySource> &v = std::get<std::shared_ptr<RawGeometrySource>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::JoinStackEntryGeometrySourceUnion::RawGeometrySource);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::CategoryFilter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const CategoryFilter &o) {
    const ::flatbuffers::Offset<::ColumnGroupId> column_group_id_offset = serialize_to(builder, o.column_group_id_);
    std::vector<::flatbuffers::Offset<::flatbuffers::String>> values_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
    for (const auto &i: o.values_) {
        values_offsets.push_back(builder.CreateString(i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values_offset = builder.CreateVector(values_offsets);

    ::CategoryFilterBuilder instance_builder = ::CategoryFilterBuilder(builder);
    instance_builder.add_column_group_id(column_group_id_offset);
    instance_builder.add_comparator(o.comparator_);
    instance_builder.add_include_nulls(o.include_nulls_);
    instance_builder.add_values(values_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const CategoryFilter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

CategoryFilter::CategoryFilter()
    : column_group_id_()
    , comparator_(FieldComparator(0))
    , include_nulls_(false)
    , values_() {
}

CategoryFilter::CategoryFilter(const std::vector<uint8_t> &bytes)
    : CategoryFilter(::flatbuffers::GetSizePrefixedRoot<::CategoryFilter>(bytes.data())) {
}

CategoryFilter::CategoryFilter(const ::CategoryFilter *root) 
    : column_group_id_()
    , comparator_(FieldComparator(0))
    , include_nulls_(false)
    , values_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->column_group_id() != nullptr) {
        column_group_id_ = decltype(column_group_id_)(root->column_group_id());
    }
    comparator_ = root->comparator();
    include_nulls_ = root->include_nulls();
    const auto &values_vector = root->values();
    if (values_vector != nullptr) {
        values_.reserve(values_vector->size());
        for (const auto &i: *values_vector) {
            values_.emplace_back(i->begin(), i->end());
        }
    }
}

::flatbuffers::Offset<::RangeFilter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RangeFilter &o) {
    const ::flatbuffers::Offset<::ColumnGroupId> column_group_id_offset = serialize_to(builder, o.column_group_id_);

    ::RangeFilterBuilder instance_builder = ::RangeFilterBuilder(builder);
    instance_builder.add_column_group_id(column_group_id_offset);
    instance_builder.add_include_nulls(o.include_nulls_);
    instance_builder.add_max(o.max_);
    instance_builder.add_min(o.min_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RangeFilter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RangeFilter::RangeFilter()
    : column_group_id_()
    , include_nulls_(false)
    , max_(0)
    , min_(0) {
}

RangeFilter::RangeFilter(const std::vector<uint8_t> &bytes)
    : RangeFilter(::flatbuffers::GetSizePrefixedRoot<::RangeFilter>(bytes.data())) {
}

RangeFilter::RangeFilter(const ::RangeFilter *root) 
    : column_group_id_()
    , include_nulls_(false)
    , max_(0)
    , min_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->column_group_id() != nullptr) {
        column_group_id_ = decltype(column_group_id_)(root->column_group_id());
    }
    include_nulls_ = root->include_nulls();
    max_ = root->max();
    min_ = root->min();
}

::flatbuffers::Offset<::RelationshipRangeFilter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RelationshipRangeFilter &o) {
    const ::flatbuffers::Offset<::ColumnGroupId> column_group_id_offset = serialize_to(builder, o.column_group_id_);
    std::vector<::flatbuffers::Offset<::flatbuffers::String>> columns_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
    for (const auto &i: o.columns_) {
        columns_offsets.push_back(builder.CreateString(i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> columns_offset = builder.CreateVector(columns_offsets);

    ::RelationshipRangeFilterBuilder instance_builder = ::RelationshipRangeFilterBuilder(builder);
    instance_builder.add_aggregate_op(o.aggregate_op_);
    instance_builder.add_column_group_id(column_group_id_offset);
    instance_builder.add_columns(columns_offset);
    instance_builder.add_include_nulls(o.include_nulls_);
    instance_builder.add_max(o.max_);
    instance_builder.add_min(o.min_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RelationshipRangeFilter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RelationshipRangeFilter::RelationshipRangeFilter()
    : aggregate_op_(AggregateOp(0))
    , column_group_id_()
    , columns_()
    , include_nulls_(false)
    , max_(0)
    , min_(0) {
}

RelationshipRangeFilter::RelationshipRangeFilter(const std::vector<uint8_t> &bytes)
    : RelationshipRangeFilter(::flatbuffers::GetSizePrefixedRoot<::RelationshipRangeFilter>(bytes.data())) {
}

RelationshipRangeFilter::RelationshipRangeFilter(const ::RelationshipRangeFilter *root) 
    : aggregate_op_(AggregateOp(0))
    , column_group_id_()
    , columns_()
    , include_nulls_(false)
    , max_(0)
    , min_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    aggregate_op_ = root->aggregate_op();
    if (root->column_group_id() != nullptr) {
        column_group_id_ = decltype(column_group_id_)(root->column_group_id());
    }
    const auto &columns_vector = root->columns();
    if (columns_vector != nullptr) {
        columns_.reserve(columns_vector->size());
        for (const auto &i: *columns_vector) {
            columns_.emplace_back(i->begin(), i->end());
        }
    }
    include_nulls_ = root->include_nulls();
    max_ = root->max();
    min_ = root->min();
}

::flatbuffers::Offset<::DataStateGeometrySource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DataStateGeometrySource &o) {
    const ::flatbuffers::Offset<::DataStateId> data_state_id_offset = serialize_to(builder, o.data_state_id_);

    ::DataStateGeometrySourceBuilder instance_builder = ::DataStateGeometrySourceBuilder(builder);
    instance_builder.add_data_state_id(data_state_id_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DataStateGeometrySource &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DataStateGeometrySource::DataStateGeometrySource()
    : data_state_id_() {
}

DataStateGeometrySource::DataStateGeometrySource(const std::vector<uint8_t> &bytes)
    : DataStateGeometrySource(::flatbuffers::GetSizePrefixedRoot<::DataStateGeometrySource>(bytes.data())) {
}

DataStateGeometrySource::DataStateGeometrySource(const ::DataStateGeometrySource *root) 
    : data_state_id_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->data_state_id() != nullptr) {
        data_state_id_ = decltype(data_state_id_)(root->data_state_id());
    }
}

::flatbuffers::Offset<::RawGeometrySource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RawGeometrySource &o) {
    std::vector<::flatbuffers::Offset<::RawGeometrySourceGeom>> geoms_offsets = std::vector<::flatbuffers::Offset<::RawGeometrySourceGeom>>();
    geoms_offsets.reserve(o.geoms_.size());
    for (const auto &i: o.geoms_) {
        geoms_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::RawGeometrySourceGeom>>> geoms_offset = builder.CreateVector(geoms_offsets);

    ::RawGeometrySourceBuilder instance_builder = ::RawGeometrySourceBuilder(builder);
    instance_builder.add_geoms(geoms_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RawGeometrySource &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RawGeometrySource::RawGeometrySource()
    : geoms_() {
}

RawGeometrySource::RawGeometrySource(const std::vector<uint8_t> &bytes)
    : RawGeometrySource(::flatbuffers::GetSizePrefixedRoot<::RawGeometrySource>(bytes.data())) {
}

RawGeometrySource::RawGeometrySource(const ::RawGeometrySource *root) 
    : geoms_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &geoms_vector = root->geoms();
    if (geoms_vector != nullptr) {
        geoms_.reserve(geoms_vector->size());
        for (const auto &i: *geoms_vector) {
            geoms_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::ColumnGroup>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ColumnGroup &o) {
    std::vector<::flatbuffers::Offset<::flatbuffers::String>> columns_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
    for (const auto &i: o.columns_) {
        columns_offsets.push_back(builder.CreateString(i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> columns_offset = builder.CreateVector(columns_offsets);
    const ::flatbuffers::Offset<::flatbuffers::String> display_name_offset = builder.CreateString(o.display_name_);
    const ::flatbuffers::Offset<::ColumnGroupId> id_offset = serialize_to(builder, o.id_);
    std::optional<::flatbuffers::Offset<::StreamId>> stream_id_offset = std::nullopt;
    if (o.stream_id_.has_value()) {
        const ::flatbuffers::Offset<::StreamId> stream_id_offset_val = serialize_to(builder, o.stream_id_.value());
        stream_id_offset = std::make_optional(stream_id_offset_val);
    }

    ::ColumnGroupBuilder instance_builder = ::ColumnGroupBuilder(builder);
    instance_builder.add_columns(columns_offset);
    instance_builder.add_display_name(display_name_offset);
    instance_builder.add_id(id_offset);
    if (stream_id_offset.has_value()) {
        instance_builder.add_stream_id(stream_id_offset.value());
    }
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ColumnGroup &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ColumnGroup::ColumnGroup()
    : columns_()
    , display_name_()
    , id_()
    , stream_id_(std::nullopt)
    , ty_(ColumnGroupType(0)) {
}

ColumnGroup::ColumnGroup(const std::vector<uint8_t> &bytes)
    : ColumnGroup(::flatbuffers::GetSizePrefixedRoot<::ColumnGroup>(bytes.data())) {
}

ColumnGroup::ColumnGroup(const ::ColumnGroup *root) 
    : columns_()
    , display_name_()
    , id_()
    , stream_id_(std::nullopt)
    , ty_(ColumnGroupType(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &columns_vector = root->columns();
    if (columns_vector != nullptr) {
        columns_.reserve(columns_vector->size());
        for (const auto &i: *columns_vector) {
            columns_.emplace_back(i->begin(), i->end());
        }
    }
        display_name_ = std::string(*root->display_name()->begin(), *root->display_name()->end());
    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    if (root->stream_id() != nullptr) {
        stream_id_ = decltype(stream_id_)(root->stream_id());
    }
    ty_ = root->ty();
}

::flatbuffers::Offset<::DeprecatedDataStateJoin>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DeprecatedDataStateJoin &o) {
    const ::flatbuffers::Offset<::DataStateId> from_offset = serialize_to(builder, o.from_);
    const ::flatbuffers::Offset<::DataStateId> to_offset = serialize_to(builder, o.to_);

    ::DeprecatedDataStateJoinBuilder instance_builder = ::DeprecatedDataStateJoinBuilder(builder);
    instance_builder.add_distance(o.distance_);
    instance_builder.add_from(from_offset);
    instance_builder.add_operation(o.operation_);
    instance_builder.add_to(to_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DeprecatedDataStateJoin &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DeprecatedDataStateJoin::DeprecatedDataStateJoin()
    : distance_(0)
    , from_()
    , operation_(JoinOperation(0))
    , to_() {
}

DeprecatedDataStateJoin::DeprecatedDataStateJoin(const std::vector<uint8_t> &bytes)
    : DeprecatedDataStateJoin(::flatbuffers::GetSizePrefixedRoot<::DeprecatedDataStateJoin>(bytes.data())) {
}

DeprecatedDataStateJoin::DeprecatedDataStateJoin(const ::DeprecatedDataStateJoin *root) 
    : distance_(0)
    , from_()
    , operation_(JoinOperation(0))
    , to_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    distance_ = root->distance();
    if (root->from() != nullptr) {
        from_ = decltype(from_)(root->from());
    }
    operation_ = root->operation();
    if (root->to() != nullptr) {
        to_ = decltype(to_)(root->to());
    }
}

::flatbuffers::Offset<::FieldFilter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FieldFilter &o) {
    const std::pair<::flatbuffers::Offset<void>, ::Filter> filter_offset = serialize_to(builder, o.filter_);

    ::FieldFilterBuilder instance_builder = ::FieldFilterBuilder(builder);
    instance_builder.add_filter(filter_offset.first);
    instance_builder.add_filter_type(filter_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const FieldFilter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

FieldFilter::FieldFilter()
    : filter_(std::make_shared<CategoryFilter>()) {
}

FieldFilter::FieldFilter(const std::vector<uint8_t> &bytes)
    : FieldFilter(::flatbuffers::GetSizePrefixedRoot<::FieldFilter>(bytes.data())) {
}

FieldFilter::FieldFilter(const ::FieldFilter *root) 
    : filter_(std::make_shared<CategoryFilter>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->filter() != nullptr) {
        switch (root->filter_type()) {
            case ::Filter::NONE: throw std::runtime_error("unexpected none variant");
            case ::Filter::CategoryFilter: {
                const auto filter__local = static_cast<const ::CategoryFilter *>(root->filter());
                std::shared_ptr<CategoryFilter> filter__shared = std::make_shared<CategoryFilter>(filter__local);
                filter_ = filter__shared;
                break;
            }
            case ::Filter::RangeFilter: {
                const auto filter__local = static_cast<const ::RangeFilter *>(root->filter());
                std::shared_ptr<RangeFilter> filter__shared = std::make_shared<RangeFilter>(filter__local);
                filter_ = filter__shared;
                break;
            }
            case ::Filter::RelationshipRangeFilter: {
                const auto filter__local = static_cast<const ::RelationshipRangeFilter *>(root->filter());
                std::shared_ptr<RelationshipRangeFilter> filter__shared = std::make_shared<RelationshipRangeFilter>(filter__local);
                filter_ = filter__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::JoinStackEntry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const JoinStackEntry &o) {
    std::optional<::flatbuffers::Offset<::DataStateId>> deprecated_data_state_id_do_not_use_offset = std::nullopt;
    if (o.deprecated_data_state_id_do_not_use_.has_value()) {
        const ::flatbuffers::Offset<::DataStateId> deprecated_data_state_id_do_not_use_offset_val = serialize_to(builder, o.deprecated_data_state_id_do_not_use_.value());
        deprecated_data_state_id_do_not_use_offset = std::make_optional(deprecated_data_state_id_do_not_use_offset_val);
    }
    const std::pair<::flatbuffers::Offset<void>, ::JoinStackEntryGeometrySourceUnion> geometry_source_offset = serialize_to(builder, o.geometry_source_);

    ::JoinStackEntryBuilder instance_builder = ::JoinStackEntryBuilder(builder);
    instance_builder.add_buffer(o.buffer_);
    if (deprecated_data_state_id_do_not_use_offset.has_value()) {
        instance_builder.add_deprecated_data_state_id_do_not_use(deprecated_data_state_id_do_not_use_offset.value());
    }
    instance_builder.add_geometry_source(geometry_source_offset.first);
    instance_builder.add_geometry_source_type(geometry_source_offset.second);
    instance_builder.add_mode(o.mode_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const JoinStackEntry &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

JoinStackEntry::JoinStackEntry()
    : buffer_(0)
    , deprecated_data_state_id_do_not_use_(std::nullopt)
    , geometry_source_(std::make_shared<DataStateGeometrySource>())
    , mode_(LayerCombineMode(0)) {
}

JoinStackEntry::JoinStackEntry(const std::vector<uint8_t> &bytes)
    : JoinStackEntry(::flatbuffers::GetSizePrefixedRoot<::JoinStackEntry>(bytes.data())) {
}

JoinStackEntry::JoinStackEntry(const ::JoinStackEntry *root) 
    : buffer_(0)
    , deprecated_data_state_id_do_not_use_(std::nullopt)
    , geometry_source_(std::make_shared<DataStateGeometrySource>())
    , mode_(LayerCombineMode(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    buffer_ = root->buffer();
    if (root->deprecated_data_state_id_do_not_use() != nullptr) {
        deprecated_data_state_id_do_not_use_ = decltype(deprecated_data_state_id_do_not_use_)(root->deprecated_data_state_id_do_not_use());
    }
    if (root->geometry_source() != nullptr) {
        switch (root->geometry_source_type()) {
            case ::JoinStackEntryGeometrySourceUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::JoinStackEntryGeometrySourceUnion::DataStateGeometrySource: {
                const auto geometry_source__local = static_cast<const ::DataStateGeometrySource *>(root->geometry_source());
                std::shared_ptr<DataStateGeometrySource> geometry_source__shared = std::make_shared<DataStateGeometrySource>(geometry_source__local);
                geometry_source_ = geometry_source__shared;
                break;
            }
            case ::JoinStackEntryGeometrySourceUnion::RawGeometrySource: {
                const auto geometry_source__local = static_cast<const ::RawGeometrySource *>(root->geometry_source());
                std::shared_ptr<RawGeometrySource> geometry_source__shared = std::make_shared<RawGeometrySource>(geometry_source__local);
                geometry_source_ = geometry_source__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    mode_ = root->mode();
}

::flatbuffers::Offset<::RawGeometrySourceGeom>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RawGeometrySourceGeom &o) {
    const std::pair<::flatbuffers::Offset<void>, ::Geometry> geom_offset = serialize_to(builder, o.geom_);

    ::RawGeometrySourceGeomBuilder instance_builder = ::RawGeometrySourceGeomBuilder(builder);
    instance_builder.add_geom(geom_offset.first);
    instance_builder.add_geom_type(geom_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RawGeometrySourceGeom &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RawGeometrySourceGeom::RawGeometrySourceGeom()
    : geom_(std::make_shared<Point>()) {
}

RawGeometrySourceGeom::RawGeometrySourceGeom(const std::vector<uint8_t> &bytes)
    : RawGeometrySourceGeom(::flatbuffers::GetSizePrefixedRoot<::RawGeometrySourceGeom>(bytes.data())) {
}

RawGeometrySourceGeom::RawGeometrySourceGeom(const ::RawGeometrySourceGeom *root) 
    : geom_(std::make_shared<Point>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->geom() != nullptr) {
        switch (root->geom_type()) {
            case ::Geometry::NONE: throw std::runtime_error("unexpected none variant");
            case ::Geometry::Point: {
                const auto geom__local = static_cast<const ::Point *>(root->geom());
                std::shared_ptr<Point> geom__shared = std::make_shared<Point>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::Line: {
                const auto geom__local = static_cast<const ::Line *>(root->geom());
                std::shared_ptr<Line> geom__shared = std::make_shared<Line>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::MultiLine: {
                const auto geom__local = static_cast<const ::MultiLine *>(root->geom());
                std::shared_ptr<MultiLine> geom__shared = std::make_shared<MultiLine>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::Polygon: {
                const auto geom__local = static_cast<const ::Polygon *>(root->geom());
                std::shared_ptr<Polygon> geom__shared = std::make_shared<Polygon>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::MultiPolygon: {
                const auto geom__local = static_cast<const ::MultiPolygon *>(root->geom());
                std::shared_ptr<MultiPolygon> geom__shared = std::make_shared<MultiPolygon>(geom__local);
                geom_ = geom__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::StackableDataStateJoin>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const StackableDataStateJoin &o) {
    std::vector<::flatbuffers::Offset<::JoinStackEntry>> join_stack_offsets = std::vector<::flatbuffers::Offset<::JoinStackEntry>>();
    join_stack_offsets.reserve(o.join_stack_.size());
    for (const auto &i: o.join_stack_) {
        join_stack_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::JoinStackEntry>>> join_stack_offset = builder.CreateVector(join_stack_offsets);
    const ::flatbuffers::Offset<::DataStateId> target_offset = serialize_to(builder, o.target_);

    ::StackableDataStateJoinBuilder instance_builder = ::StackableDataStateJoinBuilder(builder);
    instance_builder.add_buffer(o.buffer_);
    instance_builder.add_join_stack(join_stack_offset);
    instance_builder.add_op(o.op_);
    instance_builder.add_target(target_offset);
    instance_builder.add_type(o.type_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const StackableDataStateJoin &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

StackableDataStateJoin::StackableDataStateJoin()
    : buffer_(0)
    , join_stack_()
    , op_(JoinOperation(0))
    , target_()
    , type_(JoinType(0)) {
}

StackableDataStateJoin::StackableDataStateJoin(const std::vector<uint8_t> &bytes)
    : StackableDataStateJoin(::flatbuffers::GetSizePrefixedRoot<::StackableDataStateJoin>(bytes.data())) {
}

StackableDataStateJoin::StackableDataStateJoin(const ::StackableDataStateJoin *root) 
    : buffer_(0)
    , join_stack_()
    , op_(JoinOperation(0))
    , target_()
    , type_(JoinType(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    buffer_ = root->buffer();
    const auto &join_stack_vector = root->join_stack();
    if (join_stack_vector != nullptr) {
        join_stack_.reserve(join_stack_vector->size());
        for (const auto &i: *join_stack_vector) {
            join_stack_.emplace_back(i);
        }
    }
    op_ = root->op();
    if (root->target() != nullptr) {
        target_ = decltype(target_)(root->target());
    }
    type_ = root->type();
}

::flatbuffers::Offset<::UserLayer>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UserLayer &o) {
    std::vector<::flatbuffers::Offset<::UserLayerDataState>> data_states_offsets = std::vector<::flatbuffers::Offset<::UserLayerDataState>>();
    data_states_offsets.reserve(o.data_states_.size());
    for (const auto &i: o.data_states_) {
        data_states_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::UserLayerDataState>>> data_states_offset = builder.CreateVector(data_states_offsets);
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::DeprecatedDataStateJoin>>>> deprecated_data_joins_do_not_use_offset = std::nullopt;
    if (o.deprecated_data_joins_do_not_use_.has_value()) {
        const auto &deprecated_data_joins_do_not_use__var = o.deprecated_data_joins_do_not_use_.value();
        std::vector<::flatbuffers::Offset<::DeprecatedDataStateJoin>> deprecated_data_joins_do_not_use_offsets = std::vector<::flatbuffers::Offset<::DeprecatedDataStateJoin>>();
        deprecated_data_joins_do_not_use_offsets.reserve(deprecated_data_joins_do_not_use__var.size());
        for (const auto &i: deprecated_data_joins_do_not_use__var) {
            deprecated_data_joins_do_not_use_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::DeprecatedDataStateJoin>>> deprecated_data_joins_do_not_use_offset_val = builder.CreateVector(deprecated_data_joins_do_not_use_offsets);
        deprecated_data_joins_do_not_use_offset = std::make_optional(deprecated_data_joins_do_not_use_offset_val);
    }
    std::vector<::flatbuffers::Offset<::StackableDataStateJoin>> joins_offsets = std::vector<::flatbuffers::Offset<::StackableDataStateJoin>>();
    joins_offsets.reserve(o.joins_.size());
    for (const auto &i: o.joins_) {
        joins_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::StackableDataStateJoin>>> joins_offset = builder.CreateVector(joins_offsets);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> name_offset = std::nullopt;
    if (o.name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> name_offset_val = builder.CreateString(o.name_.value());
        name_offset = std::make_optional(name_offset_val);
    }

    ::UserLayerBuilder instance_builder = ::UserLayerBuilder(builder);
    instance_builder.add_data_states(data_states_offset);
    if (deprecated_data_joins_do_not_use_offset.has_value()) {
        instance_builder.add_deprecated_data_joins_do_not_use(deprecated_data_joins_do_not_use_offset.value());
    }
    instance_builder.add_joins(joins_offset);
    if (name_offset.has_value()) {
        instance_builder.add_name(name_offset.value());
    }
    instance_builder.add_visible(o.visible_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UserLayer &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UserLayer::UserLayer()
    : data_states_()
    , deprecated_data_joins_do_not_use_(std::nullopt)
    , joins_()
    , name_(std::nullopt)
    , visible_(true) {
}

UserLayer::UserLayer(const std::vector<uint8_t> &bytes)
    : UserLayer(::flatbuffers::GetSizePrefixedRoot<::UserLayer>(bytes.data())) {
}

UserLayer::UserLayer(const ::UserLayer *root) 
    : data_states_()
    , deprecated_data_joins_do_not_use_(std::nullopt)
    , joins_()
    , name_(std::nullopt)
    , visible_(true) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &data_states_vector = root->data_states();
    if (data_states_vector != nullptr) {
        data_states_.reserve(data_states_vector->size());
        for (const auto &i: *data_states_vector) {
            data_states_.emplace_back(i);
        }
    }
    const auto &deprecated_data_joins_do_not_use_vector = root->deprecated_data_joins_do_not_use();
    if (deprecated_data_joins_do_not_use_vector != nullptr) {
        decltype(deprecated_data_joins_do_not_use_)::value_type deprecated_data_joins_do_not_use__target = decltype(deprecated_data_joins_do_not_use_)::value_type();
        deprecated_data_joins_do_not_use__target.reserve(deprecated_data_joins_do_not_use_vector->size());
        for (const auto &i: *deprecated_data_joins_do_not_use_vector) {
            deprecated_data_joins_do_not_use__target.emplace_back(i);
        }
        deprecated_data_joins_do_not_use_ = std::make_optional(deprecated_data_joins_do_not_use__target);
    }
    const auto &joins_vector = root->joins();
    if (joins_vector != nullptr) {
        joins_.reserve(joins_vector->size());
        for (const auto &i: *joins_vector) {
            joins_.emplace_back(i);
        }
    }
    if (root->name() != nullptr) {
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    }
    visible_ = root->visible();
}

::flatbuffers::Offset<::UserLayerDataState>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UserLayerDataState &o) {
    std::vector<::flatbuffers::Offset<::ColumnGroup>> active_fields_offsets = std::vector<::flatbuffers::Offset<::ColumnGroup>>();
    active_fields_offsets.reserve(o.active_fields_.size());
    for (const auto &i: o.active_fields_) {
        active_fields_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ColumnGroup>>> active_fields_offset = builder.CreateVector(active_fields_offsets);
    const ::flatbuffers::Offset<::DataStateId> data_state_id_offset = serialize_to(builder, o.data_state_id_);
    std::vector<::flatbuffers::Offset<::FieldFilter>> filters_offsets = std::vector<::flatbuffers::Offset<::FieldFilter>>();
    filters_offsets.reserve(o.filters_.size());
    for (const auto &i: o.filters_) {
        filters_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::FieldFilter>>> filters_offset = builder.CreateVector(filters_offsets);
    const ::flatbuffers::Offset<::StreamId> stream_id_offset = serialize_to(builder, o.stream_id_);

    ::UserLayerDataStateBuilder instance_builder = ::UserLayerDataStateBuilder(builder);
    instance_builder.add_active_fields(active_fields_offset);
    instance_builder.add_data_state_id(data_state_id_offset);
    instance_builder.add_filters(filters_offset);
    instance_builder.add_stream_id(stream_id_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UserLayerDataState &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UserLayerDataState::UserLayerDataState()
    : active_fields_()
    , data_state_id_()
    , filters_()
    , stream_id_() {
}

UserLayerDataState::UserLayerDataState(const std::vector<uint8_t> &bytes)
    : UserLayerDataState(::flatbuffers::GetSizePrefixedRoot<::UserLayerDataState>(bytes.data())) {
}

UserLayerDataState::UserLayerDataState(const ::UserLayerDataState *root) 
    : active_fields_()
    , data_state_id_()
    , filters_()
    , stream_id_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &active_fields_vector = root->active_fields();
    if (active_fields_vector != nullptr) {
        active_fields_.reserve(active_fields_vector->size());
        for (const auto &i: *active_fields_vector) {
            active_fields_.emplace_back(i);
        }
    }
    if (root->data_state_id() != nullptr) {
        data_state_id_ = decltype(data_state_id_)(root->data_state_id());
    }
    const auto &filters_vector = root->filters();
    if (filters_vector != nullptr) {
        filters_.reserve(filters_vector->size());
        for (const auto &i: *filters_vector) {
            filters_.emplace_back(i);
        }
    }
    if (root->stream_id() != nullptr) {
        stream_id_ = decltype(stream_id_)(root->stream_id());
    }
}

::flatbuffers::Offset<::UserProject>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UserProject &o) {
    const ::flatbuffers::Offset<::GenericId> id_offset = serialize_to(builder, o.id_);
    std::vector<::flatbuffers::Offset<::UserLayer>> layers_offsets = std::vector<::flatbuffers::Offset<::UserLayer>>();
    layers_offsets.reserve(o.layers_.size());
    for (const auto &i: o.layers_) {
        layers_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::UserLayer>>> layers_offset = builder.CreateVector(layers_offsets);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> name_offset = std::nullopt;
    if (o.name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> name_offset_val = builder.CreateString(o.name_.value());
        name_offset = std::make_optional(name_offset_val);
    }

    ::UserProjectBuilder instance_builder = ::UserProjectBuilder(builder);
    instance_builder.add_id(id_offset);
    instance_builder.add_layers(layers_offset);
    if (name_offset.has_value()) {
        instance_builder.add_name(name_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UserProject &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UserProject::UserProject()
    : id_()
    , layers_()
    , name_(std::nullopt) {
}

UserProject::UserProject(const std::vector<uint8_t> &bytes)
    : UserProject(::flatbuffers::GetSizePrefixedRoot<::UserProject>(bytes.data())) {
}

UserProject::UserProject(const ::UserProject *root) 
    : id_()
    , layers_()
    , name_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    const auto &layers_vector = root->layers();
    if (layers_vector != nullptr) {
        layers_.reserve(layers_vector->size());
        for (const auto &i: *layers_vector) {
            layers_.emplace_back(i);
        }
    }
    if (root->name() != nullptr) {
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    }
}

} // namespace types
} // namespace ul
