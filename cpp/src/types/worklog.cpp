// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/worklog.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::ParameterValue>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterValue &o) {
    if (std::holds_alternative<std::shared_ptr<ByteArray>>(o)) {
        const std::shared_ptr<ByteArray> &v = std::get<std::shared_ptr<ByteArray>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ParameterValue::ByteArray);
    } else if (std::holds_alternative<std::shared_ptr<ObjectId>>(o)) {
        const std::shared_ptr<ObjectId> &v = std::get<std::shared_ptr<ObjectId>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ParameterValue::ObjectId);
    } else if (std::holds_alternative<std::shared_ptr<ParameterFlags>>(o)) {
        const std::shared_ptr<ParameterFlags> &v = std::get<std::shared_ptr<ParameterFlags>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ParameterValue::ParameterFlags);
    } else if (std::holds_alternative<std::shared_ptr<ValueInstance>>(o)) {
        const std::shared_ptr<ValueInstance> &v = std::get<std::shared_ptr<ValueInstance>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ParameterValue::ValueInstance);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::ByteArray>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ByteArray &o) {
    std::optional<decltype(builder.CreateVector(o.b_.value()))> b_offset = std::nullopt;
    if (o.b_.has_value()) {
        const decltype(builder.CreateVector(o.b_.value())) b_offset_val = builder.CreateVector(o.b_.value());
        b_offset = std::make_optional(b_offset_val);
    }

    ::ByteArrayBuilder instance_builder = ::ByteArrayBuilder(builder);
    if (b_offset.has_value()) {
        instance_builder.add_b(b_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ByteArray &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ByteArray::ByteArray()
    : b_(std::nullopt) {
}

ByteArray::ByteArray(const std::vector<uint8_t> &bytes)
    : ByteArray(::flatbuffers::GetSizePrefixedRoot<::ByteArray>(bytes.data())) {
}

ByteArray::ByteArray(const ::ByteArray *root) 
    : b_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        decltype(b_)::value_type b__target = decltype(b_)::value_type();
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b__target));
        b_ = std::make_optional(b__target);
    }
}

::flatbuffers::Offset<::ParameterFlags>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterFlags &o) {

    ::ParameterFlagsBuilder instance_builder = ::ParameterFlagsBuilder(builder);
    instance_builder.add_flags(o.flags_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ParameterFlags &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ParameterFlags::ParameterFlags()
    : flags_(0) {
}

ParameterFlags::ParameterFlags(const std::vector<uint8_t> &bytes)
    : ParameterFlags(::flatbuffers::GetSizePrefixedRoot<::ParameterFlags>(bytes.data())) {
}

ParameterFlags::ParameterFlags(const ::ParameterFlags *root) 
    : flags_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    flags_ = root->flags();
}

::flatbuffers::Offset<::Layout>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Layout &o) {

    ::LayoutBuilder instance_builder = ::LayoutBuilder(builder);
    instance_builder.add_height(o.height_);
    instance_builder.add_width(o.width_);
    instance_builder.add_x(o.x_);
    instance_builder.add_y(o.y_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Layout &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Layout::Layout()
    : height_(0)
    , width_(0)
    , x_(0)
    , y_(0) {
}

Layout::Layout(const std::vector<uint8_t> &bytes)
    : Layout(::flatbuffers::GetSizePrefixedRoot<::Layout>(bytes.data())) {
}

Layout::Layout(const ::Layout *root) 
    : height_(0)
    , width_(0)
    , x_(0)
    , y_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    height_ = root->height();
    width_ = root->width();
    x_ = root->x();
    y_ = root->y();
}

::flatbuffers::Offset<::TileSettings>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TileSettings &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> field_name_offset = builder.CreateString(o.field_name_);
    const ::flatbuffers::Offset<::ObjectId> metadata_id_offset = serialize_to(builder, o.metadata_id_);
    std::optional<::flatbuffers::Offset<::ObjectId>> record_count_stream_id_offset = std::nullopt;
    if (o.record_count_stream_id_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> record_count_stream_id_offset_val = serialize_to(builder, o.record_count_stream_id_.value());
        record_count_stream_id_offset = std::make_optional(record_count_stream_id_offset_val);
    }
    std::vector<::flatbuffers::Offset<::flatbuffers::String>> selected_columns_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
    for (const auto &i: o.selected_columns_) {
        selected_columns_offsets.push_back(builder.CreateString(i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> selected_columns_offset = builder.CreateVector(selected_columns_offsets);
    const ::flatbuffers::Offset<::flatbuffers::String> title_offset = builder.CreateString(o.title_);

    ::TileSettingsBuilder instance_builder = ::TileSettingsBuilder(builder);
    instance_builder.add_aggregation(o.aggregation_);
    instance_builder.add_category(o.category_);
    instance_builder.add_chart_type(o.chart_type_);
    instance_builder.add_field_name(field_name_offset);
    instance_builder.add_group_others(o.group_others_);
    instance_builder.add_is_record_count_tile(o.is_record_count_tile_);
    instance_builder.add_is_relationship_field(o.is_relationship_field_);
    instance_builder.add_metadata_id(metadata_id_offset);
    instance_builder.add_output_stream_index(o.output_stream_index_);
    if (record_count_stream_id_offset.has_value()) {
        instance_builder.add_record_count_stream_id(record_count_stream_id_offset.value());
    }
    instance_builder.add_selected_columns(selected_columns_offset);
    instance_builder.add_text_tile_font_size(o.text_tile_font_size_);
    instance_builder.add_title(title_offset);
    instance_builder.add_values_format(o.values_format_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TileSettings &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TileSettings::TileSettings()
    : aggregation_(AggregationTy(0))
    , category_(0)
    , chart_type_(ChartTypeTy(0))
    , field_name_()
    , group_others_(false)
    , is_record_count_tile_(false)
    , is_relationship_field_(false)
    , metadata_id_()
    , output_stream_index_(0)
    , record_count_stream_id_(std::nullopt)
    , selected_columns_()
    , text_tile_font_size_(0)
    , title_()
    , values_format_(ValuesFormatTy(0)) {
}

TileSettings::TileSettings(const std::vector<uint8_t> &bytes)
    : TileSettings(::flatbuffers::GetSizePrefixedRoot<::TileSettings>(bytes.data())) {
}

TileSettings::TileSettings(const ::TileSettings *root) 
    : aggregation_(AggregationTy(0))
    , category_(0)
    , chart_type_(ChartTypeTy(0))
    , field_name_()
    , group_others_(false)
    , is_record_count_tile_(false)
    , is_relationship_field_(false)
    , metadata_id_()
    , output_stream_index_(0)
    , record_count_stream_id_(std::nullopt)
    , selected_columns_()
    , text_tile_font_size_(0)
    , title_()
    , values_format_(ValuesFormatTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    aggregation_ = root->aggregation();
    category_ = root->category();
    chart_type_ = root->chart_type();
        field_name_ = std::string(*root->field_name()->begin(), *root->field_name()->end());
    group_others_ = root->group_others();
    is_record_count_tile_ = root->is_record_count_tile();
    is_relationship_field_ = root->is_relationship_field();
    if (root->metadata_id() != nullptr) {
        metadata_id_ = decltype(metadata_id_)(root->metadata_id());
    }
    output_stream_index_ = root->output_stream_index();
    if (root->record_count_stream_id() != nullptr) {
        record_count_stream_id_ = decltype(record_count_stream_id_)(root->record_count_stream_id());
    }
    const auto &selected_columns_vector = root->selected_columns();
    if (selected_columns_vector != nullptr) {
        selected_columns_.reserve(selected_columns_vector->size());
        for (const auto &i: *selected_columns_vector) {
            selected_columns_.emplace_back(i->begin(), i->end());
        }
    }
    text_tile_font_size_ = root->text_tile_font_size();
        title_ = std::string(*root->title()->begin(), *root->title()->end());
    values_format_ = root->values_format();
}

::flatbuffers::Offset<::TileData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TileData &o) {
    const ::flatbuffers::Offset<::Layout> layout_offset = serialize_to(builder, o.layout_);
    const ::flatbuffers::Offset<::TileSettings> tile_settings_offset = serialize_to(builder, o.tile_settings_);

    ::TileDataBuilder instance_builder = ::TileDataBuilder(builder);
    instance_builder.add_layout(layout_offset);
    instance_builder.add_tile_settings(tile_settings_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TileData &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TileData::TileData()
    : layout_()
    , tile_settings_() {
}

TileData::TileData(const std::vector<uint8_t> &bytes)
    : TileData(::flatbuffers::GetSizePrefixedRoot<::TileData>(bytes.data())) {
}

TileData::TileData(const ::TileData *root) 
    : layout_()
    , tile_settings_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->layout() != nullptr) {
        layout_ = decltype(layout_)(root->layout());
    }
    if (root->tile_settings() != nullptr) {
        tile_settings_ = decltype(tile_settings_)(root->tile_settings());
    }
}

::flatbuffers::Offset<::UserSettings>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UserSettings &o) {
    std::vector<::flatbuffers::Offset<::TileData>> tile_data_offsets = std::vector<::flatbuffers::Offset<::TileData>>();
    tile_data_offsets.reserve(o.tile_data_.size());
    for (const auto &i: o.tile_data_) {
        tile_data_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TileData>>> tile_data_offset = builder.CreateVector(tile_data_offsets);

    ::UserSettingsBuilder instance_builder = ::UserSettingsBuilder(builder);
    instance_builder.add_is_template(o.is_template_);
    instance_builder.add_tile_data(tile_data_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UserSettings &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UserSettings::UserSettings()
    : is_template_(false)
    , tile_data_() {
}

UserSettings::UserSettings(const std::vector<uint8_t> &bytes)
    : UserSettings(::flatbuffers::GetSizePrefixedRoot<::UserSettings>(bytes.data())) {
}

UserSettings::UserSettings(const ::UserSettings *root) 
    : is_template_(false)
    , tile_data_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    is_template_ = root->is_template();
    const auto &tile_data_vector = root->tile_data();
    if (tile_data_vector != nullptr) {
        tile_data_.reserve(tile_data_vector->size());
        for (const auto &i: *tile_data_vector) {
            tile_data_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::WorkLog>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorkLog &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>>> input_streams_offset = std::nullopt;
    if (o.input_streams_.has_value()) {
        const auto &input_streams__var = o.input_streams_.value();
        std::vector<::flatbuffers::Offset<::ObjectId>> input_streams_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
        input_streams_offsets.reserve(input_streams__var.size());
        for (const auto &i: input_streams__var) {
            input_streams_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> input_streams_offset_val = builder.CreateVector(input_streams_offsets);
        input_streams_offset = std::make_optional(input_streams_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ObjectId>> job_id_offset = std::nullopt;
    if (o.job_id_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> job_id_offset_val = serialize_to(builder, o.job_id_.value());
        job_id_offset = std::make_optional(job_id_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> name_offset = std::nullopt;
    if (o.name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> name_offset_val = builder.CreateString(o.name_.value());
        name_offset = std::make_optional(name_offset_val);
    }
    std::vector<::flatbuffers::Offset<::ObjectId>> output_streams_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
    output_streams_offsets.reserve(o.output_streams_.size());
    for (const auto &i: o.output_streams_) {
        output_streams_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> output_streams_offset = builder.CreateVector(output_streams_offsets);
    std::vector<::flatbuffers::Offset<::WorklogParameter>> params_offsets = std::vector<::flatbuffers::Offset<::WorklogParameter>>();
    params_offsets.reserve(o.params_.size());
    for (const auto &i: o.params_) {
        params_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::WorklogParameter>>> params_offset = builder.CreateVector(params_offsets);
    std::optional<::flatbuffers::Offset<::ObjectId>> parent_offset = std::nullopt;
    if (o.parent_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> parent_offset_val = serialize_to(builder, o.parent_.value());
        parent_offset = std::make_optional(parent_offset_val);
    }
    const ::flatbuffers::Offset<::ObjectId> schematic_offset = serialize_to(builder, o.schematic_);
    std::optional<::flatbuffers::Offset<::UserSettings>> user_settings_offset = std::nullopt;
    if (o.user_settings_.has_value()) {
        const ::flatbuffers::Offset<::UserSettings> user_settings_offset_val = serialize_to(builder, o.user_settings_.value());
        user_settings_offset = std::make_optional(user_settings_offset_val);
    }

    ::WorkLogBuilder instance_builder = ::WorkLogBuilder(builder);
    if (input_streams_offset.has_value()) {
        instance_builder.add_input_streams(input_streams_offset.value());
    }
    if (job_id_offset.has_value()) {
        instance_builder.add_job_id(job_id_offset.value());
    }
    if (name_offset.has_value()) {
        instance_builder.add_name(name_offset.value());
    }
    instance_builder.add_output_streams(output_streams_offset);
    instance_builder.add_params(params_offset);
    if (parent_offset.has_value()) {
        instance_builder.add_parent(parent_offset.value());
    }
    instance_builder.add_schematic(schematic_offset);
    if (user_settings_offset.has_value()) {
        instance_builder.add_user_settings(user_settings_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const WorkLog &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

WorkLog::WorkLog()
    : input_streams_(std::nullopt)
    , job_id_(std::nullopt)
    , name_(std::nullopt)
    , output_streams_()
    , params_()
    , parent_(std::nullopt)
    , schematic_()
    , user_settings_(std::nullopt) {
}

WorkLog::WorkLog(const std::vector<uint8_t> &bytes)
    : WorkLog(::flatbuffers::GetSizePrefixedRoot<::WorkLog>(bytes.data())) {
}

WorkLog::WorkLog(const ::WorkLog *root) 
    : input_streams_(std::nullopt)
    , job_id_(std::nullopt)
    , name_(std::nullopt)
    , output_streams_()
    , params_()
    , parent_(std::nullopt)
    , schematic_()
    , user_settings_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &input_streams_vector = root->input_streams();
    if (input_streams_vector != nullptr) {
        decltype(input_streams_)::value_type input_streams__target = decltype(input_streams_)::value_type();
        input_streams__target.reserve(input_streams_vector->size());
        for (const auto &i: *input_streams_vector) {
            input_streams__target.emplace_back(i);
        }
        input_streams_ = std::make_optional(input_streams__target);
    }
    if (root->job_id() != nullptr) {
        job_id_ = decltype(job_id_)(root->job_id());
    }
    if (root->name() != nullptr) {
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    }
    const auto &output_streams_vector = root->output_streams();
    if (output_streams_vector != nullptr) {
        output_streams_.reserve(output_streams_vector->size());
        for (const auto &i: *output_streams_vector) {
            output_streams_.emplace_back(i);
        }
    }
    const auto &params_vector = root->params();
    if (params_vector != nullptr) {
        params_.reserve(params_vector->size());
        for (const auto &i: *params_vector) {
            params_.emplace_back(i);
        }
    }
    if (root->parent() != nullptr) {
        parent_ = decltype(parent_)(root->parent());
    }
    if (root->schematic() != nullptr) {
        schematic_ = decltype(schematic_)(root->schematic());
    }
    if (root->user_settings() != nullptr) {
        user_settings_ = decltype(user_settings_)(root->user_settings());
    }
}

::flatbuffers::Offset<::WorklogParameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorklogParameter &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> key_offset = builder.CreateString(o.key_);
    std::optional<std::pair<::flatbuffers::Offset<void>, ::ParameterValue>> value_offset = std::nullopt;
    if (o.value_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::ParameterValue> value_offset_val = serialize_to(builder, o.value_.value());
        value_offset = std::make_optional(value_offset_val);
    }

    ::WorklogParameterBuilder instance_builder = ::WorklogParameterBuilder(builder);
    instance_builder.add_key(key_offset);
    if (value_offset.has_value()) {
        const auto value_opt = value_offset.value();
        instance_builder.add_value(value_opt.first);
        instance_builder.add_value_type(value_opt.second);
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const WorklogParameter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

WorklogParameter::WorklogParameter()
    : key_()
    , value_(std::nullopt) {
}

WorklogParameter::WorklogParameter(const std::vector<uint8_t> &bytes)
    : WorklogParameter(::flatbuffers::GetSizePrefixedRoot<::WorklogParameter>(bytes.data())) {
}

WorklogParameter::WorklogParameter(const ::WorklogParameter *root) 
    : key_()
    , value_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        key_ = std::string(*root->key()->begin(), *root->key()->end());
    if (root->value() != nullptr) {
        switch (root->value_type()) {
            case ::ParameterValue::NONE: throw std::runtime_error("unexpected none variant");
            case ::ParameterValue::ByteArray: {
                const auto value__local = static_cast<const ::ByteArray *>(root->value());
                std::shared_ptr<ByteArray> value__shared = std::make_shared<ByteArray>(value__local);
                value_ = value__shared;
                break;
            }
            case ::ParameterValue::ObjectId: {
                const auto value__local = static_cast<const ::ObjectId *>(root->value());
                std::shared_ptr<ObjectId> value__shared = std::make_shared<ObjectId>(value__local);
                value_ = value__shared;
                break;
            }
            case ::ParameterValue::ParameterFlags: {
                const auto value__local = static_cast<const ::ParameterFlags *>(root->value());
                std::shared_ptr<ParameterFlags> value__shared = std::make_shared<ParameterFlags>(value__local);
                value_ = value__shared;
                break;
            }
            case ::ParameterValue::ValueInstance: {
                const auto value__local = static_cast<const ::ValueInstance *>(root->value());
                std::shared_ptr<ValueInstance> value__shared = std::make_shared<ValueInstance>(value__local);
                value_ = value__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

} // namespace types
} // namespace ul
