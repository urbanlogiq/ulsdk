// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/data.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::AttributePair>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const AttributePair &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> key_offset = std::nullopt;
    if (o.key_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> key_offset_val = builder.CreateString(o.key_.value());
        key_offset = std::make_optional(key_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> value_offset = std::nullopt;
    if (o.value_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> value_offset_val = builder.CreateString(o.value_.value());
        value_offset = std::make_optional(value_offset_val);
    }

    ::AttributePairBuilder instance_builder = ::AttributePairBuilder(builder);
    if (key_offset.has_value()) {
        instance_builder.add_key(key_offset.value());
    }
    if (value_offset.has_value()) {
        instance_builder.add_value(value_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const AttributePair &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

AttributePair::AttributePair()
    : key_(std::nullopt)
    , value_(std::nullopt) {
}

AttributePair::AttributePair(const std::vector<uint8_t> &bytes)
    : AttributePair(::flatbuffers::GetSizePrefixedRoot<::AttributePair>(bytes.data())) {
}

AttributePair::AttributePair(const ::AttributePair *root) 
    : key_(std::nullopt)
    , value_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->key() != nullptr) {
        key_ = std::string(*root->key()->begin(), *root->key()->end());
    }
    if (root->value() != nullptr) {
        value_ = std::string(*root->value()->begin(), *root->value()->end());
    }
}

::flatbuffers::Offset<::DirectionAndRoadName>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DirectionAndRoadName &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> direction_offset = builder.CreateString(o.direction_);
    const ::flatbuffers::Offset<::flatbuffers::String> road_name_offset = builder.CreateString(o.road_name_);

    ::DirectionAndRoadNameBuilder instance_builder = ::DirectionAndRoadNameBuilder(builder);
    instance_builder.add_direction(direction_offset);
    instance_builder.add_road_name(road_name_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DirectionAndRoadName &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DirectionAndRoadName::DirectionAndRoadName()
    : direction_()
    , road_name_() {
}

DirectionAndRoadName::DirectionAndRoadName(const std::vector<uint8_t> &bytes)
    : DirectionAndRoadName(::flatbuffers::GetSizePrefixedRoot<::DirectionAndRoadName>(bytes.data())) {
}

DirectionAndRoadName::DirectionAndRoadName(const ::DirectionAndRoadName *root) 
    : direction_()
    , road_name_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        direction_ = std::string(*root->direction()->begin(), *root->direction()->end());
        road_name_ = std::string(*root->road_name()->begin(), *root->road_name()->end());
}

::flatbuffers::Offset<::DirectionAndRoadNames>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DirectionAndRoadNames &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::DirectionAndRoadName>>>> direction_and_road_names_offset = std::nullopt;
    if (o.direction_and_road_names_.has_value()) {
        const auto &direction_and_road_names__var = o.direction_and_road_names_.value();
        std::vector<::flatbuffers::Offset<::DirectionAndRoadName>> direction_and_road_names_offsets = std::vector<::flatbuffers::Offset<::DirectionAndRoadName>>();
        direction_and_road_names_offsets.reserve(direction_and_road_names__var.size());
        for (const auto &i: direction_and_road_names__var) {
            direction_and_road_names_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::DirectionAndRoadName>>> direction_and_road_names_offset_val = builder.CreateVector(direction_and_road_names_offsets);
        direction_and_road_names_offset = std::make_optional(direction_and_road_names_offset_val);
    }

    ::DirectionAndRoadNamesBuilder instance_builder = ::DirectionAndRoadNamesBuilder(builder);
    if (direction_and_road_names_offset.has_value()) {
        instance_builder.add_direction_and_road_names(direction_and_road_names_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DirectionAndRoadNames &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DirectionAndRoadNames::DirectionAndRoadNames()
    : direction_and_road_names_(std::nullopt) {
}

DirectionAndRoadNames::DirectionAndRoadNames(const std::vector<uint8_t> &bytes)
    : DirectionAndRoadNames(::flatbuffers::GetSizePrefixedRoot<::DirectionAndRoadNames>(bytes.data())) {
}

DirectionAndRoadNames::DirectionAndRoadNames(const ::DirectionAndRoadNames *root) 
    : direction_and_road_names_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &direction_and_road_names_vector = root->direction_and_road_names();
    if (direction_and_road_names_vector != nullptr) {
        decltype(direction_and_road_names_)::value_type direction_and_road_names__target = decltype(direction_and_road_names_)::value_type();
        direction_and_road_names__target.reserve(direction_and_road_names_vector->size());
        for (const auto &i: *direction_and_road_names_vector) {
            direction_and_road_names__target.emplace_back(i);
        }
        direction_and_road_names_ = std::make_optional(direction_and_road_names__target);
    }
}

::flatbuffers::Offset<::NamedParameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NamedParameter &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> description_offset = std::nullopt;
    if (o.description_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> description_offset_val = builder.CreateString(o.description_.value());
        description_offset = std::make_optional(description_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    std::optional<::flatbuffers::Offset<::Schema>> schema_offset = std::nullopt;
    if (o.schema_.has_value()) {
        const ::flatbuffers::Offset<::Schema> schema_offset_val = serialize_to(builder, o.schema_.value());
        schema_offset = std::make_optional(schema_offset_val);
    }

    ::NamedParameterBuilder instance_builder = ::NamedParameterBuilder(builder);
    if (description_offset.has_value()) {
        instance_builder.add_description(description_offset.value());
    }
    instance_builder.add_flags(o.flags_);
    instance_builder.add_name(name_offset);
    if (schema_offset.has_value()) {
        instance_builder.add_schema(schema_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NamedParameter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NamedParameter::NamedParameter()
    : description_(std::nullopt)
    , flags_(0)
    , name_()
    , schema_(std::nullopt) {
}

NamedParameter::NamedParameter(const std::vector<uint8_t> &bytes)
    : NamedParameter(::flatbuffers::GetSizePrefixedRoot<::NamedParameter>(bytes.data())) {
}

NamedParameter::NamedParameter(const ::NamedParameter *root) 
    : description_(std::nullopt)
    , flags_(0)
    , name_()
    , schema_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->description() != nullptr) {
        description_ = std::string(*root->description()->begin(), *root->description()->end());
    }
    flags_ = root->flags();
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->schema() != nullptr) {
        schema_ = decltype(schema_)(root->schema());
    }
}

::flatbuffers::Offset<::Source>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Source &o) {
    std::optional<::flatbuffers::Offset<::ObjectId>> metadata_offset = std::nullopt;
    if (o.metadata_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> metadata_offset_val = serialize_to(builder, o.metadata_.value());
        metadata_offset = std::make_optional(metadata_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ContentId>> metadata_revision_offset = std::nullopt;
    if (o.metadata_revision_.has_value()) {
        const ::flatbuffers::Offset<::ContentId> metadata_revision_offset_val = serialize_to(builder, o.metadata_revision_.value());
        metadata_revision_offset = std::make_optional(metadata_revision_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NamedParameter>>>> named_parameters_offset = std::nullopt;
    if (o.named_parameters_.has_value()) {
        const auto &named_parameters__var = o.named_parameters_.value();
        std::vector<::flatbuffers::Offset<::NamedParameter>> named_parameters_offsets = std::vector<::flatbuffers::Offset<::NamedParameter>>();
        named_parameters_offsets.reserve(named_parameters__var.size());
        for (const auto &i: named_parameters__var) {
            named_parameters_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NamedParameter>>> named_parameters_offset_val = builder.CreateVector(named_parameters_offsets);
        named_parameters_offset = std::make_optional(named_parameters_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.options_.value()))> options_offset = std::nullopt;
    if (o.options_.has_value()) {
        const decltype(builder.CreateVector(o.options_.value())) options_offset_val = builder.CreateVector(o.options_.value());
        options_offset = std::make_optional(options_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Schema>>>> schemas_offset = std::nullopt;
    if (o.schemas_.has_value()) {
        const auto &schemas__var = o.schemas_.value();
        std::vector<::flatbuffers::Offset<::Schema>> schemas_offsets = std::vector<::flatbuffers::Offset<::Schema>>();
        schemas_offsets.reserve(schemas__var.size());
        for (const auto &i: schemas__var) {
            schemas_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Schema>>> schemas_offset_val = builder.CreateVector(schemas_offsets);
        schemas_offset = std::make_optional(schemas_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> url_offset = builder.CreateString(o.url_);

    ::SourceBuilder instance_builder = ::SourceBuilder(builder);
    if (metadata_offset.has_value()) {
        instance_builder.add_metadata(metadata_offset.value());
    }
    if (metadata_revision_offset.has_value()) {
        instance_builder.add_metadata_revision(metadata_revision_offset.value());
    }
    instance_builder.add_name(name_offset);
    if (named_parameters_offset.has_value()) {
        instance_builder.add_named_parameters(named_parameters_offset.value());
    }
    if (options_offset.has_value()) {
        instance_builder.add_options(options_offset.value());
    }
    if (schemas_offset.has_value()) {
        instance_builder.add_schemas(schemas_offset.value());
    }
    instance_builder.add_url(url_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Source &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Source::Source()
    : metadata_(std::nullopt)
    , metadata_revision_(std::nullopt)
    , name_()
    , named_parameters_(std::nullopt)
    , options_(std::nullopt)
    , schemas_(std::nullopt)
    , url_() {
}

Source::Source(const std::vector<uint8_t> &bytes)
    : Source(::flatbuffers::GetSizePrefixedRoot<::Source>(bytes.data())) {
}

Source::Source(const ::Source *root) 
    : metadata_(std::nullopt)
    , metadata_revision_(std::nullopt)
    , name_()
    , named_parameters_(std::nullopt)
    , options_(std::nullopt)
    , schemas_(std::nullopt)
    , url_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->metadata() != nullptr) {
        metadata_ = decltype(metadata_)(root->metadata());
    }
    if (root->metadata_revision() != nullptr) {
        metadata_revision_ = decltype(metadata_revision_)(root->metadata_revision());
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    const auto &named_parameters_vector = root->named_parameters();
    if (named_parameters_vector != nullptr) {
        decltype(named_parameters_)::value_type named_parameters__target = decltype(named_parameters_)::value_type();
        named_parameters__target.reserve(named_parameters_vector->size());
        for (const auto &i: *named_parameters_vector) {
            named_parameters__target.emplace_back(i);
        }
        named_parameters_ = std::make_optional(named_parameters__target);
    }
    const auto &options_vector = root->options();
    if (options_vector != nullptr) {
        decltype(options_)::value_type options__target = decltype(options_)::value_type();
        std::copy(options_vector->begin(), options_vector->end(), std::back_inserter(options__target));
        options_ = std::make_optional(options__target);
    }
    const auto &schemas_vector = root->schemas();
    if (schemas_vector != nullptr) {
        decltype(schemas_)::value_type schemas__target = decltype(schemas_)::value_type();
        schemas__target.reserve(schemas_vector->size());
        for (const auto &i: *schemas_vector) {
            schemas__target.emplace_back(i);
        }
        schemas_ = std::make_optional(schemas__target);
    }
        url_ = std::string(*root->url()->begin(), *root->url()->end());
}

} // namespace types
} // namespace ul
