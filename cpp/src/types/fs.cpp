// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/fs.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::Entry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Entry &o) {
    if (std::holds_alternative<std::shared_ptr<File>>(o)) {
        const std::shared_ptr<File> &v = std::get<std::shared_ptr<File>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Entry::File);
    } else if (std::holds_alternative<std::shared_ptr<Directory>>(o)) {
        const std::shared_ptr<Directory> &v = std::get<std::shared_ptr<Directory>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Entry::Directory);
    } else if (std::holds_alternative<std::shared_ptr<ObjectRef>>(o)) {
        const std::shared_ptr<ObjectRef> &v = std::get<std::shared_ptr<ObjectRef>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Entry::ObjectRef);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::ListEntry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ListEntry &o) {
    if (std::holds_alternative<std::shared_ptr<ListFile>>(o)) {
        const std::shared_ptr<ListFile> &v = std::get<std::shared_ptr<ListFile>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ListEntry::ListFile);
    } else if (std::holds_alternative<std::shared_ptr<ListDirectory>>(o)) {
        const std::shared_ptr<ListDirectory> &v = std::get<std::shared_ptr<ListDirectory>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ListEntry::ListDirectory);
    } else if (std::holds_alternative<std::shared_ptr<ListObject>>(o)) {
        const std::shared_ptr<ListObject> &v = std::get<std::shared_ptr<ListObject>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ListEntry::ListObject);
    } else if (std::holds_alternative<std::shared_ptr<TopLevelDirectory>>(o)) {
        const std::shared_ptr<TopLevelDirectory> &v = std::get<std::shared_ptr<TopLevelDirectory>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ListEntry::TopLevelDirectory);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::File>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const File &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> account_offset = builder.CreateString(o.account_);
    std::optional<::flatbuffers::Offset<::GenericId>> blob_offset = std::nullopt;
    if (o.blob_.has_value()) {
        const ::flatbuffers::Offset<::GenericId> blob_offset_val = serialize_to(builder, o.blob_.value());
        blob_offset = std::make_optional(blob_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Chunk>>>> chunks_offset = std::nullopt;
    if (o.chunks_.has_value()) {
        const auto &chunks__var = o.chunks_.value();
        std::vector<::flatbuffers::Offset<::Chunk>> chunks_offsets = std::vector<::flatbuffers::Offset<::Chunk>>();
        chunks_offsets.reserve(chunks__var.size());
        for (const auto &i: chunks__var) {
            chunks_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Chunk>>> chunks_offset_val = builder.CreateVector(chunks_offsets);
        chunks_offset = std::make_optional(chunks_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> container_offset = std::nullopt;
    if (o.container_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> container_offset_val = builder.CreateString(o.container_.value());
        container_offset = std::make_optional(container_offset_val);
    }
    std::optional<std::pair<::flatbuffers::Offset<void>, ::Digest>> digest_offset = std::nullopt;
    if (o.digest_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::Digest> digest_offset_val = serialize_to(builder, o.digest_.value());
        digest_offset = std::make_optional(digest_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> mime_offset = builder.CreateString(o.mime_);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> virus_offset = std::nullopt;
    if (o.virus_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> virus_offset_val = builder.CreateString(o.virus_.value());
        virus_offset = std::make_optional(virus_offset_val);
    }

    ::FileBuilder instance_builder = ::FileBuilder(builder);
    instance_builder.add_account(account_offset);
    if (blob_offset.has_value()) {
        instance_builder.add_blob(blob_offset.value());
    }
    if (chunks_offset.has_value()) {
        instance_builder.add_chunks(chunks_offset.value());
    }
    if (container_offset.has_value()) {
        instance_builder.add_container(container_offset.value());
    }
    if (digest_offset.has_value()) {
        const auto digest_opt = digest_offset.value();
        instance_builder.add_digest(digest_opt.first);
        instance_builder.add_digest_type(digest_opt.second);
    }
    instance_builder.add_mime(mime_offset);
    instance_builder.add_size(o.size_);
    if (virus_offset.has_value()) {
        instance_builder.add_virus(virus_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const File &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

File::File()
    : account_()
    , blob_(std::nullopt)
    , chunks_(std::nullopt)
    , container_(std::nullopt)
    , digest_(std::nullopt)
    , mime_()
    , size_(0)
    , virus_(std::nullopt) {
}

File::File(const std::vector<uint8_t> &bytes)
    : File(::flatbuffers::GetSizePrefixedRoot<::File>(bytes.data())) {
}

File::File(const ::File *root) 
    : account_()
    , blob_(std::nullopt)
    , chunks_(std::nullopt)
    , container_(std::nullopt)
    , digest_(std::nullopt)
    , mime_()
    , size_(0)
    , virus_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        account_ = std::string(*root->account()->begin(), *root->account()->end());
    if (root->blob() != nullptr) {
        blob_ = decltype(blob_)(root->blob());
    }
    const auto &chunks_vector = root->chunks();
    if (chunks_vector != nullptr) {
        decltype(chunks_)::value_type chunks__target = decltype(chunks_)::value_type();
        chunks__target.reserve(chunks_vector->size());
        for (const auto &i: *chunks_vector) {
            chunks__target.emplace_back(i);
        }
        chunks_ = std::make_optional(chunks__target);
    }
    if (root->container() != nullptr) {
        container_ = std::string(*root->container()->begin(), *root->container()->end());
    }
    if (root->digest() != nullptr) {
        switch (root->digest_type()) {
            case ::Digest::NONE: throw std::runtime_error("unexpected none variant");
            case ::Digest::Sha256: {
                const auto digest__local = static_cast<const ::Sha256 *>(root->digest());
                std::shared_ptr<Sha256> digest__shared = std::make_shared<Sha256>(digest__local);
                digest_ = digest__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
        mime_ = std::string(*root->mime()->begin(), *root->mime()->end());
    size_ = root->size();
    if (root->virus() != nullptr) {
        virus_ = std::string(*root->virus()->begin(), *root->virus()->end());
    }
}

::flatbuffers::Offset<::Directory>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Directory &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::B2cId>>>> notifications_offset = std::nullopt;
    if (o.notifications_.has_value()) {
        const auto &notifications__var = o.notifications_.value();
        std::vector<::flatbuffers::Offset<::B2cId>> notifications_offsets = std::vector<::flatbuffers::Offset<::B2cId>>();
        notifications_offsets.reserve(notifications__var.size());
        for (const auto &i: notifications__var) {
            notifications_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::B2cId>>> notifications_offset_val = builder.CreateVector(notifications_offsets);
        notifications_offset = std::make_optional(notifications_offset_val);
    }
    std::vector<::flatbuffers::Offset<::Slot>> slots_offsets = std::vector<::flatbuffers::Offset<::Slot>>();
    slots_offsets.reserve(o.slots_.size());
    for (const auto &i: o.slots_) {
        slots_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Slot>>> slots_offset = builder.CreateVector(slots_offsets);

    ::DirectoryBuilder instance_builder = ::DirectoryBuilder(builder);
    if (notifications_offset.has_value()) {
        instance_builder.add_notifications(notifications_offset.value());
    }
    instance_builder.add_slots(slots_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Directory &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Directory::Directory()
    : notifications_(std::nullopt)
    , slots_() {
}

Directory::Directory(const std::vector<uint8_t> &bytes)
    : Directory(::flatbuffers::GetSizePrefixedRoot<::Directory>(bytes.data())) {
}

Directory::Directory(const ::Directory *root) 
    : notifications_(std::nullopt)
    , slots_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &notifications_vector = root->notifications();
    if (notifications_vector != nullptr) {
        decltype(notifications_)::value_type notifications__target = decltype(notifications_)::value_type();
        notifications__target.reserve(notifications_vector->size());
        for (const auto &i: *notifications_vector) {
            notifications__target.emplace_back(i);
        }
        notifications_ = std::make_optional(notifications__target);
    }
    const auto &slots_vector = root->slots();
    if (slots_vector != nullptr) {
        slots_.reserve(slots_vector->size());
        for (const auto &i: *slots_vector) {
            slots_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::ObjectRef>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectRef &o) {
    const ::flatbuffers::Offset<::ObjectId> id_offset = serialize_to(builder, o.id_);

    ::ObjectRefBuilder instance_builder = ::ObjectRefBuilder(builder);
    instance_builder.add_id(id_offset);
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ObjectRef &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ObjectRef::ObjectRef()
    : id_()
    , ty_(DataCatalogObjectTy(0)) {
}

ObjectRef::ObjectRef(const std::vector<uint8_t> &bytes)
    : ObjectRef(::flatbuffers::GetSizePrefixedRoot<::ObjectRef>(bytes.data())) {
}

ObjectRef::ObjectRef(const ::ObjectRef *root) 
    : id_()
    , ty_(DataCatalogObjectTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    ty_ = root->ty();
}

::flatbuffers::Offset<::ListFile>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ListFile &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> mime_offset = builder.CreateString(o.mime_);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> virus_offset = std::nullopt;
    if (o.virus_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> virus_offset_val = builder.CreateString(o.virus_.value());
        virus_offset = std::make_optional(virus_offset_val);
    }

    ::ListFileBuilder instance_builder = ::ListFileBuilder(builder);
    instance_builder.add_mime(mime_offset);
    instance_builder.add_size(o.size_);
    if (virus_offset.has_value()) {
        instance_builder.add_virus(virus_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ListFile &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ListFile::ListFile()
    : mime_()
    , size_(0)
    , virus_(std::nullopt) {
}

ListFile::ListFile(const std::vector<uint8_t> &bytes)
    : ListFile(::flatbuffers::GetSizePrefixedRoot<::ListFile>(bytes.data())) {
}

ListFile::ListFile(const ::ListFile *root) 
    : mime_()
    , size_(0)
    , virus_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        mime_ = std::string(*root->mime()->begin(), *root->mime()->end());
    size_ = root->size();
    if (root->virus() != nullptr) {
        virus_ = std::string(*root->virus()->begin(), *root->virus()->end());
    }
}

::flatbuffers::Offset<::ListDirectory>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ListDirectory &) {

    ::ListDirectoryBuilder instance_builder = ::ListDirectoryBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ListDirectory &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ListDirectory::ListDirectory() {
}

ListDirectory::ListDirectory(const std::vector<uint8_t> &bytes)
    : ListDirectory(::flatbuffers::GetSizePrefixedRoot<::ListDirectory>(bytes.data())) {
}

ListDirectory::ListDirectory(const ::ListDirectory *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::ListObject>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ListObject &o) {
    const ::flatbuffers::Offset<::ObjectId> id_offset = serialize_to(builder, o.id_);

    ::ListObjectBuilder instance_builder = ::ListObjectBuilder(builder);
    instance_builder.add_id(id_offset);
    instance_builder.add_size(o.size_);
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ListObject &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ListObject::ListObject()
    : id_()
    , size_(0)
    , ty_(DataCatalogObjectTy(0)) {
}

ListObject::ListObject(const std::vector<uint8_t> &bytes)
    : ListObject(::flatbuffers::GetSizePrefixedRoot<::ListObject>(bytes.data())) {
}

ListObject::ListObject(const ::ListObject *root) 
    : id_()
    , size_(0)
    , ty_(DataCatalogObjectTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    size_ = root->size();
    ty_ = root->ty();
}

::flatbuffers::Offset<::TopLevelDirectory>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TopLevelDirectory &o) {
    const ::flatbuffers::Offset<::B2cId> b2c_entity_offset = serialize_to(builder, o.b2c_entity_);

    ::TopLevelDirectoryBuilder instance_builder = ::TopLevelDirectoryBuilder(builder);
    instance_builder.add_b2c_entity(b2c_entity_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TopLevelDirectory &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TopLevelDirectory::TopLevelDirectory()
    : b2c_entity_() {
}

TopLevelDirectory::TopLevelDirectory(const std::vector<uint8_t> &bytes)
    : TopLevelDirectory(::flatbuffers::GetSizePrefixedRoot<::TopLevelDirectory>(bytes.data())) {
}

TopLevelDirectory::TopLevelDirectory(const ::TopLevelDirectory *root) 
    : b2c_entity_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->b2c_entity() != nullptr) {
        b2c_entity_ = decltype(b2c_entity_)(root->b2c_entity());
    }
}

::flatbuffers::Offset<::Attr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Attr &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> key_offset = builder.CreateString(o.key_);
    const std::pair<::flatbuffers::Offset<void>, ::Value> v_offset = serialize_to(builder, o.v_);

    ::AttrBuilder instance_builder = ::AttrBuilder(builder);
    instance_builder.add_key(key_offset);
    instance_builder.add_v(v_offset.first);
    instance_builder.add_v_type(v_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Attr &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Attr::Attr()
    : key_()
    , v_(std::make_shared<VBool>()) {
}

Attr::Attr(const std::vector<uint8_t> &bytes)
    : Attr(::flatbuffers::GetSizePrefixedRoot<::Attr>(bytes.data())) {
}

Attr::Attr(const ::Attr *root) 
    : key_()
    , v_(std::make_shared<VBool>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        key_ = std::string(*root->key()->begin(), *root->key()->end());
    if (root->v() != nullptr) {
        switch (root->v_type()) {
            case ::Value::NONE: throw std::runtime_error("unexpected none variant");
            case ::Value::VBool: {
                const auto v__local = static_cast<const ::VBool *>(root->v());
                std::shared_ptr<VBool> v__shared = std::make_shared<VBool>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VUnit: {
                const auto v__local = static_cast<const ::VUnit *>(root->v());
                std::shared_ptr<VUnit> v__shared = std::make_shared<VUnit>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VChar: {
                const auto v__local = static_cast<const ::VChar *>(root->v());
                std::shared_ptr<VChar> v__shared = std::make_shared<VChar>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VNull: {
                const auto v__local = static_cast<const ::VNull *>(root->v());
                std::shared_ptr<VNull> v__shared = std::make_shared<VNull>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI8: {
                const auto v__local = static_cast<const ::VI8 *>(root->v());
                std::shared_ptr<VI8> v__shared = std::make_shared<VI8>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU8: {
                const auto v__local = static_cast<const ::VU8 *>(root->v());
                std::shared_ptr<VU8> v__shared = std::make_shared<VU8>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI16: {
                const auto v__local = static_cast<const ::VI16 *>(root->v());
                std::shared_ptr<VI16> v__shared = std::make_shared<VI16>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU16: {
                const auto v__local = static_cast<const ::VU16 *>(root->v());
                std::shared_ptr<VU16> v__shared = std::make_shared<VU16>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI32: {
                const auto v__local = static_cast<const ::VI32 *>(root->v());
                std::shared_ptr<VI32> v__shared = std::make_shared<VI32>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU32: {
                const auto v__local = static_cast<const ::VU32 *>(root->v());
                std::shared_ptr<VU32> v__shared = std::make_shared<VU32>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VF32: {
                const auto v__local = static_cast<const ::VF32 *>(root->v());
                std::shared_ptr<VF32> v__shared = std::make_shared<VF32>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VIsize: {
                const auto v__local = static_cast<const ::VIsize *>(root->v());
                std::shared_ptr<VIsize> v__shared = std::make_shared<VIsize>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VUsize: {
                const auto v__local = static_cast<const ::VUsize *>(root->v());
                std::shared_ptr<VUsize> v__shared = std::make_shared<VUsize>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI64: {
                const auto v__local = static_cast<const ::VI64 *>(root->v());
                std::shared_ptr<VI64> v__shared = std::make_shared<VI64>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU64: {
                const auto v__local = static_cast<const ::VU64 *>(root->v());
                std::shared_ptr<VU64> v__shared = std::make_shared<VU64>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VF64: {
                const auto v__local = static_cast<const ::VF64 *>(root->v());
                std::shared_ptr<VF64> v__shared = std::make_shared<VF64>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VStr: {
                const auto v__local = static_cast<const ::VStr *>(root->v());
                std::shared_ptr<VStr> v__shared = std::make_shared<VStr>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VBytes: {
                const auto v__local = static_cast<const ::VBytes *>(root->v());
                std::shared_ptr<VBytes> v__shared = std::make_shared<VBytes>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VArray: {
                const auto v__local = static_cast<const ::VArray *>(root->v());
                std::shared_ptr<VArray> v__shared = std::make_shared<VArray>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTri2D: {
                const auto v__local = static_cast<const ::VTri2D *>(root->v());
                std::shared_ptr<VTri2D> v__shared = std::make_shared<VTri2D>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VFixedSizeBytes: {
                const auto v__local = static_cast<const ::VFixedSizeBytes *>(root->v());
                std::shared_ptr<VFixedSizeBytes> v__shared = std::make_shared<VFixedSizeBytes>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampMsUtc: {
                const auto v__local = static_cast<const ::VTimestampMsUtc *>(root->v());
                std::shared_ptr<VTimestampMsUtc> v__shared = std::make_shared<VTimestampMsUtc>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampMs: {
                const auto v__local = static_cast<const ::VTimestampMs *>(root->v());
                std::shared_ptr<VTimestampMs> v__shared = std::make_shared<VTimestampMs>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampNsUtc: {
                const auto v__local = static_cast<const ::VTimestampNsUtc *>(root->v());
                std::shared_ptr<VTimestampNsUtc> v__shared = std::make_shared<VTimestampNsUtc>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampNs: {
                const auto v__local = static_cast<const ::VTimestampNs *>(root->v());
                std::shared_ptr<VTimestampNs> v__shared = std::make_shared<VTimestampNs>(v__local);
                v_ = v__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::Chunk>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Chunk &o) {
    const ::flatbuffers::Offset<::GenericId> blob_offset = serialize_to(builder, o.blob_);
    const std::pair<::flatbuffers::Offset<void>, ::Digest> digest_offset = serialize_to(builder, o.digest_);

    ::ChunkBuilder instance_builder = ::ChunkBuilder(builder);
    instance_builder.add_blob(blob_offset);
    instance_builder.add_digest(digest_offset.first);
    instance_builder.add_digest_type(digest_offset.second);
    instance_builder.add_size(o.size_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Chunk &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Chunk::Chunk()
    : blob_()
    , digest_(std::make_shared<Sha256>())
    , size_(0) {
}

Chunk::Chunk(const std::vector<uint8_t> &bytes)
    : Chunk(::flatbuffers::GetSizePrefixedRoot<::Chunk>(bytes.data())) {
}

Chunk::Chunk(const ::Chunk *root) 
    : blob_()
    , digest_(std::make_shared<Sha256>())
    , size_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->blob() != nullptr) {
        blob_ = decltype(blob_)(root->blob());
    }
    if (root->digest() != nullptr) {
        switch (root->digest_type()) {
            case ::Digest::NONE: throw std::runtime_error("unexpected none variant");
            case ::Digest::Sha256: {
                const auto digest__local = static_cast<const ::Sha256 *>(root->digest());
                std::shared_ptr<Sha256> digest__shared = std::make_shared<Sha256>(digest__local);
                digest_ = digest__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    size_ = root->size();
}

::flatbuffers::Offset<::DirectoryEntry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DirectoryEntry &o) {
    const std::pair<::flatbuffers::Offset<void>, ::Entry> entry_offset = serialize_to(builder, o.entry_);
    const ::flatbuffers::Offset<::ObjectId> parent_offset = serialize_to(builder, o.parent_);

    ::DirectoryEntryBuilder instance_builder = ::DirectoryEntryBuilder(builder);
    instance_builder.add_entry(entry_offset.first);
    instance_builder.add_entry_type(entry_offset.second);
    instance_builder.add_parent(parent_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DirectoryEntry &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DirectoryEntry::DirectoryEntry()
    : entry_(std::make_shared<File>())
    , parent_() {
}

DirectoryEntry::DirectoryEntry(const std::vector<uint8_t> &bytes)
    : DirectoryEntry(::flatbuffers::GetSizePrefixedRoot<::DirectoryEntry>(bytes.data())) {
}

DirectoryEntry::DirectoryEntry(const ::DirectoryEntry *root) 
    : entry_(std::make_shared<File>())
    , parent_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->entry() != nullptr) {
        switch (root->entry_type()) {
            case ::Entry::NONE: throw std::runtime_error("unexpected none variant");
            case ::Entry::File: {
                const auto entry__local = static_cast<const ::File *>(root->entry());
                std::shared_ptr<File> entry__shared = std::make_shared<File>(entry__local);
                entry_ = entry__shared;
                break;
            }
            case ::Entry::Directory: {
                const auto entry__local = static_cast<const ::Directory *>(root->entry());
                std::shared_ptr<Directory> entry__shared = std::make_shared<Directory>(entry__local);
                entry_ = entry__shared;
                break;
            }
            case ::Entry::ObjectRef: {
                const auto entry__local = static_cast<const ::ObjectRef *>(root->entry());
                std::shared_ptr<ObjectRef> entry__shared = std::make_shared<ObjectRef>(entry__local);
                entry_ = entry__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    if (root->parent() != nullptr) {
        parent_ = decltype(parent_)(root->parent());
    }
}

::flatbuffers::Offset<::DirectoryList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DirectoryList &o) {
    std::vector<::flatbuffers::Offset<::ListSlot>> slots_offsets = std::vector<::flatbuffers::Offset<::ListSlot>>();
    slots_offsets.reserve(o.slots_.size());
    for (const auto &i: o.slots_) {
        slots_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ListSlot>>> slots_offset = builder.CreateVector(slots_offsets);

    ::DirectoryListBuilder instance_builder = ::DirectoryListBuilder(builder);
    instance_builder.add_slots(slots_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DirectoryList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DirectoryList::DirectoryList()
    : slots_() {
}

DirectoryList::DirectoryList(const std::vector<uint8_t> &bytes)
    : DirectoryList(::flatbuffers::GetSizePrefixedRoot<::DirectoryList>(bytes.data())) {
}

DirectoryList::DirectoryList(const ::DirectoryList *root) 
    : slots_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &slots_vector = root->slots();
    if (slots_vector != nullptr) {
        slots_.reserve(slots_vector->size());
        for (const auto &i: *slots_vector) {
            slots_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::ListSlot>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ListSlot &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::Attr>> attributes_offsets = std::vector<::flatbuffers::Offset<::Attr>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    const std::pair<::flatbuffers::Offset<void>, ::ListEntry> entry_offset = serialize_to(builder, o.entry_);
    const ::flatbuffers::Offset<::ObjectId> id_offset = serialize_to(builder, o.id_);
    std::optional<::flatbuffers::Offset<::B2cId>> last_modified_by_offset = std::nullopt;
    if (o.last_modified_by_.has_value()) {
        const ::flatbuffers::Offset<::B2cId> last_modified_by_offset_val = serialize_to(builder, o.last_modified_by_.value());
        last_modified_by_offset = std::make_optional(last_modified_by_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);

    ::ListSlotBuilder instance_builder = ::ListSlotBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    instance_builder.add_entry(entry_offset.first);
    instance_builder.add_entry_type(entry_offset.second);
    instance_builder.add_id(id_offset);
    if (last_modified_by_offset.has_value()) {
        instance_builder.add_last_modified_by(last_modified_by_offset.value());
    }
    instance_builder.add_name(name_offset);
    instance_builder.add_size(o.size_);
    instance_builder.add_time(o.time_);
    instance_builder.add_user_permissions(o.user_permissions_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ListSlot &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ListSlot::ListSlot()
    : attributes_(std::nullopt)
    , entry_(std::make_shared<ListFile>())
    , id_()
    , last_modified_by_(std::nullopt)
    , name_()
    , size_(0)
    , time_(0)
    , user_permissions_(0) {
}

ListSlot::ListSlot(const std::vector<uint8_t> &bytes)
    : ListSlot(::flatbuffers::GetSizePrefixedRoot<::ListSlot>(bytes.data())) {
}

ListSlot::ListSlot(const ::ListSlot *root) 
    : attributes_(std::nullopt)
    , entry_(std::make_shared<ListFile>())
    , id_()
    , last_modified_by_(std::nullopt)
    , name_()
    , size_(0)
    , time_(0)
    , user_permissions_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    if (root->entry() != nullptr) {
        switch (root->entry_type()) {
            case ::ListEntry::NONE: throw std::runtime_error("unexpected none variant");
            case ::ListEntry::ListFile: {
                const auto entry__local = static_cast<const ::ListFile *>(root->entry());
                std::shared_ptr<ListFile> entry__shared = std::make_shared<ListFile>(entry__local);
                entry_ = entry__shared;
                break;
            }
            case ::ListEntry::ListDirectory: {
                const auto entry__local = static_cast<const ::ListDirectory *>(root->entry());
                std::shared_ptr<ListDirectory> entry__shared = std::make_shared<ListDirectory>(entry__local);
                entry_ = entry__shared;
                break;
            }
            case ::ListEntry::ListObject: {
                const auto entry__local = static_cast<const ::ListObject *>(root->entry());
                std::shared_ptr<ListObject> entry__shared = std::make_shared<ListObject>(entry__local);
                entry_ = entry__shared;
                break;
            }
            case ::ListEntry::TopLevelDirectory: {
                const auto entry__local = static_cast<const ::TopLevelDirectory *>(root->entry());
                std::shared_ptr<TopLevelDirectory> entry__shared = std::make_shared<TopLevelDirectory>(entry__local);
                entry_ = entry__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    if (root->last_modified_by() != nullptr) {
        last_modified_by_ = decltype(last_modified_by_)(root->last_modified_by());
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    size_ = root->size();
    time_ = root->time();
    user_permissions_ = root->user_permissions();
}

::flatbuffers::Offset<::MoveRequest>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const MoveRequest &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> dest_name_offset = std::nullopt;
    if (o.dest_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> dest_name_offset_val = builder.CreateString(o.dest_name_.value());
        dest_name_offset = std::make_optional(dest_name_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ObjectId>> dest_root_offset = std::nullopt;
    if (o.dest_root_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> dest_root_offset_val = serialize_to(builder, o.dest_root_.value());
        dest_root_offset = std::make_optional(dest_root_offset_val);
    }
    const ::flatbuffers::Offset<::ObjectId> entry_offset = serialize_to(builder, o.entry_);

    ::MoveRequestBuilder instance_builder = ::MoveRequestBuilder(builder);
    if (dest_name_offset.has_value()) {
        instance_builder.add_dest_name(dest_name_offset.value());
    }
    if (dest_root_offset.has_value()) {
        instance_builder.add_dest_root(dest_root_offset.value());
    }
    instance_builder.add_entry(entry_offset);
    instance_builder.add_overwrite(o.overwrite_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const MoveRequest &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

MoveRequest::MoveRequest()
    : dest_name_(std::nullopt)
    , dest_root_(std::nullopt)
    , entry_()
    , overwrite_(false) {
}

MoveRequest::MoveRequest(const std::vector<uint8_t> &bytes)
    : MoveRequest(::flatbuffers::GetSizePrefixedRoot<::MoveRequest>(bytes.data())) {
}

MoveRequest::MoveRequest(const ::MoveRequest *root) 
    : dest_name_(std::nullopt)
    , dest_root_(std::nullopt)
    , entry_()
    , overwrite_(false) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->dest_name() != nullptr) {
        dest_name_ = std::string(*root->dest_name()->begin(), *root->dest_name()->end());
    }
    if (root->dest_root() != nullptr) {
        dest_root_ = decltype(dest_root_)(root->dest_root());
    }
    if (root->entry() != nullptr) {
        entry_ = decltype(entry_)(root->entry());
    }
    overwrite_ = root->overwrite();
}

::flatbuffers::Offset<::NewLink>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NewLink &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    const ::flatbuffers::Offset<::ObjectId> obj_offset = serialize_to(builder, o.obj_);

    ::NewLinkBuilder instance_builder = ::NewLinkBuilder(builder);
    instance_builder.add_name(name_offset);
    instance_builder.add_obj(obj_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NewLink &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NewLink::NewLink()
    : name_()
    , obj_() {
}

NewLink::NewLink(const std::vector<uint8_t> &bytes)
    : NewLink(::flatbuffers::GetSizePrefixedRoot<::NewLink>(bytes.data())) {
}

NewLink::NewLink(const ::NewLink *root) 
    : name_()
    , obj_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->obj() != nullptr) {
        obj_ = decltype(obj_)(root->obj());
    }
}

::flatbuffers::Offset<::Slot>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Slot &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::Attr>> attributes_offsets = std::vector<::flatbuffers::Offset<::Attr>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    const ::flatbuffers::Offset<::ObjectId> id_offset = serialize_to(builder, o.id_);
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);

    ::SlotBuilder instance_builder = ::SlotBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    instance_builder.add_id(id_offset);
    instance_builder.add_name(name_offset);
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Slot &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Slot::Slot()
    : attributes_(std::nullopt)
    , id_()
    , name_()
    , ty_(EntryTy(0)) {
}

Slot::Slot(const std::vector<uint8_t> &bytes)
    : Slot(::flatbuffers::GetSizePrefixedRoot<::Slot>(bytes.data())) {
}

Slot::Slot(const ::Slot *root) 
    : attributes_(std::nullopt)
    , id_()
    , name_()
    , ty_(EntryTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    ty_ = root->ty();
}

} // namespace types
} // namespace ul
