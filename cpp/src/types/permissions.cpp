// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/permissions.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::AccessControlList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const AccessControlList &o) {
    std::optional<::flatbuffers::Offset<::ObjectId>> extends_offset = std::nullopt;
    if (o.extends_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> extends_offset_val = serialize_to(builder, o.extends_.value());
        extends_offset = std::make_optional(extends_offset_val);
    }
    std::vector<::flatbuffers::Offset<::Role>> roles_offsets = std::vector<::flatbuffers::Offset<::Role>>();
    roles_offsets.reserve(o.roles_.size());
    for (const auto &i: o.roles_) {
        roles_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Role>>> roles_offset = builder.CreateVector(roles_offsets);

    ::AccessControlListBuilder instance_builder = ::AccessControlListBuilder(builder);
    if (extends_offset.has_value()) {
        instance_builder.add_extends(extends_offset.value());
    }
    instance_builder.add_roles(roles_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const AccessControlList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

AccessControlList::AccessControlList()
    : extends_(std::nullopt)
    , roles_() {
}

AccessControlList::AccessControlList(const std::vector<uint8_t> &bytes)
    : AccessControlList(::flatbuffers::GetSizePrefixedRoot<::AccessControlList>(bytes.data())) {
}

AccessControlList::AccessControlList(const ::AccessControlList *root) 
    : extends_(std::nullopt)
    , roles_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->extends() != nullptr) {
        extends_ = decltype(extends_)(root->extends());
    }
    const auto &roles_vector = root->roles();
    if (roles_vector != nullptr) {
        roles_.reserve(roles_vector->size());
        for (const auto &i: *roles_vector) {
            roles_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::Role>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Role &o) {
    const ::flatbuffers::Offset<::B2cId> principal_offset = serialize_to(builder, o.principal_);

    ::RoleBuilder instance_builder = ::RoleBuilder(builder);
    instance_builder.add_permission(o.permission_);
    instance_builder.add_principal(principal_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Role &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Role::Role()
    : permission_(0)
    , principal_() {
}

Role::Role(const std::vector<uint8_t> &bytes)
    : Role(::flatbuffers::GetSizePrefixedRoot<::Role>(bytes.data())) {
}

Role::Role(const ::Role *root) 
    : permission_(0)
    , principal_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    permission_ = root->permission();
    if (root->principal() != nullptr) {
        principal_ = decltype(principal_)(root->principal());
    }
}

} // namespace types
} // namespace ul
