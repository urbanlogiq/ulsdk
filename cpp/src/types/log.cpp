// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/log.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::Label>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Label &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> key_offset = builder.CreateString(o.key_);
    const ::flatbuffers::Offset<::flatbuffers::String> value_offset = builder.CreateString(o.value_);

    ::LabelBuilder instance_builder = ::LabelBuilder(builder);
    instance_builder.add_key(key_offset);
    instance_builder.add_value(value_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Label &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Label::Label()
    : key_()
    , value_() {
}

Label::Label(const std::vector<uint8_t> &bytes)
    : Label(::flatbuffers::GetSizePrefixedRoot<::Label>(bytes.data())) {
}

Label::Label(const ::Label *root) 
    : key_()
    , value_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        key_ = std::string(*root->key()->begin(), *root->key()->end());
        value_ = std::string(*root->value()->begin(), *root->value()->end());
}

::flatbuffers::Offset<::Log>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Log &o) {
    std::vector<::flatbuffers::Offset<::Label>> labels_offsets = std::vector<::flatbuffers::Offset<::Label>>();
    labels_offsets.reserve(o.labels_.size());
    for (const auto &i: o.labels_) {
        labels_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Label>>> labels_offset = builder.CreateVector(labels_offsets);
    std::vector<::flatbuffers::Offset<::Pair>> pairs_offsets = std::vector<::flatbuffers::Offset<::Pair>>();
    pairs_offsets.reserve(o.pairs_.size());
    for (const auto &i: o.pairs_) {
        pairs_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Pair>>> pairs_offset = builder.CreateVector(pairs_offsets);

    ::LogBuilder instance_builder = ::LogBuilder(builder);
    instance_builder.add_labels(labels_offset);
    instance_builder.add_pairs(pairs_offset);
    instance_builder.add_timestamp(o.timestamp_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Log &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Log::Log()
    : labels_()
    , pairs_()
    , timestamp_(0) {
}

Log::Log(const std::vector<uint8_t> &bytes)
    : Log(::flatbuffers::GetSizePrefixedRoot<::Log>(bytes.data())) {
}

Log::Log(const ::Log *root) 
    : labels_()
    , pairs_()
    , timestamp_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &labels_vector = root->labels();
    if (labels_vector != nullptr) {
        labels_.reserve(labels_vector->size());
        for (const auto &i: *labels_vector) {
            labels_.emplace_back(i);
        }
    }
    const auto &pairs_vector = root->pairs();
    if (pairs_vector != nullptr) {
        pairs_.reserve(pairs_vector->size());
        for (const auto &i: *pairs_vector) {
            pairs_.emplace_back(i);
        }
    }
    timestamp_ = root->timestamp();
}

::flatbuffers::Offset<::Pair>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Pair &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> key_offset = builder.CreateString(o.key_);
    const std::pair<::flatbuffers::Offset<void>, ::Value> value_offset = serialize_to(builder, o.value_);

    ::PairBuilder instance_builder = ::PairBuilder(builder);
    instance_builder.add_key(key_offset);
    instance_builder.add_value(value_offset.first);
    instance_builder.add_value_type(value_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Pair &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Pair::Pair()
    : key_()
    , value_(std::make_shared<VBool>()) {
}

Pair::Pair(const std::vector<uint8_t> &bytes)
    : Pair(::flatbuffers::GetSizePrefixedRoot<::Pair>(bytes.data())) {
}

Pair::Pair(const ::Pair *root) 
    : key_()
    , value_(std::make_shared<VBool>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        key_ = std::string(*root->key()->begin(), *root->key()->end());
    if (root->value() != nullptr) {
        switch (root->value_type()) {
            case ::Value::NONE: throw std::runtime_error("unexpected none variant");
            case ::Value::VBool: {
                const auto value__local = static_cast<const ::VBool *>(root->value());
                std::shared_ptr<VBool> value__shared = std::make_shared<VBool>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VUnit: {
                const auto value__local = static_cast<const ::VUnit *>(root->value());
                std::shared_ptr<VUnit> value__shared = std::make_shared<VUnit>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VChar: {
                const auto value__local = static_cast<const ::VChar *>(root->value());
                std::shared_ptr<VChar> value__shared = std::make_shared<VChar>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VNull: {
                const auto value__local = static_cast<const ::VNull *>(root->value());
                std::shared_ptr<VNull> value__shared = std::make_shared<VNull>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VI8: {
                const auto value__local = static_cast<const ::VI8 *>(root->value());
                std::shared_ptr<VI8> value__shared = std::make_shared<VI8>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VU8: {
                const auto value__local = static_cast<const ::VU8 *>(root->value());
                std::shared_ptr<VU8> value__shared = std::make_shared<VU8>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VI16: {
                const auto value__local = static_cast<const ::VI16 *>(root->value());
                std::shared_ptr<VI16> value__shared = std::make_shared<VI16>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VU16: {
                const auto value__local = static_cast<const ::VU16 *>(root->value());
                std::shared_ptr<VU16> value__shared = std::make_shared<VU16>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VI32: {
                const auto value__local = static_cast<const ::VI32 *>(root->value());
                std::shared_ptr<VI32> value__shared = std::make_shared<VI32>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VU32: {
                const auto value__local = static_cast<const ::VU32 *>(root->value());
                std::shared_ptr<VU32> value__shared = std::make_shared<VU32>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VF32: {
                const auto value__local = static_cast<const ::VF32 *>(root->value());
                std::shared_ptr<VF32> value__shared = std::make_shared<VF32>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VIsize: {
                const auto value__local = static_cast<const ::VIsize *>(root->value());
                std::shared_ptr<VIsize> value__shared = std::make_shared<VIsize>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VUsize: {
                const auto value__local = static_cast<const ::VUsize *>(root->value());
                std::shared_ptr<VUsize> value__shared = std::make_shared<VUsize>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VI64: {
                const auto value__local = static_cast<const ::VI64 *>(root->value());
                std::shared_ptr<VI64> value__shared = std::make_shared<VI64>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VU64: {
                const auto value__local = static_cast<const ::VU64 *>(root->value());
                std::shared_ptr<VU64> value__shared = std::make_shared<VU64>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VF64: {
                const auto value__local = static_cast<const ::VF64 *>(root->value());
                std::shared_ptr<VF64> value__shared = std::make_shared<VF64>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VStr: {
                const auto value__local = static_cast<const ::VStr *>(root->value());
                std::shared_ptr<VStr> value__shared = std::make_shared<VStr>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VBytes: {
                const auto value__local = static_cast<const ::VBytes *>(root->value());
                std::shared_ptr<VBytes> value__shared = std::make_shared<VBytes>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VArray: {
                const auto value__local = static_cast<const ::VArray *>(root->value());
                std::shared_ptr<VArray> value__shared = std::make_shared<VArray>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VTri2D: {
                const auto value__local = static_cast<const ::VTri2D *>(root->value());
                std::shared_ptr<VTri2D> value__shared = std::make_shared<VTri2D>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VFixedSizeBytes: {
                const auto value__local = static_cast<const ::VFixedSizeBytes *>(root->value());
                std::shared_ptr<VFixedSizeBytes> value__shared = std::make_shared<VFixedSizeBytes>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VTimestampMsUtc: {
                const auto value__local = static_cast<const ::VTimestampMsUtc *>(root->value());
                std::shared_ptr<VTimestampMsUtc> value__shared = std::make_shared<VTimestampMsUtc>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VTimestampMs: {
                const auto value__local = static_cast<const ::VTimestampMs *>(root->value());
                std::shared_ptr<VTimestampMs> value__shared = std::make_shared<VTimestampMs>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VTimestampNsUtc: {
                const auto value__local = static_cast<const ::VTimestampNsUtc *>(root->value());
                std::shared_ptr<VTimestampNsUtc> value__shared = std::make_shared<VTimestampNsUtc>(value__local);
                value_ = value__shared;
                break;
            }
            case ::Value::VTimestampNs: {
                const auto value__local = static_cast<const ::VTimestampNs *>(root->value());
                std::shared_ptr<VTimestampNs> value__shared = std::make_shared<VTimestampNs>(value__local);
                value_ = value__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

} // namespace types
} // namespace ul
