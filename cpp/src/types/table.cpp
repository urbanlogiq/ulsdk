// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/table.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::ChangeOp>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ChangeOp &o) {
    if (std::holds_alternative<std::shared_ptr<Modify>>(o)) {
        const std::shared_ptr<Modify> &v = std::get<std::shared_ptr<Modify>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ChangeOp::Modify);
    } else if (std::holds_alternative<std::shared_ptr<Delete>>(o)) {
        const std::shared_ptr<Delete> &v = std::get<std::shared_ptr<Delete>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ChangeOp::Delete);
    } else if (std::holds_alternative<std::shared_ptr<Restore>>(o)) {
        const std::shared_ptr<Restore> &v = std::get<std::shared_ptr<Restore>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ChangeOp::Restore);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::Op>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Op &o) {
    if (std::holds_alternative<std::shared_ptr<Set>>(o)) {
        const std::shared_ptr<Set> &v = std::get<std::shared_ptr<Set>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Op::Set);
    } else if (std::holds_alternative<std::shared_ptr<RmRow>>(o)) {
        const std::shared_ptr<RmRow> &v = std::get<std::shared_ptr<RmRow>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Op::RmRow);
    } else if (std::holds_alternative<std::shared_ptr<RestoreRow>>(o)) {
        const std::shared_ptr<RestoreRow> &v = std::get<std::shared_ptr<RestoreRow>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Op::RestoreRow);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::Modify>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Modify &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> col_offset = builder.CreateString(o.col_);
    std::optional<::flatbuffers::Offset<::ValueInstance>> previous_offset = std::nullopt;
    if (o.previous_.has_value()) {
        const ::flatbuffers::Offset<::ValueInstance> previous_offset_val = serialize_to(builder, o.previous_.value());
        previous_offset = std::make_optional(previous_offset_val);
    }
    const ::flatbuffers::Offset<::GenericId> row_offset = serialize_to(builder, o.row_);
    const ::flatbuffers::Offset<::ValueInstance> value_offset = serialize_to(builder, o.value_);

    ::ModifyBuilder instance_builder = ::ModifyBuilder(builder);
    instance_builder.add_col(col_offset);
    if (previous_offset.has_value()) {
        instance_builder.add_previous(previous_offset.value());
    }
    instance_builder.add_row(row_offset);
    instance_builder.add_value(value_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Modify &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Modify::Modify()
    : col_()
    , previous_(std::nullopt)
    , row_()
    , value_() {
}

Modify::Modify(const std::vector<uint8_t> &bytes)
    : Modify(::flatbuffers::GetSizePrefixedRoot<::Modify>(bytes.data())) {
}

Modify::Modify(const ::Modify *root) 
    : col_()
    , previous_(std::nullopt)
    , row_()
    , value_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        col_ = std::string(*root->col()->begin(), *root->col()->end());
    if (root->previous() != nullptr) {
        previous_ = decltype(previous_)(root->previous());
    }
    if (root->row() != nullptr) {
        row_ = decltype(row_)(root->row());
    }
    if (root->value() != nullptr) {
        value_ = decltype(value_)(root->value());
    }
}

::flatbuffers::Offset<::Delete>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Delete &o) {
    const ::flatbuffers::Offset<::GenericId> row_offset = serialize_to(builder, o.row_);

    ::DeleteBuilder instance_builder = ::DeleteBuilder(builder);
    instance_builder.add_row(row_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Delete &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Delete::Delete()
    : row_() {
}

Delete::Delete(const std::vector<uint8_t> &bytes)
    : Delete(::flatbuffers::GetSizePrefixedRoot<::Delete>(bytes.data())) {
}

Delete::Delete(const ::Delete *root) 
    : row_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->row() != nullptr) {
        row_ = decltype(row_)(root->row());
    }
}

::flatbuffers::Offset<::Restore>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Restore &o) {
    const ::flatbuffers::Offset<::GenericId> row_offset = serialize_to(builder, o.row_);

    ::RestoreBuilder instance_builder = ::RestoreBuilder(builder);
    instance_builder.add_row(row_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Restore &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Restore::Restore()
    : row_() {
}

Restore::Restore(const std::vector<uint8_t> &bytes)
    : Restore(::flatbuffers::GetSizePrefixedRoot<::Restore>(bytes.data())) {
}

Restore::Restore(const ::Restore *root) 
    : row_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->row() != nullptr) {
        row_ = decltype(row_)(root->row());
    }
}

::flatbuffers::Offset<::Set>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Set &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> col_offset = builder.CreateString(o.col_);
    const ::flatbuffers::Offset<::GenericId> row_offset = serialize_to(builder, o.row_);
    const ::flatbuffers::Offset<::ValueInstance> value_offset = serialize_to(builder, o.value_);

    ::SetBuilder instance_builder = ::SetBuilder(builder);
    instance_builder.add_col(col_offset);
    instance_builder.add_row(row_offset);
    instance_builder.add_value(value_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Set &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Set::Set()
    : col_()
    , row_()
    , value_() {
}

Set::Set(const std::vector<uint8_t> &bytes)
    : Set(::flatbuffers::GetSizePrefixedRoot<::Set>(bytes.data())) {
}

Set::Set(const ::Set *root) 
    : col_()
    , row_()
    , value_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        col_ = std::string(*root->col()->begin(), *root->col()->end());
    if (root->row() != nullptr) {
        row_ = decltype(row_)(root->row());
    }
    if (root->value() != nullptr) {
        value_ = decltype(value_)(root->value());
    }
}

::flatbuffers::Offset<::RmRow>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RmRow &o) {
    const ::flatbuffers::Offset<::GenericId> row_offset = serialize_to(builder, o.row_);

    ::RmRowBuilder instance_builder = ::RmRowBuilder(builder);
    instance_builder.add_row(row_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RmRow &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RmRow::RmRow()
    : row_() {
}

RmRow::RmRow(const std::vector<uint8_t> &bytes)
    : RmRow(::flatbuffers::GetSizePrefixedRoot<::RmRow>(bytes.data())) {
}

RmRow::RmRow(const ::RmRow *root) 
    : row_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->row() != nullptr) {
        row_ = decltype(row_)(root->row());
    }
}

::flatbuffers::Offset<::RestoreRow>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RestoreRow &o) {
    const ::flatbuffers::Offset<::GenericId> row_offset = serialize_to(builder, o.row_);

    ::RestoreRowBuilder instance_builder = ::RestoreRowBuilder(builder);
    instance_builder.add_row(row_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RestoreRow &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RestoreRow::RestoreRow()
    : row_() {
}

RestoreRow::RestoreRow(const std::vector<uint8_t> &bytes)
    : RestoreRow(::flatbuffers::GetSizePrefixedRoot<::RestoreRow>(bytes.data())) {
}

RestoreRow::RestoreRow(const ::RestoreRow *root) 
    : row_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->row() != nullptr) {
        row_ = decltype(row_)(root->row());
    }
}

::flatbuffers::Offset<::ChangeOpEntry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ChangeOpEntry &o) {
    const std::pair<::flatbuffers::Offset<void>, ::ChangeOp> op_offset = serialize_to(builder, o.op_);

    ::ChangeOpEntryBuilder instance_builder = ::ChangeOpEntryBuilder(builder);
    instance_builder.add_op(op_offset.first);
    instance_builder.add_op_type(op_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ChangeOpEntry &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ChangeOpEntry::ChangeOpEntry()
    : op_(std::make_shared<Modify>()) {
}

ChangeOpEntry::ChangeOpEntry(const std::vector<uint8_t> &bytes)
    : ChangeOpEntry(::flatbuffers::GetSizePrefixedRoot<::ChangeOpEntry>(bytes.data())) {
}

ChangeOpEntry::ChangeOpEntry(const ::ChangeOpEntry *root) 
    : op_(std::make_shared<Modify>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->op() != nullptr) {
        switch (root->op_type()) {
            case ::ChangeOp::NONE: throw std::runtime_error("unexpected none variant");
            case ::ChangeOp::Modify: {
                const auto op__local = static_cast<const ::Modify *>(root->op());
                std::shared_ptr<Modify> op__shared = std::make_shared<Modify>(op__local);
                op_ = op__shared;
                break;
            }
            case ::ChangeOp::Delete: {
                const auto op__local = static_cast<const ::Delete *>(root->op());
                std::shared_ptr<Delete> op__shared = std::make_shared<Delete>(op__local);
                op_ = op__shared;
                break;
            }
            case ::ChangeOp::Restore: {
                const auto op__local = static_cast<const ::Restore *>(root->op());
                std::shared_ptr<Restore> op__shared = std::make_shared<Restore>(op__local);
                op_ = op__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::ChangeSet>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ChangeSet &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::Attr>> attributes_offsets = std::vector<::flatbuffers::Offset<::Attr>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::vector<::flatbuffers::Offset<::ChangeOpEntry>> ops_offsets = std::vector<::flatbuffers::Offset<::ChangeOpEntry>>();
    ops_offsets.reserve(o.ops_.size());
    for (const auto &i: o.ops_) {
        ops_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ChangeOpEntry>>> ops_offset = builder.CreateVector(ops_offsets);
    const ::flatbuffers::Offset<::ContentId> revision_offset = serialize_to(builder, o.revision_);
    const ::flatbuffers::Offset<::B2cId> who_offset = serialize_to(builder, o.who_);

    ::ChangeSetBuilder instance_builder = ::ChangeSetBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    instance_builder.add_ops(ops_offset);
    instance_builder.add_revision(revision_offset);
    instance_builder.add_when(o.when_);
    instance_builder.add_who(who_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ChangeSet &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ChangeSet::ChangeSet()
    : attributes_(std::nullopt)
    , ops_()
    , revision_()
    , when_(0)
    , who_() {
}

ChangeSet::ChangeSet(const std::vector<uint8_t> &bytes)
    : ChangeSet(::flatbuffers::GetSizePrefixedRoot<::ChangeSet>(bytes.data())) {
}

ChangeSet::ChangeSet(const ::ChangeSet *root) 
    : attributes_(std::nullopt)
    , ops_()
    , revision_()
    , when_(0)
    , who_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    const auto &ops_vector = root->ops();
    if (ops_vector != nullptr) {
        ops_.reserve(ops_vector->size());
        for (const auto &i: *ops_vector) {
            ops_.emplace_back(i);
        }
    }
    if (root->revision() != nullptr) {
        revision_ = decltype(revision_)(root->revision());
    }
    when_ = root->when();
    if (root->who() != nullptr) {
        who_ = decltype(who_)(root->who());
    }
}

::flatbuffers::Offset<::DiffStream>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DiffStream &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::Attr>> attributes_offsets = std::vector<::flatbuffers::Offset<::Attr>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Attr>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    const ::flatbuffers::Offset<::ContentId> base_offset = serialize_to(builder, o.base_);
    std::vector<::flatbuffers::Offset<::OpEntry>> seq_offsets = std::vector<::flatbuffers::Offset<::OpEntry>>();
    seq_offsets.reserve(o.seq_.size());
    for (const auto &i: o.seq_) {
        seq_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OpEntry>>> seq_offset = builder.CreateVector(seq_offsets);

    ::DiffStreamBuilder instance_builder = ::DiffStreamBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    instance_builder.add_base(base_offset);
    instance_builder.add_seq(seq_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DiffStream &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DiffStream::DiffStream()
    : attributes_(std::nullopt)
    , base_()
    , seq_() {
}

DiffStream::DiffStream(const std::vector<uint8_t> &bytes)
    : DiffStream(::flatbuffers::GetSizePrefixedRoot<::DiffStream>(bytes.data())) {
}

DiffStream::DiffStream(const ::DiffStream *root) 
    : attributes_(std::nullopt)
    , base_()
    , seq_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    if (root->base() != nullptr) {
        base_ = decltype(base_)(root->base());
    }
    const auto &seq_vector = root->seq();
    if (seq_vector != nullptr) {
        seq_.reserve(seq_vector->size());
        for (const auto &i: *seq_vector) {
            seq_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::History>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const History &o) {
    std::vector<::flatbuffers::Offset<::ChangeSet>> changes_offsets = std::vector<::flatbuffers::Offset<::ChangeSet>>();
    changes_offsets.reserve(o.changes_.size());
    for (const auto &i: o.changes_) {
        changes_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ChangeSet>>> changes_offset = builder.CreateVector(changes_offsets);
    std::optional<::flatbuffers::Offset<::ContentId>> continuation_id_offset = std::nullopt;
    if (o.continuation_id_.has_value()) {
        const ::flatbuffers::Offset<::ContentId> continuation_id_offset_val = serialize_to(builder, o.continuation_id_.value());
        continuation_id_offset = std::make_optional(continuation_id_offset_val);
    }

    ::HistoryBuilder instance_builder = ::HistoryBuilder(builder);
    instance_builder.add_changes(changes_offset);
    if (continuation_id_offset.has_value()) {
        instance_builder.add_continuation_id(continuation_id_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const History &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

History::History()
    : changes_()
    , continuation_id_(std::nullopt) {
}

History::History(const std::vector<uint8_t> &bytes)
    : History(::flatbuffers::GetSizePrefixedRoot<::History>(bytes.data())) {
}

History::History(const ::History *root) 
    : changes_()
    , continuation_id_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &changes_vector = root->changes();
    if (changes_vector != nullptr) {
        changes_.reserve(changes_vector->size());
        for (const auto &i: *changes_vector) {
            changes_.emplace_back(i);
        }
    }
    if (root->continuation_id() != nullptr) {
        continuation_id_ = decltype(continuation_id_)(root->continuation_id());
    }
}

::flatbuffers::Offset<::NewTable>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NewTable &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    std::optional<::flatbuffers::Offset<::ObjectId>> parent_offset = std::nullopt;
    if (o.parent_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> parent_offset_val = serialize_to(builder, o.parent_.value());
        parent_offset = std::make_optional(parent_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ObjectId>> target_offset = std::nullopt;
    if (o.target_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> target_offset_val = serialize_to(builder, o.target_.value());
        target_offset = std::make_optional(target_offset_val);
    }

    ::NewTableBuilder instance_builder = ::NewTableBuilder(builder);
    instance_builder.add_name(name_offset);
    if (parent_offset.has_value()) {
        instance_builder.add_parent(parent_offset.value());
    }
    if (target_offset.has_value()) {
        instance_builder.add_target(target_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NewTable &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NewTable::NewTable()
    : name_()
    , parent_(std::nullopt)
    , target_(std::nullopt) {
}

NewTable::NewTable(const std::vector<uint8_t> &bytes)
    : NewTable(::flatbuffers::GetSizePrefixedRoot<::NewTable>(bytes.data())) {
}

NewTable::NewTable(const ::NewTable *root) 
    : name_()
    , parent_(std::nullopt)
    , target_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->parent() != nullptr) {
        parent_ = decltype(parent_)(root->parent());
    }
    if (root->target() != nullptr) {
        target_ = decltype(target_)(root->target());
    }
}

::flatbuffers::Offset<::OpEntry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const OpEntry &o) {
    const std::pair<::flatbuffers::Offset<void>, ::Op> op_offset = serialize_to(builder, o.op_);

    ::OpEntryBuilder instance_builder = ::OpEntryBuilder(builder);
    instance_builder.add_op(op_offset.first);
    instance_builder.add_op_type(op_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const OpEntry &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

OpEntry::OpEntry()
    : op_(std::make_shared<Set>()) {
}

OpEntry::OpEntry(const std::vector<uint8_t> &bytes)
    : OpEntry(::flatbuffers::GetSizePrefixedRoot<::OpEntry>(bytes.data())) {
}

OpEntry::OpEntry(const ::OpEntry *root) 
    : op_(std::make_shared<Set>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->op() != nullptr) {
        switch (root->op_type()) {
            case ::Op::NONE: throw std::runtime_error("unexpected none variant");
            case ::Op::Set: {
                const auto op__local = static_cast<const ::Set *>(root->op());
                std::shared_ptr<Set> op__shared = std::make_shared<Set>(op__local);
                op_ = op__shared;
                break;
            }
            case ::Op::RmRow: {
                const auto op__local = static_cast<const ::RmRow *>(root->op());
                std::shared_ptr<RmRow> op__shared = std::make_shared<RmRow>(op__local);
                op_ = op__shared;
                break;
            }
            case ::Op::RestoreRow: {
                const auto op__local = static_cast<const ::RestoreRow *>(root->op());
                std::shared_ptr<RestoreRow> op__shared = std::make_shared<RestoreRow>(op__local);
                op_ = op__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

} // namespace types
} // namespace ul
