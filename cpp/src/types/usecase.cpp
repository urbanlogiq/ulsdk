// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/usecase.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::UseCaseInput>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UseCaseInput &o) {
    if (std::holds_alternative<std::shared_ptr<ObjectId>>(o)) {
        const std::shared_ptr<ObjectId> &v = std::get<std::shared_ptr<ObjectId>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UseCaseInput::ObjectId);
    } else if (std::holds_alternative<std::shared_ptr<Schema>>(o)) {
        const std::shared_ptr<Schema> &v = std::get<std::shared_ptr<Schema>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UseCaseInput::Schema);
    } else if (std::holds_alternative<std::shared_ptr<ParameterizedQuery>>(o)) {
        const std::shared_ptr<ParameterizedQuery> &v = std::get<std::shared_ptr<ParameterizedQuery>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UseCaseInput::ParameterizedQuery);
    } else if (std::holds_alternative<std::shared_ptr<ValueInstance>>(o)) {
        const std::shared_ptr<ValueInstance> &v = std::get<std::shared_ptr<ValueInstance>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UseCaseInput::ValueInstance);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::UseCase>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UseCase &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> abbreviation_offset = std::nullopt;
    if (o.abbreviation_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> abbreviation_offset_val = builder.CreateString(o.abbreviation_.value());
        abbreviation_offset = std::make_optional(abbreviation_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> description_offset = std::nullopt;
    if (o.description_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> description_offset_val = builder.CreateString(o.description_.value());
        description_offset = std::make_optional(description_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> extended_description_offset = std::nullopt;
    if (o.extended_description_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> extended_description_offset_val = builder.CreateString(o.extended_description_.value());
        extended_description_offset = std::make_optional(extended_description_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> extended_title_offset = std::nullopt;
    if (o.extended_title_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> extended_title_offset_val = builder.CreateString(o.extended_title_.value());
        extended_title_offset = std::make_optional(extended_title_offset_val);
    }
    std::vector<::flatbuffers::Offset<::UseCaseInputPair>> inputs_offsets = std::vector<::flatbuffers::Offset<::UseCaseInputPair>>();
    inputs_offsets.reserve(o.inputs_.size());
    for (const auto &i: o.inputs_) {
        inputs_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::UseCaseInputPair>>> inputs_offset = builder.CreateVector(inputs_offsets);
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> subtitle_offset = std::nullopt;
    if (o.subtitle_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> subtitle_offset_val = builder.CreateString(o.subtitle_.value());
        subtitle_offset = std::make_optional(subtitle_offset_val);
    }

    ::UseCaseBuilder instance_builder = ::UseCaseBuilder(builder);
    if (abbreviation_offset.has_value()) {
        instance_builder.add_abbreviation(abbreviation_offset.value());
    }
    if (description_offset.has_value()) {
        instance_builder.add_description(description_offset.value());
    }
    if (extended_description_offset.has_value()) {
        instance_builder.add_extended_description(extended_description_offset.value());
    }
    if (extended_title_offset.has_value()) {
        instance_builder.add_extended_title(extended_title_offset.value());
    }
    instance_builder.add_inputs(inputs_offset);
    instance_builder.add_module_(o.module_);
    instance_builder.add_name(name_offset);
    if (subtitle_offset.has_value()) {
        instance_builder.add_subtitle(subtitle_offset.value());
    }
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UseCase &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UseCase::UseCase()
    : abbreviation_(std::nullopt)
    , description_(std::nullopt)
    , extended_description_(std::nullopt)
    , extended_title_(std::nullopt)
    , inputs_()
    , module_(UseCaseModule(0))
    , name_()
    , subtitle_(std::nullopt)
    , ty_(UseCaseTy(0)) {
}

UseCase::UseCase(const std::vector<uint8_t> &bytes)
    : UseCase(::flatbuffers::GetSizePrefixedRoot<::UseCase>(bytes.data())) {
}

UseCase::UseCase(const ::UseCase *root) 
    : abbreviation_(std::nullopt)
    , description_(std::nullopt)
    , extended_description_(std::nullopt)
    , extended_title_(std::nullopt)
    , inputs_()
    , module_(UseCaseModule(0))
    , name_()
    , subtitle_(std::nullopt)
    , ty_(UseCaseTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->abbreviation() != nullptr) {
        abbreviation_ = std::string(*root->abbreviation()->begin(), *root->abbreviation()->end());
    }
    if (root->description() != nullptr) {
        description_ = std::string(*root->description()->begin(), *root->description()->end());
    }
    if (root->extended_description() != nullptr) {
        extended_description_ = std::string(*root->extended_description()->begin(), *root->extended_description()->end());
    }
    if (root->extended_title() != nullptr) {
        extended_title_ = std::string(*root->extended_title()->begin(), *root->extended_title()->end());
    }
    const auto &inputs_vector = root->inputs();
    if (inputs_vector != nullptr) {
        inputs_.reserve(inputs_vector->size());
        for (const auto &i: *inputs_vector) {
            inputs_.emplace_back(i);
        }
    }
    module_ = root->module_();
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->subtitle() != nullptr) {
        subtitle_ = std::string(*root->subtitle()->begin(), *root->subtitle()->end());
    }
    ty_ = root->ty();
}

::flatbuffers::Offset<::UseCaseInputPair>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UseCaseInputPair &o) {
    std::optional<std::pair<::flatbuffers::Offset<void>, ::UseCaseInput>> input_offset = std::nullopt;
    if (o.input_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::UseCaseInput> input_offset_val = serialize_to(builder, o.input_.value());
        input_offset = std::make_optional(input_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);

    ::UseCaseInputPairBuilder instance_builder = ::UseCaseInputPairBuilder(builder);
    if (input_offset.has_value()) {
        const auto input_opt = input_offset.value();
        instance_builder.add_input(input_opt.first);
        instance_builder.add_input_type(input_opt.second);
    }
    instance_builder.add_name(name_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UseCaseInputPair &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UseCaseInputPair::UseCaseInputPair()
    : input_(std::nullopt)
    , name_() {
}

UseCaseInputPair::UseCaseInputPair(const std::vector<uint8_t> &bytes)
    : UseCaseInputPair(::flatbuffers::GetSizePrefixedRoot<::UseCaseInputPair>(bytes.data())) {
}

UseCaseInputPair::UseCaseInputPair(const ::UseCaseInputPair *root) 
    : input_(std::nullopt)
    , name_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->input() != nullptr) {
        switch (root->input_type()) {
            case ::UseCaseInput::NONE: throw std::runtime_error("unexpected none variant");
            case ::UseCaseInput::ObjectId: {
                const auto input__local = static_cast<const ::ObjectId *>(root->input());
                std::shared_ptr<ObjectId> input__shared = std::make_shared<ObjectId>(input__local);
                input_ = input__shared;
                break;
            }
            case ::UseCaseInput::Schema: {
                const auto input__local = static_cast<const ::Schema *>(root->input());
                std::shared_ptr<Schema> input__shared = std::make_shared<Schema>(input__local);
                input_ = input__shared;
                break;
            }
            case ::UseCaseInput::ParameterizedQuery: {
                const auto input__local = static_cast<const ::ParameterizedQuery *>(root->input());
                std::shared_ptr<ParameterizedQuery> input__shared = std::make_shared<ParameterizedQuery>(input__local);
                input_ = input__shared;
                break;
            }
            case ::UseCaseInput::ValueInstance: {
                const auto input__local = static_cast<const ::ValueInstance *>(root->input());
                std::shared_ptr<ValueInstance> input__shared = std::make_shared<ValueInstance>(input__local);
                input_ = input__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
}

} // namespace types
} // namespace ul
