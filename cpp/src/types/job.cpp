// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/job.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::TaskParameterValue>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TaskParameterValue &o) {
    if (std::holds_alternative<std::shared_ptr<ObjectId>>(o)) {
        const std::shared_ptr<ObjectId> &v = std::get<std::shared_ptr<ObjectId>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TaskParameterValue::ObjectId);
    } else if (std::holds_alternative<std::shared_ptr<EmbeddedTable>>(o)) {
        const std::shared_ptr<EmbeddedTable> &v = std::get<std::shared_ptr<EmbeddedTable>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TaskParameterValue::EmbeddedTable);
    } else if (std::holds_alternative<std::shared_ptr<ValueInstance>>(o)) {
        const std::shared_ptr<ValueInstance> &v = std::get<std::shared_ptr<ValueInstance>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TaskParameterValue::ValueInstance);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::EmbeddedTable>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const EmbeddedTable &o) {
    const decltype(builder.CreateVector(o.v_)) v_offset = builder.CreateVector(o.v_);

    ::EmbeddedTableBuilder instance_builder = ::EmbeddedTableBuilder(builder);
    instance_builder.add_v(v_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const EmbeddedTable &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

EmbeddedTable::EmbeddedTable()
    : v_() {
}

EmbeddedTable::EmbeddedTable(const std::vector<uint8_t> &bytes)
    : EmbeddedTable(::flatbuffers::GetSizePrefixedRoot<::EmbeddedTable>(bytes.data())) {
}

EmbeddedTable::EmbeddedTable(const ::EmbeddedTable *root) 
    : v_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &v_vector = root->v();
    if (v_vector != nullptr) {
        std::copy(v_vector->begin(), v_vector->end(), std::back_inserter(v_));
    }
}

::flatbuffers::Offset<::DeprecatedRunSpec>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DeprecatedRunSpec &o) {
    std::vector<::flatbuffers::Offset<::ParamIndices>> param_indices_offsets = std::vector<::flatbuffers::Offset<::ParamIndices>>();
    param_indices_offsets.reserve(o.param_indices_.size());
    for (const auto &i: o.param_indices_) {
        param_indices_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ParamIndices>>> param_indices_offset = builder.CreateVector(param_indices_offsets);
    std::vector<::flatbuffers::Offset<::DeprecatedTaskParameter>> params_offsets = std::vector<::flatbuffers::Offset<::DeprecatedTaskParameter>>();
    params_offsets.reserve(o.params_.size());
    for (const auto &i: o.params_) {
        params_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::DeprecatedTaskParameter>>> params_offset = builder.CreateVector(params_offsets);
    const ::flatbuffers::Offset<::ObjectId> schematic_offset = serialize_to(builder, o.schematic_);

    ::DeprecatedRunSpecBuilder instance_builder = ::DeprecatedRunSpecBuilder(builder);
    instance_builder.add_param_indices(param_indices_offset);
    instance_builder.add_params(params_offset);
    instance_builder.add_persist(o.persist_);
    instance_builder.add_schematic(schematic_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DeprecatedRunSpec &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DeprecatedRunSpec::DeprecatedRunSpec()
    : param_indices_()
    , params_()
    , persist_(false)
    , schematic_() {
}

DeprecatedRunSpec::DeprecatedRunSpec(const std::vector<uint8_t> &bytes)
    : DeprecatedRunSpec(::flatbuffers::GetSizePrefixedRoot<::DeprecatedRunSpec>(bytes.data())) {
}

DeprecatedRunSpec::DeprecatedRunSpec(const ::DeprecatedRunSpec *root) 
    : param_indices_()
    , params_()
    , persist_(false)
    , schematic_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &param_indices_vector = root->param_indices();
    if (param_indices_vector != nullptr) {
        param_indices_.reserve(param_indices_vector->size());
        for (const auto &i: *param_indices_vector) {
            param_indices_.emplace_back(i);
        }
    }
    const auto &params_vector = root->params();
    if (params_vector != nullptr) {
        params_.reserve(params_vector->size());
        for (const auto &i: *params_vector) {
            params_.emplace_back(i);
        }
    }
    persist_ = root->persist();
    if (root->schematic() != nullptr) {
        schematic_ = decltype(schematic_)(root->schematic());
    }
}

::flatbuffers::Offset<::DeprecatedTaskParameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DeprecatedTaskParameter &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> key_offset = builder.CreateString(o.key_);
    std::optional<::flatbuffers::Offset<::ObjectId>> obj_offset = std::nullopt;
    if (o.obj_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> obj_offset_val = serialize_to(builder, o.obj_.value());
        obj_offset = std::make_optional(obj_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.value_.value()))> value_offset = std::nullopt;
    if (o.value_.has_value()) {
        const decltype(builder.CreateVector(o.value_.value())) value_offset_val = builder.CreateVector(o.value_.value());
        value_offset = std::make_optional(value_offset_val);
    }

    ::DeprecatedTaskParameterBuilder instance_builder = ::DeprecatedTaskParameterBuilder(builder);
    instance_builder.add_flags(o.flags_);
    instance_builder.add_key(key_offset);
    if (obj_offset.has_value()) {
        instance_builder.add_obj(obj_offset.value());
    }
    if (value_offset.has_value()) {
        instance_builder.add_value(value_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DeprecatedTaskParameter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DeprecatedTaskParameter::DeprecatedTaskParameter()
    : flags_(0)
    , key_()
    , obj_(std::nullopt)
    , value_(std::nullopt) {
}

DeprecatedTaskParameter::DeprecatedTaskParameter(const std::vector<uint8_t> &bytes)
    : DeprecatedTaskParameter(::flatbuffers::GetSizePrefixedRoot<::DeprecatedTaskParameter>(bytes.data())) {
}

DeprecatedTaskParameter::DeprecatedTaskParameter(const ::DeprecatedTaskParameter *root) 
    : flags_(0)
    , key_()
    , obj_(std::nullopt)
    , value_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    flags_ = root->flags();
        key_ = std::string(*root->key()->begin(), *root->key()->end());
    if (root->obj() != nullptr) {
        obj_ = decltype(obj_)(root->obj());
    }
    const auto &value_vector = root->value();
    if (value_vector != nullptr) {
        decltype(value_)::value_type value__target = decltype(value_)::value_type();
        std::copy(value_vector->begin(), value_vector->end(), std::back_inserter(value__target));
        value_ = std::make_optional(value__target);
    }
}

::flatbuffers::Offset<::Edge>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Edge &o) {

    ::EdgeBuilder instance_builder = ::EdgeBuilder(builder);
    instance_builder.add_from(o.from_);
    instance_builder.add_to(o.to_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Edge &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Edge::Edge()
    : from_(0)
    , to_(0) {
}

Edge::Edge(const std::vector<uint8_t> &bytes)
    : Edge(::flatbuffers::GetSizePrefixedRoot<::Edge>(bytes.data())) {
}

Edge::Edge(const ::Edge *root) 
    : from_(0)
    , to_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    from_ = root->from();
    to_ = root->to();
}

::flatbuffers::Offset<::Job>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Job &o) {
    std::optional<decltype(builder.CreateVector(o.error_tys_.value()))> error_tys_offset = std::nullopt;
    if (o.error_tys_.has_value()) {
        const decltype(builder.CreateVector(o.error_tys_.value())) error_tys_offset_val = builder.CreateVector(o.error_tys_.value());
        error_tys_offset = std::make_optional(error_tys_offset_val);
    }
    std::vector<::flatbuffers::Offset<::TaskParameter>> params_offsets = std::vector<::flatbuffers::Offset<::TaskParameter>>();
    params_offsets.reserve(o.params_.size());
    for (const auto &i: o.params_) {
        params_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TaskParameter>>> params_offset = builder.CreateVector(params_offsets);
    std::vector<::flatbuffers::Offset<::Task>> tasks_offsets = std::vector<::flatbuffers::Offset<::Task>>();
    tasks_offsets.reserve(o.tasks_.size());
    for (const auto &i: o.tasks_) {
        tasks_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Task>>> tasks_offset = builder.CreateVector(tasks_offsets);
    const ::flatbuffers::Offset<::ObjectId> user_id_offset = serialize_to(builder, o.user_id_);

    ::JobBuilder instance_builder = ::JobBuilder(builder);
    if (error_tys_offset.has_value()) {
        instance_builder.add_error_tys(error_tys_offset.value());
    }
    instance_builder.add_params(params_offset);
    instance_builder.add_status(o.status_);
    instance_builder.add_tasks(tasks_offset);
    instance_builder.add_user_id(user_id_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Job &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Job::Job()
    : error_tys_(std::nullopt)
    , params_()
    , status_(Status(0))
    , tasks_()
    , user_id_() {
}

Job::Job(const std::vector<uint8_t> &bytes)
    : Job(::flatbuffers::GetSizePrefixedRoot<::Job>(bytes.data())) {
}

Job::Job(const ::Job *root) 
    : error_tys_(std::nullopt)
    , params_()
    , status_(Status(0))
    , tasks_()
    , user_id_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &error_tys_vector = root->error_tys();
    if (error_tys_vector != nullptr) {
        decltype(error_tys_)::value_type error_tys__target = decltype(error_tys_)::value_type();
        std::copy(error_tys_vector->begin(), error_tys_vector->end(), std::back_inserter(error_tys__target));
        error_tys_ = std::make_optional(error_tys__target);
    }
    const auto &params_vector = root->params();
    if (params_vector != nullptr) {
        params_.reserve(params_vector->size());
        for (const auto &i: *params_vector) {
            params_.emplace_back(i);
        }
    }
    status_ = root->status();
    const auto &tasks_vector = root->tasks();
    if (tasks_vector != nullptr) {
        tasks_.reserve(tasks_vector->size());
        for (const auto &i: *tasks_vector) {
            tasks_.emplace_back(i);
        }
    }
    if (root->user_id() != nullptr) {
        user_id_ = decltype(user_id_)(root->user_id());
    }
}

::flatbuffers::Offset<::Node>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Node &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    const ::flatbuffers::Offset<::ObjectId> obj_offset = serialize_to(builder, o.obj_);

    ::NodeBuilder instance_builder = ::NodeBuilder(builder);
    instance_builder.add_name(name_offset);
    instance_builder.add_obj(obj_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Node &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Node::Node()
    : name_()
    , obj_() {
}

Node::Node(const std::vector<uint8_t> &bytes)
    : Node(::flatbuffers::GetSizePrefixedRoot<::Node>(bytes.data())) {
}

Node::Node(const ::Node *root) 
    : name_()
    , obj_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->obj() != nullptr) {
        obj_ = decltype(obj_)(root->obj());
    }
}

::flatbuffers::Offset<::ParamIndices>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParamIndices &o) {
    const decltype(builder.CreateVector(o.idxs_)) idxs_offset = builder.CreateVector(o.idxs_);

    ::ParamIndicesBuilder instance_builder = ::ParamIndicesBuilder(builder);
    instance_builder.add_idxs(idxs_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ParamIndices &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ParamIndices::ParamIndices()
    : idxs_() {
}

ParamIndices::ParamIndices(const std::vector<uint8_t> &bytes)
    : ParamIndices(::flatbuffers::GetSizePrefixedRoot<::ParamIndices>(bytes.data())) {
}

ParamIndices::ParamIndices(const ::ParamIndices *root) 
    : idxs_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &idxs_vector = root->idxs();
    if (idxs_vector != nullptr) {
        std::copy(idxs_vector->begin(), idxs_vector->end(), std::back_inserter(idxs_));
    }
}

::flatbuffers::Offset<::RunSpec>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RunSpec &o) {
    std::vector<::flatbuffers::Offset<::ParamIndices>> param_indices_offsets = std::vector<::flatbuffers::Offset<::ParamIndices>>();
    param_indices_offsets.reserve(o.param_indices_.size());
    for (const auto &i: o.param_indices_) {
        param_indices_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ParamIndices>>> param_indices_offset = builder.CreateVector(param_indices_offsets);
    std::vector<::flatbuffers::Offset<::TaskParameter>> params_offsets = std::vector<::flatbuffers::Offset<::TaskParameter>>();
    params_offsets.reserve(o.params_.size());
    for (const auto &i: o.params_) {
        params_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TaskParameter>>> params_offset = builder.CreateVector(params_offsets);
    const ::flatbuffers::Offset<::ObjectId> schematic_offset = serialize_to(builder, o.schematic_);

    ::RunSpecBuilder instance_builder = ::RunSpecBuilder(builder);
    instance_builder.add_notify(o.notify_);
    instance_builder.add_param_indices(param_indices_offset);
    instance_builder.add_params(params_offset);
    instance_builder.add_persist(o.persist_);
    instance_builder.add_priority(o.priority_);
    instance_builder.add_schematic(schematic_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RunSpec &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RunSpec::RunSpec()
    : notify_(true)
    , param_indices_()
    , params_()
    , persist_(false)
    , priority_(TaskPriority(0))
    , schematic_() {
}

RunSpec::RunSpec(const std::vector<uint8_t> &bytes)
    : RunSpec(::flatbuffers::GetSizePrefixedRoot<::RunSpec>(bytes.data())) {
}

RunSpec::RunSpec(const ::RunSpec *root) 
    : notify_(true)
    , param_indices_()
    , params_()
    , persist_(false)
    , priority_(TaskPriority(0))
    , schematic_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    notify_ = root->notify();
    const auto &param_indices_vector = root->param_indices();
    if (param_indices_vector != nullptr) {
        param_indices_.reserve(param_indices_vector->size());
        for (const auto &i: *param_indices_vector) {
            param_indices_.emplace_back(i);
        }
    }
    const auto &params_vector = root->params();
    if (params_vector != nullptr) {
        params_.reserve(params_vector->size());
        for (const auto &i: *params_vector) {
            params_.emplace_back(i);
        }
    }
    persist_ = root->persist();
    priority_ = root->priority();
    if (root->schematic() != nullptr) {
        schematic_ = decltype(schematic_)(root->schematic());
    }
}

::flatbuffers::Offset<::Schematic>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Schematic &o) {
    std::vector<::flatbuffers::Offset<::AttributePair>> attributes_offsets = std::vector<::flatbuffers::Offset<::AttributePair>>();
    attributes_offsets.reserve(o.attributes_.size());
    for (const auto &i: o.attributes_) {
        attributes_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::AttributePair>>> attributes_offset = builder.CreateVector(attributes_offsets);
    std::vector<::flatbuffers::Offset<::Edge>> edges_offsets = std::vector<::flatbuffers::Offset<::Edge>>();
    edges_offsets.reserve(o.edges_.size());
    for (const auto &i: o.edges_) {
        edges_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Edge>>> edges_offset = builder.CreateVector(edges_offsets);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> name_offset = std::nullopt;
    if (o.name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> name_offset_val = builder.CreateString(o.name_.value());
        name_offset = std::make_optional(name_offset_val);
    }
    std::vector<::flatbuffers::Offset<::Node>> nodes_offsets = std::vector<::flatbuffers::Offset<::Node>>();
    nodes_offsets.reserve(o.nodes_.size());
    for (const auto &i: o.nodes_) {
        nodes_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Node>>> nodes_offset = builder.CreateVector(nodes_offsets);

    ::SchematicBuilder instance_builder = ::SchematicBuilder(builder);
    instance_builder.add_attributes(attributes_offset);
    instance_builder.add_edges(edges_offset);
    if (name_offset.has_value()) {
        instance_builder.add_name(name_offset.value());
    }
    instance_builder.add_nodes(nodes_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Schematic &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Schematic::Schematic()
    : attributes_()
    , edges_()
    , name_(std::nullopt)
    , nodes_() {
}

Schematic::Schematic(const std::vector<uint8_t> &bytes)
    : Schematic(::flatbuffers::GetSizePrefixedRoot<::Schematic>(bytes.data())) {
}

Schematic::Schematic(const ::Schematic *root) 
    : attributes_()
    , edges_()
    , name_(std::nullopt)
    , nodes_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        attributes_.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes_.emplace_back(i);
        }
    }
    const auto &edges_vector = root->edges();
    if (edges_vector != nullptr) {
        edges_.reserve(edges_vector->size());
        for (const auto &i: *edges_vector) {
            edges_.emplace_back(i);
        }
    }
    if (root->name() != nullptr) {
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    }
    const auto &nodes_vector = root->nodes();
    if (nodes_vector != nullptr) {
        nodes_.reserve(nodes_vector->size());
        for (const auto &i: *nodes_vector) {
            nodes_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::Task>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Task &o) {
    const ::flatbuffers::Offset<::ObjectId> _id_offset = serialize_to(builder, o._id_);
    std::vector<::flatbuffers::Offset<::ObjectId>> downstream_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
    downstream_offsets.reserve(o.downstream_.size());
    for (const auto &i: o.downstream_) {
        downstream_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> downstream_offset = builder.CreateVector(downstream_offsets);
    const ::flatbuffers::Offset<::ObjectId> job_id_offset = serialize_to(builder, o.job_id_);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> last_updated_by_pod_offset = std::nullopt;
    if (o.last_updated_by_pod_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> last_updated_by_pod_offset_val = builder.CreateString(o.last_updated_by_pod_.value());
        last_updated_by_pod_offset = std::make_optional(last_updated_by_pod_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> message_offset = std::nullopt;
    if (o.message_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> message_offset_val = builder.CreateString(o.message_.value());
        message_offset = std::make_optional(message_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    const ::flatbuffers::Offset<::ObjectId> output_offset = serialize_to(builder, o.output_);
    const ::flatbuffers::Offset<::ParamIndices> params_offset = serialize_to(builder, o.params_);
    std::optional<::flatbuffers::Offset<::ObjectId>> schematic_id_offset = std::nullopt;
    if (o.schematic_id_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> schematic_id_offset_val = serialize_to(builder, o.schematic_id_.value());
        schematic_id_offset = std::make_optional(schematic_id_offset_val);
    }
    const ::flatbuffers::Offset<::ObjectId> task_offset = serialize_to(builder, o.task_);
    std::vector<::flatbuffers::Offset<::ObjectId>> upstream_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
    upstream_offsets.reserve(o.upstream_.size());
    for (const auto &i: o.upstream_) {
        upstream_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> upstream_offset = builder.CreateVector(upstream_offsets);
    const ::flatbuffers::Offset<::ObjectId> user_id_offset = serialize_to(builder, o.user_id_);

    ::TaskBuilder instance_builder = ::TaskBuilder(builder);
    instance_builder.add__id(_id_offset);
    instance_builder.add_barrier_count(o.barrier_count_);
    instance_builder.add_created(o.created_);
    instance_builder.add_discard(o.discard_);
    instance_builder.add_downstream(downstream_offset);
    instance_builder.add_end(o.end_);
    instance_builder.add_error_ty(o.error_ty_);
    instance_builder.add_flags(o.flags_);
    instance_builder.add_job_id(job_id_offset);
    instance_builder.add_last_updated(o.last_updated_);
    if (last_updated_by_pod_offset.has_value()) {
        instance_builder.add_last_updated_by_pod(last_updated_by_pod_offset.value());
    }
    if (message_offset.has_value()) {
        instance_builder.add_message(message_offset.value());
    }
    instance_builder.add_name(name_offset);
    instance_builder.add_output(output_offset);
    instance_builder.add_params(params_offset);
    instance_builder.add_retries(o.retries_);
    if (schematic_id_offset.has_value()) {
        instance_builder.add_schematic_id(schematic_id_offset.value());
    }
    instance_builder.add_start(o.start_);
    instance_builder.add_status(o.status_);
    instance_builder.add_task(task_offset);
    instance_builder.add_upstream(upstream_offset);
    instance_builder.add_user_id(user_id_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Task &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Task::Task()
    : _id_()
    , barrier_count_(0)
    , created_(0)
    , discard_(false)
    , downstream_()
    , end_(0)
    , error_ty_(TaskErrorTy(0))
    , flags_(0)
    , job_id_()
    , last_updated_(0)
    , last_updated_by_pod_(std::nullopt)
    , message_(std::nullopt)
    , name_()
    , output_()
    , params_()
    , retries_(0)
    , schematic_id_(std::nullopt)
    , start_(0)
    , status_(Status(0))
    , task_()
    , upstream_()
    , user_id_() {
}

Task::Task(const std::vector<uint8_t> &bytes)
    : Task(::flatbuffers::GetSizePrefixedRoot<::Task>(bytes.data())) {
}

Task::Task(const ::Task *root) 
    : _id_()
    , barrier_count_(0)
    , created_(0)
    , discard_(false)
    , downstream_()
    , end_(0)
    , error_ty_(TaskErrorTy(0))
    , flags_(0)
    , job_id_()
    , last_updated_(0)
    , last_updated_by_pod_(std::nullopt)
    , message_(std::nullopt)
    , name_()
    , output_()
    , params_()
    , retries_(0)
    , schematic_id_(std::nullopt)
    , start_(0)
    , status_(Status(0))
    , task_()
    , upstream_()
    , user_id_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->_id() != nullptr) {
        _id_ = decltype(_id_)(root->_id());
    }
    barrier_count_ = root->barrier_count();
    created_ = root->created();
    discard_ = root->discard();
    const auto &downstream_vector = root->downstream();
    if (downstream_vector != nullptr) {
        downstream_.reserve(downstream_vector->size());
        for (const auto &i: *downstream_vector) {
            downstream_.emplace_back(i);
        }
    }
    end_ = root->end();
    error_ty_ = root->error_ty();
    flags_ = root->flags();
    if (root->job_id() != nullptr) {
        job_id_ = decltype(job_id_)(root->job_id());
    }
    last_updated_ = root->last_updated();
    if (root->last_updated_by_pod() != nullptr) {
        last_updated_by_pod_ = std::string(*root->last_updated_by_pod()->begin(), *root->last_updated_by_pod()->end());
    }
    if (root->message() != nullptr) {
        message_ = std::string(*root->message()->begin(), *root->message()->end());
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->output() != nullptr) {
        output_ = decltype(output_)(root->output());
    }
    if (root->params() != nullptr) {
        params_ = decltype(params_)(root->params());
    }
    retries_ = root->retries();
    if (root->schematic_id() != nullptr) {
        schematic_id_ = decltype(schematic_id_)(root->schematic_id());
    }
    start_ = root->start();
    status_ = root->status();
    if (root->task() != nullptr) {
        task_ = decltype(task_)(root->task());
    }
    const auto &upstream_vector = root->upstream();
    if (upstream_vector != nullptr) {
        upstream_.reserve(upstream_vector->size());
        for (const auto &i: *upstream_vector) {
            upstream_.emplace_back(i);
        }
    }
    if (root->user_id() != nullptr) {
        user_id_ = decltype(user_id_)(root->user_id());
    }
}

::flatbuffers::Offset<::TaskList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TaskList &o) {
    std::vector<::flatbuffers::Offset<::Task>> tasks_offsets = std::vector<::flatbuffers::Offset<::Task>>();
    tasks_offsets.reserve(o.tasks_.size());
    for (const auto &i: o.tasks_) {
        tasks_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Task>>> tasks_offset = builder.CreateVector(tasks_offsets);

    ::TaskListBuilder instance_builder = ::TaskListBuilder(builder);
    instance_builder.add_tasks(tasks_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TaskList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TaskList::TaskList()
    : tasks_() {
}

TaskList::TaskList(const std::vector<uint8_t> &bytes)
    : TaskList(::flatbuffers::GetSizePrefixedRoot<::TaskList>(bytes.data())) {
}

TaskList::TaskList(const ::TaskList *root) 
    : tasks_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &tasks_vector = root->tasks();
    if (tasks_vector != nullptr) {
        tasks_.reserve(tasks_vector->size());
        for (const auto &i: *tasks_vector) {
            tasks_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::TaskParameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TaskParameter &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> key_offset = builder.CreateString(o.key_);
    const std::pair<::flatbuffers::Offset<void>, ::TaskParameterValue> value_offset = serialize_to(builder, o.value_);

    ::TaskParameterBuilder instance_builder = ::TaskParameterBuilder(builder);
    instance_builder.add_key(key_offset);
    instance_builder.add_value(value_offset.first);
    instance_builder.add_value_type(value_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TaskParameter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TaskParameter::TaskParameter()
    : key_()
    , value_(std::make_shared<ObjectId>()) {
}

TaskParameter::TaskParameter(const std::vector<uint8_t> &bytes)
    : TaskParameter(::flatbuffers::GetSizePrefixedRoot<::TaskParameter>(bytes.data())) {
}

TaskParameter::TaskParameter(const ::TaskParameter *root) 
    : key_()
    , value_(std::make_shared<ObjectId>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        key_ = std::string(*root->key()->begin(), *root->key()->end());
    if (root->value() != nullptr) {
        switch (root->value_type()) {
            case ::TaskParameterValue::NONE: throw std::runtime_error("unexpected none variant");
            case ::TaskParameterValue::ObjectId: {
                const auto value__local = static_cast<const ::ObjectId *>(root->value());
                std::shared_ptr<ObjectId> value__shared = std::make_shared<ObjectId>(value__local);
                value_ = value__shared;
                break;
            }
            case ::TaskParameterValue::EmbeddedTable: {
                const auto value__local = static_cast<const ::EmbeddedTable *>(root->value());
                std::shared_ptr<EmbeddedTable> value__shared = std::make_shared<EmbeddedTable>(value__local);
                value_ = value__shared;
                break;
            }
            case ::TaskParameterValue::ValueInstance: {
                const auto value__local = static_cast<const ::ValueInstance *>(root->value());
                std::shared_ptr<ValueInstance> value__shared = std::make_shared<ValueInstance>(value__local);
                value_ = value__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

} // namespace types
} // namespace ul
