// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/Schema.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::Type>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Type &o) {
    if (std::holds_alternative<std::shared_ptr<Null>>(o)) {
        const std::shared_ptr<Null> &v = std::get<std::shared_ptr<Null>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Null);
    } else if (std::holds_alternative<std::shared_ptr<Int>>(o)) {
        const std::shared_ptr<Int> &v = std::get<std::shared_ptr<Int>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Int);
    } else if (std::holds_alternative<std::shared_ptr<FloatingPoint>>(o)) {
        const std::shared_ptr<FloatingPoint> &v = std::get<std::shared_ptr<FloatingPoint>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::FloatingPoint);
    } else if (std::holds_alternative<std::shared_ptr<Binary>>(o)) {
        const std::shared_ptr<Binary> &v = std::get<std::shared_ptr<Binary>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Binary);
    } else if (std::holds_alternative<std::shared_ptr<Utf8>>(o)) {
        const std::shared_ptr<Utf8> &v = std::get<std::shared_ptr<Utf8>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Utf8);
    } else if (std::holds_alternative<std::shared_ptr<Bool>>(o)) {
        const std::shared_ptr<Bool> &v = std::get<std::shared_ptr<Bool>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Bool);
    } else if (std::holds_alternative<std::shared_ptr<Decimal>>(o)) {
        const std::shared_ptr<Decimal> &v = std::get<std::shared_ptr<Decimal>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Decimal);
    } else if (std::holds_alternative<std::shared_ptr<Date>>(o)) {
        const std::shared_ptr<Date> &v = std::get<std::shared_ptr<Date>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Date);
    } else if (std::holds_alternative<std::shared_ptr<Time>>(o)) {
        const std::shared_ptr<Time> &v = std::get<std::shared_ptr<Time>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Time);
    } else if (std::holds_alternative<std::shared_ptr<Timestamp>>(o)) {
        const std::shared_ptr<Timestamp> &v = std::get<std::shared_ptr<Timestamp>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Timestamp);
    } else if (std::holds_alternative<std::shared_ptr<Interval>>(o)) {
        const std::shared_ptr<Interval> &v = std::get<std::shared_ptr<Interval>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Interval);
    } else if (std::holds_alternative<std::shared_ptr<List>>(o)) {
        const std::shared_ptr<List> &v = std::get<std::shared_ptr<List>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::List);
    } else if (std::holds_alternative<std::shared_ptr<Struct_>>(o)) {
        const std::shared_ptr<Struct_> &v = std::get<std::shared_ptr<Struct_>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Struct_);
    } else if (std::holds_alternative<std::shared_ptr<Union>>(o)) {
        const std::shared_ptr<Union> &v = std::get<std::shared_ptr<Union>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Union);
    } else if (std::holds_alternative<std::shared_ptr<FixedSizeBinary>>(o)) {
        const std::shared_ptr<FixedSizeBinary> &v = std::get<std::shared_ptr<FixedSizeBinary>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::FixedSizeBinary);
    } else if (std::holds_alternative<std::shared_ptr<FixedSizeList>>(o)) {
        const std::shared_ptr<FixedSizeList> &v = std::get<std::shared_ptr<FixedSizeList>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::FixedSizeList);
    } else if (std::holds_alternative<std::shared_ptr<Map>>(o)) {
        const std::shared_ptr<Map> &v = std::get<std::shared_ptr<Map>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Map);
    } else if (std::holds_alternative<std::shared_ptr<Duration>>(o)) {
        const std::shared_ptr<Duration> &v = std::get<std::shared_ptr<Duration>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::Duration);
    } else if (std::holds_alternative<std::shared_ptr<LargeBinary>>(o)) {
        const std::shared_ptr<LargeBinary> &v = std::get<std::shared_ptr<LargeBinary>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::LargeBinary);
    } else if (std::holds_alternative<std::shared_ptr<LargeUtf8>>(o)) {
        const std::shared_ptr<LargeUtf8> &v = std::get<std::shared_ptr<LargeUtf8>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::LargeUtf8);
    } else if (std::holds_alternative<std::shared_ptr<LargeList>>(o)) {
        const std::shared_ptr<LargeList> &v = std::get<std::shared_ptr<LargeList>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Type::LargeList);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::Null>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Null &) {

    ::NullBuilder instance_builder = ::NullBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Null &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Null::Null() {
}

Null::Null(const std::vector<uint8_t> &bytes)
    : Null(::flatbuffers::GetSizePrefixedRoot<::Null>(bytes.data())) {
}

Null::Null(const ::Null *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::Int>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Int &o) {

    ::IntBuilder instance_builder = ::IntBuilder(builder);
    instance_builder.add_bitWidth(o.bitWidth_);
    instance_builder.add_is_signed(o.is_signed_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Int &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Int::Int()
    : bitWidth_(0)
    , is_signed_(false) {
}

Int::Int(const std::vector<uint8_t> &bytes)
    : Int(::flatbuffers::GetSizePrefixedRoot<::Int>(bytes.data())) {
}

Int::Int(const ::Int *root) 
    : bitWidth_(0)
    , is_signed_(false) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    bitWidth_ = root->bitWidth();
    is_signed_ = root->is_signed();
}

::flatbuffers::Offset<::FloatingPoint>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FloatingPoint &o) {

    ::FloatingPointBuilder instance_builder = ::FloatingPointBuilder(builder);
    instance_builder.add_precision(o.precision_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const FloatingPoint &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

FloatingPoint::FloatingPoint()
    : precision_(Precision(0)) {
}

FloatingPoint::FloatingPoint(const std::vector<uint8_t> &bytes)
    : FloatingPoint(::flatbuffers::GetSizePrefixedRoot<::FloatingPoint>(bytes.data())) {
}

FloatingPoint::FloatingPoint(const ::FloatingPoint *root) 
    : precision_(Precision(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    precision_ = root->precision();
}

::flatbuffers::Offset<::Binary>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Binary &) {

    ::BinaryBuilder instance_builder = ::BinaryBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Binary &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Binary::Binary() {
}

Binary::Binary(const std::vector<uint8_t> &bytes)
    : Binary(::flatbuffers::GetSizePrefixedRoot<::Binary>(bytes.data())) {
}

Binary::Binary(const ::Binary *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::Utf8>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Utf8 &) {

    ::Utf8Builder instance_builder = ::Utf8Builder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Utf8 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Utf8::Utf8() {
}

Utf8::Utf8(const std::vector<uint8_t> &bytes)
    : Utf8(::flatbuffers::GetSizePrefixedRoot<::Utf8>(bytes.data())) {
}

Utf8::Utf8(const ::Utf8 *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::Bool>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Bool &) {

    ::BoolBuilder instance_builder = ::BoolBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Bool &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Bool::Bool() {
}

Bool::Bool(const std::vector<uint8_t> &bytes)
    : Bool(::flatbuffers::GetSizePrefixedRoot<::Bool>(bytes.data())) {
}

Bool::Bool(const ::Bool *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::Decimal>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Decimal &o) {

    ::DecimalBuilder instance_builder = ::DecimalBuilder(builder);
    instance_builder.add_bitWidth(o.bitWidth_);
    instance_builder.add_precision(o.precision_);
    instance_builder.add_scale(o.scale_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Decimal &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Decimal::Decimal()
    : bitWidth_(128)
    , precision_(0)
    , scale_(0) {
}

Decimal::Decimal(const std::vector<uint8_t> &bytes)
    : Decimal(::flatbuffers::GetSizePrefixedRoot<::Decimal>(bytes.data())) {
}

Decimal::Decimal(const ::Decimal *root) 
    : bitWidth_(128)
    , precision_(0)
    , scale_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    bitWidth_ = root->bitWidth();
    precision_ = root->precision();
    scale_ = root->scale();
}

::flatbuffers::Offset<::Date>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Date &o) {

    ::DateBuilder instance_builder = ::DateBuilder(builder);
    instance_builder.add_unit(o.unit_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Date &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Date::Date()
    : unit_(DateUnit(1)) {
}

Date::Date(const std::vector<uint8_t> &bytes)
    : Date(::flatbuffers::GetSizePrefixedRoot<::Date>(bytes.data())) {
}

Date::Date(const ::Date *root) 
    : unit_(DateUnit(1)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    unit_ = root->unit();
}

::flatbuffers::Offset<::Time>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Time &o) {

    ::TimeBuilder instance_builder = ::TimeBuilder(builder);
    instance_builder.add_bitWidth(o.bitWidth_);
    instance_builder.add_unit(o.unit_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Time &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Time::Time()
    : bitWidth_(32)
    , unit_(TimeUnit(1)) {
}

Time::Time(const std::vector<uint8_t> &bytes)
    : Time(::flatbuffers::GetSizePrefixedRoot<::Time>(bytes.data())) {
}

Time::Time(const ::Time *root) 
    : bitWidth_(32)
    , unit_(TimeUnit(1)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    bitWidth_ = root->bitWidth();
    unit_ = root->unit();
}

::flatbuffers::Offset<::Timestamp>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Timestamp &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> timezone_offset = std::nullopt;
    if (o.timezone_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> timezone_offset_val = builder.CreateString(o.timezone_.value());
        timezone_offset = std::make_optional(timezone_offset_val);
    }

    ::TimestampBuilder instance_builder = ::TimestampBuilder(builder);
    if (timezone_offset.has_value()) {
        instance_builder.add_timezone(timezone_offset.value());
    }
    instance_builder.add_unit(o.unit_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Timestamp &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Timestamp::Timestamp()
    : timezone_(std::nullopt)
    , unit_(TimeUnit(0)) {
}

Timestamp::Timestamp(const std::vector<uint8_t> &bytes)
    : Timestamp(::flatbuffers::GetSizePrefixedRoot<::Timestamp>(bytes.data())) {
}

Timestamp::Timestamp(const ::Timestamp *root) 
    : timezone_(std::nullopt)
    , unit_(TimeUnit(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->timezone() != nullptr) {
        timezone_ = std::string(*root->timezone()->begin(), *root->timezone()->end());
    }
    unit_ = root->unit();
}

::flatbuffers::Offset<::Interval>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Interval &o) {

    ::IntervalBuilder instance_builder = ::IntervalBuilder(builder);
    instance_builder.add_unit(o.unit_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Interval &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Interval::Interval()
    : unit_(IntervalUnit(0)) {
}

Interval::Interval(const std::vector<uint8_t> &bytes)
    : Interval(::flatbuffers::GetSizePrefixedRoot<::Interval>(bytes.data())) {
}

Interval::Interval(const ::Interval *root) 
    : unit_(IntervalUnit(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    unit_ = root->unit();
}

::flatbuffers::Offset<::List>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const List &) {

    ::ListBuilder instance_builder = ::ListBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const List &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

List::List() {
}

List::List(const std::vector<uint8_t> &bytes)
    : List(::flatbuffers::GetSizePrefixedRoot<::List>(bytes.data())) {
}

List::List(const ::List *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::Struct_>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Struct_ &) {

    ::Struct_Builder instance_builder = ::Struct_Builder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Struct_ &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Struct_::Struct_() {
}

Struct_::Struct_(const std::vector<uint8_t> &bytes)
    : Struct_(::flatbuffers::GetSizePrefixedRoot<::Struct_>(bytes.data())) {
}

Struct_::Struct_(const ::Struct_ *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::Union>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Union &o) {
    std::optional<decltype(builder.CreateVector(o.typeIds_.value()))> typeIds_offset = std::nullopt;
    if (o.typeIds_.has_value()) {
        const decltype(builder.CreateVector(o.typeIds_.value())) typeIds_offset_val = builder.CreateVector(o.typeIds_.value());
        typeIds_offset = std::make_optional(typeIds_offset_val);
    }

    ::UnionBuilder instance_builder = ::UnionBuilder(builder);
    instance_builder.add_mode(o.mode_);
    if (typeIds_offset.has_value()) {
        instance_builder.add_typeIds(typeIds_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Union &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Union::Union()
    : mode_(UnionMode(0))
    , typeIds_(std::nullopt) {
}

Union::Union(const std::vector<uint8_t> &bytes)
    : Union(::flatbuffers::GetSizePrefixedRoot<::Union>(bytes.data())) {
}

Union::Union(const ::Union *root) 
    : mode_(UnionMode(0))
    , typeIds_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    mode_ = root->mode();
    const auto &typeIds_vector = root->typeIds();
    if (typeIds_vector != nullptr) {
        decltype(typeIds_)::value_type typeIds__target = decltype(typeIds_)::value_type();
        std::copy(typeIds_vector->begin(), typeIds_vector->end(), std::back_inserter(typeIds__target));
        typeIds_ = std::make_optional(typeIds__target);
    }
}

::flatbuffers::Offset<::FixedSizeBinary>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FixedSizeBinary &o) {

    ::FixedSizeBinaryBuilder instance_builder = ::FixedSizeBinaryBuilder(builder);
    instance_builder.add_byteWidth(o.byteWidth_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const FixedSizeBinary &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

FixedSizeBinary::FixedSizeBinary()
    : byteWidth_(0) {
}

FixedSizeBinary::FixedSizeBinary(const std::vector<uint8_t> &bytes)
    : FixedSizeBinary(::flatbuffers::GetSizePrefixedRoot<::FixedSizeBinary>(bytes.data())) {
}

FixedSizeBinary::FixedSizeBinary(const ::FixedSizeBinary *root) 
    : byteWidth_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    byteWidth_ = root->byteWidth();
}

::flatbuffers::Offset<::FixedSizeList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FixedSizeList &o) {

    ::FixedSizeListBuilder instance_builder = ::FixedSizeListBuilder(builder);
    instance_builder.add_listSize(o.listSize_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const FixedSizeList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

FixedSizeList::FixedSizeList()
    : listSize_(0) {
}

FixedSizeList::FixedSizeList(const std::vector<uint8_t> &bytes)
    : FixedSizeList(::flatbuffers::GetSizePrefixedRoot<::FixedSizeList>(bytes.data())) {
}

FixedSizeList::FixedSizeList(const ::FixedSizeList *root) 
    : listSize_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    listSize_ = root->listSize();
}

::flatbuffers::Offset<::Map>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Map &o) {

    ::MapBuilder instance_builder = ::MapBuilder(builder);
    instance_builder.add_keysSorted(o.keysSorted_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Map &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Map::Map()
    : keysSorted_(false) {
}

Map::Map(const std::vector<uint8_t> &bytes)
    : Map(::flatbuffers::GetSizePrefixedRoot<::Map>(bytes.data())) {
}

Map::Map(const ::Map *root) 
    : keysSorted_(false) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    keysSorted_ = root->keysSorted();
}

::flatbuffers::Offset<::Duration>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Duration &o) {

    ::DurationBuilder instance_builder = ::DurationBuilder(builder);
    instance_builder.add_unit(o.unit_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Duration &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Duration::Duration()
    : unit_(TimeUnit(1)) {
}

Duration::Duration(const std::vector<uint8_t> &bytes)
    : Duration(::flatbuffers::GetSizePrefixedRoot<::Duration>(bytes.data())) {
}

Duration::Duration(const ::Duration *root) 
    : unit_(TimeUnit(1)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    unit_ = root->unit();
}

::flatbuffers::Offset<::LargeBinary>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const LargeBinary &) {

    ::LargeBinaryBuilder instance_builder = ::LargeBinaryBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const LargeBinary &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

LargeBinary::LargeBinary() {
}

LargeBinary::LargeBinary(const std::vector<uint8_t> &bytes)
    : LargeBinary(::flatbuffers::GetSizePrefixedRoot<::LargeBinary>(bytes.data())) {
}

LargeBinary::LargeBinary(const ::LargeBinary *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::LargeUtf8>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const LargeUtf8 &) {

    ::LargeUtf8Builder instance_builder = ::LargeUtf8Builder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const LargeUtf8 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

LargeUtf8::LargeUtf8() {
}

LargeUtf8::LargeUtf8(const std::vector<uint8_t> &bytes)
    : LargeUtf8(::flatbuffers::GetSizePrefixedRoot<::LargeUtf8>(bytes.data())) {
}

LargeUtf8::LargeUtf8(const ::LargeUtf8 *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::LargeList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const LargeList &) {

    ::LargeListBuilder instance_builder = ::LargeListBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const LargeList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

LargeList::LargeList() {
}

LargeList::LargeList(const std::vector<uint8_t> &bytes)
    : LargeList(::flatbuffers::GetSizePrefixedRoot<::LargeList>(bytes.data())) {
}

LargeList::LargeList(const ::LargeList *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

Buffer::Buffer()
    : length_(0)
    , offset_(0) {
}

Buffer::Buffer(const ::Buffer *root) 
    : length_(0)
    , offset_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    length_ = root->length();
    offset_ = root->offset();
}

::flatbuffers::Offset<::DictionaryEncoding>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DictionaryEncoding &o) {
    std::optional<::flatbuffers::Offset<::Int>> indexType_offset = std::nullopt;
    if (o.indexType_.has_value()) {
        const ::flatbuffers::Offset<::Int> indexType_offset_val = serialize_to(builder, o.indexType_.value());
        indexType_offset = std::make_optional(indexType_offset_val);
    }

    ::DictionaryEncodingBuilder instance_builder = ::DictionaryEncodingBuilder(builder);
    instance_builder.add_dictionaryKind(o.dictionaryKind_);
    instance_builder.add_id(o.id_);
    if (indexType_offset.has_value()) {
        instance_builder.add_indexType(indexType_offset.value());
    }
    instance_builder.add_isOrdered(o.isOrdered_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DictionaryEncoding &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DictionaryEncoding::DictionaryEncoding()
    : dictionaryKind_(DictionaryKind(0))
    , id_(0)
    , indexType_(std::nullopt)
    , isOrdered_(false) {
}

DictionaryEncoding::DictionaryEncoding(const std::vector<uint8_t> &bytes)
    : DictionaryEncoding(::flatbuffers::GetSizePrefixedRoot<::DictionaryEncoding>(bytes.data())) {
}

DictionaryEncoding::DictionaryEncoding(const ::DictionaryEncoding *root) 
    : dictionaryKind_(DictionaryKind(0))
    , id_(0)
    , indexType_(std::nullopt)
    , isOrdered_(false) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    dictionaryKind_ = root->dictionaryKind();
    id_ = root->id();
    if (root->indexType() != nullptr) {
        indexType_ = decltype(indexType_)(root->indexType());
    }
    isOrdered_ = root->isOrdered();
}

::flatbuffers::Offset<::Field>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Field &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Field>>>> children_offset = std::nullopt;
    if (o.children_.has_value()) {
        const auto &children__var = o.children_.value();
        std::vector<::flatbuffers::Offset<::Field>> children_offsets = std::vector<::flatbuffers::Offset<::Field>>();
        children_offsets.reserve(children__var.size());
        for (const auto &i: children__var) {
            children_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Field>>> children_offset_val = builder.CreateVector(children_offsets);
        children_offset = std::make_optional(children_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::KeyValue>>>> custom_metadata_offset = std::nullopt;
    if (o.custom_metadata_.has_value()) {
        const auto &custom_metadata__var = o.custom_metadata_.value();
        std::vector<::flatbuffers::Offset<::KeyValue>> custom_metadata_offsets = std::vector<::flatbuffers::Offset<::KeyValue>>();
        custom_metadata_offsets.reserve(custom_metadata__var.size());
        for (const auto &i: custom_metadata__var) {
            custom_metadata_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::KeyValue>>> custom_metadata_offset_val = builder.CreateVector(custom_metadata_offsets);
        custom_metadata_offset = std::make_optional(custom_metadata_offset_val);
    }
    std::optional<::flatbuffers::Offset<::DictionaryEncoding>> dictionary_offset = std::nullopt;
    if (o.dictionary_.has_value()) {
        const ::flatbuffers::Offset<::DictionaryEncoding> dictionary_offset_val = serialize_to(builder, o.dictionary_.value());
        dictionary_offset = std::make_optional(dictionary_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> name_offset = std::nullopt;
    if (o.name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> name_offset_val = builder.CreateString(o.name_.value());
        name_offset = std::make_optional(name_offset_val);
    }
    std::optional<std::pair<::flatbuffers::Offset<void>, ::Type>> type_offset = std::nullopt;
    if (o.type_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::Type> type_offset_val = serialize_to(builder, o.type_.value());
        type_offset = std::make_optional(type_offset_val);
    }

    ::FieldBuilder instance_builder = ::FieldBuilder(builder);
    if (children_offset.has_value()) {
        instance_builder.add_children(children_offset.value());
    }
    if (custom_metadata_offset.has_value()) {
        instance_builder.add_custom_metadata(custom_metadata_offset.value());
    }
    if (dictionary_offset.has_value()) {
        instance_builder.add_dictionary(dictionary_offset.value());
    }
    if (name_offset.has_value()) {
        instance_builder.add_name(name_offset.value());
    }
    instance_builder.add_nullable(o.nullable_);
    if (type_offset.has_value()) {
        const auto type_opt = type_offset.value();
        instance_builder.add_type(type_opt.first);
        instance_builder.add_type_type(type_opt.second);
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Field &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Field::Field()
    : children_(std::nullopt)
    , custom_metadata_(std::nullopt)
    , dictionary_(std::nullopt)
    , name_(std::nullopt)
    , nullable_(false)
    , type_(std::nullopt) {
}

Field::Field(const std::vector<uint8_t> &bytes)
    : Field(::flatbuffers::GetSizePrefixedRoot<::Field>(bytes.data())) {
}

Field::Field(const ::Field *root) 
    : children_(std::nullopt)
    , custom_metadata_(std::nullopt)
    , dictionary_(std::nullopt)
    , name_(std::nullopt)
    , nullable_(false)
    , type_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &children_vector = root->children();
    if (children_vector != nullptr) {
        decltype(children_)::value_type children__target = decltype(children_)::value_type();
        children__target.reserve(children_vector->size());
        for (const auto &i: *children_vector) {
            children__target.emplace_back(i);
        }
        children_ = std::make_optional(children__target);
    }
    const auto &custom_metadata_vector = root->custom_metadata();
    if (custom_metadata_vector != nullptr) {
        decltype(custom_metadata_)::value_type custom_metadata__target = decltype(custom_metadata_)::value_type();
        custom_metadata__target.reserve(custom_metadata_vector->size());
        for (const auto &i: *custom_metadata_vector) {
            custom_metadata__target.emplace_back(i);
        }
        custom_metadata_ = std::make_optional(custom_metadata__target);
    }
    if (root->dictionary() != nullptr) {
        dictionary_ = decltype(dictionary_)(root->dictionary());
    }
    if (root->name() != nullptr) {
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    }
    nullable_ = root->nullable();
    if (root->type() != nullptr) {
        switch (root->type_type()) {
            case ::Type::NONE: throw std::runtime_error("unexpected none variant");
            case ::Type::Null: {
                const auto type__local = static_cast<const ::Null *>(root->type());
                std::shared_ptr<Null> type__shared = std::make_shared<Null>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Int: {
                const auto type__local = static_cast<const ::Int *>(root->type());
                std::shared_ptr<Int> type__shared = std::make_shared<Int>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::FloatingPoint: {
                const auto type__local = static_cast<const ::FloatingPoint *>(root->type());
                std::shared_ptr<FloatingPoint> type__shared = std::make_shared<FloatingPoint>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Binary: {
                const auto type__local = static_cast<const ::Binary *>(root->type());
                std::shared_ptr<Binary> type__shared = std::make_shared<Binary>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Utf8: {
                const auto type__local = static_cast<const ::Utf8 *>(root->type());
                std::shared_ptr<Utf8> type__shared = std::make_shared<Utf8>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Bool: {
                const auto type__local = static_cast<const ::Bool *>(root->type());
                std::shared_ptr<Bool> type__shared = std::make_shared<Bool>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Decimal: {
                const auto type__local = static_cast<const ::Decimal *>(root->type());
                std::shared_ptr<Decimal> type__shared = std::make_shared<Decimal>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Date: {
                const auto type__local = static_cast<const ::Date *>(root->type());
                std::shared_ptr<Date> type__shared = std::make_shared<Date>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Time: {
                const auto type__local = static_cast<const ::Time *>(root->type());
                std::shared_ptr<Time> type__shared = std::make_shared<Time>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Timestamp: {
                const auto type__local = static_cast<const ::Timestamp *>(root->type());
                std::shared_ptr<Timestamp> type__shared = std::make_shared<Timestamp>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Interval: {
                const auto type__local = static_cast<const ::Interval *>(root->type());
                std::shared_ptr<Interval> type__shared = std::make_shared<Interval>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::List: {
                const auto type__local = static_cast<const ::List *>(root->type());
                std::shared_ptr<List> type__shared = std::make_shared<List>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Struct_: {
                const auto type__local = static_cast<const ::Struct_ *>(root->type());
                std::shared_ptr<Struct_> type__shared = std::make_shared<Struct_>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Union: {
                const auto type__local = static_cast<const ::Union *>(root->type());
                std::shared_ptr<Union> type__shared = std::make_shared<Union>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::FixedSizeBinary: {
                const auto type__local = static_cast<const ::FixedSizeBinary *>(root->type());
                std::shared_ptr<FixedSizeBinary> type__shared = std::make_shared<FixedSizeBinary>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::FixedSizeList: {
                const auto type__local = static_cast<const ::FixedSizeList *>(root->type());
                std::shared_ptr<FixedSizeList> type__shared = std::make_shared<FixedSizeList>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Map: {
                const auto type__local = static_cast<const ::Map *>(root->type());
                std::shared_ptr<Map> type__shared = std::make_shared<Map>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::Duration: {
                const auto type__local = static_cast<const ::Duration *>(root->type());
                std::shared_ptr<Duration> type__shared = std::make_shared<Duration>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::LargeBinary: {
                const auto type__local = static_cast<const ::LargeBinary *>(root->type());
                std::shared_ptr<LargeBinary> type__shared = std::make_shared<LargeBinary>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::LargeUtf8: {
                const auto type__local = static_cast<const ::LargeUtf8 *>(root->type());
                std::shared_ptr<LargeUtf8> type__shared = std::make_shared<LargeUtf8>(type__local);
                type_ = type__shared;
                break;
            }
            case ::Type::LargeList: {
                const auto type__local = static_cast<const ::LargeList *>(root->type());
                std::shared_ptr<LargeList> type__shared = std::make_shared<LargeList>(type__local);
                type_ = type__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::KeyValue>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const KeyValue &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> key_offset = std::nullopt;
    if (o.key_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> key_offset_val = builder.CreateString(o.key_.value());
        key_offset = std::make_optional(key_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> value_offset = std::nullopt;
    if (o.value_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> value_offset_val = builder.CreateString(o.value_.value());
        value_offset = std::make_optional(value_offset_val);
    }

    ::KeyValueBuilder instance_builder = ::KeyValueBuilder(builder);
    if (key_offset.has_value()) {
        instance_builder.add_key(key_offset.value());
    }
    if (value_offset.has_value()) {
        instance_builder.add_value(value_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const KeyValue &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

KeyValue::KeyValue()
    : key_(std::nullopt)
    , value_(std::nullopt) {
}

KeyValue::KeyValue(const std::vector<uint8_t> &bytes)
    : KeyValue(::flatbuffers::GetSizePrefixedRoot<::KeyValue>(bytes.data())) {
}

KeyValue::KeyValue(const ::KeyValue *root) 
    : key_(std::nullopt)
    , value_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->key() != nullptr) {
        key_ = std::string(*root->key()->begin(), *root->key()->end());
    }
    if (root->value() != nullptr) {
        value_ = std::string(*root->value()->begin(), *root->value()->end());
    }
}

::flatbuffers::Offset<::Schema>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Schema &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::KeyValue>>>> custom_metadata_offset = std::nullopt;
    if (o.custom_metadata_.has_value()) {
        const auto &custom_metadata__var = o.custom_metadata_.value();
        std::vector<::flatbuffers::Offset<::KeyValue>> custom_metadata_offsets = std::vector<::flatbuffers::Offset<::KeyValue>>();
        custom_metadata_offsets.reserve(custom_metadata__var.size());
        for (const auto &i: custom_metadata__var) {
            custom_metadata_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::KeyValue>>> custom_metadata_offset_val = builder.CreateVector(custom_metadata_offsets);
        custom_metadata_offset = std::make_optional(custom_metadata_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.features_.value()))> features_offset = std::nullopt;
    if (o.features_.has_value()) {
        const decltype(builder.CreateVector(o.features_.value())) features_offset_val = builder.CreateVector(o.features_.value());
        features_offset = std::make_optional(features_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Field>>>> fields_offset = std::nullopt;
    if (o.fields_.has_value()) {
        const auto &fields__var = o.fields_.value();
        std::vector<::flatbuffers::Offset<::Field>> fields_offsets = std::vector<::flatbuffers::Offset<::Field>>();
        fields_offsets.reserve(fields__var.size());
        for (const auto &i: fields__var) {
            fields_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Field>>> fields_offset_val = builder.CreateVector(fields_offsets);
        fields_offset = std::make_optional(fields_offset_val);
    }

    ::SchemaBuilder instance_builder = ::SchemaBuilder(builder);
    if (custom_metadata_offset.has_value()) {
        instance_builder.add_custom_metadata(custom_metadata_offset.value());
    }
    instance_builder.add_endianness(o.endianness_);
    if (features_offset.has_value()) {
        instance_builder.add_features(features_offset.value());
    }
    if (fields_offset.has_value()) {
        instance_builder.add_fields(fields_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Schema &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Schema::Schema()
    : custom_metadata_(std::nullopt)
    , endianness_(Endianness(0))
    , features_(std::nullopt)
    , fields_(std::nullopt) {
}

Schema::Schema(const std::vector<uint8_t> &bytes)
    : Schema(::flatbuffers::GetSizePrefixedRoot<::Schema>(bytes.data())) {
}

Schema::Schema(const ::Schema *root) 
    : custom_metadata_(std::nullopt)
    , endianness_(Endianness(0))
    , features_(std::nullopt)
    , fields_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &custom_metadata_vector = root->custom_metadata();
    if (custom_metadata_vector != nullptr) {
        decltype(custom_metadata_)::value_type custom_metadata__target = decltype(custom_metadata_)::value_type();
        custom_metadata__target.reserve(custom_metadata_vector->size());
        for (const auto &i: *custom_metadata_vector) {
            custom_metadata__target.emplace_back(i);
        }
        custom_metadata_ = std::make_optional(custom_metadata__target);
    }
    endianness_ = root->endianness();
    const auto &features_vector = root->features();
    if (features_vector != nullptr) {
        decltype(features_)::value_type features__target = decltype(features_)::value_type();
        std::copy(features_vector->begin(), features_vector->end(), std::back_inserter(features__target));
        features_ = std::make_optional(features__target);
    }
    const auto &fields_vector = root->fields();
    if (fields_vector != nullptr) {
        decltype(fields_)::value_type fields__target = decltype(fields_)::value_type();
        fields__target.reserve(fields_vector->size());
        for (const auto &i: *fields_vector) {
            fields__target.emplace_back(i);
        }
        fields_ = std::make_optional(fields__target);
    }
}

} // namespace types
} // namespace ul
