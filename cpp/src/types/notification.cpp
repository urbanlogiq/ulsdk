// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/notification.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::NotificationUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NotificationUnion &o) {
    if (std::holds_alternative<std::shared_ptr<Share>>(o)) {
        const std::shared_ptr<Share> &v = std::get<std::shared_ptr<Share>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::NotificationUnion::Share);
    } else if (std::holds_alternative<std::shared_ptr<JobComplete>>(o)) {
        const std::shared_ptr<JobComplete> &v = std::get<std::shared_ptr<JobComplete>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::NotificationUnion::JobComplete);
    } else if (std::holds_alternative<std::shared_ptr<AccessRequest>>(o)) {
        const std::shared_ptr<AccessRequest> &v = std::get<std::shared_ptr<AccessRequest>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::NotificationUnion::AccessRequest);
    } else if (std::holds_alternative<std::shared_ptr<DriveChange>>(o)) {
        const std::shared_ptr<DriveChange> &v = std::get<std::shared_ptr<DriveChange>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::NotificationUnion::DriveChange);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::Share>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Share &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> dest_offset = std::nullopt;
    if (o.dest_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> dest_offset_val = builder.CreateString(o.dest_.value());
        dest_offset = std::make_optional(dest_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> msg_offset = std::nullopt;
    if (o.msg_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> msg_offset_val = builder.CreateString(o.msg_.value());
        msg_offset = std::make_optional(msg_offset_val);
    }
    const ::flatbuffers::Offset<::ObjectId> object_offset = serialize_to(builder, o.object_);

    ::ShareBuilder instance_builder = ::ShareBuilder(builder);
    if (dest_offset.has_value()) {
        instance_builder.add_dest(dest_offset.value());
    }
    if (msg_offset.has_value()) {
        instance_builder.add_msg(msg_offset.value());
    }
    instance_builder.add_new_perms(o.new_perms_);
    instance_builder.add_object(object_offset);
    instance_builder.add_old_perms(o.old_perms_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Share &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Share::Share()
    : dest_(std::nullopt)
    , msg_(std::nullopt)
    , new_perms_(PermissionTy(0))
    , object_()
    , old_perms_(PermissionTy(0)) {
}

Share::Share(const std::vector<uint8_t> &bytes)
    : Share(::flatbuffers::GetSizePrefixedRoot<::Share>(bytes.data())) {
}

Share::Share(const ::Share *root) 
    : dest_(std::nullopt)
    , msg_(std::nullopt)
    , new_perms_(PermissionTy(0))
    , object_()
    , old_perms_(PermissionTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->dest() != nullptr) {
        dest_ = std::string(*root->dest()->begin(), *root->dest()->end());
    }
    if (root->msg() != nullptr) {
        msg_ = std::string(*root->msg()->begin(), *root->msg()->end());
    }
    new_perms_ = root->new_perms();
    if (root->object() != nullptr) {
        object_ = decltype(object_)(root->object());
    }
    old_perms_ = root->old_perms();
}

::flatbuffers::Offset<::JobComplete>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const JobComplete &o) {
    const ::flatbuffers::Offset<::ObjectId> job_offset = serialize_to(builder, o.job_);

    ::JobCompleteBuilder instance_builder = ::JobCompleteBuilder(builder);
    instance_builder.add_job(job_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const JobComplete &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

JobComplete::JobComplete()
    : job_() {
}

JobComplete::JobComplete(const std::vector<uint8_t> &bytes)
    : JobComplete(::flatbuffers::GetSizePrefixedRoot<::JobComplete>(bytes.data())) {
}

JobComplete::JobComplete(const ::JobComplete *root) 
    : job_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->job() != nullptr) {
        job_ = decltype(job_)(root->job());
    }
}

::flatbuffers::Offset<::AccessRequest>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const AccessRequest &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> msg_offset = std::nullopt;
    if (o.msg_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> msg_offset_val = builder.CreateString(o.msg_.value());
        msg_offset = std::make_optional(msg_offset_val);
    }
    const ::flatbuffers::Offset<::ObjectId> object_offset = serialize_to(builder, o.object_);

    ::AccessRequestBuilder instance_builder = ::AccessRequestBuilder(builder);
    if (msg_offset.has_value()) {
        instance_builder.add_msg(msg_offset.value());
    }
    instance_builder.add_object(object_offset);
    instance_builder.add_perms(o.perms_);
    instance_builder.add_requested_ownership(o.requested_ownership_);
    instance_builder.add_status(o.status_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const AccessRequest &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

AccessRequest::AccessRequest()
    : msg_(std::nullopt)
    , object_()
    , perms_(0)
    , requested_ownership_(0)
    , status_(RequestStatus(0)) {
}

AccessRequest::AccessRequest(const std::vector<uint8_t> &bytes)
    : AccessRequest(::flatbuffers::GetSizePrefixedRoot<::AccessRequest>(bytes.data())) {
}

AccessRequest::AccessRequest(const ::AccessRequest *root) 
    : msg_(std::nullopt)
    , object_()
    , perms_(0)
    , requested_ownership_(0)
    , status_(RequestStatus(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->msg() != nullptr) {
        msg_ = std::string(*root->msg()->begin(), *root->msg()->end());
    }
    if (root->object() != nullptr) {
        object_ = decltype(object_)(root->object());
    }
    perms_ = root->perms();
    requested_ownership_ = root->requested_ownership();
    status_ = root->status();
}

::flatbuffers::Offset<::DriveChange>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DriveChange &o) {
    const ::flatbuffers::Offset<::ObjectId> object_offset = serialize_to(builder, o.object_);
    const ::flatbuffers::Offset<::ObjectId> root_offset = serialize_to(builder, o.root_);

    ::DriveChangeBuilder instance_builder = ::DriveChangeBuilder(builder);
    instance_builder.add_action(o.action_);
    instance_builder.add_object(object_offset);
    instance_builder.add_root(root_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DriveChange &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DriveChange::DriveChange()
    : action_(DriveAction(0))
    , object_()
    , root_() {
}

DriveChange::DriveChange(const std::vector<uint8_t> &bytes)
    : DriveChange(::flatbuffers::GetSizePrefixedRoot<::DriveChange>(bytes.data())) {
}

DriveChange::DriveChange(const ::DriveChange *root) 
    : action_(DriveAction(0))
    , object_()
    , root_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    action_ = root->action();
    if (root->object() != nullptr) {
        object_ = decltype(object_)(root->object());
    }
    if (root->root() != nullptr) {
        root_ = decltype(root_)(root->root());
    }
}

::flatbuffers::Offset<::Inbox>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Inbox &o) {
    std::vector<::flatbuffers::Offset<::InboxItem>> items_offsets = std::vector<::flatbuffers::Offset<::InboxItem>>();
    items_offsets.reserve(o.items_.size());
    for (const auto &i: o.items_) {
        items_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::InboxItem>>> items_offset = builder.CreateVector(items_offsets);

    ::InboxBuilder instance_builder = ::InboxBuilder(builder);
    instance_builder.add_items(items_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Inbox &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Inbox::Inbox()
    : items_() {
}

Inbox::Inbox(const std::vector<uint8_t> &bytes)
    : Inbox(::flatbuffers::GetSizePrefixedRoot<::Inbox>(bytes.data())) {
}

Inbox::Inbox(const ::Inbox *root) 
    : items_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &items_vector = root->items();
    if (items_vector != nullptr) {
        items_.reserve(items_vector->size());
        for (const auto &i: *items_vector) {
            items_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::InboxItem>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const InboxItem &o) {
    const ::flatbuffers::Offset<::ObjectId> notification_offset = serialize_to(builder, o.notification_);

    ::InboxItemBuilder instance_builder = ::InboxItemBuilder(builder);
    instance_builder.add_notification(notification_offset);
    instance_builder.add_status(o.status_);
    instance_builder.add_time(o.time_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const InboxItem &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

InboxItem::InboxItem()
    : notification_()
    , status_(ReadStatus(0))
    , time_(0) {
}

InboxItem::InboxItem(const std::vector<uint8_t> &bytes)
    : InboxItem(::flatbuffers::GetSizePrefixedRoot<::InboxItem>(bytes.data())) {
}

InboxItem::InboxItem(const ::InboxItem *root) 
    : notification_()
    , status_(ReadStatus(0))
    , time_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->notification() != nullptr) {
        notification_ = decltype(notification_)(root->notification());
    }
    status_ = root->status();
    time_ = root->time();
}

::flatbuffers::Offset<::Notification>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Notification &o) {
    std::optional<std::pair<::flatbuffers::Offset<void>, ::NotificationUnion>> notification_offset = std::nullopt;
    if (o.notification_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::NotificationUnion> notification_offset_val = serialize_to(builder, o.notification_.value());
        notification_offset = std::make_optional(notification_offset_val);
    }
    std::optional<::flatbuffers::Offset<::B2cId>> sender_offset = std::nullopt;
    if (o.sender_.has_value()) {
        const ::flatbuffers::Offset<::B2cId> sender_offset_val = serialize_to(builder, o.sender_.value());
        sender_offset = std::make_optional(sender_offset_val);
    }

    ::NotificationBuilder instance_builder = ::NotificationBuilder(builder);
    if (notification_offset.has_value()) {
        const auto notification_opt = notification_offset.value();
        instance_builder.add_notification(notification_opt.first);
        instance_builder.add_notification_type(notification_opt.second);
    }
    if (sender_offset.has_value()) {
        instance_builder.add_sender(sender_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Notification &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Notification::Notification()
    : notification_(std::nullopt)
    , sender_(std::nullopt) {
}

Notification::Notification(const std::vector<uint8_t> &bytes)
    : Notification(::flatbuffers::GetSizePrefixedRoot<::Notification>(bytes.data())) {
}

Notification::Notification(const ::Notification *root) 
    : notification_(std::nullopt)
    , sender_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->notification() != nullptr) {
        switch (root->notification_type()) {
            case ::NotificationUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::NotificationUnion::Share: {
                const auto notification__local = static_cast<const ::Share *>(root->notification());
                std::shared_ptr<Share> notification__shared = std::make_shared<Share>(notification__local);
                notification_ = notification__shared;
                break;
            }
            case ::NotificationUnion::JobComplete: {
                const auto notification__local = static_cast<const ::JobComplete *>(root->notification());
                std::shared_ptr<JobComplete> notification__shared = std::make_shared<JobComplete>(notification__local);
                notification_ = notification__shared;
                break;
            }
            case ::NotificationUnion::AccessRequest: {
                const auto notification__local = static_cast<const ::AccessRequest *>(root->notification());
                std::shared_ptr<AccessRequest> notification__shared = std::make_shared<AccessRequest>(notification__local);
                notification_ = notification__shared;
                break;
            }
            case ::NotificationUnion::DriveChange: {
                const auto notification__local = static_cast<const ::DriveChange *>(root->notification());
                std::shared_ptr<DriveChange> notification__shared = std::make_shared<DriveChange>(notification__local);
                notification_ = notification__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    if (root->sender() != nullptr) {
        sender_ = decltype(sender_)(root->sender());
    }
}

::flatbuffers::Offset<::Response>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Response &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> msg_offset = std::nullopt;
    if (o.msg_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> msg_offset_val = builder.CreateString(o.msg_.value());
        msg_offset = std::make_optional(msg_offset_val);
    }

    ::ResponseBuilder instance_builder = ::ResponseBuilder(builder);
    if (msg_offset.has_value()) {
        instance_builder.add_msg(msg_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Response &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Response::Response()
    : msg_(std::nullopt) {
}

Response::Response(const std::vector<uint8_t> &bytes)
    : Response(::flatbuffers::GetSizePrefixedRoot<::Response>(bytes.data())) {
}

Response::Response(const ::Response *root) 
    : msg_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->msg() != nullptr) {
        msg_ = std::string(*root->msg()->begin(), *root->msg()->end());
    }
}

::flatbuffers::Offset<::ShareDetails>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ShareDetails &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> msg_offset = std::nullopt;
    if (o.msg_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> msg_offset_val = builder.CreateString(o.msg_.value());
        msg_offset = std::make_optional(msg_offset_val);
    }

    ::ShareDetailsBuilder instance_builder = ::ShareDetailsBuilder(builder);
    if (msg_offset.has_value()) {
        instance_builder.add_msg(msg_offset.value());
    }
    instance_builder.add_notify(o.notify_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ShareDetails &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ShareDetails::ShareDetails()
    : msg_(std::nullopt)
    , notify_(false) {
}

ShareDetails::ShareDetails(const std::vector<uint8_t> &bytes)
    : ShareDetails(::flatbuffers::GetSizePrefixedRoot<::ShareDetails>(bytes.data())) {
}

ShareDetails::ShareDetails(const ::ShareDetails *root) 
    : msg_(std::nullopt)
    , notify_(false) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->msg() != nullptr) {
        msg_ = std::string(*root->msg()->begin(), *root->msg()->end());
    }
    notify_ = root->notify();
}

} // namespace types
} // namespace ul
