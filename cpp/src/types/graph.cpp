// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/graph.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::QueryPathElementUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryPathElementUnion &o) {
    if (std::holds_alternative<std::shared_ptr<NodeQuery>>(o)) {
        const std::shared_ptr<NodeQuery> &v = std::get<std::shared_ptr<NodeQuery>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::QueryPathElementUnion::NodeQuery);
    } else if (std::holds_alternative<std::shared_ptr<EdgeQuery>>(o)) {
        const std::shared_ptr<EdgeQuery> &v = std::get<std::shared_ptr<EdgeQuery>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::QueryPathElementUnion::EdgeQuery);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::GeomOp>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GeomOp &o) {
    std::vector<::flatbuffers::Offset<::Geom>> geoms_offsets = std::vector<::flatbuffers::Offset<::Geom>>();
    geoms_offsets.reserve(o.geoms_.size());
    for (const auto &i: o.geoms_) {
        geoms_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Geom>>> geoms_offset = builder.CreateVector(geoms_offsets);

    ::GeomOpBuilder instance_builder = ::GeomOpBuilder(builder);
    instance_builder.add_geoms(geoms_offset);
    instance_builder.add_op(o.op_);
    instance_builder.add_predicate(o.predicate_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const GeomOp &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

GeomOp::GeomOp()
    : geoms_()
    , op_(Fn(0))
    , predicate_(Predicate(7)) {
}

GeomOp::GeomOp(const std::vector<uint8_t> &bytes)
    : GeomOp(::flatbuffers::GetSizePrefixedRoot<::GeomOp>(bytes.data())) {
}

GeomOp::GeomOp(const ::GeomOp *root) 
    : geoms_()
    , op_(Fn(0))
    , predicate_(Predicate(7)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &geoms_vector = root->geoms();
    if (geoms_vector != nullptr) {
        geoms_.reserve(geoms_vector->size());
        for (const auto &i: *geoms_vector) {
            geoms_.emplace_back(i);
        }
    }
    op_ = root->op();
    predicate_ = root->predicate();
}

::flatbuffers::Offset<::NodeQuery>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NodeQuery &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> descriptions_offset = std::nullopt;
    if (o.descriptions_.has_value()) {
        const auto &descriptions__var = o.descriptions_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> descriptions_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: descriptions__var) {
            descriptions_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> descriptions_offset_val = builder.CreateVector(descriptions_offsets);
        descriptions_offset = std::make_optional(descriptions_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.entity_tys_.value()))> entity_tys_offset = std::nullopt;
    if (o.entity_tys_.has_value()) {
        const decltype(builder.CreateVector(o.entity_tys_.value())) entity_tys_offset_val = builder.CreateVector(o.entity_tys_.value());
        entity_tys_offset = std::make_optional(entity_tys_offset_val);
    }
    std::optional<::flatbuffers::Offset<::GeomOp>> geom_op_offset = std::nullopt;
    if (o.geom_op_.has_value()) {
        const ::flatbuffers::Offset<::GeomOp> geom_op_offset_val = serialize_to(builder, o.geom_op_.value());
        geom_op_offset = std::make_optional(geom_op_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NodeIdPair>>>> node_ids_offset = std::nullopt;
    if (o.node_ids_.has_value()) {
        const auto &node_ids__var = o.node_ids_.value();
        std::vector<::flatbuffers::Offset<::NodeIdPair>> node_ids_offsets = std::vector<::flatbuffers::Offset<::NodeIdPair>>();
        node_ids_offsets.reserve(node_ids__var.size());
        for (const auto &i: node_ids__var) {
            node_ids_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NodeIdPair>>> node_ids_offset_val = builder.CreateVector(node_ids_offsets);
        node_ids_offset = std::make_optional(node_ids_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Projection>>>> projections_offset = std::nullopt;
    if (o.projections_.has_value()) {
        const auto &projections__var = o.projections_.value();
        std::vector<::flatbuffers::Offset<::Projection>> projections_offsets = std::vector<::flatbuffers::Offset<::Projection>>();
        projections_offsets.reserve(projections__var.size());
        for (const auto &i: projections__var) {
            projections_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Projection>>> projections_offset_val = builder.CreateVector(projections_offsets);
        projections_offset = std::make_optional(projections_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>>> stream_ids_offset = std::nullopt;
    if (o.stream_ids_.has_value()) {
        const auto &stream_ids__var = o.stream_ids_.value();
        std::vector<::flatbuffers::Offset<::ObjectId>> stream_ids_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
        stream_ids_offsets.reserve(stream_ids__var.size());
        for (const auto &i: stream_ids__var) {
            stream_ids_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> stream_ids_offset_val = builder.CreateVector(stream_ids_offsets);
        stream_ids_offset = std::make_optional(stream_ids_offset_val);
    }

    ::NodeQueryBuilder instance_builder = ::NodeQueryBuilder(builder);
    if (descriptions_offset.has_value()) {
        instance_builder.add_descriptions(descriptions_offset.value());
    }
    if (entity_tys_offset.has_value()) {
        instance_builder.add_entity_tys(entity_tys_offset.value());
    }
    if (geom_op_offset.has_value()) {
        instance_builder.add_geom_op(geom_op_offset.value());
    }
    if (node_ids_offset.has_value()) {
        instance_builder.add_node_ids(node_ids_offset.value());
    }
    if (projections_offset.has_value()) {
        instance_builder.add_projections(projections_offset.value());
    }
    if (stream_ids_offset.has_value()) {
        instance_builder.add_stream_ids(stream_ids_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NodeQuery &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NodeQuery::NodeQuery()
    : descriptions_(std::nullopt)
    , entity_tys_(std::nullopt)
    , geom_op_(std::nullopt)
    , node_ids_(std::nullopt)
    , projections_(std::nullopt)
    , stream_ids_(std::nullopt) {
}

NodeQuery::NodeQuery(const std::vector<uint8_t> &bytes)
    : NodeQuery(::flatbuffers::GetSizePrefixedRoot<::NodeQuery>(bytes.data())) {
}

NodeQuery::NodeQuery(const ::NodeQuery *root) 
    : descriptions_(std::nullopt)
    , entity_tys_(std::nullopt)
    , geom_op_(std::nullopt)
    , node_ids_(std::nullopt)
    , projections_(std::nullopt)
    , stream_ids_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &descriptions_vector = root->descriptions();
    if (descriptions_vector != nullptr) {
        std::vector<std::string> descriptions__target = std::vector<std::string>();
        for (const auto &i: *descriptions_vector) {
            descriptions__target.emplace_back(i->begin(), i->end());
        }
        descriptions_ = std::make_optional(descriptions__target);
    }
    const auto &entity_tys_vector = root->entity_tys();
    if (entity_tys_vector != nullptr) {
        decltype(entity_tys_)::value_type entity_tys__target = decltype(entity_tys_)::value_type();
        std::copy(entity_tys_vector->begin(), entity_tys_vector->end(), std::back_inserter(entity_tys__target));
        entity_tys_ = std::make_optional(entity_tys__target);
    }
    if (root->geom_op() != nullptr) {
        geom_op_ = decltype(geom_op_)(root->geom_op());
    }
    const auto &node_ids_vector = root->node_ids();
    if (node_ids_vector != nullptr) {
        decltype(node_ids_)::value_type node_ids__target = decltype(node_ids_)::value_type();
        node_ids__target.reserve(node_ids_vector->size());
        for (const auto &i: *node_ids_vector) {
            node_ids__target.emplace_back(i);
        }
        node_ids_ = std::make_optional(node_ids__target);
    }
    const auto &projections_vector = root->projections();
    if (projections_vector != nullptr) {
        decltype(projections_)::value_type projections__target = decltype(projections_)::value_type();
        projections__target.reserve(projections_vector->size());
        for (const auto &i: *projections_vector) {
            projections__target.emplace_back(i);
        }
        projections_ = std::make_optional(projections__target);
    }
    const auto &stream_ids_vector = root->stream_ids();
    if (stream_ids_vector != nullptr) {
        decltype(stream_ids_)::value_type stream_ids__target = decltype(stream_ids_)::value_type();
        stream_ids__target.reserve(stream_ids_vector->size());
        for (const auto &i: *stream_ids_vector) {
            stream_ids__target.emplace_back(i);
        }
        stream_ids_ = std::make_optional(stream_ids__target);
    }
}

::flatbuffers::Offset<::EdgeQuery>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const EdgeQuery &o) {

    ::EdgeQueryBuilder instance_builder = ::EdgeQueryBuilder(builder);
    instance_builder.add_edge_ty(o.edge_ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const EdgeQuery &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

EdgeQuery::EdgeQuery()
    : edge_ty_(EdgeTy(0)) {
}

EdgeQuery::EdgeQuery(const std::vector<uint8_t> &bytes)
    : EdgeQuery(::flatbuffers::GetSizePrefixedRoot<::EdgeQuery>(bytes.data())) {
}

EdgeQuery::EdgeQuery(const ::EdgeQuery *root) 
    : edge_ty_(EdgeTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    edge_ty_ = root->edge_ty();
}

::flatbuffers::Offset<::EdgeList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const EdgeList &o) {
    std::vector<::flatbuffers::Offset<::GraphEdge>> edges_offsets = std::vector<::flatbuffers::Offset<::GraphEdge>>();
    edges_offsets.reserve(o.edges_.size());
    for (const auto &i: o.edges_) {
        edges_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::GraphEdge>>> edges_offset = builder.CreateVector(edges_offsets);

    ::EdgeListBuilder instance_builder = ::EdgeListBuilder(builder);
    instance_builder.add_edges(edges_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const EdgeList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

EdgeList::EdgeList()
    : edges_() {
}

EdgeList::EdgeList(const std::vector<uint8_t> &bytes)
    : EdgeList(::flatbuffers::GetSizePrefixedRoot<::EdgeList>(bytes.data())) {
}

EdgeList::EdgeList(const ::EdgeList *root) 
    : edges_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &edges_vector = root->edges();
    if (edges_vector != nullptr) {
        edges_.reserve(edges_vector->size());
        for (const auto &i: *edges_vector) {
            edges_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::Geom>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Geom &o) {
    const std::pair<::flatbuffers::Offset<void>, ::Geometry> geom_offset = serialize_to(builder, o.geom_);

    ::GeomBuilder instance_builder = ::GeomBuilder(builder);
    instance_builder.add_geom(geom_offset.first);
    instance_builder.add_geom_type(geom_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Geom &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Geom::Geom()
    : geom_(std::make_shared<Point>()) {
}

Geom::Geom(const std::vector<uint8_t> &bytes)
    : Geom(::flatbuffers::GetSizePrefixedRoot<::Geom>(bytes.data())) {
}

Geom::Geom(const ::Geom *root) 
    : geom_(std::make_shared<Point>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->geom() != nullptr) {
        switch (root->geom_type()) {
            case ::Geometry::NONE: throw std::runtime_error("unexpected none variant");
            case ::Geometry::Point: {
                const auto geom__local = static_cast<const ::Point *>(root->geom());
                std::shared_ptr<Point> geom__shared = std::make_shared<Point>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::Line: {
                const auto geom__local = static_cast<const ::Line *>(root->geom());
                std::shared_ptr<Line> geom__shared = std::make_shared<Line>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::MultiLine: {
                const auto geom__local = static_cast<const ::MultiLine *>(root->geom());
                std::shared_ptr<MultiLine> geom__shared = std::make_shared<MultiLine>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::Polygon: {
                const auto geom__local = static_cast<const ::Polygon *>(root->geom());
                std::shared_ptr<Polygon> geom__shared = std::make_shared<Polygon>(geom__local);
                geom_ = geom__shared;
                break;
            }
            case ::Geometry::MultiPolygon: {
                const auto geom__local = static_cast<const ::MultiPolygon *>(root->geom());
                std::shared_ptr<MultiPolygon> geom__shared = std::make_shared<MultiPolygon>(geom__local);
                geom_ = geom__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::GraphQuery>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GraphQuery &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OrderBy>>>> order_by_offset = std::nullopt;
    if (o.order_by_.has_value()) {
        const auto &order_by__var = o.order_by_.value();
        std::vector<::flatbuffers::Offset<::OrderBy>> order_by_offsets = std::vector<::flatbuffers::Offset<::OrderBy>>();
        order_by_offsets.reserve(order_by__var.size());
        for (const auto &i: order_by__var) {
            order_by_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OrderBy>>> order_by_offset_val = builder.CreateVector(order_by_offsets);
        order_by_offset = std::make_optional(order_by_offset_val);
    }
    std::vector<::flatbuffers::Offset<::QueryPathElement>> path_offsets = std::vector<::flatbuffers::Offset<::QueryPathElement>>();
    path_offsets.reserve(o.path_.size());
    for (const auto &i: o.path_) {
        path_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::QueryPathElement>>> path_offset = builder.CreateVector(path_offsets);

    ::GraphQueryBuilder instance_builder = ::GraphQueryBuilder(builder);
    instance_builder.add_limit(o.limit_);
    if (order_by_offset.has_value()) {
        instance_builder.add_order_by(order_by_offset.value());
    }
    instance_builder.add_path(path_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const GraphQuery &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

GraphQuery::GraphQuery()
    : limit_(0)
    , order_by_(std::nullopt)
    , path_() {
}

GraphQuery::GraphQuery(const std::vector<uint8_t> &bytes)
    : GraphQuery(::flatbuffers::GetSizePrefixedRoot<::GraphQuery>(bytes.data())) {
}

GraphQuery::GraphQuery(const ::GraphQuery *root) 
    : limit_(0)
    , order_by_(std::nullopt)
    , path_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    limit_ = root->limit();
    const auto &order_by_vector = root->order_by();
    if (order_by_vector != nullptr) {
        decltype(order_by_)::value_type order_by__target = decltype(order_by_)::value_type();
        order_by__target.reserve(order_by_vector->size());
        for (const auto &i: *order_by_vector) {
            order_by__target.emplace_back(i);
        }
        order_by_ = std::make_optional(order_by__target);
    }
    const auto &path_vector = root->path();
    if (path_vector != nullptr) {
        path_.reserve(path_vector->size());
        for (const auto &i: *path_vector) {
            path_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::NodeIdPair>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NodeIdPair &o) {
    const ::flatbuffers::Offset<::GraphNodeId> node_id_offset = serialize_to(builder, o.node_id_);
    std::optional<::flatbuffers::Offset<::ObjectId>> stream_id_offset = std::nullopt;
    if (o.stream_id_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> stream_id_offset_val = serialize_to(builder, o.stream_id_.value());
        stream_id_offset = std::make_optional(stream_id_offset_val);
    }

    ::NodeIdPairBuilder instance_builder = ::NodeIdPairBuilder(builder);
    instance_builder.add_node_id(node_id_offset);
    if (stream_id_offset.has_value()) {
        instance_builder.add_stream_id(stream_id_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NodeIdPair &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NodeIdPair::NodeIdPair()
    : node_id_()
    , stream_id_(std::nullopt) {
}

NodeIdPair::NodeIdPair(const std::vector<uint8_t> &bytes)
    : NodeIdPair(::flatbuffers::GetSizePrefixedRoot<::NodeIdPair>(bytes.data())) {
}

NodeIdPair::NodeIdPair(const ::NodeIdPair *root) 
    : node_id_()
    , stream_id_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->node_id() != nullptr) {
        node_id_ = decltype(node_id_)(root->node_id());
    }
    if (root->stream_id() != nullptr) {
        stream_id_ = decltype(stream_id_)(root->stream_id());
    }
}

::flatbuffers::Offset<::NodeList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NodeList &o) {
    std::vector<::flatbuffers::Offset<::GraphNode>> nodes_offsets = std::vector<::flatbuffers::Offset<::GraphNode>>();
    nodes_offsets.reserve(o.nodes_.size());
    for (const auto &i: o.nodes_) {
        nodes_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::GraphNode>>> nodes_offset = builder.CreateVector(nodes_offsets);

    ::NodeListBuilder instance_builder = ::NodeListBuilder(builder);
    instance_builder.add_nodes(nodes_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NodeList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NodeList::NodeList()
    : nodes_() {
}

NodeList::NodeList(const std::vector<uint8_t> &bytes)
    : NodeList(::flatbuffers::GetSizePrefixedRoot<::NodeList>(bytes.data())) {
}

NodeList::NodeList(const ::NodeList *root) 
    : nodes_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &nodes_vector = root->nodes();
    if (nodes_vector != nullptr) {
        nodes_.reserve(nodes_vector->size());
        for (const auto &i: *nodes_vector) {
            nodes_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::OrderBy>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const OrderBy &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> field_offset = builder.CreateString(o.field_);

    ::OrderByBuilder instance_builder = ::OrderByBuilder(builder);
    instance_builder.add_field(field_offset);
    instance_builder.add_sort(o.sort_);
    instance_builder.add_transform(o.transform_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const OrderBy &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

OrderBy::OrderBy()
    : field_()
    , sort_(SortOrder(0))
    , transform_(ValueTransform(0)) {
}

OrderBy::OrderBy(const std::vector<uint8_t> &bytes)
    : OrderBy(::flatbuffers::GetSizePrefixedRoot<::OrderBy>(bytes.data())) {
}

OrderBy::OrderBy(const ::OrderBy *root) 
    : field_()
    , sort_(SortOrder(0))
    , transform_(ValueTransform(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        field_ = std::string(*root->field()->begin(), *root->field()->end());
    sort_ = root->sort();
    transform_ = root->transform();
}

::flatbuffers::Offset<::Projection>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Projection &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> alias_offset = builder.CreateString(o.alias_);

    ::ProjectionBuilder instance_builder = ::ProjectionBuilder(builder);
    instance_builder.add_alias(alias_offset);
    instance_builder.add_predicate(o.predicate_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Projection &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Projection::Projection()
    : alias_()
    , predicate_(Predicate(0)) {
}

Projection::Projection(const std::vector<uint8_t> &bytes)
    : Projection(::flatbuffers::GetSizePrefixedRoot<::Projection>(bytes.data())) {
}

Projection::Projection(const ::Projection *root) 
    : alias_()
    , predicate_(Predicate(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        alias_ = std::string(*root->alias()->begin(), *root->alias()->end());
    predicate_ = root->predicate();
}

::flatbuffers::Offset<::QueryPathElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryPathElement &o) {
    const std::pair<::flatbuffers::Offset<void>, ::QueryPathElementUnion> element_offset = serialize_to(builder, o.element_);

    ::QueryPathElementBuilder instance_builder = ::QueryPathElementBuilder(builder);
    instance_builder.add_element(element_offset.first);
    instance_builder.add_element_type(element_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const QueryPathElement &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

QueryPathElement::QueryPathElement()
    : element_(std::make_shared<NodeQuery>()) {
}

QueryPathElement::QueryPathElement(const std::vector<uint8_t> &bytes)
    : QueryPathElement(::flatbuffers::GetSizePrefixedRoot<::QueryPathElement>(bytes.data())) {
}

QueryPathElement::QueryPathElement(const ::QueryPathElement *root) 
    : element_(std::make_shared<NodeQuery>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->element() != nullptr) {
        switch (root->element_type()) {
            case ::QueryPathElementUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::QueryPathElementUnion::NodeQuery: {
                const auto element__local = static_cast<const ::NodeQuery *>(root->element());
                std::shared_ptr<NodeQuery> element__shared = std::make_shared<NodeQuery>(element__local);
                element_ = element__shared;
                break;
            }
            case ::QueryPathElementUnion::EdgeQuery: {
                const auto element__local = static_cast<const ::EdgeQuery *>(root->element());
                std::shared_ptr<EdgeQuery> element__shared = std::make_shared<EdgeQuery>(element__local);
                element_ = element__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

} // namespace types
} // namespace ul
