// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/query.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::ExprUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ExprUnion &o) {
    if (std::holds_alternative<std::shared_ptr<ValueIndex>>(o)) {
        const std::shared_ptr<ValueIndex> &v = std::get<std::shared_ptr<ValueIndex>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::ValueIndex);
    } else if (std::holds_alternative<std::shared_ptr<Column>>(o)) {
        const std::shared_ptr<Column> &v = std::get<std::shared_ptr<Column>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::Column);
    } else if (std::holds_alternative<std::shared_ptr<Function>>(o)) {
        const std::shared_ptr<Function> &v = std::get<std::shared_ptr<Function>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::Function);
    } else if (std::holds_alternative<std::shared_ptr<AllColumns>>(o)) {
        const std::shared_ptr<AllColumns> &v = std::get<std::shared_ptr<AllColumns>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::AllColumns);
    } else if (std::holds_alternative<std::shared_ptr<Case>>(o)) {
        const std::shared_ptr<Case> &v = std::get<std::shared_ptr<Case>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::Case);
    } else if (std::holds_alternative<std::shared_ptr<OrderByExpr>>(o)) {
        const std::shared_ptr<OrderByExpr> &v = std::get<std::shared_ptr<OrderByExpr>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::OrderByExpr);
    } else if (std::holds_alternative<std::shared_ptr<Partition>>(o)) {
        const std::shared_ptr<Partition> &v = std::get<std::shared_ptr<Partition>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::Partition);
    } else if (std::holds_alternative<std::shared_ptr<UnsetArgument>>(o)) {
        const std::shared_ptr<UnsetArgument> &v = std::get<std::shared_ptr<UnsetArgument>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::UnsetArgument);
    } else if (std::holds_alternative<std::shared_ptr<Window>>(o)) {
        const std::shared_ptr<Window> &v = std::get<std::shared_ptr<Window>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ExprUnion::Window);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::ParameterSlot>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterSlot &o) {
    if (std::holds_alternative<std::shared_ptr<Parameter>>(o)) {
        const std::shared_ptr<Parameter> &v = std::get<std::shared_ptr<Parameter>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ParameterSlot::Parameter);
    } else if (std::holds_alternative<std::shared_ptr<ValueInstance>>(o)) {
        const std::shared_ptr<ValueInstance> &v = std::get<std::shared_ptr<ValueInstance>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ParameterSlot::ValueInstance);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::QueryElementUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryElementUnion &o) {
    if (std::holds_alternative<std::shared_ptr<UnaryQueryElement>>(o)) {
        const std::shared_ptr<UnaryQueryElement> &v = std::get<std::shared_ptr<UnaryQueryElement>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::QueryElementUnion::UnaryQueryElement);
    } else if (std::holds_alternative<std::shared_ptr<BinaryQueryElement>>(o)) {
        const std::shared_ptr<BinaryQueryElement> &v = std::get<std::shared_ptr<BinaryQueryElement>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::QueryElementUnion::BinaryQueryElement);
    } else if (std::holds_alternative<std::shared_ptr<UpdateQueryElement>>(o)) {
        const std::shared_ptr<UpdateQueryElement> &v = std::get<std::shared_ptr<UpdateQueryElement>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::QueryElementUnion::UpdateQueryElement);
    } else if (std::holds_alternative<std::shared_ptr<DeleteQueryElement>>(o)) {
        const std::shared_ptr<DeleteQueryElement> &v = std::get<std::shared_ptr<DeleteQueryElement>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::QueryElementUnion::DeleteQueryElement);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::Subcollection>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Subcollection &o) {
    if (std::holds_alternative<std::shared_ptr<MvdbSubcollection>>(o)) {
        const std::shared_ptr<MvdbSubcollection> &v = std::get<std::shared_ptr<MvdbSubcollection>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Subcollection::MvdbSubcollection);
    } else if (std::holds_alternative<std::shared_ptr<WorklogSubcollection>>(o)) {
        const std::shared_ptr<WorklogSubcollection> &v = std::get<std::shared_ptr<WorklogSubcollection>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Subcollection::WorklogSubcollection);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::TableSourceUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TableSourceUnion &o) {
    if (std::holds_alternative<std::shared_ptr<DataCatalog>>(o)) {
        const std::shared_ptr<DataCatalog> &v = std::get<std::shared_ptr<DataCatalog>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TableSourceUnion::DataCatalog);
    } else if (std::holds_alternative<std::shared_ptr<Arrow>>(o)) {
        const std::shared_ptr<Arrow> &v = std::get<std::shared_ptr<Arrow>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TableSourceUnion::Arrow);
    } else if (std::holds_alternative<std::shared_ptr<GraphQuery>>(o)) {
        const std::shared_ptr<GraphQuery> &v = std::get<std::shared_ptr<GraphQuery>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TableSourceUnion::GraphQuery);
    } else if (std::holds_alternative<std::shared_ptr<QueryTableSource>>(o)) {
        const std::shared_ptr<QueryTableSource> &v = std::get<std::shared_ptr<QueryTableSource>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TableSourceUnion::QueryTableSource);
    } else if (std::holds_alternative<std::shared_ptr<Vector>>(o)) {
        const std::shared_ptr<Vector> &v = std::get<std::shared_ptr<Vector>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TableSourceUnion::Vector);
    } else if (std::holds_alternative<std::shared_ptr<RecordBatchPlaceholder>>(o)) {
        const std::shared_ptr<RecordBatchPlaceholder> &v = std::get<std::shared_ptr<RecordBatchPlaceholder>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::TableSourceUnion::RecordBatchPlaceholder);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::ValueIndex>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ValueIndex &o) {

    ::ValueIndexBuilder instance_builder = ::ValueIndexBuilder(builder);
    instance_builder.add_idx(o.idx_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ValueIndex &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ValueIndex::ValueIndex()
    : idx_(0) {
}

ValueIndex::ValueIndex(const std::vector<uint8_t> &bytes)
    : ValueIndex(::flatbuffers::GetSizePrefixedRoot<::ValueIndex>(bytes.data())) {
}

ValueIndex::ValueIndex(const ::ValueIndex *root) 
    : idx_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    idx_ = root->idx();
}

::flatbuffers::Offset<::NullableUint>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NullableUint &o) {

    ::NullableUintBuilder instance_builder = ::NullableUintBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NullableUint &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NullableUint::NullableUint()
    : v_(0) {
}

NullableUint::NullableUint(const std::vector<uint8_t> &bytes)
    : NullableUint(::flatbuffers::GetSizePrefixedRoot<::NullableUint>(bytes.data())) {
}

NullableUint::NullableUint(const ::NullableUint *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::Column>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Column &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    std::optional<::flatbuffers::Offset<::NullableUint>> source_offset = std::nullopt;
    if (o.source_.has_value()) {
        const ::flatbuffers::Offset<::NullableUint> source_offset_val = serialize_to(builder, o.source_.value());
        source_offset = std::make_optional(source_offset_val);
    }

    ::ColumnBuilder instance_builder = ::ColumnBuilder(builder);
    instance_builder.add_name(name_offset);
    if (source_offset.has_value()) {
        instance_builder.add_source(source_offset.value());
    }
    instance_builder.add_type_hint(o.type_hint_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Column &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Column::Column()
    : name_()
    , source_(std::nullopt)
    , type_hint_(TypeHint(0)) {
}

Column::Column(const std::vector<uint8_t> &bytes)
    : Column(::flatbuffers::GetSizePrefixedRoot<::Column>(bytes.data())) {
}

Column::Column(const ::Column *root) 
    : name_()
    , source_(std::nullopt)
    , type_hint_(TypeHint(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->source() != nullptr) {
        source_ = decltype(source_)(root->source());
    }
    type_hint_ = root->type_hint();
}

::flatbuffers::Offset<::Function>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Function &o) {
    std::vector<::flatbuffers::Offset<::Expr>> parameters_offsets = std::vector<::flatbuffers::Offset<::Expr>>();
    parameters_offsets.reserve(o.parameters_.size());
    for (const auto &i: o.parameters_) {
        parameters_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>> parameters_offset = builder.CreateVector(parameters_offsets);

    ::FunctionBuilder instance_builder = ::FunctionBuilder(builder);
    instance_builder.add_fn(o.fn_);
    instance_builder.add_parameters(parameters_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Function &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Function::Function()
    : fn_(Fn(0))
    , parameters_() {
}

Function::Function(const std::vector<uint8_t> &bytes)
    : Function(::flatbuffers::GetSizePrefixedRoot<::Function>(bytes.data())) {
}

Function::Function(const ::Function *root) 
    : fn_(Fn(0))
    , parameters_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    fn_ = root->fn();
    const auto &parameters_vector = root->parameters();
    if (parameters_vector != nullptr) {
        parameters_.reserve(parameters_vector->size());
        for (const auto &i: *parameters_vector) {
            parameters_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::AllColumns>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const AllColumns &o) {
    std::optional<::flatbuffers::Offset<::NullableUint>> source_offset = std::nullopt;
    if (o.source_.has_value()) {
        const ::flatbuffers::Offset<::NullableUint> source_offset_val = serialize_to(builder, o.source_.value());
        source_offset = std::make_optional(source_offset_val);
    }

    ::AllColumnsBuilder instance_builder = ::AllColumnsBuilder(builder);
    if (source_offset.has_value()) {
        instance_builder.add_source(source_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const AllColumns &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

AllColumns::AllColumns()
    : source_(std::nullopt) {
}

AllColumns::AllColumns(const std::vector<uint8_t> &bytes)
    : AllColumns(::flatbuffers::GetSizePrefixedRoot<::AllColumns>(bytes.data())) {
}

AllColumns::AllColumns(const ::AllColumns *root) 
    : source_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->source() != nullptr) {
        source_ = decltype(source_)(root->source());
    }
}

::flatbuffers::Offset<::Expr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Expr &o) {
    const std::pair<::flatbuffers::Offset<void>, ::ExprUnion> exprs_offset = serialize_to(builder, o.exprs_);

    ::ExprBuilder instance_builder = ::ExprBuilder(builder);
    instance_builder.add_exprs(exprs_offset.first);
    instance_builder.add_exprs_type(exprs_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Expr &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Expr::Expr()
    : exprs_(std::make_shared<ValueIndex>()) {
}

Expr::Expr(const std::vector<uint8_t> &bytes)
    : Expr(::flatbuffers::GetSizePrefixedRoot<::Expr>(bytes.data())) {
}

Expr::Expr(const ::Expr *root) 
    : exprs_(std::make_shared<ValueIndex>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->exprs() != nullptr) {
        switch (root->exprs_type()) {
            case ::ExprUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::ExprUnion::ValueIndex: {
                const auto exprs__local = static_cast<const ::ValueIndex *>(root->exprs());
                std::shared_ptr<ValueIndex> exprs__shared = std::make_shared<ValueIndex>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::Column: {
                const auto exprs__local = static_cast<const ::Column *>(root->exprs());
                std::shared_ptr<Column> exprs__shared = std::make_shared<Column>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::Function: {
                const auto exprs__local = static_cast<const ::Function *>(root->exprs());
                std::shared_ptr<Function> exprs__shared = std::make_shared<Function>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::AllColumns: {
                const auto exprs__local = static_cast<const ::AllColumns *>(root->exprs());
                std::shared_ptr<AllColumns> exprs__shared = std::make_shared<AllColumns>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::Case: {
                const auto exprs__local = static_cast<const ::Case *>(root->exprs());
                std::shared_ptr<Case> exprs__shared = std::make_shared<Case>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::OrderByExpr: {
                const auto exprs__local = static_cast<const ::OrderByExpr *>(root->exprs());
                std::shared_ptr<OrderByExpr> exprs__shared = std::make_shared<OrderByExpr>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::Partition: {
                const auto exprs__local = static_cast<const ::Partition *>(root->exprs());
                std::shared_ptr<Partition> exprs__shared = std::make_shared<Partition>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::UnsetArgument: {
                const auto exprs__local = static_cast<const ::UnsetArgument *>(root->exprs());
                std::shared_ptr<UnsetArgument> exprs__shared = std::make_shared<UnsetArgument>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            case ::ExprUnion::Window: {
                const auto exprs__local = static_cast<const ::Window *>(root->exprs());
                std::shared_ptr<Window> exprs__shared = std::make_shared<Window>(exprs__local);
                exprs_ = exprs__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::Case>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Case &o) {
    std::optional<::flatbuffers::Offset<::Expr>> else__offset = std::nullopt;
    if (o.else_.has_value()) {
        const ::flatbuffers::Offset<::Expr> else__offset_val = serialize_to(builder, o.else_.value());
        else__offset = std::make_optional(else__offset_val);
    }
    std::vector<::flatbuffers::Offset<::When>> when_offsets = std::vector<::flatbuffers::Offset<::When>>();
    when_offsets.reserve(o.when_.size());
    for (const auto &i: o.when_) {
        when_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::When>>> when_offset = builder.CreateVector(when_offsets);

    ::CaseBuilder instance_builder = ::CaseBuilder(builder);
    if (else__offset.has_value()) {
        instance_builder.add_else_(else__offset.value());
    }
    instance_builder.add_when(when_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Case &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Case::Case()
    : else_(std::nullopt)
    , when_() {
}

Case::Case(const std::vector<uint8_t> &bytes)
    : Case(::flatbuffers::GetSizePrefixedRoot<::Case>(bytes.data())) {
}

Case::Case(const ::Case *root) 
    : else_(std::nullopt)
    , when_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->else_() != nullptr) {
        else_ = decltype(else_)(root->else_());
    }
    const auto &when_vector = root->when();
    if (when_vector != nullptr) {
        when_.reserve(when_vector->size());
        for (const auto &i: *when_vector) {
            when_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::OrderByExpr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const OrderByExpr &o) {
    std::vector<::flatbuffers::Offset<::OrderBy>> order_by_offsets = std::vector<::flatbuffers::Offset<::OrderBy>>();
    order_by_offsets.reserve(o.order_by_.size());
    for (const auto &i: o.order_by_) {
        order_by_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OrderBy>>> order_by_offset = builder.CreateVector(order_by_offsets);

    ::OrderByExprBuilder instance_builder = ::OrderByExprBuilder(builder);
    instance_builder.add_order_by(order_by_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const OrderByExpr &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

OrderByExpr::OrderByExpr()
    : order_by_() {
}

OrderByExpr::OrderByExpr(const std::vector<uint8_t> &bytes)
    : OrderByExpr(::flatbuffers::GetSizePrefixedRoot<::OrderByExpr>(bytes.data())) {
}

OrderByExpr::OrderByExpr(const ::OrderByExpr *root) 
    : order_by_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &order_by_vector = root->order_by();
    if (order_by_vector != nullptr) {
        order_by_.reserve(order_by_vector->size());
        for (const auto &i: *order_by_vector) {
            order_by_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::Partition>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Partition &o) {
    const ::flatbuffers::Offset<::Expr> expr_offset = serialize_to(builder, o.expr_);

    ::PartitionBuilder instance_builder = ::PartitionBuilder(builder);
    instance_builder.add_expr(expr_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Partition &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Partition::Partition()
    : expr_() {
}

Partition::Partition(const std::vector<uint8_t> &bytes)
    : Partition(::flatbuffers::GetSizePrefixedRoot<::Partition>(bytes.data())) {
}

Partition::Partition(const ::Partition *root) 
    : expr_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->expr() != nullptr) {
        expr_ = decltype(expr_)(root->expr());
    }
}

::flatbuffers::Offset<::UnsetArgument>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UnsetArgument &) {

    ::UnsetArgumentBuilder instance_builder = ::UnsetArgumentBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UnsetArgument &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UnsetArgument::UnsetArgument() {
}

UnsetArgument::UnsetArgument(const std::vector<uint8_t> &bytes)
    : UnsetArgument(::flatbuffers::GetSizePrefixedRoot<::UnsetArgument>(bytes.data())) {
}

UnsetArgument::UnsetArgument(const ::UnsetArgument *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::Window>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Window &o) {
    const ::flatbuffers::Offset<::Function> fun_offset = serialize_to(builder, o.fun_);
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OrderBy>>>> order_by_offset = std::nullopt;
    if (o.order_by_.has_value()) {
        const auto &order_by__var = o.order_by_.value();
        std::vector<::flatbuffers::Offset<::OrderBy>> order_by_offsets = std::vector<::flatbuffers::Offset<::OrderBy>>();
        order_by_offsets.reserve(order_by__var.size());
        for (const auto &i: order_by__var) {
            order_by_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OrderBy>>> order_by_offset_val = builder.CreateVector(order_by_offsets);
        order_by_offset = std::make_optional(order_by_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>>> partition_offset = std::nullopt;
    if (o.partition_.has_value()) {
        const auto &partition__var = o.partition_.value();
        std::vector<::flatbuffers::Offset<::Expr>> partition_offsets = std::vector<::flatbuffers::Offset<::Expr>>();
        partition_offsets.reserve(partition__var.size());
        for (const auto &i: partition__var) {
            partition_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>> partition_offset_val = builder.CreateVector(partition_offsets);
        partition_offset = std::make_optional(partition_offset_val);
    }

    ::WindowBuilder instance_builder = ::WindowBuilder(builder);
    instance_builder.add_fun(fun_offset);
    if (order_by_offset.has_value()) {
        instance_builder.add_order_by(order_by_offset.value());
    }
    if (partition_offset.has_value()) {
        instance_builder.add_partition(partition_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Window &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Window::Window()
    : fun_()
    , order_by_(std::nullopt)
    , partition_(std::nullopt) {
}

Window::Window(const std::vector<uint8_t> &bytes)
    : Window(::flatbuffers::GetSizePrefixedRoot<::Window>(bytes.data())) {
}

Window::Window(const ::Window *root) 
    : fun_()
    , order_by_(std::nullopt)
    , partition_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->fun() != nullptr) {
        fun_ = decltype(fun_)(root->fun());
    }
    const auto &order_by_vector = root->order_by();
    if (order_by_vector != nullptr) {
        decltype(order_by_)::value_type order_by__target = decltype(order_by_)::value_type();
        order_by__target.reserve(order_by_vector->size());
        for (const auto &i: *order_by_vector) {
            order_by__target.emplace_back(i);
        }
        order_by_ = std::make_optional(order_by__target);
    }
    const auto &partition_vector = root->partition();
    if (partition_vector != nullptr) {
        decltype(partition_)::value_type partition__target = decltype(partition_)::value_type();
        partition__target.reserve(partition_vector->size());
        for (const auto &i: *partition_vector) {
            partition__target.emplace_back(i);
        }
        partition_ = std::make_optional(partition__target);
    }
}

::flatbuffers::Offset<::Parameter>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Parameter &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);

    ::ParameterBuilder instance_builder = ::ParameterBuilder(builder);
    instance_builder.add_hint(o.hint_);
    instance_builder.add_name(name_offset);
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Parameter &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Parameter::Parameter()
    : hint_(TypeHint(0))
    , name_()
    , ty_(ValueTy(0)) {
}

Parameter::Parameter(const std::vector<uint8_t> &bytes)
    : Parameter(::flatbuffers::GetSizePrefixedRoot<::Parameter>(bytes.data())) {
}

Parameter::Parameter(const ::Parameter *root) 
    : hint_(TypeHint(0))
    , name_()
    , ty_(ValueTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    hint_ = root->hint();
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    ty_ = root->ty();
}

::flatbuffers::Offset<::Distinct>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Distinct &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>>> on_offset = std::nullopt;
    if (o.on_.has_value()) {
        const auto &on__var = o.on_.value();
        std::vector<::flatbuffers::Offset<::Expr>> on_offsets = std::vector<::flatbuffers::Offset<::Expr>>();
        on_offsets.reserve(on__var.size());
        for (const auto &i: on__var) {
            on_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>> on_offset_val = builder.CreateVector(on_offsets);
        on_offset = std::make_optional(on_offset_val);
    }

    ::DistinctBuilder instance_builder = ::DistinctBuilder(builder);
    if (on_offset.has_value()) {
        instance_builder.add_on(on_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Distinct &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Distinct::Distinct()
    : on_(std::nullopt) {
}

Distinct::Distinct(const std::vector<uint8_t> &bytes)
    : Distinct(::flatbuffers::GetSizePrefixedRoot<::Distinct>(bytes.data())) {
}

Distinct::Distinct(const ::Distinct *root) 
    : on_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &on_vector = root->on();
    if (on_vector != nullptr) {
        decltype(on_)::value_type on__target = decltype(on_)::value_type();
        on__target.reserve(on_vector->size());
        for (const auto &i: *on_vector) {
            on__target.emplace_back(i);
        }
        on_ = std::make_optional(on__target);
    }
}

::flatbuffers::Offset<::UnaryQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UnaryQueryElement &o) {
    std::optional<::flatbuffers::Offset<::Distinct>> distinct_offset = std::nullopt;
    if (o.distinct_.has_value()) {
        const ::flatbuffers::Offset<::Distinct> distinct_offset_val = serialize_to(builder, o.distinct_.value());
        distinct_offset = std::make_optional(distinct_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>>> fields_offset = std::nullopt;
    if (o.fields_.has_value()) {
        const auto &fields__var = o.fields_.value();
        std::vector<::flatbuffers::Offset<::Expr>> fields_offsets = std::vector<::flatbuffers::Offset<::Expr>>();
        fields_offsets.reserve(fields__var.size());
        for (const auto &i: fields__var) {
            fields_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>> fields_offset_val = builder.CreateVector(fields_offsets);
        fields_offset = std::make_optional(fields_offset_val);
    }
    std::optional<::flatbuffers::Offset<::Function>> filter_offset = std::nullopt;
    if (o.filter_.has_value()) {
        const ::flatbuffers::Offset<::Function> filter_offset_val = serialize_to(builder, o.filter_.value());
        filter_offset = std::make_optional(filter_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>>> group_by_offset = std::nullopt;
    if (o.group_by_.has_value()) {
        const auto &group_by__var = o.group_by_.value();
        std::vector<::flatbuffers::Offset<::Expr>> group_by_offsets = std::vector<::flatbuffers::Offset<::Expr>>();
        group_by_offsets.reserve(group_by__var.size());
        for (const auto &i: group_by__var) {
            group_by_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>> group_by_offset_val = builder.CreateVector(group_by_offsets);
        group_by_offset = std::make_optional(group_by_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Join>>>> joins_offset = std::nullopt;
    if (o.joins_.has_value()) {
        const auto &joins__var = o.joins_.value();
        std::vector<::flatbuffers::Offset<::Join>> joins_offsets = std::vector<::flatbuffers::Offset<::Join>>();
        joins_offsets.reserve(joins__var.size());
        for (const auto &i: joins__var) {
            joins_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Join>>> joins_offset_val = builder.CreateVector(joins_offsets);
        joins_offset = std::make_optional(joins_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TableOrderBy>>>> order_by_offset = std::nullopt;
    if (o.order_by_.has_value()) {
        const auto &order_by__var = o.order_by_.value();
        std::vector<::flatbuffers::Offset<::TableOrderBy>> order_by_offsets = std::vector<::flatbuffers::Offset<::TableOrderBy>>();
        order_by_offsets.reserve(order_by__var.size());
        for (const auto &i: order_by__var) {
            order_by_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TableOrderBy>>> order_by_offset_val = builder.CreateVector(order_by_offsets);
        order_by_offset = std::make_optional(order_by_offset_val);
    }
    std::vector<::flatbuffers::Offset<::TableSource>> sources_offsets = std::vector<::flatbuffers::Offset<::TableSource>>();
    sources_offsets.reserve(o.sources_.size());
    for (const auto &i: o.sources_) {
        sources_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TableSource>>> sources_offset = builder.CreateVector(sources_offsets);

    ::UnaryQueryElementBuilder instance_builder = ::UnaryQueryElementBuilder(builder);
    if (distinct_offset.has_value()) {
        instance_builder.add_distinct(distinct_offset.value());
    }
    if (fields_offset.has_value()) {
        instance_builder.add_fields(fields_offset.value());
    }
    if (filter_offset.has_value()) {
        instance_builder.add_filter(filter_offset.value());
    }
    if (group_by_offset.has_value()) {
        instance_builder.add_group_by(group_by_offset.value());
    }
    if (joins_offset.has_value()) {
        instance_builder.add_joins(joins_offset.value());
    }
    instance_builder.add_limit(o.limit_);
    if (order_by_offset.has_value()) {
        instance_builder.add_order_by(order_by_offset.value());
    }
    instance_builder.add_sources(sources_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UnaryQueryElement &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UnaryQueryElement::UnaryQueryElement()
    : distinct_(std::nullopt)
    , fields_(std::nullopt)
    , filter_(std::nullopt)
    , group_by_(std::nullopt)
    , joins_(std::nullopt)
    , limit_(0)
    , order_by_(std::nullopt)
    , sources_() {
}

UnaryQueryElement::UnaryQueryElement(const std::vector<uint8_t> &bytes)
    : UnaryQueryElement(::flatbuffers::GetSizePrefixedRoot<::UnaryQueryElement>(bytes.data())) {
}

UnaryQueryElement::UnaryQueryElement(const ::UnaryQueryElement *root) 
    : distinct_(std::nullopt)
    , fields_(std::nullopt)
    , filter_(std::nullopt)
    , group_by_(std::nullopt)
    , joins_(std::nullopt)
    , limit_(0)
    , order_by_(std::nullopt)
    , sources_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->distinct() != nullptr) {
        distinct_ = decltype(distinct_)(root->distinct());
    }
    const auto &fields_vector = root->fields();
    if (fields_vector != nullptr) {
        decltype(fields_)::value_type fields__target = decltype(fields_)::value_type();
        fields__target.reserve(fields_vector->size());
        for (const auto &i: *fields_vector) {
            fields__target.emplace_back(i);
        }
        fields_ = std::make_optional(fields__target);
    }
    if (root->filter() != nullptr) {
        filter_ = decltype(filter_)(root->filter());
    }
    const auto &group_by_vector = root->group_by();
    if (group_by_vector != nullptr) {
        decltype(group_by_)::value_type group_by__target = decltype(group_by_)::value_type();
        group_by__target.reserve(group_by_vector->size());
        for (const auto &i: *group_by_vector) {
            group_by__target.emplace_back(i);
        }
        group_by_ = std::make_optional(group_by__target);
    }
    const auto &joins_vector = root->joins();
    if (joins_vector != nullptr) {
        decltype(joins_)::value_type joins__target = decltype(joins_)::value_type();
        joins__target.reserve(joins_vector->size());
        for (const auto &i: *joins_vector) {
            joins__target.emplace_back(i);
        }
        joins_ = std::make_optional(joins__target);
    }
    limit_ = root->limit();
    const auto &order_by_vector = root->order_by();
    if (order_by_vector != nullptr) {
        decltype(order_by_)::value_type order_by__target = decltype(order_by_)::value_type();
        order_by__target.reserve(order_by_vector->size());
        for (const auto &i: *order_by_vector) {
            order_by__target.emplace_back(i);
        }
        order_by_ = std::make_optional(order_by__target);
    }
    const auto &sources_vector = root->sources();
    if (sources_vector != nullptr) {
        sources_.reserve(sources_vector->size());
        for (const auto &i: *sources_vector) {
            sources_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::QueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryElement &o) {
    std::optional<std::pair<::flatbuffers::Offset<void>, ::QueryElementUnion>> q_offset = std::nullopt;
    if (o.q_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::QueryElementUnion> q_offset_val = serialize_to(builder, o.q_.value());
        q_offset = std::make_optional(q_offset_val);
    }

    ::QueryElementBuilder instance_builder = ::QueryElementBuilder(builder);
    if (q_offset.has_value()) {
        const auto q_opt = q_offset.value();
        instance_builder.add_q(q_opt.first);
        instance_builder.add_q_type(q_opt.second);
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const QueryElement &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

QueryElement::QueryElement()
    : q_(std::nullopt) {
}

QueryElement::QueryElement(const std::vector<uint8_t> &bytes)
    : QueryElement(::flatbuffers::GetSizePrefixedRoot<::QueryElement>(bytes.data())) {
}

QueryElement::QueryElement(const ::QueryElement *root) 
    : q_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->q() != nullptr) {
        switch (root->q_type()) {
            case ::QueryElementUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::QueryElementUnion::UnaryQueryElement: {
                const auto q__local = static_cast<const ::UnaryQueryElement *>(root->q());
                std::shared_ptr<UnaryQueryElement> q__shared = std::make_shared<UnaryQueryElement>(q__local);
                q_ = q__shared;
                break;
            }
            case ::QueryElementUnion::BinaryQueryElement: {
                const auto q__local = static_cast<const ::BinaryQueryElement *>(root->q());
                std::shared_ptr<BinaryQueryElement> q__shared = std::make_shared<BinaryQueryElement>(q__local);
                q_ = q__shared;
                break;
            }
            case ::QueryElementUnion::UpdateQueryElement: {
                const auto q__local = static_cast<const ::UpdateQueryElement *>(root->q());
                std::shared_ptr<UpdateQueryElement> q__shared = std::make_shared<UpdateQueryElement>(q__local);
                q_ = q__shared;
                break;
            }
            case ::QueryElementUnion::DeleteQueryElement: {
                const auto q__local = static_cast<const ::DeleteQueryElement *>(root->q());
                std::shared_ptr<DeleteQueryElement> q__shared = std::make_shared<DeleteQueryElement>(q__local);
                q_ = q__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::BinaryQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const BinaryQueryElement &o) {
    const ::flatbuffers::Offset<::QueryElement> lhs_offset = serialize_to(builder, o.lhs_);
    const ::flatbuffers::Offset<::QueryElement> rhs_offset = serialize_to(builder, o.rhs_);

    ::BinaryQueryElementBuilder instance_builder = ::BinaryQueryElementBuilder(builder);
    instance_builder.add_lhs(lhs_offset);
    instance_builder.add_op(o.op_);
    instance_builder.add_rhs(rhs_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const BinaryQueryElement &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

BinaryQueryElement::BinaryQueryElement()
    : lhs_()
    , op_(QueryElementOp(0))
    , rhs_() {
}

BinaryQueryElement::BinaryQueryElement(const std::vector<uint8_t> &bytes)
    : BinaryQueryElement(::flatbuffers::GetSizePrefixedRoot<::BinaryQueryElement>(bytes.data())) {
}

BinaryQueryElement::BinaryQueryElement(const ::BinaryQueryElement *root) 
    : lhs_()
    , op_(QueryElementOp(0))
    , rhs_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->lhs() != nullptr) {
        lhs_ = decltype(lhs_)(root->lhs());
    }
    op_ = root->op();
    if (root->rhs() != nullptr) {
        rhs_ = decltype(rhs_)(root->rhs());
    }
}

::flatbuffers::Offset<::MvdbSubcollection>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const MvdbSubcollection &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> subcollection_offset = builder.CreateString(o.subcollection_);

    ::MvdbSubcollectionBuilder instance_builder = ::MvdbSubcollectionBuilder(builder);
    instance_builder.add_subcollection(subcollection_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const MvdbSubcollection &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

MvdbSubcollection::MvdbSubcollection()
    : subcollection_() {
}

MvdbSubcollection::MvdbSubcollection(const std::vector<uint8_t> &bytes)
    : MvdbSubcollection(::flatbuffers::GetSizePrefixedRoot<::MvdbSubcollection>(bytes.data())) {
}

MvdbSubcollection::MvdbSubcollection(const ::MvdbSubcollection *root) 
    : subcollection_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        subcollection_ = std::string(*root->subcollection()->begin(), *root->subcollection()->end());
}

::flatbuffers::Offset<::WorklogSubcollection>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorklogSubcollection &o) {

    ::WorklogSubcollectionBuilder instance_builder = ::WorklogSubcollectionBuilder(builder);
    instance_builder.add_idx(o.idx_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const WorklogSubcollection &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

WorklogSubcollection::WorklogSubcollection()
    : idx_(0) {
}

WorklogSubcollection::WorklogSubcollection(const std::vector<uint8_t> &bytes)
    : WorklogSubcollection(::flatbuffers::GetSizePrefixedRoot<::WorklogSubcollection>(bytes.data())) {
}

WorklogSubcollection::WorklogSubcollection(const ::WorklogSubcollection *root) 
    : idx_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    idx_ = root->idx();
}

::flatbuffers::Offset<::DataCatalog>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DataCatalog &o) {
    const ::flatbuffers::Offset<::ObjectId> id_offset = serialize_to(builder, o.id_);
    std::optional<::flatbuffers::Offset<::ContentId>> revision_offset = std::nullopt;
    if (o.revision_.has_value()) {
        const ::flatbuffers::Offset<::ContentId> revision_offset_val = serialize_to(builder, o.revision_.value());
        revision_offset = std::make_optional(revision_offset_val);
    }
    std::optional<std::pair<::flatbuffers::Offset<void>, ::Subcollection>> subcollection_offset = std::nullopt;
    if (o.subcollection_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::Subcollection> subcollection_offset_val = serialize_to(builder, o.subcollection_.value());
        subcollection_offset = std::make_optional(subcollection_offset_val);
    }

    ::DataCatalogBuilder instance_builder = ::DataCatalogBuilder(builder);
    instance_builder.add_id(id_offset);
    if (revision_offset.has_value()) {
        instance_builder.add_revision(revision_offset.value());
    }
    if (subcollection_offset.has_value()) {
        const auto subcollection_opt = subcollection_offset.value();
        instance_builder.add_subcollection(subcollection_opt.first);
        instance_builder.add_subcollection_type(subcollection_opt.second);
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DataCatalog &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DataCatalog::DataCatalog()
    : id_()
    , revision_(std::nullopt)
    , subcollection_(std::nullopt) {
}

DataCatalog::DataCatalog(const std::vector<uint8_t> &bytes)
    : DataCatalog(::flatbuffers::GetSizePrefixedRoot<::DataCatalog>(bytes.data())) {
}

DataCatalog::DataCatalog(const ::DataCatalog *root) 
    : id_()
    , revision_(std::nullopt)
    , subcollection_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    if (root->revision() != nullptr) {
        revision_ = decltype(revision_)(root->revision());
    }
    if (root->subcollection() != nullptr) {
        switch (root->subcollection_type()) {
            case ::Subcollection::NONE: throw std::runtime_error("unexpected none variant");
            case ::Subcollection::MvdbSubcollection: {
                const auto subcollection__local = static_cast<const ::MvdbSubcollection *>(root->subcollection());
                std::shared_ptr<MvdbSubcollection> subcollection__shared = std::make_shared<MvdbSubcollection>(subcollection__local);
                subcollection_ = subcollection__shared;
                break;
            }
            case ::Subcollection::WorklogSubcollection: {
                const auto subcollection__local = static_cast<const ::WorklogSubcollection *>(root->subcollection());
                std::shared_ptr<WorklogSubcollection> subcollection__shared = std::make_shared<WorklogSubcollection>(subcollection__local);
                subcollection_ = subcollection__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::Arrow>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Arrow &o) {
    const decltype(builder.CreateVector(o.value_)) value_offset = builder.CreateVector(o.value_);

    ::ArrowBuilder instance_builder = ::ArrowBuilder(builder);
    instance_builder.add_value(value_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Arrow &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Arrow::Arrow()
    : value_() {
}

Arrow::Arrow(const std::vector<uint8_t> &bytes)
    : Arrow(::flatbuffers::GetSizePrefixedRoot<::Arrow>(bytes.data())) {
}

Arrow::Arrow(const ::Arrow *root) 
    : value_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &value_vector = root->value();
    if (value_vector != nullptr) {
        std::copy(value_vector->begin(), value_vector->end(), std::back_inserter(value_));
    }
}

::flatbuffers::Offset<::Query>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Query &o) {
    const ::flatbuffers::Offset<::QueryElement> query_offset = serialize_to(builder, o.query_);
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ValueInstance>>>> values_offset = std::nullopt;
    if (o.values_.has_value()) {
        const auto &values__var = o.values_.value();
        std::vector<::flatbuffers::Offset<::ValueInstance>> values_offsets = std::vector<::flatbuffers::Offset<::ValueInstance>>();
        values_offsets.reserve(values__var.size());
        for (const auto &i: values__var) {
            values_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ValueInstance>>> values_offset_val = builder.CreateVector(values_offsets);
        values_offset = std::make_optional(values_offset_val);
    }

    ::QueryBuilder instance_builder = ::QueryBuilder(builder);
    instance_builder.add_limit(o.limit_);
    instance_builder.add_query(query_offset);
    if (values_offset.has_value()) {
        instance_builder.add_values(values_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Query &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Query::Query()
    : limit_(0)
    , query_()
    , values_(std::nullopt) {
}

Query::Query(const std::vector<uint8_t> &bytes)
    : Query(::flatbuffers::GetSizePrefixedRoot<::Query>(bytes.data())) {
}

Query::Query(const ::Query *root) 
    : limit_(0)
    , query_()
    , values_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    limit_ = root->limit();
    if (root->query() != nullptr) {
        query_ = decltype(query_)(root->query());
    }
    const auto &values_vector = root->values();
    if (values_vector != nullptr) {
        decltype(values_)::value_type values__target = decltype(values_)::value_type();
        values__target.reserve(values_vector->size());
        for (const auto &i: *values_vector) {
            values__target.emplace_back(i);
        }
        values_ = std::make_optional(values__target);
    }
}

::flatbuffers::Offset<::QueryTableSource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const QueryTableSource &o) {
    const ::flatbuffers::Offset<::Query> q_offset = serialize_to(builder, o.q_);

    ::QueryTableSourceBuilder instance_builder = ::QueryTableSourceBuilder(builder);
    instance_builder.add_q(q_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const QueryTableSource &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

QueryTableSource::QueryTableSource()
    : q_() {
}

QueryTableSource::QueryTableSource(const std::vector<uint8_t> &bytes)
    : QueryTableSource(::flatbuffers::GetSizePrefixedRoot<::QueryTableSource>(bytes.data())) {
}

QueryTableSource::QueryTableSource(const ::QueryTableSource *root) 
    : q_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->q() != nullptr) {
        q_ = decltype(q_)(root->q());
    }
}

::flatbuffers::Offset<::Vector>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Vector &o) {
    std::vector<::flatbuffers::Offset<::ObjectId>> ids_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
    ids_offsets.reserve(o.ids_.size());
    for (const auto &i: o.ids_) {
        ids_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> ids_offset = builder.CreateVector(ids_offsets);
    std::optional<::flatbuffers::Offset<::NullableUint>> limit_offset = std::nullopt;
    if (o.limit_.has_value()) {
        const ::flatbuffers::Offset<::NullableUint> limit_offset_val = serialize_to(builder, o.limit_.value());
        limit_offset = std::make_optional(limit_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> query_offset = builder.CreateString(o.query_);

    ::VectorBuilder instance_builder = ::VectorBuilder(builder);
    instance_builder.add_ids(ids_offset);
    if (limit_offset.has_value()) {
        instance_builder.add_limit(limit_offset.value());
    }
    instance_builder.add_max_distance(o.max_distance_);
    instance_builder.add_query(query_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Vector &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Vector::Vector()
    : ids_()
    , limit_(std::nullopt)
    , max_distance_(0)
    , query_() {
}

Vector::Vector(const std::vector<uint8_t> &bytes)
    : Vector(::flatbuffers::GetSizePrefixedRoot<::Vector>(bytes.data())) {
}

Vector::Vector(const ::Vector *root) 
    : ids_()
    , limit_(std::nullopt)
    , max_distance_(0)
    , query_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &ids_vector = root->ids();
    if (ids_vector != nullptr) {
        ids_.reserve(ids_vector->size());
        for (const auto &i: *ids_vector) {
            ids_.emplace_back(i);
        }
    }
    if (root->limit() != nullptr) {
        limit_ = decltype(limit_)(root->limit());
    }
    max_distance_ = root->max_distance();
        query_ = std::string(*root->query()->begin(), *root->query()->end());
}

::flatbuffers::Offset<::RecordBatchPlaceholder>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RecordBatchPlaceholder &o) {

    ::RecordBatchPlaceholderBuilder instance_builder = ::RecordBatchPlaceholderBuilder(builder);
    instance_builder.add_idx(o.idx_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RecordBatchPlaceholder &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RecordBatchPlaceholder::RecordBatchPlaceholder()
    : idx_(0) {
}

RecordBatchPlaceholder::RecordBatchPlaceholder(const std::vector<uint8_t> &bytes)
    : RecordBatchPlaceholder(::flatbuffers::GetSizePrefixedRoot<::RecordBatchPlaceholder>(bytes.data())) {
}

RecordBatchPlaceholder::RecordBatchPlaceholder(const ::RecordBatchPlaceholder *root) 
    : idx_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    idx_ = root->idx();
}

::flatbuffers::Offset<::UpdateQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UpdateQueryElement &o) {
    std::optional<::flatbuffers::Offset<::Function>> filter_offset = std::nullopt;
    if (o.filter_.has_value()) {
        const ::flatbuffers::Offset<::Function> filter_offset_val = serialize_to(builder, o.filter_.value());
        filter_offset = std::make_optional(filter_offset_val);
    }
    std::vector<::flatbuffers::Offset<::SetExpr>> sets_offsets = std::vector<::flatbuffers::Offset<::SetExpr>>();
    sets_offsets.reserve(o.sets_.size());
    for (const auto &i: o.sets_) {
        sets_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::SetExpr>>> sets_offset = builder.CreateVector(sets_offsets);
    const std::pair<::flatbuffers::Offset<void>, ::TableSourceUnion> source_offset = serialize_to(builder, o.source_);

    ::UpdateQueryElementBuilder instance_builder = ::UpdateQueryElementBuilder(builder);
    if (filter_offset.has_value()) {
        instance_builder.add_filter(filter_offset.value());
    }
    instance_builder.add_sets(sets_offset);
    instance_builder.add_source(source_offset.first);
    instance_builder.add_source_type(source_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UpdateQueryElement &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UpdateQueryElement::UpdateQueryElement()
    : filter_(std::nullopt)
    , sets_()
    , source_(std::make_shared<DataCatalog>()) {
}

UpdateQueryElement::UpdateQueryElement(const std::vector<uint8_t> &bytes)
    : UpdateQueryElement(::flatbuffers::GetSizePrefixedRoot<::UpdateQueryElement>(bytes.data())) {
}

UpdateQueryElement::UpdateQueryElement(const ::UpdateQueryElement *root) 
    : filter_(std::nullopt)
    , sets_()
    , source_(std::make_shared<DataCatalog>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->filter() != nullptr) {
        filter_ = decltype(filter_)(root->filter());
    }
    const auto &sets_vector = root->sets();
    if (sets_vector != nullptr) {
        sets_.reserve(sets_vector->size());
        for (const auto &i: *sets_vector) {
            sets_.emplace_back(i);
        }
    }
    if (root->source() != nullptr) {
        switch (root->source_type()) {
            case ::TableSourceUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::TableSourceUnion::DataCatalog: {
                const auto source__local = static_cast<const ::DataCatalog *>(root->source());
                std::shared_ptr<DataCatalog> source__shared = std::make_shared<DataCatalog>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::Arrow: {
                const auto source__local = static_cast<const ::Arrow *>(root->source());
                std::shared_ptr<Arrow> source__shared = std::make_shared<Arrow>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::GraphQuery: {
                const auto source__local = static_cast<const ::GraphQuery *>(root->source());
                std::shared_ptr<GraphQuery> source__shared = std::make_shared<GraphQuery>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::QueryTableSource: {
                const auto source__local = static_cast<const ::QueryTableSource *>(root->source());
                std::shared_ptr<QueryTableSource> source__shared = std::make_shared<QueryTableSource>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::Vector: {
                const auto source__local = static_cast<const ::Vector *>(root->source());
                std::shared_ptr<Vector> source__shared = std::make_shared<Vector>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::RecordBatchPlaceholder: {
                const auto source__local = static_cast<const ::RecordBatchPlaceholder *>(root->source());
                std::shared_ptr<RecordBatchPlaceholder> source__shared = std::make_shared<RecordBatchPlaceholder>(source__local);
                source_ = source__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::DeleteQueryElement>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DeleteQueryElement &o) {
    std::optional<::flatbuffers::Offset<::Function>> filter_offset = std::nullopt;
    if (o.filter_.has_value()) {
        const ::flatbuffers::Offset<::Function> filter_offset_val = serialize_to(builder, o.filter_.value());
        filter_offset = std::make_optional(filter_offset_val);
    }
    const std::pair<::flatbuffers::Offset<void>, ::TableSourceUnion> source_offset = serialize_to(builder, o.source_);

    ::DeleteQueryElementBuilder instance_builder = ::DeleteQueryElementBuilder(builder);
    if (filter_offset.has_value()) {
        instance_builder.add_filter(filter_offset.value());
    }
    instance_builder.add_source(source_offset.first);
    instance_builder.add_source_type(source_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DeleteQueryElement &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DeleteQueryElement::DeleteQueryElement()
    : filter_(std::nullopt)
    , source_(std::make_shared<DataCatalog>()) {
}

DeleteQueryElement::DeleteQueryElement(const std::vector<uint8_t> &bytes)
    : DeleteQueryElement(::flatbuffers::GetSizePrefixedRoot<::DeleteQueryElement>(bytes.data())) {
}

DeleteQueryElement::DeleteQueryElement(const ::DeleteQueryElement *root) 
    : filter_(std::nullopt)
    , source_(std::make_shared<DataCatalog>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->filter() != nullptr) {
        filter_ = decltype(filter_)(root->filter());
    }
    if (root->source() != nullptr) {
        switch (root->source_type()) {
            case ::TableSourceUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::TableSourceUnion::DataCatalog: {
                const auto source__local = static_cast<const ::DataCatalog *>(root->source());
                std::shared_ptr<DataCatalog> source__shared = std::make_shared<DataCatalog>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::Arrow: {
                const auto source__local = static_cast<const ::Arrow *>(root->source());
                std::shared_ptr<Arrow> source__shared = std::make_shared<Arrow>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::GraphQuery: {
                const auto source__local = static_cast<const ::GraphQuery *>(root->source());
                std::shared_ptr<GraphQuery> source__shared = std::make_shared<GraphQuery>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::QueryTableSource: {
                const auto source__local = static_cast<const ::QueryTableSource *>(root->source());
                std::shared_ptr<QueryTableSource> source__shared = std::make_shared<QueryTableSource>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::Vector: {
                const auto source__local = static_cast<const ::Vector *>(root->source());
                std::shared_ptr<Vector> source__shared = std::make_shared<Vector>(source__local);
                source_ = source__shared;
                break;
            }
            case ::TableSourceUnion::RecordBatchPlaceholder: {
                const auto source__local = static_cast<const ::RecordBatchPlaceholder *>(root->source());
                std::shared_ptr<RecordBatchPlaceholder> source__shared = std::make_shared<RecordBatchPlaceholder>(source__local);
                source_ = source__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::Join>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Join &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> dest_col_offset = std::nullopt;
    if (o.dest_col_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> dest_col_offset_val = builder.CreateString(o.dest_col_.value());
        dest_col_offset = std::make_optional(dest_col_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> src_col_offset = std::nullopt;
    if (o.src_col_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> src_col_offset_val = builder.CreateString(o.src_col_.value());
        src_col_offset = std::make_optional(src_col_offset_val);
    }

    ::JoinBuilder instance_builder = ::JoinBuilder(builder);
    if (dest_col_offset.has_value()) {
        instance_builder.add_dest_col(dest_col_offset.value());
    }
    instance_builder.add_dest_idx(o.dest_idx_);
    if (src_col_offset.has_value()) {
        instance_builder.add_src_col(src_col_offset.value());
    }
    instance_builder.add_src_idx(o.src_idx_);
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Join &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Join::Join()
    : dest_col_(std::nullopt)
    , dest_idx_(0)
    , src_col_(std::nullopt)
    , src_idx_(0)
    , ty_(JoinTy(0)) {
}

Join::Join(const std::vector<uint8_t> &bytes)
    : Join(::flatbuffers::GetSizePrefixedRoot<::Join>(bytes.data())) {
}

Join::Join(const ::Join *root) 
    : dest_col_(std::nullopt)
    , dest_idx_(0)
    , src_col_(std::nullopt)
    , src_idx_(0)
    , ty_(JoinTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->dest_col() != nullptr) {
        dest_col_ = std::string(*root->dest_col()->begin(), *root->dest_col()->end());
    }
    dest_idx_ = root->dest_idx();
    if (root->src_col() != nullptr) {
        src_col_ = std::string(*root->src_col()->begin(), *root->src_col()->end());
    }
    src_idx_ = root->src_idx();
    ty_ = root->ty();
}

::flatbuffers::Offset<::ParameterInstance>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterInstance &o) {
    const std::pair<::flatbuffers::Offset<void>, ::ParameterSlot> p_offset = serialize_to(builder, o.p_);

    ::ParameterInstanceBuilder instance_builder = ::ParameterInstanceBuilder(builder);
    instance_builder.add_p(p_offset.first);
    instance_builder.add_p_type(p_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ParameterInstance &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ParameterInstance::ParameterInstance()
    : p_(std::make_shared<Parameter>()) {
}

ParameterInstance::ParameterInstance(const std::vector<uint8_t> &bytes)
    : ParameterInstance(::flatbuffers::GetSizePrefixedRoot<::ParameterInstance>(bytes.data())) {
}

ParameterInstance::ParameterInstance(const ::ParameterInstance *root) 
    : p_(std::make_shared<Parameter>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->p() != nullptr) {
        switch (root->p_type()) {
            case ::ParameterSlot::NONE: throw std::runtime_error("unexpected none variant");
            case ::ParameterSlot::Parameter: {
                const auto p__local = static_cast<const ::Parameter *>(root->p());
                std::shared_ptr<Parameter> p__shared = std::make_shared<Parameter>(p__local);
                p_ = p__shared;
                break;
            }
            case ::ParameterSlot::ValueInstance: {
                const auto p__local = static_cast<const ::ValueInstance *>(root->p());
                std::shared_ptr<ValueInstance> p__shared = std::make_shared<ValueInstance>(p__local);
                p_ = p__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::ParameterizedQuery>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ParameterizedQuery &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ParameterInstance>>>> parameters_offset = std::nullopt;
    if (o.parameters_.has_value()) {
        const auto &parameters__var = o.parameters_.value();
        std::vector<::flatbuffers::Offset<::ParameterInstance>> parameters_offsets = std::vector<::flatbuffers::Offset<::ParameterInstance>>();
        parameters_offsets.reserve(parameters__var.size());
        for (const auto &i: parameters__var) {
            parameters_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ParameterInstance>>> parameters_offset_val = builder.CreateVector(parameters_offsets);
        parameters_offset = std::make_optional(parameters_offset_val);
    }
    const ::flatbuffers::Offset<::QueryElement> query_offset = serialize_to(builder, o.query_);

    ::ParameterizedQueryBuilder instance_builder = ::ParameterizedQueryBuilder(builder);
    instance_builder.add_limit(o.limit_);
    if (parameters_offset.has_value()) {
        instance_builder.add_parameters(parameters_offset.value());
    }
    instance_builder.add_query(query_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ParameterizedQuery &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ParameterizedQuery::ParameterizedQuery()
    : limit_(0)
    , parameters_(std::nullopt)
    , query_() {
}

ParameterizedQuery::ParameterizedQuery(const std::vector<uint8_t> &bytes)
    : ParameterizedQuery(::flatbuffers::GetSizePrefixedRoot<::ParameterizedQuery>(bytes.data())) {
}

ParameterizedQuery::ParameterizedQuery(const ::ParameterizedQuery *root) 
    : limit_(0)
    , parameters_(std::nullopt)
    , query_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    limit_ = root->limit();
    const auto &parameters_vector = root->parameters();
    if (parameters_vector != nullptr) {
        decltype(parameters_)::value_type parameters__target = decltype(parameters_)::value_type();
        parameters__target.reserve(parameters_vector->size());
        for (const auto &i: *parameters_vector) {
            parameters__target.emplace_back(i);
        }
        parameters_ = std::make_optional(parameters__target);
    }
    if (root->query() != nullptr) {
        query_ = decltype(query_)(root->query());
    }
}

::flatbuffers::Offset<::SetExpr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const SetExpr &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> col_offset = builder.CreateString(o.col_);
    const ::flatbuffers::Offset<::Expr> expr_offset = serialize_to(builder, o.expr_);

    ::SetExprBuilder instance_builder = ::SetExprBuilder(builder);
    instance_builder.add_col(col_offset);
    instance_builder.add_expr(expr_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const SetExpr &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

SetExpr::SetExpr()
    : col_()
    , expr_() {
}

SetExpr::SetExpr(const std::vector<uint8_t> &bytes)
    : SetExpr(::flatbuffers::GetSizePrefixedRoot<::SetExpr>(bytes.data())) {
}

SetExpr::SetExpr(const ::SetExpr *root) 
    : col_()
    , expr_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        col_ = std::string(*root->col()->begin(), *root->col()->end());
    if (root->expr() != nullptr) {
        expr_ = decltype(expr_)(root->expr());
    }
}

::flatbuffers::Offset<::TableOrderBy>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TableOrderBy &o) {
    const ::flatbuffers::Offset<::OrderBy> order_by_offset = serialize_to(builder, o.order_by_);

    ::TableOrderByBuilder instance_builder = ::TableOrderByBuilder(builder);
    instance_builder.add_order_by(order_by_offset);
    instance_builder.add_source(o.source_);
    instance_builder.add_use_source(o.use_source_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TableOrderBy &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TableOrderBy::TableOrderBy()
    : order_by_()
    , source_(0)
    , use_source_(true) {
}

TableOrderBy::TableOrderBy(const std::vector<uint8_t> &bytes)
    : TableOrderBy(::flatbuffers::GetSizePrefixedRoot<::TableOrderBy>(bytes.data())) {
}

TableOrderBy::TableOrderBy(const ::TableOrderBy *root) 
    : order_by_()
    , source_(0)
    , use_source_(true) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->order_by() != nullptr) {
        order_by_ = decltype(order_by_)(root->order_by());
    }
    source_ = root->source();
    use_source_ = root->use_source();
}

::flatbuffers::Offset<::TableSource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TableSource &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>>> fields_offset = std::nullopt;
    if (o.fields_.has_value()) {
        const auto &fields__var = o.fields_.value();
        std::vector<::flatbuffers::Offset<::Expr>> fields_offsets = std::vector<::flatbuffers::Offset<::Expr>>();
        fields_offsets.reserve(fields__var.size());
        for (const auto &i: fields__var) {
            fields_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>> fields_offset_val = builder.CreateVector(fields_offsets);
        fields_offset = std::make_optional(fields_offset_val);
    }
    std::optional<::flatbuffers::Offset<::Function>> filter_offset = std::nullopt;
    if (o.filter_.has_value()) {
        const ::flatbuffers::Offset<::Function> filter_offset_val = serialize_to(builder, o.filter_.value());
        filter_offset = std::make_optional(filter_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>>> group_by_offset = std::nullopt;
    if (o.group_by_.has_value()) {
        const auto &group_by__var = o.group_by_.value();
        std::vector<::flatbuffers::Offset<::Expr>> group_by_offsets = std::vector<::flatbuffers::Offset<::Expr>>();
        group_by_offsets.reserve(group_by__var.size());
        for (const auto &i: group_by__var) {
            group_by_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Expr>>> group_by_offset_val = builder.CreateVector(group_by_offsets);
        group_by_offset = std::make_optional(group_by_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OrderBy>>>> order_by_offset = std::nullopt;
    if (o.order_by_.has_value()) {
        const auto &order_by__var = o.order_by_.value();
        std::vector<::flatbuffers::Offset<::OrderBy>> order_by_offsets = std::vector<::flatbuffers::Offset<::OrderBy>>();
        order_by_offsets.reserve(order_by__var.size());
        for (const auto &i: order_by__var) {
            order_by_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::OrderBy>>> order_by_offset_val = builder.CreateVector(order_by_offsets);
        order_by_offset = std::make_optional(order_by_offset_val);
    }
    const std::pair<::flatbuffers::Offset<void>, ::TableSourceUnion> t_offset = serialize_to(builder, o.t_);

    ::TableSourceBuilder instance_builder = ::TableSourceBuilder(builder);
    if (fields_offset.has_value()) {
        instance_builder.add_fields(fields_offset.value());
    }
    if (filter_offset.has_value()) {
        instance_builder.add_filter(filter_offset.value());
    }
    if (group_by_offset.has_value()) {
        instance_builder.add_group_by(group_by_offset.value());
    }
    if (order_by_offset.has_value()) {
        instance_builder.add_order_by(order_by_offset.value());
    }
    instance_builder.add_t(t_offset.first);
    instance_builder.add_t_type(t_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TableSource &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TableSource::TableSource()
    : fields_(std::nullopt)
    , filter_(std::nullopt)
    , group_by_(std::nullopt)
    , order_by_(std::nullopt)
    , t_(std::make_shared<DataCatalog>()) {
}

TableSource::TableSource(const std::vector<uint8_t> &bytes)
    : TableSource(::flatbuffers::GetSizePrefixedRoot<::TableSource>(bytes.data())) {
}

TableSource::TableSource(const ::TableSource *root) 
    : fields_(std::nullopt)
    , filter_(std::nullopt)
    , group_by_(std::nullopt)
    , order_by_(std::nullopt)
    , t_(std::make_shared<DataCatalog>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &fields_vector = root->fields();
    if (fields_vector != nullptr) {
        decltype(fields_)::value_type fields__target = decltype(fields_)::value_type();
        fields__target.reserve(fields_vector->size());
        for (const auto &i: *fields_vector) {
            fields__target.emplace_back(i);
        }
        fields_ = std::make_optional(fields__target);
    }
    if (root->filter() != nullptr) {
        filter_ = decltype(filter_)(root->filter());
    }
    const auto &group_by_vector = root->group_by();
    if (group_by_vector != nullptr) {
        decltype(group_by_)::value_type group_by__target = decltype(group_by_)::value_type();
        group_by__target.reserve(group_by_vector->size());
        for (const auto &i: *group_by_vector) {
            group_by__target.emplace_back(i);
        }
        group_by_ = std::make_optional(group_by__target);
    }
    const auto &order_by_vector = root->order_by();
    if (order_by_vector != nullptr) {
        decltype(order_by_)::value_type order_by__target = decltype(order_by_)::value_type();
        order_by__target.reserve(order_by_vector->size());
        for (const auto &i: *order_by_vector) {
            order_by__target.emplace_back(i);
        }
        order_by_ = std::make_optional(order_by__target);
    }
    if (root->t() != nullptr) {
        switch (root->t_type()) {
            case ::TableSourceUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::TableSourceUnion::DataCatalog: {
                const auto t__local = static_cast<const ::DataCatalog *>(root->t());
                std::shared_ptr<DataCatalog> t__shared = std::make_shared<DataCatalog>(t__local);
                t_ = t__shared;
                break;
            }
            case ::TableSourceUnion::Arrow: {
                const auto t__local = static_cast<const ::Arrow *>(root->t());
                std::shared_ptr<Arrow> t__shared = std::make_shared<Arrow>(t__local);
                t_ = t__shared;
                break;
            }
            case ::TableSourceUnion::GraphQuery: {
                const auto t__local = static_cast<const ::GraphQuery *>(root->t());
                std::shared_ptr<GraphQuery> t__shared = std::make_shared<GraphQuery>(t__local);
                t_ = t__shared;
                break;
            }
            case ::TableSourceUnion::QueryTableSource: {
                const auto t__local = static_cast<const ::QueryTableSource *>(root->t());
                std::shared_ptr<QueryTableSource> t__shared = std::make_shared<QueryTableSource>(t__local);
                t_ = t__shared;
                break;
            }
            case ::TableSourceUnion::Vector: {
                const auto t__local = static_cast<const ::Vector *>(root->t());
                std::shared_ptr<Vector> t__shared = std::make_shared<Vector>(t__local);
                t_ = t__shared;
                break;
            }
            case ::TableSourceUnion::RecordBatchPlaceholder: {
                const auto t__local = static_cast<const ::RecordBatchPlaceholder *>(root->t());
                std::shared_ptr<RecordBatchPlaceholder> t__shared = std::make_shared<RecordBatchPlaceholder>(t__local);
                t_ = t__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::When>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const When &o) {
    const ::flatbuffers::Offset<::Expr> cond_offset = serialize_to(builder, o.cond_);
    const ::flatbuffers::Offset<::Expr> value_offset = serialize_to(builder, o.value_);

    ::WhenBuilder instance_builder = ::WhenBuilder(builder);
    instance_builder.add_cond(cond_offset);
    instance_builder.add_value(value_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const When &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

When::When()
    : cond_()
    , value_() {
}

When::When(const std::vector<uint8_t> &bytes)
    : When(::flatbuffers::GetSizePrefixedRoot<::When>(bytes.data())) {
}

When::When(const ::When *root) 
    : cond_()
    , value_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->cond() != nullptr) {
        cond_ = decltype(cond_)(root->cond());
    }
    if (root->value() != nullptr) {
        value_ = decltype(value_)(root->value());
    }
}

} // namespace types
} // namespace ul
