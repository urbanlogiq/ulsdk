// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/metadata.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::ComponentData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ComponentData &o) {
    if (std::holds_alternative<std::shared_ptr<StringCategories>>(o)) {
        const std::shared_ptr<StringCategories> &v = std::get<std::shared_ptr<StringCategories>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ComponentData::StringCategories);
    } else if (std::holds_alternative<std::shared_ptr<IntRange>>(o)) {
        const std::shared_ptr<IntRange> &v = std::get<std::shared_ptr<IntRange>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ComponentData::IntRange);
    } else if (std::holds_alternative<std::shared_ptr<FloatRange>>(o)) {
        const std::shared_ptr<FloatRange> &v = std::get<std::shared_ptr<FloatRange>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ComponentData::FloatRange);
    } else if (std::holds_alternative<std::shared_ptr<DatetimeRange>>(o)) {
        const std::shared_ptr<DatetimeRange> &v = std::get<std::shared_ptr<DatetimeRange>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ComponentData::DatetimeRange);
    } else if (std::holds_alternative<std::shared_ptr<Dates>>(o)) {
        const std::shared_ptr<Dates> &v = std::get<std::shared_ptr<Dates>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ComponentData::Dates);
    } else if (std::holds_alternative<std::shared_ptr<NestedStringCategories>>(o)) {
        const std::shared_ptr<NestedStringCategories> &v = std::get<std::shared_ptr<NestedStringCategories>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::ComponentData::NestedStringCategories);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::GeometryDataUnion>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GeometryDataUnion &o) {
    if (std::holds_alternative<std::shared_ptr<RawGeom>>(o)) {
        const std::shared_ptr<RawGeom> &v = std::get<std::shared_ptr<RawGeom>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::GeometryDataUnion::RawGeom);
    } else if (std::holds_alternative<std::shared_ptr<NodeIdPair>>(o)) {
        const std::shared_ptr<NodeIdPair> &v = std::get<std::shared_ptr<NodeIdPair>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::GeometryDataUnion::NodeIdPair);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::GeometrySource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GeometrySource &o) {
    if (std::holds_alternative<std::shared_ptr<NoGeometry>>(o)) {
        const std::shared_ptr<NoGeometry> &v = std::get<std::shared_ptr<NoGeometry>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::GeometrySource::NoGeometry);
    } else if (std::holds_alternative<std::shared_ptr<DatacatalogGeometry>>(o)) {
        const std::shared_ptr<DatacatalogGeometry> &v = std::get<std::shared_ptr<DatacatalogGeometry>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::GeometrySource::DatacatalogGeometry);
    } else if (std::holds_alternative<std::shared_ptr<WorldGraphGeometry>>(o)) {
        const std::shared_ptr<WorldGraphGeometry> &v = std::get<std::shared_ptr<WorldGraphGeometry>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::GeometrySource::WorldGraphGeometry);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

std::pair<::flatbuffers::Offset<void>, ::UlFieldRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UlFieldRelationshipData &o) {
    if (std::holds_alternative<std::shared_ptr<HierarchyRelationshipData>>(o)) {
        const std::shared_ptr<HierarchyRelationshipData> &v = std::get<std::shared_ptr<HierarchyRelationshipData>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UlFieldRelationshipData::HierarchyRelationshipData);
    } else if (std::holds_alternative<std::shared_ptr<CategoryRelationshipData>>(o)) {
        const std::shared_ptr<CategoryRelationshipData> &v = std::get<std::shared_ptr<CategoryRelationshipData>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UlFieldRelationshipData::CategoryRelationshipData);
    } else if (std::holds_alternative<std::shared_ptr<NestedCategoryRelationshipData>>(o)) {
        const std::shared_ptr<NestedCategoryRelationshipData> &v = std::get<std::shared_ptr<NestedCategoryRelationshipData>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UlFieldRelationshipData::NestedCategoryRelationshipData);
    } else if (std::holds_alternative<std::shared_ptr<NestedHierarchyRelationshipData>>(o)) {
        const std::shared_ptr<NestedHierarchyRelationshipData> &v = std::get<std::shared_ptr<NestedHierarchyRelationshipData>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::UlFieldRelationshipData::NestedHierarchyRelationshipData);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::StringCategories>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const StringCategories &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> categories_offset = std::nullopt;
    if (o.categories_.has_value()) {
        const auto &categories__var = o.categories_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> categories_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: categories__var) {
            categories_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> categories_offset_val = builder.CreateVector(categories_offsets);
        categories_offset = std::make_optional(categories_offset_val);
    }

    ::StringCategoriesBuilder instance_builder = ::StringCategoriesBuilder(builder);
    if (categories_offset.has_value()) {
        instance_builder.add_categories(categories_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const StringCategories &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

StringCategories::StringCategories()
    : categories_(std::nullopt) {
}

StringCategories::StringCategories(const std::vector<uint8_t> &bytes)
    : StringCategories(::flatbuffers::GetSizePrefixedRoot<::StringCategories>(bytes.data())) {
}

StringCategories::StringCategories(const ::StringCategories *root) 
    : categories_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &categories_vector = root->categories();
    if (categories_vector != nullptr) {
        std::vector<std::string> categories__target = std::vector<std::string>();
        for (const auto &i: *categories_vector) {
            categories__target.emplace_back(i->begin(), i->end());
        }
        categories_ = std::make_optional(categories__target);
    }
}

::flatbuffers::Offset<::NumericalFieldFormat>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NumericalFieldFormat &o) {

    ::NumericalFieldFormatBuilder instance_builder = ::NumericalFieldFormatBuilder(builder);
    instance_builder.add_decimal_places(o.decimal_places_);
    instance_builder.add_offset(o.offset_);
    instance_builder.add_scale(o.scale_);
    instance_builder.add_value_type(o.value_type_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NumericalFieldFormat &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NumericalFieldFormat::NumericalFieldFormat()
    : decimal_places_(0)
    , offset_(0)
    , scale_(0)
    , value_type_(NumericalFieldValueType(0)) {
}

NumericalFieldFormat::NumericalFieldFormat(const std::vector<uint8_t> &bytes)
    : NumericalFieldFormat(::flatbuffers::GetSizePrefixedRoot<::NumericalFieldFormat>(bytes.data())) {
}

NumericalFieldFormat::NumericalFieldFormat(const ::NumericalFieldFormat *root) 
    : decimal_places_(0)
    , offset_(0)
    , scale_(0)
    , value_type_(NumericalFieldValueType(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    decimal_places_ = root->decimal_places();
    offset_ = root->offset();
    scale_ = root->scale();
    value_type_ = root->value_type();
}

::flatbuffers::Offset<::IntRange>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const IntRange &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::IntegerDisplayString>>>> display_strings_offset = std::nullopt;
    if (o.display_strings_.has_value()) {
        const auto &display_strings__var = o.display_strings_.value();
        std::vector<::flatbuffers::Offset<::IntegerDisplayString>> display_strings_offsets = std::vector<::flatbuffers::Offset<::IntegerDisplayString>>();
        display_strings_offsets.reserve(display_strings__var.size());
        for (const auto &i: display_strings__var) {
            display_strings_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::IntegerDisplayString>>> display_strings_offset_val = builder.CreateVector(display_strings_offsets);
        display_strings_offset = std::make_optional(display_strings_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> enum_name_offset = std::nullopt;
    if (o.enum_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> enum_name_offset_val = builder.CreateString(o.enum_name_.value());
        enum_name_offset = std::make_optional(enum_name_offset_val);
    }
    std::optional<::flatbuffers::Offset<::NumericalFieldFormat>> field_format_offset = std::nullopt;
    if (o.field_format_.has_value()) {
        const ::flatbuffers::Offset<::NumericalFieldFormat> field_format_offset_val = serialize_to(builder, o.field_format_.value());
        field_format_offset = std::make_optional(field_format_offset_val);
    }

    ::IntRangeBuilder instance_builder = ::IntRangeBuilder(builder);
    instance_builder.add_aggregation_protocol(o.aggregation_protocol_);
    if (display_strings_offset.has_value()) {
        instance_builder.add_display_strings(display_strings_offset.value());
    }
    if (enum_name_offset.has_value()) {
        instance_builder.add_enum_name(enum_name_offset.value());
    }
    if (field_format_offset.has_value()) {
        instance_builder.add_field_format(field_format_offset.value());
    }
    instance_builder.add_max(o.max_);
    instance_builder.add_min(o.min_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const IntRange &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

IntRange::IntRange()
    : aggregation_protocol_(AggregationFunction(0))
    , display_strings_(std::nullopt)
    , enum_name_(std::nullopt)
    , field_format_(std::nullopt)
    , max_(0)
    , min_(0) {
}

IntRange::IntRange(const std::vector<uint8_t> &bytes)
    : IntRange(::flatbuffers::GetSizePrefixedRoot<::IntRange>(bytes.data())) {
}

IntRange::IntRange(const ::IntRange *root) 
    : aggregation_protocol_(AggregationFunction(0))
    , display_strings_(std::nullopt)
    , enum_name_(std::nullopt)
    , field_format_(std::nullopt)
    , max_(0)
    , min_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    aggregation_protocol_ = root->aggregation_protocol();
    const auto &display_strings_vector = root->display_strings();
    if (display_strings_vector != nullptr) {
        decltype(display_strings_)::value_type display_strings__target = decltype(display_strings_)::value_type();
        display_strings__target.reserve(display_strings_vector->size());
        for (const auto &i: *display_strings_vector) {
            display_strings__target.emplace_back(i);
        }
        display_strings_ = std::make_optional(display_strings__target);
    }
    if (root->enum_name() != nullptr) {
        enum_name_ = std::string(*root->enum_name()->begin(), *root->enum_name()->end());
    }
    if (root->field_format() != nullptr) {
        field_format_ = decltype(field_format_)(root->field_format());
    }
    max_ = root->max();
    min_ = root->min();
}

::flatbuffers::Offset<::FloatRange>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FloatRange &o) {
    std::optional<::flatbuffers::Offset<::NumericalFieldFormat>> field_format_offset = std::nullopt;
    if (o.field_format_.has_value()) {
        const ::flatbuffers::Offset<::NumericalFieldFormat> field_format_offset_val = serialize_to(builder, o.field_format_.value());
        field_format_offset = std::make_optional(field_format_offset_val);
    }

    ::FloatRangeBuilder instance_builder = ::FloatRangeBuilder(builder);
    instance_builder.add_aggregation_protocol(o.aggregation_protocol_);
    if (field_format_offset.has_value()) {
        instance_builder.add_field_format(field_format_offset.value());
    }
    instance_builder.add_max(o.max_);
    instance_builder.add_min(o.min_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const FloatRange &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

FloatRange::FloatRange()
    : aggregation_protocol_(AggregationFunction(0))
    , field_format_(std::nullopt)
    , max_(0)
    , min_(0) {
}

FloatRange::FloatRange(const std::vector<uint8_t> &bytes)
    : FloatRange(::flatbuffers::GetSizePrefixedRoot<::FloatRange>(bytes.data())) {
}

FloatRange::FloatRange(const ::FloatRange *root) 
    : aggregation_protocol_(AggregationFunction(0))
    , field_format_(std::nullopt)
    , max_(0)
    , min_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    aggregation_protocol_ = root->aggregation_protocol();
    if (root->field_format() != nullptr) {
        field_format_ = decltype(field_format_)(root->field_format());
    }
    max_ = root->max();
    min_ = root->min();
}

::flatbuffers::Offset<::DatetimeRange>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DatetimeRange &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TimeInterval>>>> intervals_offset = std::nullopt;
    if (o.intervals_.has_value()) {
        const auto &intervals__var = o.intervals_.value();
        std::vector<::flatbuffers::Offset<::TimeInterval>> intervals_offsets = std::vector<::flatbuffers::Offset<::TimeInterval>>();
        intervals_offsets.reserve(intervals__var.size());
        for (const auto &i: intervals__var) {
            intervals_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::TimeInterval>>> intervals_offset_val = builder.CreateVector(intervals_offsets);
        intervals_offset = std::make_optional(intervals_offset_val);
    }

    ::DatetimeRangeBuilder instance_builder = ::DatetimeRangeBuilder(builder);
    if (intervals_offset.has_value()) {
        instance_builder.add_intervals(intervals_offset.value());
    }
    instance_builder.add_max(o.max_);
    instance_builder.add_min(o.min_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DatetimeRange &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DatetimeRange::DatetimeRange()
    : intervals_(std::nullopt)
    , max_(0)
    , min_(0) {
}

DatetimeRange::DatetimeRange(const std::vector<uint8_t> &bytes)
    : DatetimeRange(::flatbuffers::GetSizePrefixedRoot<::DatetimeRange>(bytes.data())) {
}

DatetimeRange::DatetimeRange(const ::DatetimeRange *root) 
    : intervals_(std::nullopt)
    , max_(0)
    , min_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &intervals_vector = root->intervals();
    if (intervals_vector != nullptr) {
        decltype(intervals_)::value_type intervals__target = decltype(intervals_)::value_type();
        intervals__target.reserve(intervals_vector->size());
        for (const auto &i: *intervals_vector) {
            intervals__target.emplace_back(i);
        }
        intervals_ = std::make_optional(intervals__target);
    }
    max_ = root->max();
    min_ = root->min();
}

::flatbuffers::Offset<::Dates>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Dates &o) {
    std::optional<decltype(builder.CreateVector(o.unique_value_counts_.value()))> unique_value_counts_offset = std::nullopt;
    if (o.unique_value_counts_.has_value()) {
        const decltype(builder.CreateVector(o.unique_value_counts_.value())) unique_value_counts_offset_val = builder.CreateVector(o.unique_value_counts_.value());
        unique_value_counts_offset = std::make_optional(unique_value_counts_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.unique_values_.value()))> unique_values_offset = std::nullopt;
    if (o.unique_values_.has_value()) {
        const decltype(builder.CreateVector(o.unique_values_.value())) unique_values_offset_val = builder.CreateVector(o.unique_values_.value());
        unique_values_offset = std::make_optional(unique_values_offset_val);
    }

    ::DatesBuilder instance_builder = ::DatesBuilder(builder);
    instance_builder.add_max(o.max_);
    instance_builder.add_min(o.min_);
    if (unique_value_counts_offset.has_value()) {
        instance_builder.add_unique_value_counts(unique_value_counts_offset.value());
    }
    if (unique_values_offset.has_value()) {
        instance_builder.add_unique_values(unique_values_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Dates &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Dates::Dates()
    : max_(0)
    , min_(0)
    , unique_value_counts_(std::nullopt)
    , unique_values_(std::nullopt) {
}

Dates::Dates(const std::vector<uint8_t> &bytes)
    : Dates(::flatbuffers::GetSizePrefixedRoot<::Dates>(bytes.data())) {
}

Dates::Dates(const ::Dates *root) 
    : max_(0)
    , min_(0)
    , unique_value_counts_(std::nullopt)
    , unique_values_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    max_ = root->max();
    min_ = root->min();
    const auto &unique_value_counts_vector = root->unique_value_counts();
    if (unique_value_counts_vector != nullptr) {
        decltype(unique_value_counts_)::value_type unique_value_counts__target = decltype(unique_value_counts_)::value_type();
        std::copy(unique_value_counts_vector->begin(), unique_value_counts_vector->end(), std::back_inserter(unique_value_counts__target));
        unique_value_counts_ = std::make_optional(unique_value_counts__target);
    }
    const auto &unique_values_vector = root->unique_values();
    if (unique_values_vector != nullptr) {
        decltype(unique_values_)::value_type unique_values__target = decltype(unique_values_)::value_type();
        std::copy(unique_values_vector->begin(), unique_values_vector->end(), std::back_inserter(unique_values__target));
        unique_values_ = std::make_optional(unique_values__target);
    }
}

::flatbuffers::Offset<::NestedStringCategories>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedStringCategories &o) {
    std::vector<::flatbuffers::Offset<::NestedStringCategoryNode>> nesting_tree_offsets = std::vector<::flatbuffers::Offset<::NestedStringCategoryNode>>();
    nesting_tree_offsets.reserve(o.nesting_tree_.size());
    for (const auto &i: o.nesting_tree_) {
        nesting_tree_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NestedStringCategoryNode>>> nesting_tree_offset = builder.CreateVector(nesting_tree_offsets);

    ::NestedStringCategoriesBuilder instance_builder = ::NestedStringCategoriesBuilder(builder);
    instance_builder.add_nesting_tree(nesting_tree_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NestedStringCategories &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NestedStringCategories::NestedStringCategories()
    : nesting_tree_() {
}

NestedStringCategories::NestedStringCategories(const std::vector<uint8_t> &bytes)
    : NestedStringCategories(::flatbuffers::GetSizePrefixedRoot<::NestedStringCategories>(bytes.data())) {
}

NestedStringCategories::NestedStringCategories(const ::NestedStringCategories *root) 
    : nesting_tree_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &nesting_tree_vector = root->nesting_tree();
    if (nesting_tree_vector != nullptr) {
        nesting_tree_.reserve(nesting_tree_vector->size());
        for (const auto &i: *nesting_tree_vector) {
            nesting_tree_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::RawGeom>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const RawGeom &o) {
    const decltype(builder.CreateVector(o.geom_)) geom_offset = builder.CreateVector(o.geom_);

    ::RawGeomBuilder instance_builder = ::RawGeomBuilder(builder);
    instance_builder.add_geom(geom_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const RawGeom &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

RawGeom::RawGeom()
    : geom_() {
}

RawGeom::RawGeom(const std::vector<uint8_t> &bytes)
    : RawGeom(::flatbuffers::GetSizePrefixedRoot<::RawGeom>(bytes.data())) {
}

RawGeom::RawGeom(const ::RawGeom *root) 
    : geom_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &geom_vector = root->geom();
    if (geom_vector != nullptr) {
        std::copy(geom_vector->begin(), geom_vector->end(), std::back_inserter(geom_));
    }
}

::flatbuffers::Offset<::NoGeometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NoGeometry &) {

    ::NoGeometryBuilder instance_builder = ::NoGeometryBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NoGeometry &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NoGeometry::NoGeometry() {
}

NoGeometry::NoGeometry(const std::vector<uint8_t> &bytes)
    : NoGeometry(::flatbuffers::GetSizePrefixedRoot<::NoGeometry>(bytes.data())) {
}

NoGeometry::NoGeometry(const ::NoGeometry *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::DatacatalogGeometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DatacatalogGeometry &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> column_offset = builder.CreateString(o.column_);

    ::DatacatalogGeometryBuilder instance_builder = ::DatacatalogGeometryBuilder(builder);
    instance_builder.add_column(column_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DatacatalogGeometry &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DatacatalogGeometry::DatacatalogGeometry()
    : column_() {
}

DatacatalogGeometry::DatacatalogGeometry(const std::vector<uint8_t> &bytes)
    : DatacatalogGeometry(::flatbuffers::GetSizePrefixedRoot<::DatacatalogGeometry>(bytes.data())) {
}

DatacatalogGeometry::DatacatalogGeometry(const ::DatacatalogGeometry *root) 
    : column_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        column_ = std::string(*root->column()->begin(), *root->column()->end());
}

::flatbuffers::Offset<::WorldGraphGeometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const WorldGraphGeometry &o) {
    const decltype(builder.CreateVector(o.edge_path_)) edge_path_offset = builder.CreateVector(o.edge_path_);
    std::optional<::flatbuffers::Offset<::ObjectId>> start_stream_id_offset = std::nullopt;
    if (o.start_stream_id_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> start_stream_id_offset_val = serialize_to(builder, o.start_stream_id_.value());
        start_stream_id_offset = std::make_optional(start_stream_id_offset_val);
    }

    ::WorldGraphGeometryBuilder instance_builder = ::WorldGraphGeometryBuilder(builder);
    instance_builder.add_edge_path(edge_path_offset);
    if (start_stream_id_offset.has_value()) {
        instance_builder.add_start_stream_id(start_stream_id_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const WorldGraphGeometry &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

WorldGraphGeometry::WorldGraphGeometry()
    : edge_path_()
    , start_stream_id_(std::nullopt) {
}

WorldGraphGeometry::WorldGraphGeometry(const std::vector<uint8_t> &bytes)
    : WorldGraphGeometry(::flatbuffers::GetSizePrefixedRoot<::WorldGraphGeometry>(bytes.data())) {
}

WorldGraphGeometry::WorldGraphGeometry(const ::WorldGraphGeometry *root) 
    : edge_path_()
    , start_stream_id_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &edge_path_vector = root->edge_path();
    if (edge_path_vector != nullptr) {
        std::copy(edge_path_vector->begin(), edge_path_vector->end(), std::back_inserter(edge_path_));
    }
    if (root->start_stream_id() != nullptr) {
        start_stream_id_ = decltype(start_stream_id_)(root->start_stream_id());
    }
}

::flatbuffers::Offset<::HierarchyRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const HierarchyRelationshipData &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::HierarchicalRelationship>>>> hierarchy_offset = std::nullopt;
    if (o.hierarchy_.has_value()) {
        const auto &hierarchy__var = o.hierarchy_.value();
        std::vector<::flatbuffers::Offset<::HierarchicalRelationship>> hierarchy_offsets = std::vector<::flatbuffers::Offset<::HierarchicalRelationship>>();
        hierarchy_offsets.reserve(hierarchy__var.size());
        for (const auto &i: hierarchy__var) {
            hierarchy_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::HierarchicalRelationship>>> hierarchy_offset_val = builder.CreateVector(hierarchy_offsets);
        hierarchy_offset = std::make_optional(hierarchy_offset_val);
    }

    ::HierarchyRelationshipDataBuilder instance_builder = ::HierarchyRelationshipDataBuilder(builder);
    if (hierarchy_offset.has_value()) {
        instance_builder.add_hierarchy(hierarchy_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const HierarchyRelationshipData &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

HierarchyRelationshipData::HierarchyRelationshipData()
    : hierarchy_(std::nullopt) {
}

HierarchyRelationshipData::HierarchyRelationshipData(const std::vector<uint8_t> &bytes)
    : HierarchyRelationshipData(::flatbuffers::GetSizePrefixedRoot<::HierarchyRelationshipData>(bytes.data())) {
}

HierarchyRelationshipData::HierarchyRelationshipData(const ::HierarchyRelationshipData *root) 
    : hierarchy_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &hierarchy_vector = root->hierarchy();
    if (hierarchy_vector != nullptr) {
        decltype(hierarchy_)::value_type hierarchy__target = decltype(hierarchy_)::value_type();
        hierarchy__target.reserve(hierarchy_vector->size());
        for (const auto &i: *hierarchy_vector) {
            hierarchy__target.emplace_back(i);
        }
        hierarchy_ = std::make_optional(hierarchy__target);
    }
}

::flatbuffers::Offset<::CategoryRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const CategoryRelationshipData &o) {
    std::optional<decltype(builder.CreateVector(o.associated_fields_.value()))> associated_fields_offset = std::nullopt;
    if (o.associated_fields_.has_value()) {
        const decltype(builder.CreateVector(o.associated_fields_.value())) associated_fields_offset_val = builder.CreateVector(o.associated_fields_.value());
        associated_fields_offset = std::make_optional(associated_fields_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.categories_.value()))> categories_offset = std::nullopt;
    if (o.categories_.has_value()) {
        const decltype(builder.CreateVector(o.categories_.value())) categories_offset_val = builder.CreateVector(o.categories_.value());
        categories_offset = std::make_optional(categories_offset_val);
    }

    ::CategoryRelationshipDataBuilder instance_builder = ::CategoryRelationshipDataBuilder(builder);
    if (associated_fields_offset.has_value()) {
        instance_builder.add_associated_fields(associated_fields_offset.value());
    }
    if (categories_offset.has_value()) {
        instance_builder.add_categories(categories_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const CategoryRelationshipData &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

CategoryRelationshipData::CategoryRelationshipData()
    : associated_fields_(std::nullopt)
    , categories_(std::nullopt) {
}

CategoryRelationshipData::CategoryRelationshipData(const std::vector<uint8_t> &bytes)
    : CategoryRelationshipData(::flatbuffers::GetSizePrefixedRoot<::CategoryRelationshipData>(bytes.data())) {
}

CategoryRelationshipData::CategoryRelationshipData(const ::CategoryRelationshipData *root) 
    : associated_fields_(std::nullopt)
    , categories_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &associated_fields_vector = root->associated_fields();
    if (associated_fields_vector != nullptr) {
        decltype(associated_fields_)::value_type associated_fields__target = decltype(associated_fields_)::value_type();
        std::copy(associated_fields_vector->begin(), associated_fields_vector->end(), std::back_inserter(associated_fields__target));
        associated_fields_ = std::make_optional(associated_fields__target);
    }
    const auto &categories_vector = root->categories();
    if (categories_vector != nullptr) {
        decltype(categories_)::value_type categories__target = decltype(categories_)::value_type();
        std::copy(categories_vector->begin(), categories_vector->end(), std::back_inserter(categories__target));
        categories_ = std::make_optional(categories__target);
    }
}

::flatbuffers::Offset<::NestedCategoryRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedCategoryRelationshipData &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NestedCategoryRelationshipNode>>>> categories_offset = std::nullopt;
    if (o.categories_.has_value()) {
        const auto &categories__var = o.categories_.value();
        std::vector<::flatbuffers::Offset<::NestedCategoryRelationshipNode>> categories_offsets = std::vector<::flatbuffers::Offset<::NestedCategoryRelationshipNode>>();
        categories_offsets.reserve(categories__var.size());
        for (const auto &i: categories__var) {
            categories_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NestedCategoryRelationshipNode>>> categories_offset_val = builder.CreateVector(categories_offsets);
        categories_offset = std::make_optional(categories_offset_val);
    }

    ::NestedCategoryRelationshipDataBuilder instance_builder = ::NestedCategoryRelationshipDataBuilder(builder);
    if (categories_offset.has_value()) {
        instance_builder.add_categories(categories_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NestedCategoryRelationshipData &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NestedCategoryRelationshipData::NestedCategoryRelationshipData()
    : categories_(std::nullopt) {
}

NestedCategoryRelationshipData::NestedCategoryRelationshipData(const std::vector<uint8_t> &bytes)
    : NestedCategoryRelationshipData(::flatbuffers::GetSizePrefixedRoot<::NestedCategoryRelationshipData>(bytes.data())) {
}

NestedCategoryRelationshipData::NestedCategoryRelationshipData(const ::NestedCategoryRelationshipData *root) 
    : categories_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &categories_vector = root->categories();
    if (categories_vector != nullptr) {
        decltype(categories_)::value_type categories__target = decltype(categories_)::value_type();
        categories__target.reserve(categories_vector->size());
        for (const auto &i: *categories_vector) {
            categories__target.emplace_back(i);
        }
        categories_ = std::make_optional(categories__target);
    }
}

::flatbuffers::Offset<::NestedHierarchyRelationshipData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedHierarchyRelationshipData &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NestedHierarchyRelationshipNode>>>> nodes_offset = std::nullopt;
    if (o.nodes_.has_value()) {
        const auto &nodes__var = o.nodes_.value();
        std::vector<::flatbuffers::Offset<::NestedHierarchyRelationshipNode>> nodes_offsets = std::vector<::flatbuffers::Offset<::NestedHierarchyRelationshipNode>>();
        nodes_offsets.reserve(nodes__var.size());
        for (const auto &i: nodes__var) {
            nodes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::NestedHierarchyRelationshipNode>>> nodes_offset_val = builder.CreateVector(nodes_offsets);
        nodes_offset = std::make_optional(nodes_offset_val);
    }

    ::NestedHierarchyRelationshipDataBuilder instance_builder = ::NestedHierarchyRelationshipDataBuilder(builder);
    if (nodes_offset.has_value()) {
        instance_builder.add_nodes(nodes_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NestedHierarchyRelationshipData &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NestedHierarchyRelationshipData::NestedHierarchyRelationshipData()
    : nodes_(std::nullopt) {
}

NestedHierarchyRelationshipData::NestedHierarchyRelationshipData(const std::vector<uint8_t> &bytes)
    : NestedHierarchyRelationshipData(::flatbuffers::GetSizePrefixedRoot<::NestedHierarchyRelationshipData>(bytes.data())) {
}

NestedHierarchyRelationshipData::NestedHierarchyRelationshipData(const ::NestedHierarchyRelationshipData *root) 
    : nodes_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &nodes_vector = root->nodes();
    if (nodes_vector != nullptr) {
        decltype(nodes_)::value_type nodes__target = decltype(nodes_)::value_type();
        nodes__target.reserve(nodes_vector->size());
        for (const auto &i: *nodes_vector) {
            nodes__target.emplace_back(i);
        }
        nodes_ = std::make_optional(nodes__target);
    }
}

::flatbuffers::Offset<::ContactInfo>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ContactInfo &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> address_offset = std::nullopt;
    if (o.address_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> address_offset_val = builder.CreateString(o.address_.value());
        address_offset = std::make_optional(address_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> email_offset = std::nullopt;
    if (o.email_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> email_offset_val = builder.CreateString(o.email_.value());
        email_offset = std::make_optional(email_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> name_offset = std::nullopt;
    if (o.name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> name_offset_val = builder.CreateString(o.name_.value());
        name_offset = std::make_optional(name_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> phone_offset = std::nullopt;
    if (o.phone_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> phone_offset_val = builder.CreateString(o.phone_.value());
        phone_offset = std::make_optional(phone_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> url_offset = std::nullopt;
    if (o.url_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> url_offset_val = builder.CreateString(o.url_.value());
        url_offset = std::make_optional(url_offset_val);
    }

    ::ContactInfoBuilder instance_builder = ::ContactInfoBuilder(builder);
    if (address_offset.has_value()) {
        instance_builder.add_address(address_offset.value());
    }
    if (email_offset.has_value()) {
        instance_builder.add_email(email_offset.value());
    }
    if (name_offset.has_value()) {
        instance_builder.add_name(name_offset.value());
    }
    if (phone_offset.has_value()) {
        instance_builder.add_phone(phone_offset.value());
    }
    if (url_offset.has_value()) {
        instance_builder.add_url(url_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ContactInfo &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ContactInfo::ContactInfo()
    : address_(std::nullopt)
    , email_(std::nullopt)
    , name_(std::nullopt)
    , phone_(std::nullopt)
    , url_(std::nullopt) {
}

ContactInfo::ContactInfo(const std::vector<uint8_t> &bytes)
    : ContactInfo(::flatbuffers::GetSizePrefixedRoot<::ContactInfo>(bytes.data())) {
}

ContactInfo::ContactInfo(const ::ContactInfo *root) 
    : address_(std::nullopt)
    , email_(std::nullopt)
    , name_(std::nullopt)
    , phone_(std::nullopt)
    , url_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->address() != nullptr) {
        address_ = std::string(*root->address()->begin(), *root->address()->end());
    }
    if (root->email() != nullptr) {
        email_ = std::string(*root->email()->begin(), *root->email()->end());
    }
    if (root->name() != nullptr) {
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    }
    if (root->phone() != nullptr) {
        phone_ = std::string(*root->phone()->begin(), *root->phone()->end());
    }
    if (root->url() != nullptr) {
        url_ = std::string(*root->url()->begin(), *root->url()->end());
    }
}

::flatbuffers::Offset<::DatasetSource>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DatasetSource &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> date_offset = std::nullopt;
    if (o.date_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> date_offset_val = builder.CreateString(o.date_.value());
        date_offset = std::make_optional(date_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> source_offset = std::nullopt;
    if (o.source_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> source_offset_val = builder.CreateString(o.source_.value());
        source_offset = std::make_optional(source_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> url_offset = std::nullopt;
    if (o.url_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> url_offset_val = builder.CreateString(o.url_.value());
        url_offset = std::make_optional(url_offset_val);
    }

    ::DatasetSourceBuilder instance_builder = ::DatasetSourceBuilder(builder);
    if (date_offset.has_value()) {
        instance_builder.add_date(date_offset.value());
    }
    if (source_offset.has_value()) {
        instance_builder.add_source(source_offset.value());
    }
    if (url_offset.has_value()) {
        instance_builder.add_url(url_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DatasetSource &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DatasetSource::DatasetSource()
    : date_(std::nullopt)
    , source_(std::nullopt)
    , url_(std::nullopt) {
}

DatasetSource::DatasetSource(const std::vector<uint8_t> &bytes)
    : DatasetSource(::flatbuffers::GetSizePrefixedRoot<::DatasetSource>(bytes.data())) {
}

DatasetSource::DatasetSource(const ::DatasetSource *root) 
    : date_(std::nullopt)
    , source_(std::nullopt)
    , url_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->date() != nullptr) {
        date_ = std::string(*root->date()->begin(), *root->date()->end());
    }
    if (root->source() != nullptr) {
        source_ = std::string(*root->source()->begin(), *root->source()->end());
    }
    if (root->url() != nullptr) {
        url_ = std::string(*root->url()->begin(), *root->url()->end());
    }
}

::flatbuffers::Offset<::Document>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Document &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> display_name_offset = std::nullopt;
    if (o.display_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> display_name_offset_val = builder.CreateString(o.display_name_.value());
        display_name_offset = std::make_optional(display_name_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> filename_offset = std::nullopt;
    if (o.filename_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> filename_offset_val = builder.CreateString(o.filename_.value());
        filename_offset = std::make_optional(filename_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> mime_type_offset = std::nullopt;
    if (o.mime_type_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> mime_type_offset_val = builder.CreateString(o.mime_type_.value());
        mime_type_offset = std::make_optional(mime_type_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> url_offset = std::nullopt;
    if (o.url_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> url_offset_val = builder.CreateString(o.url_.value());
        url_offset = std::make_optional(url_offset_val);
    }

    ::DocumentBuilder instance_builder = ::DocumentBuilder(builder);
    if (display_name_offset.has_value()) {
        instance_builder.add_display_name(display_name_offset.value());
    }
    if (filename_offset.has_value()) {
        instance_builder.add_filename(filename_offset.value());
    }
    if (mime_type_offset.has_value()) {
        instance_builder.add_mime_type(mime_type_offset.value());
    }
    if (url_offset.has_value()) {
        instance_builder.add_url(url_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Document &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Document::Document()
    : display_name_(std::nullopt)
    , filename_(std::nullopt)
    , mime_type_(std::nullopt)
    , url_(std::nullopt) {
}

Document::Document(const std::vector<uint8_t> &bytes)
    : Document(::flatbuffers::GetSizePrefixedRoot<::Document>(bytes.data())) {
}

Document::Document(const ::Document *root) 
    : display_name_(std::nullopt)
    , filename_(std::nullopt)
    , mime_type_(std::nullopt)
    , url_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->display_name() != nullptr) {
        display_name_ = std::string(*root->display_name()->begin(), *root->display_name()->end());
    }
    if (root->filename() != nullptr) {
        filename_ = std::string(*root->filename()->begin(), *root->filename()->end());
    }
    if (root->mime_type() != nullptr) {
        mime_type_ = std::string(*root->mime_type()->begin(), *root->mime_type()->end());
    }
    if (root->url() != nullptr) {
        url_ = std::string(*root->url()->begin(), *root->url()->end());
    }
}

::flatbuffers::Offset<::Documents>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Documents &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Document>>>> documents_offset = std::nullopt;
    if (o.documents_.has_value()) {
        const auto &documents__var = o.documents_.value();
        std::vector<::flatbuffers::Offset<::Document>> documents_offsets = std::vector<::flatbuffers::Offset<::Document>>();
        documents_offsets.reserve(documents__var.size());
        for (const auto &i: documents__var) {
            documents_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Document>>> documents_offset_val = builder.CreateVector(documents_offsets);
        documents_offset = std::make_optional(documents_offset_val);
    }

    ::DocumentsBuilder instance_builder = ::DocumentsBuilder(builder);
    if (documents_offset.has_value()) {
        instance_builder.add_documents(documents_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Documents &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Documents::Documents()
    : documents_(std::nullopt) {
}

Documents::Documents(const std::vector<uint8_t> &bytes)
    : Documents(::flatbuffers::GetSizePrefixedRoot<::Documents>(bytes.data())) {
}

Documents::Documents(const ::Documents *root) 
    : documents_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &documents_vector = root->documents();
    if (documents_vector != nullptr) {
        decltype(documents_)::value_type documents__target = decltype(documents_)::value_type();
        documents__target.reserve(documents_vector->size());
        for (const auto &i: *documents_vector) {
            documents__target.emplace_back(i);
        }
        documents_ = std::make_optional(documents__target);
    }
}

::flatbuffers::Offset<::FloatAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const FloatAggregate &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<const ::FloatBucket *>>> histo_offset = std::nullopt;
    if (o.histo_.has_value()) {
        const auto &histo__var = o.histo_.value();
        std::vector<const ::FloatBucket *> histo_offsets = std::vector<const ::FloatBucket *>();
        histo_offsets.reserve(histo__var.size());
        for (size_t i = 0; i < histo__var.size(); ++i) {
            histo_offsets.push_back(reinterpret_cast<const ::FloatBucket *>(histo__var.data() + i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<const ::FloatBucket *>> histo_offset_val = builder.CreateVector(histo_offsets);
        histo_offset = std::make_optional(histo_offset_val);
    }

    ::FloatAggregateBuilder instance_builder = ::FloatAggregateBuilder(builder);
    instance_builder.add_count(o.count_);
    if (histo_offset.has_value()) {
        instance_builder.add_histo(histo_offset.value());
    }
    instance_builder.add_max(o.max_);
    instance_builder.add_mean(o.mean_);
    instance_builder.add_min(o.min_);
    instance_builder.add_sum(o.sum_);
    instance_builder.add_variance(o.variance_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const FloatAggregate &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

FloatAggregate::FloatAggregate()
    : count_(0)
    , histo_(std::nullopt)
    , max_(0)
    , mean_(0)
    , min_(0)
    , sum_(0)
    , variance_(0) {
}

FloatAggregate::FloatAggregate(const std::vector<uint8_t> &bytes)
    : FloatAggregate(::flatbuffers::GetSizePrefixedRoot<::FloatAggregate>(bytes.data())) {
}

FloatAggregate::FloatAggregate(const ::FloatAggregate *root) 
    : count_(0)
    , histo_(std::nullopt)
    , max_(0)
    , mean_(0)
    , min_(0)
    , sum_(0)
    , variance_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    count_ = root->count();
    const auto &histo_vector = root->histo();
    if (histo_vector != nullptr) {
        decltype(histo_)::value_type histo__target = decltype(histo_)::value_type();
        histo__target.reserve(histo_vector->size());
        for (const auto &i: *histo_vector) {
            histo__target.emplace_back(i);
        }
        histo_ = std::make_optional(histo__target);
    }
    max_ = root->max();
    mean_ = root->mean();
    min_ = root->min();
    sum_ = root->sum();
    variance_ = root->variance();
}

FloatBucket::FloatBucket()
    : count_(0)
    , max_(0) {
}

FloatBucket::FloatBucket(const ::FloatBucket *root) 
    : count_(0)
    , max_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    count_ = root->count();
    max_ = root->max();
}

::flatbuffers::Offset<::GeometryData>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GeometryData &o) {
    const std::pair<::flatbuffers::Offset<void>, ::GeometryDataUnion> data_offset = serialize_to(builder, o.data_);

    ::GeometryDataBuilder instance_builder = ::GeometryDataBuilder(builder);
    instance_builder.add_data(data_offset.first);
    instance_builder.add_data_type(data_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const GeometryData &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

GeometryData::GeometryData()
    : data_(std::make_shared<RawGeom>()) {
}

GeometryData::GeometryData(const std::vector<uint8_t> &bytes)
    : GeometryData(::flatbuffers::GetSizePrefixedRoot<::GeometryData>(bytes.data())) {
}

GeometryData::GeometryData(const ::GeometryData *root) 
    : data_(std::make_shared<RawGeom>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->data() != nullptr) {
        switch (root->data_type()) {
            case ::GeometryDataUnion::NONE: throw std::runtime_error("unexpected none variant");
            case ::GeometryDataUnion::RawGeom: {
                const auto data__local = static_cast<const ::RawGeom *>(root->data());
                std::shared_ptr<RawGeom> data__shared = std::make_shared<RawGeom>(data__local);
                data_ = data__shared;
                break;
            }
            case ::GeometryDataUnion::NodeIdPair: {
                const auto data__local = static_cast<const ::NodeIdPair *>(root->data());
                std::shared_ptr<NodeIdPair> data__shared = std::make_shared<NodeIdPair>(data__local);
                data_ = data__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

::flatbuffers::Offset<::HierarchicalRelationship>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const HierarchicalRelationship &o) {
    std::optional<decltype(builder.CreateVector(o.children_.value()))> children_offset = std::nullopt;
    if (o.children_.has_value()) {
        const decltype(builder.CreateVector(o.children_.value())) children_offset_val = builder.CreateVector(o.children_.value());
        children_offset = std::make_optional(children_offset_val);
    }

    ::HierarchicalRelationshipBuilder instance_builder = ::HierarchicalRelationshipBuilder(builder);
    if (children_offset.has_value()) {
        instance_builder.add_children(children_offset.value());
    }
    instance_builder.add_parent(o.parent_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const HierarchicalRelationship &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

HierarchicalRelationship::HierarchicalRelationship()
    : children_(std::nullopt)
    , parent_(0) {
}

HierarchicalRelationship::HierarchicalRelationship(const std::vector<uint8_t> &bytes)
    : HierarchicalRelationship(::flatbuffers::GetSizePrefixedRoot<::HierarchicalRelationship>(bytes.data())) {
}

HierarchicalRelationship::HierarchicalRelationship(const ::HierarchicalRelationship *root) 
    : children_(std::nullopt)
    , parent_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &children_vector = root->children();
    if (children_vector != nullptr) {
        decltype(children_)::value_type children__target = decltype(children_)::value_type();
        std::copy(children_vector->begin(), children_vector->end(), std::back_inserter(children__target));
        children_ = std::make_optional(children__target);
    }
    parent_ = root->parent();
}

::flatbuffers::Offset<::IntAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const IntAggregate &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<const ::UIntBucket *>>> histo_offset = std::nullopt;
    if (o.histo_.has_value()) {
        const auto &histo__var = o.histo_.value();
        std::vector<const ::UIntBucket *> histo_offsets = std::vector<const ::UIntBucket *>();
        histo_offsets.reserve(histo__var.size());
        for (size_t i = 0; i < histo__var.size(); ++i) {
            histo_offsets.push_back(reinterpret_cast<const ::UIntBucket *>(histo__var.data() + i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<const ::UIntBucket *>> histo_offset_val = builder.CreateVector(histo_offsets);
        histo_offset = std::make_optional(histo_offset_val);
    }

    ::IntAggregateBuilder instance_builder = ::IntAggregateBuilder(builder);
    instance_builder.add_count(o.count_);
    if (histo_offset.has_value()) {
        instance_builder.add_histo(histo_offset.value());
    }
    instance_builder.add_max(o.max_);
    instance_builder.add_mean(o.mean_);
    instance_builder.add_min(o.min_);
    instance_builder.add_sum(o.sum_);
    instance_builder.add_variance(o.variance_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const IntAggregate &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

IntAggregate::IntAggregate()
    : count_(0)
    , histo_(std::nullopt)
    , max_(0)
    , mean_(0)
    , min_(0)
    , sum_(0)
    , variance_(0) {
}

IntAggregate::IntAggregate(const std::vector<uint8_t> &bytes)
    : IntAggregate(::flatbuffers::GetSizePrefixedRoot<::IntAggregate>(bytes.data())) {
}

IntAggregate::IntAggregate(const ::IntAggregate *root) 
    : count_(0)
    , histo_(std::nullopt)
    , max_(0)
    , mean_(0)
    , min_(0)
    , sum_(0)
    , variance_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    count_ = root->count();
    const auto &histo_vector = root->histo();
    if (histo_vector != nullptr) {
        decltype(histo_)::value_type histo__target = decltype(histo_)::value_type();
        histo__target.reserve(histo_vector->size());
        for (const auto &i: *histo_vector) {
            histo__target.emplace_back(i);
        }
        histo_ = std::make_optional(histo__target);
    }
    max_ = root->max();
    mean_ = root->mean();
    min_ = root->min();
    sum_ = root->sum();
    variance_ = root->variance();
}

IntBucket::IntBucket()
    : count_(0)
    , max_(0) {
}

IntBucket::IntBucket(const ::IntBucket *root) 
    : count_(0)
    , max_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    count_ = root->count();
    max_ = root->max();
}

::flatbuffers::Offset<::IntegerDisplayString>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const IntegerDisplayString &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> display_name_offset = builder.CreateString(o.display_name_);

    ::IntegerDisplayStringBuilder instance_builder = ::IntegerDisplayStringBuilder(builder);
    instance_builder.add_display_name(display_name_offset);
    instance_builder.add_value(o.value_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const IntegerDisplayString &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

IntegerDisplayString::IntegerDisplayString()
    : display_name_()
    , value_(0) {
}

IntegerDisplayString::IntegerDisplayString(const std::vector<uint8_t> &bytes)
    : IntegerDisplayString(::flatbuffers::GetSizePrefixedRoot<::IntegerDisplayString>(bytes.data())) {
}

IntegerDisplayString::IntegerDisplayString(const ::IntegerDisplayString *root) 
    : display_name_()
    , value_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        display_name_ = std::string(*root->display_name()->begin(), *root->display_name()->end());
    value_ = root->value();
}

::flatbuffers::Offset<::Metadata>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Metadata &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> description_offset = std::nullopt;
    if (o.description_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> description_offset_val = builder.CreateString(o.description_.value());
        description_offset = std::make_optional(description_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> display_name_offset = std::nullopt;
    if (o.display_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> display_name_offset_val = builder.CreateString(o.display_name_.value());
        display_name_offset = std::make_optional(display_name_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::UlFieldRelationship>>>> field_relationships_offset = std::nullopt;
    if (o.field_relationships_.has_value()) {
        const auto &field_relationships__var = o.field_relationships_.value();
        std::vector<::flatbuffers::Offset<::UlFieldRelationship>> field_relationships_offsets = std::vector<::flatbuffers::Offset<::UlFieldRelationship>>();
        field_relationships_offsets.reserve(field_relationships__var.size());
        for (const auto &i: field_relationships__var) {
            field_relationships_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::UlFieldRelationship>>> field_relationships_offset_val = builder.CreateVector(field_relationships_offsets);
        field_relationships_offset = std::make_optional(field_relationships_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::UlField>>>> fields_offset = std::nullopt;
    if (o.fields_.has_value()) {
        const auto &fields__var = o.fields_.value();
        std::vector<::flatbuffers::Offset<::UlField>> fields_offsets = std::vector<::flatbuffers::Offset<::UlField>>();
        fields_offsets.reserve(fields__var.size());
        for (const auto &i: fields__var) {
            fields_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::UlField>>> fields_offset_val = builder.CreateVector(fields_offsets);
        fields_offset = std::make_optional(fields_offset_val);
    }
    std::optional<std::pair<::flatbuffers::Offset<void>, ::GeometrySource>> geometry_source_offset = std::nullopt;
    if (o.geometry_source_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::GeometrySource> geometry_source_offset_val = serialize_to(builder, o.geometry_source_.value());
        geometry_source_offset = std::make_optional(geometry_source_offset_val);
    }
    std::optional<::flatbuffers::Offset<::DatasetSource>> source_offset = std::nullopt;
    if (o.source_.has_value()) {
        const ::flatbuffers::Offset<::DatasetSource> source_offset_val = serialize_to(builder, o.source_.value());
        source_offset = std::make_optional(source_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.summary_.value()))> summary_offset = std::nullopt;
    if (o.summary_.has_value()) {
        const decltype(builder.CreateVector(o.summary_.value())) summary_offset_val = builder.CreateVector(o.summary_.value());
        summary_offset = std::make_optional(summary_offset_val);
    }

    ::MetadataBuilder instance_builder = ::MetadataBuilder(builder);
    instance_builder.add_area_selection(o.area_selection_);
    instance_builder.add_dataset_category(o.dataset_category_);
    if (description_offset.has_value()) {
        instance_builder.add_description(description_offset.value());
    }
    if (display_name_offset.has_value()) {
        instance_builder.add_display_name(display_name_offset.value());
    }
    instance_builder.add_do_not_filter_geometry_by_viewport(o.do_not_filter_geometry_by_viewport_);
    instance_builder.add_entity_ty(o.entity_ty_);
    if (field_relationships_offset.has_value()) {
        instance_builder.add_field_relationships(field_relationships_offset.value());
    }
    if (fields_offset.has_value()) {
        instance_builder.add_fields(fields_offset.value());
    }
    if (geometry_source_offset.has_value()) {
        const auto geometry_source_opt = geometry_source_offset.value();
        instance_builder.add_geometry_source(geometry_source_opt.first);
        instance_builder.add_geometry_source_type(geometry_source_opt.second);
    }
    instance_builder.add_location_description_field(o.location_description_field_);
    if (source_offset.has_value()) {
        instance_builder.add_source(source_offset.value());
    }
    if (summary_offset.has_value()) {
        instance_builder.add_summary(summary_offset.value());
    }
    instance_builder.add_update_cadence(o.update_cadence_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Metadata &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Metadata::Metadata()
    : area_selection_(false)
    , dataset_category_(DatasetCategory(4294967295))
    , description_(std::nullopt)
    , display_name_(std::nullopt)
    , do_not_filter_geometry_by_viewport_(false)
    , entity_ty_(EntityTy(0))
    , field_relationships_(std::nullopt)
    , fields_(std::nullopt)
    , geometry_source_(std::nullopt)
    , location_description_field_(-1)
    , source_(std::nullopt)
    , summary_(std::nullopt)
    , update_cadence_(UpdateCadence(0)) {
}

Metadata::Metadata(const std::vector<uint8_t> &bytes)
    : Metadata(::flatbuffers::GetSizePrefixedRoot<::Metadata>(bytes.data())) {
}

Metadata::Metadata(const ::Metadata *root) 
    : area_selection_(false)
    , dataset_category_(DatasetCategory(4294967295))
    , description_(std::nullopt)
    , display_name_(std::nullopt)
    , do_not_filter_geometry_by_viewport_(false)
    , entity_ty_(EntityTy(0))
    , field_relationships_(std::nullopt)
    , fields_(std::nullopt)
    , geometry_source_(std::nullopt)
    , location_description_field_(-1)
    , source_(std::nullopt)
    , summary_(std::nullopt)
    , update_cadence_(UpdateCadence(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    area_selection_ = root->area_selection();
    dataset_category_ = root->dataset_category();
    if (root->description() != nullptr) {
        description_ = std::string(*root->description()->begin(), *root->description()->end());
    }
    if (root->display_name() != nullptr) {
        display_name_ = std::string(*root->display_name()->begin(), *root->display_name()->end());
    }
    do_not_filter_geometry_by_viewport_ = root->do_not_filter_geometry_by_viewport();
    entity_ty_ = root->entity_ty();
    const auto &field_relationships_vector = root->field_relationships();
    if (field_relationships_vector != nullptr) {
        decltype(field_relationships_)::value_type field_relationships__target = decltype(field_relationships_)::value_type();
        field_relationships__target.reserve(field_relationships_vector->size());
        for (const auto &i: *field_relationships_vector) {
            field_relationships__target.emplace_back(i);
        }
        field_relationships_ = std::make_optional(field_relationships__target);
    }
    const auto &fields_vector = root->fields();
    if (fields_vector != nullptr) {
        decltype(fields_)::value_type fields__target = decltype(fields_)::value_type();
        fields__target.reserve(fields_vector->size());
        for (const auto &i: *fields_vector) {
            fields__target.emplace_back(i);
        }
        fields_ = std::make_optional(fields__target);
    }
    if (root->geometry_source() != nullptr) {
        switch (root->geometry_source_type()) {
            case ::GeometrySource::NONE: throw std::runtime_error("unexpected none variant");
            case ::GeometrySource::NoGeometry: {
                const auto geometry_source__local = static_cast<const ::NoGeometry *>(root->geometry_source());
                std::shared_ptr<NoGeometry> geometry_source__shared = std::make_shared<NoGeometry>(geometry_source__local);
                geometry_source_ = geometry_source__shared;
                break;
            }
            case ::GeometrySource::DatacatalogGeometry: {
                const auto geometry_source__local = static_cast<const ::DatacatalogGeometry *>(root->geometry_source());
                std::shared_ptr<DatacatalogGeometry> geometry_source__shared = std::make_shared<DatacatalogGeometry>(geometry_source__local);
                geometry_source_ = geometry_source__shared;
                break;
            }
            case ::GeometrySource::WorldGraphGeometry: {
                const auto geometry_source__local = static_cast<const ::WorldGraphGeometry *>(root->geometry_source());
                std::shared_ptr<WorldGraphGeometry> geometry_source__shared = std::make_shared<WorldGraphGeometry>(geometry_source__local);
                geometry_source_ = geometry_source__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    location_description_field_ = root->location_description_field();
    if (root->source() != nullptr) {
        source_ = decltype(source_)(root->source());
    }
    const auto &summary_vector = root->summary();
    if (summary_vector != nullptr) {
        decltype(summary_)::value_type summary__target = decltype(summary_)::value_type();
        std::copy(summary_vector->begin(), summary_vector->end(), std::back_inserter(summary__target));
        summary_ = std::make_optional(summary__target);
    }
    update_cadence_ = root->update_cadence();
}

::flatbuffers::Offset<::NestedCategoryRelationshipNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedCategoryRelationshipNode &o) {
    std::optional<decltype(builder.CreateVector(o.child_columns_.value()))> child_columns_offset = std::nullopt;
    if (o.child_columns_.has_value()) {
        const decltype(builder.CreateVector(o.child_columns_.value())) child_columns_offset_val = builder.CreateVector(o.child_columns_.value());
        child_columns_offset = std::make_optional(child_columns_offset_val);
    }

    ::NestedCategoryRelationshipNodeBuilder instance_builder = ::NestedCategoryRelationshipNodeBuilder(builder);
    if (child_columns_offset.has_value()) {
        instance_builder.add_child_columns(child_columns_offset.value());
    }
    instance_builder.add_column(o.column_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NestedCategoryRelationshipNode &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NestedCategoryRelationshipNode::NestedCategoryRelationshipNode()
    : child_columns_(std::nullopt)
    , column_(0) {
}

NestedCategoryRelationshipNode::NestedCategoryRelationshipNode(const std::vector<uint8_t> &bytes)
    : NestedCategoryRelationshipNode(::flatbuffers::GetSizePrefixedRoot<::NestedCategoryRelationshipNode>(bytes.data())) {
}

NestedCategoryRelationshipNode::NestedCategoryRelationshipNode(const ::NestedCategoryRelationshipNode *root) 
    : child_columns_(std::nullopt)
    , column_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &child_columns_vector = root->child_columns();
    if (child_columns_vector != nullptr) {
        decltype(child_columns_)::value_type child_columns__target = decltype(child_columns_)::value_type();
        std::copy(child_columns_vector->begin(), child_columns_vector->end(), std::back_inserter(child_columns__target));
        child_columns_ = std::make_optional(child_columns__target);
    }
    column_ = root->column();
}

::flatbuffers::Offset<::NestedHierarchyRelationshipNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedHierarchyRelationshipNode &o) {
    std::optional<decltype(builder.CreateVector(o.child_columns_.value()))> child_columns_offset = std::nullopt;
    if (o.child_columns_.has_value()) {
        const decltype(builder.CreateVector(o.child_columns_.value())) child_columns_offset_val = builder.CreateVector(o.child_columns_.value());
        child_columns_offset = std::make_optional(child_columns_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.child_nodes_.value()))> child_nodes_offset = std::nullopt;
    if (o.child_nodes_.has_value()) {
        const decltype(builder.CreateVector(o.child_nodes_.value())) child_nodes_offset_val = builder.CreateVector(o.child_nodes_.value());
        child_nodes_offset = std::make_optional(child_nodes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> label_offset = std::nullopt;
    if (o.label_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> label_offset_val = builder.CreateString(o.label_.value());
        label_offset = std::make_optional(label_offset_val);
    }

    ::NestedHierarchyRelationshipNodeBuilder instance_builder = ::NestedHierarchyRelationshipNodeBuilder(builder);
    if (child_columns_offset.has_value()) {
        instance_builder.add_child_columns(child_columns_offset.value());
    }
    if (child_nodes_offset.has_value()) {
        instance_builder.add_child_nodes(child_nodes_offset.value());
    }
    if (label_offset.has_value()) {
        instance_builder.add_label(label_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NestedHierarchyRelationshipNode &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NestedHierarchyRelationshipNode::NestedHierarchyRelationshipNode()
    : child_columns_(std::nullopt)
    , child_nodes_(std::nullopt)
    , label_(std::nullopt) {
}

NestedHierarchyRelationshipNode::NestedHierarchyRelationshipNode(const std::vector<uint8_t> &bytes)
    : NestedHierarchyRelationshipNode(::flatbuffers::GetSizePrefixedRoot<::NestedHierarchyRelationshipNode>(bytes.data())) {
}

NestedHierarchyRelationshipNode::NestedHierarchyRelationshipNode(const ::NestedHierarchyRelationshipNode *root) 
    : child_columns_(std::nullopt)
    , child_nodes_(std::nullopt)
    , label_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &child_columns_vector = root->child_columns();
    if (child_columns_vector != nullptr) {
        decltype(child_columns_)::value_type child_columns__target = decltype(child_columns_)::value_type();
        std::copy(child_columns_vector->begin(), child_columns_vector->end(), std::back_inserter(child_columns__target));
        child_columns_ = std::make_optional(child_columns__target);
    }
    const auto &child_nodes_vector = root->child_nodes();
    if (child_nodes_vector != nullptr) {
        decltype(child_nodes_)::value_type child_nodes__target = decltype(child_nodes_)::value_type();
        std::copy(child_nodes_vector->begin(), child_nodes_vector->end(), std::back_inserter(child_nodes__target));
        child_nodes_ = std::make_optional(child_nodes__target);
    }
    if (root->label() != nullptr) {
        label_ = std::string(*root->label()->begin(), *root->label()->end());
    }
}

::flatbuffers::Offset<::NestedStringCategoryNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const NestedStringCategoryNode &o) {
    std::vector<::flatbuffers::Offset<::flatbuffers::String>> child_values_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
    for (const auto &i: o.child_values_) {
        child_values_offsets.push_back(builder.CreateString(i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> child_values_offset = builder.CreateVector(child_values_offsets);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> value_offset = std::nullopt;
    if (o.value_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> value_offset_val = builder.CreateString(o.value_.value());
        value_offset = std::make_optional(value_offset_val);
    }

    ::NestedStringCategoryNodeBuilder instance_builder = ::NestedStringCategoryNodeBuilder(builder);
    instance_builder.add_child_values(child_values_offset);
    if (value_offset.has_value()) {
        instance_builder.add_value(value_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const NestedStringCategoryNode &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

NestedStringCategoryNode::NestedStringCategoryNode()
    : child_values_()
    , value_(std::nullopt) {
}

NestedStringCategoryNode::NestedStringCategoryNode(const std::vector<uint8_t> &bytes)
    : NestedStringCategoryNode(::flatbuffers::GetSizePrefixedRoot<::NestedStringCategoryNode>(bytes.data())) {
}

NestedStringCategoryNode::NestedStringCategoryNode(const ::NestedStringCategoryNode *root) 
    : child_values_()
    , value_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &child_values_vector = root->child_values();
    if (child_values_vector != nullptr) {
        child_values_.reserve(child_values_vector->size());
        for (const auto &i: *child_values_vector) {
            child_values_.emplace_back(i->begin(), i->end());
        }
    }
    if (root->value() != nullptr) {
        value_ = std::string(*root->value()->begin(), *root->value()->end());
    }
}

::flatbuffers::Offset<::StringAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const StringAggregate &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> str_offset = std::nullopt;
    if (o.str_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> str_offset_val = builder.CreateString(o.str_.value());
        str_offset = std::make_optional(str_offset_val);
    }

    ::StringAggregateBuilder instance_builder = ::StringAggregateBuilder(builder);
    instance_builder.add_count(o.count_);
    if (str_offset.has_value()) {
        instance_builder.add_str(str_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const StringAggregate &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

StringAggregate::StringAggregate()
    : count_(0)
    , str_(std::nullopt) {
}

StringAggregate::StringAggregate(const std::vector<uint8_t> &bytes)
    : StringAggregate(::flatbuffers::GetSizePrefixedRoot<::StringAggregate>(bytes.data())) {
}

StringAggregate::StringAggregate(const ::StringAggregate *root) 
    : count_(0)
    , str_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    count_ = root->count();
    if (root->str() != nullptr) {
        str_ = std::string(*root->str()->begin(), *root->str()->end());
    }
}

::flatbuffers::Offset<::TimeInterval>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const TimeInterval &o) {

    ::TimeIntervalBuilder instance_builder = ::TimeIntervalBuilder(builder);
    instance_builder.add_max(o.max_);
    instance_builder.add_min(o.min_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const TimeInterval &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

TimeInterval::TimeInterval()
    : max_(0)
    , min_(0) {
}

TimeInterval::TimeInterval(const std::vector<uint8_t> &bytes)
    : TimeInterval(::flatbuffers::GetSizePrefixedRoot<::TimeInterval>(bytes.data())) {
}

TimeInterval::TimeInterval(const ::TimeInterval *root) 
    : max_(0)
    , min_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    max_ = root->max();
    min_ = root->min();
}

::flatbuffers::Offset<::UIntAggregate>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UIntAggregate &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<const ::UIntBucket *>>> histo_offset = std::nullopt;
    if (o.histo_.has_value()) {
        const auto &histo__var = o.histo_.value();
        std::vector<const ::UIntBucket *> histo_offsets = std::vector<const ::UIntBucket *>();
        histo_offsets.reserve(histo__var.size());
        for (size_t i = 0; i < histo__var.size(); ++i) {
            histo_offsets.push_back(reinterpret_cast<const ::UIntBucket *>(histo__var.data() + i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<const ::UIntBucket *>> histo_offset_val = builder.CreateVector(histo_offsets);
        histo_offset = std::make_optional(histo_offset_val);
    }

    ::UIntAggregateBuilder instance_builder = ::UIntAggregateBuilder(builder);
    instance_builder.add_count(o.count_);
    if (histo_offset.has_value()) {
        instance_builder.add_histo(histo_offset.value());
    }
    instance_builder.add_max(o.max_);
    instance_builder.add_mean(o.mean_);
    instance_builder.add_min(o.min_);
    instance_builder.add_sum(o.sum_);
    instance_builder.add_variance(o.variance_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UIntAggregate &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UIntAggregate::UIntAggregate()
    : count_(0)
    , histo_(std::nullopt)
    , max_(0)
    , mean_(0)
    , min_(0)
    , sum_(0)
    , variance_(0) {
}

UIntAggregate::UIntAggregate(const std::vector<uint8_t> &bytes)
    : UIntAggregate(::flatbuffers::GetSizePrefixedRoot<::UIntAggregate>(bytes.data())) {
}

UIntAggregate::UIntAggregate(const ::UIntAggregate *root) 
    : count_(0)
    , histo_(std::nullopt)
    , max_(0)
    , mean_(0)
    , min_(0)
    , sum_(0)
    , variance_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    count_ = root->count();
    const auto &histo_vector = root->histo();
    if (histo_vector != nullptr) {
        decltype(histo_)::value_type histo__target = decltype(histo_)::value_type();
        histo__target.reserve(histo_vector->size());
        for (const auto &i: *histo_vector) {
            histo__target.emplace_back(i);
        }
        histo_ = std::make_optional(histo__target);
    }
    max_ = root->max();
    mean_ = root->mean();
    min_ = root->min();
    sum_ = root->sum();
    variance_ = root->variance();
}

UIntBucket::UIntBucket()
    : count_(0)
    , max_(0) {
}

UIntBucket::UIntBucket(const ::UIntBucket *root) 
    : count_(0)
    , max_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    count_ = root->count();
    max_ = root->max();
}

::flatbuffers::Offset<::UlField>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UlField &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> breakdown_display_name_offset = std::nullopt;
    if (o.breakdown_display_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> breakdown_display_name_offset_val = builder.CreateString(o.breakdown_display_name_.value());
        breakdown_display_name_offset = std::make_optional(breakdown_display_name_offset_val);
    }
    std::optional<std::pair<::flatbuffers::Offset<void>, ::ComponentData>> component_data_offset = std::nullopt;
    if (o.component_data_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::ComponentData> component_data_offset_val = serialize_to(builder, o.component_data_.value());
        component_data_offset = std::make_optional(component_data_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ValueInstance>> default__offset = std::nullopt;
    if (o.default_.has_value()) {
        const ::flatbuffers::Offset<::ValueInstance> default__offset_val = serialize_to(builder, o.default_.value());
        default__offset = std::make_optional(default__offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> description_offset = std::nullopt;
    if (o.description_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> description_offset_val = builder.CreateString(o.description_.value());
        description_offset = std::make_optional(description_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> display_name_offset = std::nullopt;
    if (o.display_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> display_name_offset_val = builder.CreateString(o.display_name_.value());
        display_name_offset = std::make_optional(display_name_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> field_name_offset = std::nullopt;
    if (o.field_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> field_name_offset_val = builder.CreateString(o.field_name_.value());
        field_name_offset = std::make_optional(field_name_offset_val);
    }
    std::optional<std::pair<::flatbuffers::Offset<void>, ::Type>> storage_type_offset = std::nullopt;
    if (o.storage_type_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::Type> storage_type_offset_val = serialize_to(builder, o.storage_type_.value());
        storage_type_offset = std::make_optional(storage_type_offset_val);
    }

    ::UlFieldBuilder instance_builder = ::UlFieldBuilder(builder);
    if (breakdown_display_name_offset.has_value()) {
        instance_builder.add_breakdown_display_name(breakdown_display_name_offset.value());
    }
    if (component_data_offset.has_value()) {
        const auto component_data_opt = component_data_offset.value();
        instance_builder.add_component_data(component_data_opt.first);
        instance_builder.add_component_data_type(component_data_opt.second);
    }
    if (default__offset.has_value()) {
        instance_builder.add_default_(default__offset.value());
    }
    if (description_offset.has_value()) {
        instance_builder.add_description(description_offset.value());
    }
    if (display_name_offset.has_value()) {
        instance_builder.add_display_name(display_name_offset.value());
    }
    if (field_name_offset.has_value()) {
        instance_builder.add_field_name(field_name_offset.value());
    }
    instance_builder.add_field_type(o.field_type_);
    instance_builder.add_flags(o.flags_);
    if (storage_type_offset.has_value()) {
        const auto storage_type_opt = storage_type_offset.value();
        instance_builder.add_storage_type(storage_type_opt.first);
        instance_builder.add_storage_type_type(storage_type_opt.second);
    }
    instance_builder.add_unit(o.unit_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UlField &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UlField::UlField()
    : breakdown_display_name_(std::nullopt)
    , component_data_(std::nullopt)
    , default_(std::nullopt)
    , description_(std::nullopt)
    , display_name_(std::nullopt)
    , field_name_(std::nullopt)
    , field_type_(UlFieldType(0))
    , flags_(0)
    , storage_type_(std::nullopt)
    , unit_(FieldUnit(0)) {
}

UlField::UlField(const std::vector<uint8_t> &bytes)
    : UlField(::flatbuffers::GetSizePrefixedRoot<::UlField>(bytes.data())) {
}

UlField::UlField(const ::UlField *root) 
    : breakdown_display_name_(std::nullopt)
    , component_data_(std::nullopt)
    , default_(std::nullopt)
    , description_(std::nullopt)
    , display_name_(std::nullopt)
    , field_name_(std::nullopt)
    , field_type_(UlFieldType(0))
    , flags_(0)
    , storage_type_(std::nullopt)
    , unit_(FieldUnit(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->breakdown_display_name() != nullptr) {
        breakdown_display_name_ = std::string(*root->breakdown_display_name()->begin(), *root->breakdown_display_name()->end());
    }
    if (root->component_data() != nullptr) {
        switch (root->component_data_type()) {
            case ::ComponentData::NONE: throw std::runtime_error("unexpected none variant");
            case ::ComponentData::StringCategories: {
                const auto component_data__local = static_cast<const ::StringCategories *>(root->component_data());
                std::shared_ptr<StringCategories> component_data__shared = std::make_shared<StringCategories>(component_data__local);
                component_data_ = component_data__shared;
                break;
            }
            case ::ComponentData::IntRange: {
                const auto component_data__local = static_cast<const ::IntRange *>(root->component_data());
                std::shared_ptr<IntRange> component_data__shared = std::make_shared<IntRange>(component_data__local);
                component_data_ = component_data__shared;
                break;
            }
            case ::ComponentData::FloatRange: {
                const auto component_data__local = static_cast<const ::FloatRange *>(root->component_data());
                std::shared_ptr<FloatRange> component_data__shared = std::make_shared<FloatRange>(component_data__local);
                component_data_ = component_data__shared;
                break;
            }
            case ::ComponentData::DatetimeRange: {
                const auto component_data__local = static_cast<const ::DatetimeRange *>(root->component_data());
                std::shared_ptr<DatetimeRange> component_data__shared = std::make_shared<DatetimeRange>(component_data__local);
                component_data_ = component_data__shared;
                break;
            }
            case ::ComponentData::Dates: {
                const auto component_data__local = static_cast<const ::Dates *>(root->component_data());
                std::shared_ptr<Dates> component_data__shared = std::make_shared<Dates>(component_data__local);
                component_data_ = component_data__shared;
                break;
            }
            case ::ComponentData::NestedStringCategories: {
                const auto component_data__local = static_cast<const ::NestedStringCategories *>(root->component_data());
                std::shared_ptr<NestedStringCategories> component_data__shared = std::make_shared<NestedStringCategories>(component_data__local);
                component_data_ = component_data__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    if (root->default_() != nullptr) {
        default_ = decltype(default_)(root->default_());
    }
    if (root->description() != nullptr) {
        description_ = std::string(*root->description()->begin(), *root->description()->end());
    }
    if (root->display_name() != nullptr) {
        display_name_ = std::string(*root->display_name()->begin(), *root->display_name()->end());
    }
    if (root->field_name() != nullptr) {
        field_name_ = std::string(*root->field_name()->begin(), *root->field_name()->end());
    }
    field_type_ = root->field_type();
    flags_ = root->flags();
    if (root->storage_type() != nullptr) {
        switch (root->storage_type_type()) {
            case ::Type::NONE: throw std::runtime_error("unexpected none variant");
            case ::Type::Null: {
                const auto storage_type__local = static_cast<const ::Null *>(root->storage_type());
                std::shared_ptr<Null> storage_type__shared = std::make_shared<Null>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Int: {
                const auto storage_type__local = static_cast<const ::Int *>(root->storage_type());
                std::shared_ptr<Int> storage_type__shared = std::make_shared<Int>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::FloatingPoint: {
                const auto storage_type__local = static_cast<const ::FloatingPoint *>(root->storage_type());
                std::shared_ptr<FloatingPoint> storage_type__shared = std::make_shared<FloatingPoint>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Binary: {
                const auto storage_type__local = static_cast<const ::Binary *>(root->storage_type());
                std::shared_ptr<Binary> storage_type__shared = std::make_shared<Binary>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Utf8: {
                const auto storage_type__local = static_cast<const ::Utf8 *>(root->storage_type());
                std::shared_ptr<Utf8> storage_type__shared = std::make_shared<Utf8>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Bool: {
                const auto storage_type__local = static_cast<const ::Bool *>(root->storage_type());
                std::shared_ptr<Bool> storage_type__shared = std::make_shared<Bool>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Decimal: {
                const auto storage_type__local = static_cast<const ::Decimal *>(root->storage_type());
                std::shared_ptr<Decimal> storage_type__shared = std::make_shared<Decimal>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Date: {
                const auto storage_type__local = static_cast<const ::Date *>(root->storage_type());
                std::shared_ptr<Date> storage_type__shared = std::make_shared<Date>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Time: {
                const auto storage_type__local = static_cast<const ::Time *>(root->storage_type());
                std::shared_ptr<Time> storage_type__shared = std::make_shared<Time>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Timestamp: {
                const auto storage_type__local = static_cast<const ::Timestamp *>(root->storage_type());
                std::shared_ptr<Timestamp> storage_type__shared = std::make_shared<Timestamp>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Interval: {
                const auto storage_type__local = static_cast<const ::Interval *>(root->storage_type());
                std::shared_ptr<Interval> storage_type__shared = std::make_shared<Interval>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::List: {
                const auto storage_type__local = static_cast<const ::List *>(root->storage_type());
                std::shared_ptr<List> storage_type__shared = std::make_shared<List>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Struct_: {
                const auto storage_type__local = static_cast<const ::Struct_ *>(root->storage_type());
                std::shared_ptr<Struct_> storage_type__shared = std::make_shared<Struct_>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Union: {
                const auto storage_type__local = static_cast<const ::Union *>(root->storage_type());
                std::shared_ptr<Union> storage_type__shared = std::make_shared<Union>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::FixedSizeBinary: {
                const auto storage_type__local = static_cast<const ::FixedSizeBinary *>(root->storage_type());
                std::shared_ptr<FixedSizeBinary> storage_type__shared = std::make_shared<FixedSizeBinary>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::FixedSizeList: {
                const auto storage_type__local = static_cast<const ::FixedSizeList *>(root->storage_type());
                std::shared_ptr<FixedSizeList> storage_type__shared = std::make_shared<FixedSizeList>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Map: {
                const auto storage_type__local = static_cast<const ::Map *>(root->storage_type());
                std::shared_ptr<Map> storage_type__shared = std::make_shared<Map>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::Duration: {
                const auto storage_type__local = static_cast<const ::Duration *>(root->storage_type());
                std::shared_ptr<Duration> storage_type__shared = std::make_shared<Duration>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::LargeBinary: {
                const auto storage_type__local = static_cast<const ::LargeBinary *>(root->storage_type());
                std::shared_ptr<LargeBinary> storage_type__shared = std::make_shared<LargeBinary>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::LargeUtf8: {
                const auto storage_type__local = static_cast<const ::LargeUtf8 *>(root->storage_type());
                std::shared_ptr<LargeUtf8> storage_type__shared = std::make_shared<LargeUtf8>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            case ::Type::LargeList: {
                const auto storage_type__local = static_cast<const ::LargeList *>(root->storage_type());
                std::shared_ptr<LargeList> storage_type__shared = std::make_shared<LargeList>(storage_type__local);
                storage_type_ = storage_type__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    unit_ = root->unit();
}

::flatbuffers::Offset<::UlFieldRelationship>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const UlFieldRelationship &o) {
    std::optional<std::pair<::flatbuffers::Offset<void>, ::UlFieldRelationshipData>> relationship_data_offset = std::nullopt;
    if (o.relationship_data_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::UlFieldRelationshipData> relationship_data_offset_val = serialize_to(builder, o.relationship_data_.value());
        relationship_data_offset = std::make_optional(relationship_data_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> relationship_display_name_offset = std::nullopt;
    if (o.relationship_display_name_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> relationship_display_name_offset_val = builder.CreateString(o.relationship_display_name_.value());
        relationship_display_name_offset = std::make_optional(relationship_display_name_offset_val);
    }

    ::UlFieldRelationshipBuilder instance_builder = ::UlFieldRelationshipBuilder(builder);
    if (relationship_data_offset.has_value()) {
        const auto relationship_data_opt = relationship_data_offset.value();
        instance_builder.add_relationship_data(relationship_data_opt.first);
        instance_builder.add_relationship_data_type(relationship_data_opt.second);
    }
    if (relationship_display_name_offset.has_value()) {
        instance_builder.add_relationship_display_name(relationship_display_name_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const UlFieldRelationship &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

UlFieldRelationship::UlFieldRelationship()
    : relationship_data_(std::nullopt)
    , relationship_display_name_(std::nullopt) {
}

UlFieldRelationship::UlFieldRelationship(const std::vector<uint8_t> &bytes)
    : UlFieldRelationship(::flatbuffers::GetSizePrefixedRoot<::UlFieldRelationship>(bytes.data())) {
}

UlFieldRelationship::UlFieldRelationship(const ::UlFieldRelationship *root) 
    : relationship_data_(std::nullopt)
    , relationship_display_name_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->relationship_data() != nullptr) {
        switch (root->relationship_data_type()) {
            case ::UlFieldRelationshipData::NONE: throw std::runtime_error("unexpected none variant");
            case ::UlFieldRelationshipData::HierarchyRelationshipData: {
                const auto relationship_data__local = static_cast<const ::HierarchyRelationshipData *>(root->relationship_data());
                std::shared_ptr<HierarchyRelationshipData> relationship_data__shared = std::make_shared<HierarchyRelationshipData>(relationship_data__local);
                relationship_data_ = relationship_data__shared;
                break;
            }
            case ::UlFieldRelationshipData::CategoryRelationshipData: {
                const auto relationship_data__local = static_cast<const ::CategoryRelationshipData *>(root->relationship_data());
                std::shared_ptr<CategoryRelationshipData> relationship_data__shared = std::make_shared<CategoryRelationshipData>(relationship_data__local);
                relationship_data_ = relationship_data__shared;
                break;
            }
            case ::UlFieldRelationshipData::NestedCategoryRelationshipData: {
                const auto relationship_data__local = static_cast<const ::NestedCategoryRelationshipData *>(root->relationship_data());
                std::shared_ptr<NestedCategoryRelationshipData> relationship_data__shared = std::make_shared<NestedCategoryRelationshipData>(relationship_data__local);
                relationship_data_ = relationship_data__shared;
                break;
            }
            case ::UlFieldRelationshipData::NestedHierarchyRelationshipData: {
                const auto relationship_data__local = static_cast<const ::NestedHierarchyRelationshipData *>(root->relationship_data());
                std::shared_ptr<NestedHierarchyRelationshipData> relationship_data__shared = std::make_shared<NestedHierarchyRelationshipData>(relationship_data__local);
                relationship_data_ = relationship_data__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    if (root->relationship_display_name() != nullptr) {
        relationship_display_name_ = std::string(*root->relationship_display_name()->begin(), *root->relationship_display_name()->end());
    }
}

} // namespace types
} // namespace ul
