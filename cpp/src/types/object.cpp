// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/object.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::DataCatalogObject>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DataCatalogObject &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::AttributePair>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::AttributePair>> attributes_offsets = std::vector<::flatbuffers::Offset<::AttributePair>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::AttributePair>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> comment_offset = std::nullopt;
    if (o.comment_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> comment_offset_val = builder.CreateString(o.comment_.value());
        comment_offset = std::make_optional(comment_offset_val);
    }
    const decltype(builder.CreateVector(o.obj_)) obj_offset = builder.CreateVector(o.obj_);
    std::vector<::flatbuffers::Offset<::ContentId>> parents_offsets = std::vector<::flatbuffers::Offset<::ContentId>>();
    parents_offsets.reserve(o.parents_.size());
    for (const auto &i: o.parents_) {
        parents_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ContentId>>> parents_offset = builder.CreateVector(parents_offsets);
    std::optional<decltype(builder.CreateVector(o.signature_.value()))> signature_offset = std::nullopt;
    if (o.signature_.has_value()) {
        const decltype(builder.CreateVector(o.signature_.value())) signature_offset_val = builder.CreateVector(o.signature_.value());
        signature_offset = std::make_optional(signature_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> tags_offset = std::nullopt;
    if (o.tags_.has_value()) {
        const auto &tags__var = o.tags_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> tags_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: tags__var) {
            tags_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags_offset_val = builder.CreateVector(tags_offsets);
        tags_offset = std::make_optional(tags_offset_val);
    }
    const ::flatbuffers::Offset<::B2cId> user_offset = serialize_to(builder, o.user_);

    ::DataCatalogObjectBuilder instance_builder = ::DataCatalogObjectBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    if (comment_offset.has_value()) {
        instance_builder.add_comment(comment_offset.value());
    }
    instance_builder.add_default_mode(o.default_mode_);
    instance_builder.add_flags(o.flags_);
    instance_builder.add_obj(obj_offset);
    instance_builder.add_parents(parents_offset);
    if (signature_offset.has_value()) {
        instance_builder.add_signature(signature_offset.value());
    }
    if (tags_offset.has_value()) {
        instance_builder.add_tags(tags_offset.value());
    }
    instance_builder.add_time(o.time_);
    instance_builder.add_ty(o.ty_);
    instance_builder.add_user(user_offset);
    instance_builder.add_version(o.version_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DataCatalogObject &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DataCatalogObject::DataCatalogObject()
    : attributes_(std::nullopt)
    , comment_(std::nullopt)
    , default_mode_(0)
    , flags_(0)
    , obj_()
    , parents_()
    , signature_(std::nullopt)
    , tags_(std::nullopt)
    , time_(0)
    , ty_(DataCatalogObjectTy(0))
    , user_()
    , version_(0) {
}

DataCatalogObject::DataCatalogObject(const std::vector<uint8_t> &bytes)
    : DataCatalogObject(::flatbuffers::GetSizePrefixedRoot<::DataCatalogObject>(bytes.data())) {
}

DataCatalogObject::DataCatalogObject(const ::DataCatalogObject *root) 
    : attributes_(std::nullopt)
    , comment_(std::nullopt)
    , default_mode_(0)
    , flags_(0)
    , obj_()
    , parents_()
    , signature_(std::nullopt)
    , tags_(std::nullopt)
    , time_(0)
    , ty_(DataCatalogObjectTy(0))
    , user_()
    , version_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    if (root->comment() != nullptr) {
        comment_ = std::string(*root->comment()->begin(), *root->comment()->end());
    }
    default_mode_ = root->default_mode();
    flags_ = root->flags();
    const auto &obj_vector = root->obj();
    if (obj_vector != nullptr) {
        std::copy(obj_vector->begin(), obj_vector->end(), std::back_inserter(obj_));
    }
    const auto &parents_vector = root->parents();
    if (parents_vector != nullptr) {
        parents_.reserve(parents_vector->size());
        for (const auto &i: *parents_vector) {
            parents_.emplace_back(i);
        }
    }
    const auto &signature_vector = root->signature();
    if (signature_vector != nullptr) {
        decltype(signature_)::value_type signature__target = decltype(signature_)::value_type();
        std::copy(signature_vector->begin(), signature_vector->end(), std::back_inserter(signature__target));
        signature_ = std::make_optional(signature__target);
    }
    const auto &tags_vector = root->tags();
    if (tags_vector != nullptr) {
        std::vector<std::string> tags__target = std::vector<std::string>();
        for (const auto &i: *tags_vector) {
            tags__target.emplace_back(i->begin(), i->end());
        }
        tags_ = std::make_optional(tags__target);
    }
    time_ = root->time();
    ty_ = root->ty();
    if (root->user() != nullptr) {
        user_ = decltype(user_)(root->user());
    }
    version_ = root->version();
}

::flatbuffers::Offset<::ObjectIdList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectIdList &o) {
    std::vector<::flatbuffers::Offset<::ObjectId>> ids_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
    ids_offsets.reserve(o.ids_.size());
    for (const auto &i: o.ids_) {
        ids_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> ids_offset = builder.CreateVector(ids_offsets);

    ::ObjectIdListBuilder instance_builder = ::ObjectIdListBuilder(builder);
    instance_builder.add_ids(ids_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ObjectIdList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ObjectIdList::ObjectIdList()
    : ids_() {
}

ObjectIdList::ObjectIdList(const std::vector<uint8_t> &bytes)
    : ObjectIdList(::flatbuffers::GetSizePrefixedRoot<::ObjectIdList>(bytes.data())) {
}

ObjectIdList::ObjectIdList(const ::ObjectIdList *root) 
    : ids_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &ids_vector = root->ids();
    if (ids_vector != nullptr) {
        ids_.reserve(ids_vector->size());
        for (const auto &i: *ids_vector) {
            ids_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::ObjectIdPair>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectIdPair &o) {
    const ::flatbuffers::Offset<::ObjectId> id_offset = serialize_to(builder, o.id_);
    std::optional<decltype(builder.CreateVector(o.object_.value()))> object_offset = std::nullopt;
    if (o.object_.has_value()) {
        const decltype(builder.CreateVector(o.object_.value())) object_offset_val = builder.CreateVector(o.object_.value());
        object_offset = std::make_optional(object_offset_val);
    }

    ::ObjectIdPairBuilder instance_builder = ::ObjectIdPairBuilder(builder);
    instance_builder.add_id(id_offset);
    if (object_offset.has_value()) {
        instance_builder.add_object(object_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ObjectIdPair &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ObjectIdPair::ObjectIdPair()
    : id_()
    , object_(std::nullopt) {
}

ObjectIdPair::ObjectIdPair(const std::vector<uint8_t> &bytes)
    : ObjectIdPair(::flatbuffers::GetSizePrefixedRoot<::ObjectIdPair>(bytes.data())) {
}

ObjectIdPair::ObjectIdPair(const ::ObjectIdPair *root) 
    : id_()
    , object_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    const auto &object_vector = root->object();
    if (object_vector != nullptr) {
        decltype(object_)::value_type object__target = decltype(object_)::value_type();
        std::copy(object_vector->begin(), object_vector->end(), std::back_inserter(object__target));
        object_ = std::make_optional(object__target);
    }
}

::flatbuffers::Offset<::ObjectIdPairList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectIdPairList &o) {
    std::vector<::flatbuffers::Offset<::ObjectIdPair>> pairs_offsets = std::vector<::flatbuffers::Offset<::ObjectIdPair>>();
    pairs_offsets.reserve(o.pairs_.size());
    for (const auto &i: o.pairs_) {
        pairs_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectIdPair>>> pairs_offset = builder.CreateVector(pairs_offsets);

    ::ObjectIdPairListBuilder instance_builder = ::ObjectIdPairListBuilder(builder);
    instance_builder.add_pairs(pairs_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ObjectIdPairList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ObjectIdPairList::ObjectIdPairList()
    : pairs_() {
}

ObjectIdPairList::ObjectIdPairList(const std::vector<uint8_t> &bytes)
    : ObjectIdPairList(::flatbuffers::GetSizePrefixedRoot<::ObjectIdPairList>(bytes.data())) {
}

ObjectIdPairList::ObjectIdPairList(const ::ObjectIdPairList *root) 
    : pairs_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &pairs_vector = root->pairs();
    if (pairs_vector != nullptr) {
        pairs_.reserve(pairs_vector->size());
        for (const auto &i: *pairs_vector) {
            pairs_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::ObjectSummary>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectSummary &o) {
    std::optional<::flatbuffers::Offset<::ObjectId>> acl_offset = std::nullopt;
    if (o.acl_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> acl_offset_val = serialize_to(builder, o.acl_.value());
        acl_offset = std::make_optional(acl_offset_val);
    }
    const ::flatbuffers::Offset<::ContentId> head_revision_offset = serialize_to(builder, o.head_revision_);
    const ::flatbuffers::Offset<::ObjectId> id_offset = serialize_to(builder, o.id_);

    ::ObjectSummaryBuilder instance_builder = ::ObjectSummaryBuilder(builder);
    if (acl_offset.has_value()) {
        instance_builder.add_acl(acl_offset.value());
    }
    instance_builder.add_drive_size(o.drive_size_);
    instance_builder.add_head_revision(head_revision_offset);
    instance_builder.add_id(id_offset);
    instance_builder.add_time(o.time_);
    instance_builder.add_ty(o.ty_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ObjectSummary &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ObjectSummary::ObjectSummary()
    : acl_(std::nullopt)
    , drive_size_(0)
    , head_revision_()
    , id_()
    , time_(0)
    , ty_(DataCatalogObjectTy(0)) {
}

ObjectSummary::ObjectSummary(const std::vector<uint8_t> &bytes)
    : ObjectSummary(::flatbuffers::GetSizePrefixedRoot<::ObjectSummary>(bytes.data())) {
}

ObjectSummary::ObjectSummary(const ::ObjectSummary *root) 
    : acl_(std::nullopt)
    , drive_size_(0)
    , head_revision_()
    , id_()
    , time_(0)
    , ty_(DataCatalogObjectTy(0)) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->acl() != nullptr) {
        acl_ = decltype(acl_)(root->acl());
    }
    drive_size_ = root->drive_size();
    if (root->head_revision() != nullptr) {
        head_revision_ = decltype(head_revision_)(root->head_revision());
    }
    if (root->id() != nullptr) {
        id_ = decltype(id_)(root->id());
    }
    time_ = root->time();
    ty_ = root->ty();
}

::flatbuffers::Offset<::ObjectSummaryList>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectSummaryList &o) {
    std::vector<::flatbuffers::Offset<::ObjectSummary>> pairs_offsets = std::vector<::flatbuffers::Offset<::ObjectSummary>>();
    pairs_offsets.reserve(o.pairs_.size());
    for (const auto &i: o.pairs_) {
        pairs_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectSummary>>> pairs_offset = builder.CreateVector(pairs_offsets);

    ::ObjectSummaryListBuilder instance_builder = ::ObjectSummaryListBuilder(builder);
    instance_builder.add_pairs(pairs_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ObjectSummaryList &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ObjectSummaryList::ObjectSummaryList()
    : pairs_() {
}

ObjectSummaryList::ObjectSummaryList(const std::vector<uint8_t> &bytes)
    : ObjectSummaryList(::flatbuffers::GetSizePrefixedRoot<::ObjectSummaryList>(bytes.data())) {
}

ObjectSummaryList::ObjectSummaryList(const ::ObjectSummaryList *root) 
    : pairs_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &pairs_vector = root->pairs();
    if (pairs_vector != nullptr) {
        pairs_.reserve(pairs_vector->size());
        for (const auto &i: *pairs_vector) {
            pairs_.emplace_back(i);
        }
    }
}

} // namespace types
} // namespace ul
