// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/stream.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::Stream>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Stream &o) {
    std::optional<decltype(builder.CreateVector(o.axes_.value()))> axes_offset = std::nullopt;
    if (o.axes_.has_value()) {
        const decltype(builder.CreateVector(o.axes_.value())) axes_offset_val = builder.CreateVector(o.axes_.value());
        axes_offset = std::make_optional(axes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ObjectId>> metadata_offset = std::nullopt;
    if (o.metadata_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> metadata_offset_val = serialize_to(builder, o.metadata_.value());
        metadata_offset = std::make_optional(metadata_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ContentId>> metadata_revision_offset = std::nullopt;
    if (o.metadata_revision_.has_value()) {
        const ::flatbuffers::Offset<::ContentId> metadata_revision_offset_val = serialize_to(builder, o.metadata_revision_.value());
        metadata_revision_offset = std::make_optional(metadata_revision_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.options_.value()))> options_offset = std::nullopt;
    if (o.options_.has_value()) {
        const decltype(builder.CreateVector(o.options_.value())) options_offset_val = builder.CreateVector(o.options_.value());
        options_offset = std::make_optional(options_offset_val);
    }
    std::optional<decltype(builder.CreateVector(o.parameters_.value()))> parameters_offset = std::nullopt;
    if (o.parameters_.has_value()) {
        const decltype(builder.CreateVector(o.parameters_.value())) parameters_offset_val = builder.CreateVector(o.parameters_.value());
        parameters_offset = std::make_optional(parameters_offset_val);
    }
    const ::flatbuffers::Offset<::Schema> schema_offset = serialize_to(builder, o.schema_);
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>>> substreams_offset = std::nullopt;
    if (o.substreams_.has_value()) {
        const auto &substreams__var = o.substreams_.value();
        std::vector<::flatbuffers::Offset<::ObjectId>> substreams_offsets = std::vector<::flatbuffers::Offset<::ObjectId>>();
        substreams_offsets.reserve(substreams__var.size());
        for (const auto &i: substreams__var) {
            substreams_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ObjectId>>> substreams_offset_val = builder.CreateVector(substreams_offsets);
        substreams_offset = std::make_optional(substreams_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> url_offset = builder.CreateString(o.url_);

    ::StreamBuilder instance_builder = ::StreamBuilder(builder);
    if (axes_offset.has_value()) {
        instance_builder.add_axes(axes_offset.value());
    }
    instance_builder.add_bucket_width(o.bucket_width_);
    instance_builder.add_flags(o.flags_);
    if (metadata_offset.has_value()) {
        instance_builder.add_metadata(metadata_offset.value());
    }
    if (metadata_revision_offset.has_value()) {
        instance_builder.add_metadata_revision(metadata_revision_offset.value());
    }
    if (options_offset.has_value()) {
        instance_builder.add_options(options_offset.value());
    }
    if (parameters_offset.has_value()) {
        instance_builder.add_parameters(parameters_offset.value());
    }
    instance_builder.add_schema(schema_offset);
    if (substreams_offset.has_value()) {
        instance_builder.add_substreams(substreams_offset.value());
    }
    instance_builder.add_url(url_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Stream &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Stream::Stream()
    : axes_(std::nullopt)
    , bucket_width_(0)
    , flags_(0)
    , metadata_(std::nullopt)
    , metadata_revision_(std::nullopt)
    , options_(std::nullopt)
    , parameters_(std::nullopt)
    , schema_()
    , substreams_(std::nullopt)
    , url_() {
}

Stream::Stream(const std::vector<uint8_t> &bytes)
    : Stream(::flatbuffers::GetSizePrefixedRoot<::Stream>(bytes.data())) {
}

Stream::Stream(const ::Stream *root) 
    : axes_(std::nullopt)
    , bucket_width_(0)
    , flags_(0)
    , metadata_(std::nullopt)
    , metadata_revision_(std::nullopt)
    , options_(std::nullopt)
    , parameters_(std::nullopt)
    , schema_()
    , substreams_(std::nullopt)
    , url_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &axes_vector = root->axes();
    if (axes_vector != nullptr) {
        decltype(axes_)::value_type axes__target = decltype(axes_)::value_type();
        std::copy(axes_vector->begin(), axes_vector->end(), std::back_inserter(axes__target));
        axes_ = std::make_optional(axes__target);
    }
    bucket_width_ = root->bucket_width();
    flags_ = root->flags();
    if (root->metadata() != nullptr) {
        metadata_ = decltype(metadata_)(root->metadata());
    }
    if (root->metadata_revision() != nullptr) {
        metadata_revision_ = decltype(metadata_revision_)(root->metadata_revision());
    }
    const auto &options_vector = root->options();
    if (options_vector != nullptr) {
        decltype(options_)::value_type options__target = decltype(options_)::value_type();
        std::copy(options_vector->begin(), options_vector->end(), std::back_inserter(options__target));
        options_ = std::make_optional(options__target);
    }
    const auto &parameters_vector = root->parameters();
    if (parameters_vector != nullptr) {
        decltype(parameters_)::value_type parameters__target = decltype(parameters_)::value_type();
        std::copy(parameters_vector->begin(), parameters_vector->end(), std::back_inserter(parameters__target));
        parameters_ = std::make_optional(parameters__target);
    }
    if (root->schema() != nullptr) {
        schema_ = decltype(schema_)(root->schema());
    }
    const auto &substreams_vector = root->substreams();
    if (substreams_vector != nullptr) {
        decltype(substreams_)::value_type substreams__target = decltype(substreams_)::value_type();
        substreams__target.reserve(substreams_vector->size());
        for (const auto &i: *substreams_vector) {
            substreams__target.emplace_back(i);
        }
        substreams_ = std::make_optional(substreams__target);
    }
        url_ = std::string(*root->url()->begin(), *root->url()->end());
}

} // namespace types
} // namespace ul
