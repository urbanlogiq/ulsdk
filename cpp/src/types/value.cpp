// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/value.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::Value>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Value &o) {
    if (std::holds_alternative<std::shared_ptr<VBool>>(o)) {
        const std::shared_ptr<VBool> &v = std::get<std::shared_ptr<VBool>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VBool);
    } else if (std::holds_alternative<std::shared_ptr<VUnit>>(o)) {
        const std::shared_ptr<VUnit> &v = std::get<std::shared_ptr<VUnit>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VUnit);
    } else if (std::holds_alternative<std::shared_ptr<VChar>>(o)) {
        const std::shared_ptr<VChar> &v = std::get<std::shared_ptr<VChar>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VChar);
    } else if (std::holds_alternative<std::shared_ptr<VNull>>(o)) {
        const std::shared_ptr<VNull> &v = std::get<std::shared_ptr<VNull>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VNull);
    } else if (std::holds_alternative<std::shared_ptr<VI8>>(o)) {
        const std::shared_ptr<VI8> &v = std::get<std::shared_ptr<VI8>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VI8);
    } else if (std::holds_alternative<std::shared_ptr<VU8>>(o)) {
        const std::shared_ptr<VU8> &v = std::get<std::shared_ptr<VU8>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VU8);
    } else if (std::holds_alternative<std::shared_ptr<VI16>>(o)) {
        const std::shared_ptr<VI16> &v = std::get<std::shared_ptr<VI16>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VI16);
    } else if (std::holds_alternative<std::shared_ptr<VU16>>(o)) {
        const std::shared_ptr<VU16> &v = std::get<std::shared_ptr<VU16>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VU16);
    } else if (std::holds_alternative<std::shared_ptr<VI32>>(o)) {
        const std::shared_ptr<VI32> &v = std::get<std::shared_ptr<VI32>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VI32);
    } else if (std::holds_alternative<std::shared_ptr<VU32>>(o)) {
        const std::shared_ptr<VU32> &v = std::get<std::shared_ptr<VU32>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VU32);
    } else if (std::holds_alternative<std::shared_ptr<VF32>>(o)) {
        const std::shared_ptr<VF32> &v = std::get<std::shared_ptr<VF32>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VF32);
    } else if (std::holds_alternative<std::shared_ptr<VIsize>>(o)) {
        const std::shared_ptr<VIsize> &v = std::get<std::shared_ptr<VIsize>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VIsize);
    } else if (std::holds_alternative<std::shared_ptr<VUsize>>(o)) {
        const std::shared_ptr<VUsize> &v = std::get<std::shared_ptr<VUsize>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VUsize);
    } else if (std::holds_alternative<std::shared_ptr<VI64>>(o)) {
        const std::shared_ptr<VI64> &v = std::get<std::shared_ptr<VI64>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VI64);
    } else if (std::holds_alternative<std::shared_ptr<VU64>>(o)) {
        const std::shared_ptr<VU64> &v = std::get<std::shared_ptr<VU64>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VU64);
    } else if (std::holds_alternative<std::shared_ptr<VF64>>(o)) {
        const std::shared_ptr<VF64> &v = std::get<std::shared_ptr<VF64>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VF64);
    } else if (std::holds_alternative<std::shared_ptr<VStr>>(o)) {
        const std::shared_ptr<VStr> &v = std::get<std::shared_ptr<VStr>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VStr);
    } else if (std::holds_alternative<std::shared_ptr<VBytes>>(o)) {
        const std::shared_ptr<VBytes> &v = std::get<std::shared_ptr<VBytes>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VBytes);
    } else if (std::holds_alternative<std::shared_ptr<VArray>>(o)) {
        const std::shared_ptr<VArray> &v = std::get<std::shared_ptr<VArray>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VArray);
    } else if (std::holds_alternative<std::shared_ptr<VTri2D>>(o)) {
        const std::shared_ptr<VTri2D> &v = std::get<std::shared_ptr<VTri2D>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VTri2D);
    } else if (std::holds_alternative<std::shared_ptr<VFixedSizeBytes>>(o)) {
        const std::shared_ptr<VFixedSizeBytes> &v = std::get<std::shared_ptr<VFixedSizeBytes>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VFixedSizeBytes);
    } else if (std::holds_alternative<std::shared_ptr<VTimestampMsUtc>>(o)) {
        const std::shared_ptr<VTimestampMsUtc> &v = std::get<std::shared_ptr<VTimestampMsUtc>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VTimestampMsUtc);
    } else if (std::holds_alternative<std::shared_ptr<VTimestampMs>>(o)) {
        const std::shared_ptr<VTimestampMs> &v = std::get<std::shared_ptr<VTimestampMs>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VTimestampMs);
    } else if (std::holds_alternative<std::shared_ptr<VTimestampNsUtc>>(o)) {
        const std::shared_ptr<VTimestampNsUtc> &v = std::get<std::shared_ptr<VTimestampNsUtc>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VTimestampNsUtc);
    } else if (std::holds_alternative<std::shared_ptr<VTimestampNs>>(o)) {
        const std::shared_ptr<VTimestampNs> &v = std::get<std::shared_ptr<VTimestampNs>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Value::VTimestampNs);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::VBool>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VBool &o) {

    ::VBoolBuilder instance_builder = ::VBoolBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VBool &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VBool::VBool()
    : v_(false) {
}

VBool::VBool(const std::vector<uint8_t> &bytes)
    : VBool(::flatbuffers::GetSizePrefixedRoot<::VBool>(bytes.data())) {
}

VBool::VBool(const ::VBool *root) 
    : v_(false) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VUnit>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VUnit &) {

    ::VUnitBuilder instance_builder = ::VUnitBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VUnit &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VUnit::VUnit() {
}

VUnit::VUnit(const std::vector<uint8_t> &bytes)
    : VUnit(::flatbuffers::GetSizePrefixedRoot<::VUnit>(bytes.data())) {
}

VUnit::VUnit(const ::VUnit *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::VChar>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VChar &o) {

    ::VCharBuilder instance_builder = ::VCharBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VChar &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VChar::VChar()
    : v_(0) {
}

VChar::VChar(const std::vector<uint8_t> &bytes)
    : VChar(::flatbuffers::GetSizePrefixedRoot<::VChar>(bytes.data())) {
}

VChar::VChar(const ::VChar *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VNull>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VNull &) {

    ::VNullBuilder instance_builder = ::VNullBuilder(builder);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VNull &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VNull::VNull() {
}

VNull::VNull(const std::vector<uint8_t> &bytes)
    : VNull(::flatbuffers::GetSizePrefixedRoot<::VNull>(bytes.data())) {
}

VNull::VNull(const ::VNull *root)  {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

}

::flatbuffers::Offset<::VI8>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VI8 &o) {

    ::VI8Builder instance_builder = ::VI8Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VI8 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VI8::VI8()
    : v_(0) {
}

VI8::VI8(const std::vector<uint8_t> &bytes)
    : VI8(::flatbuffers::GetSizePrefixedRoot<::VI8>(bytes.data())) {
}

VI8::VI8(const ::VI8 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VU8>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VU8 &o) {

    ::VU8Builder instance_builder = ::VU8Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VU8 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VU8::VU8()
    : v_(0) {
}

VU8::VU8(const std::vector<uint8_t> &bytes)
    : VU8(::flatbuffers::GetSizePrefixedRoot<::VU8>(bytes.data())) {
}

VU8::VU8(const ::VU8 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VI16>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VI16 &o) {

    ::VI16Builder instance_builder = ::VI16Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VI16 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VI16::VI16()
    : v_(0) {
}

VI16::VI16(const std::vector<uint8_t> &bytes)
    : VI16(::flatbuffers::GetSizePrefixedRoot<::VI16>(bytes.data())) {
}

VI16::VI16(const ::VI16 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VU16>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VU16 &o) {

    ::VU16Builder instance_builder = ::VU16Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VU16 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VU16::VU16()
    : v_(0) {
}

VU16::VU16(const std::vector<uint8_t> &bytes)
    : VU16(::flatbuffers::GetSizePrefixedRoot<::VU16>(bytes.data())) {
}

VU16::VU16(const ::VU16 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VI32>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VI32 &o) {

    ::VI32Builder instance_builder = ::VI32Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VI32 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VI32::VI32()
    : v_(0) {
}

VI32::VI32(const std::vector<uint8_t> &bytes)
    : VI32(::flatbuffers::GetSizePrefixedRoot<::VI32>(bytes.data())) {
}

VI32::VI32(const ::VI32 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VU32>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VU32 &o) {

    ::VU32Builder instance_builder = ::VU32Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VU32 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VU32::VU32()
    : v_(0) {
}

VU32::VU32(const std::vector<uint8_t> &bytes)
    : VU32(::flatbuffers::GetSizePrefixedRoot<::VU32>(bytes.data())) {
}

VU32::VU32(const ::VU32 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VF32>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VF32 &o) {

    ::VF32Builder instance_builder = ::VF32Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VF32 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VF32::VF32()
    : v_(0) {
}

VF32::VF32(const std::vector<uint8_t> &bytes)
    : VF32(::flatbuffers::GetSizePrefixedRoot<::VF32>(bytes.data())) {
}

VF32::VF32(const ::VF32 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VIsize>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VIsize &o) {

    ::VIsizeBuilder instance_builder = ::VIsizeBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VIsize &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VIsize::VIsize()
    : v_(0) {
}

VIsize::VIsize(const std::vector<uint8_t> &bytes)
    : VIsize(::flatbuffers::GetSizePrefixedRoot<::VIsize>(bytes.data())) {
}

VIsize::VIsize(const ::VIsize *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VUsize>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VUsize &o) {

    ::VUsizeBuilder instance_builder = ::VUsizeBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VUsize &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VUsize::VUsize()
    : v_(0) {
}

VUsize::VUsize(const std::vector<uint8_t> &bytes)
    : VUsize(::flatbuffers::GetSizePrefixedRoot<::VUsize>(bytes.data())) {
}

VUsize::VUsize(const ::VUsize *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VI64>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VI64 &o) {

    ::VI64Builder instance_builder = ::VI64Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VI64 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VI64::VI64()
    : v_(0) {
}

VI64::VI64(const std::vector<uint8_t> &bytes)
    : VI64(::flatbuffers::GetSizePrefixedRoot<::VI64>(bytes.data())) {
}

VI64::VI64(const ::VI64 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VU64>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VU64 &o) {

    ::VU64Builder instance_builder = ::VU64Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VU64 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VU64::VU64()
    : v_(0) {
}

VU64::VU64(const std::vector<uint8_t> &bytes)
    : VU64(::flatbuffers::GetSizePrefixedRoot<::VU64>(bytes.data())) {
}

VU64::VU64(const ::VU64 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VF64>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VF64 &o) {

    ::VF64Builder instance_builder = ::VF64Builder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VF64 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VF64::VF64()
    : v_(0) {
}

VF64::VF64(const std::vector<uint8_t> &bytes)
    : VF64(::flatbuffers::GetSizePrefixedRoot<::VF64>(bytes.data())) {
}

VF64::VF64(const ::VF64 *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VStr>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VStr &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> v_offset = builder.CreateString(o.v_);

    ::VStrBuilder instance_builder = ::VStrBuilder(builder);
    instance_builder.add_v(v_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VStr &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VStr::VStr()
    : v_() {
}

VStr::VStr(const std::vector<uint8_t> &bytes)
    : VStr(::flatbuffers::GetSizePrefixedRoot<::VStr>(bytes.data())) {
}

VStr::VStr(const ::VStr *root) 
    : v_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        v_ = std::string(*root->v()->begin(), *root->v()->end());
}

::flatbuffers::Offset<::VBytes>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VBytes &o) {
    const decltype(builder.CreateVector(o.v_)) v_offset = builder.CreateVector(o.v_);

    ::VBytesBuilder instance_builder = ::VBytesBuilder(builder);
    instance_builder.add_v(v_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VBytes &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VBytes::VBytes()
    : v_() {
}

VBytes::VBytes(const std::vector<uint8_t> &bytes)
    : VBytes(::flatbuffers::GetSizePrefixedRoot<::VBytes>(bytes.data())) {
}

VBytes::VBytes(const ::VBytes *root) 
    : v_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &v_vector = root->v();
    if (v_vector != nullptr) {
        std::copy(v_vector->begin(), v_vector->end(), std::back_inserter(v_));
    }
}

::flatbuffers::Offset<::VArray>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VArray &o) {
    std::vector<::flatbuffers::Offset<::ValueInstance>> v_offsets = std::vector<::flatbuffers::Offset<::ValueInstance>>();
    v_offsets.reserve(o.v_.size());
    for (const auto &i: o.v_) {
        v_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::ValueInstance>>> v_offset = builder.CreateVector(v_offsets);

    ::VArrayBuilder instance_builder = ::VArrayBuilder(builder);
    instance_builder.add_v(v_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VArray &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VArray::VArray()
    : v_() {
}

VArray::VArray(const std::vector<uint8_t> &bytes)
    : VArray(::flatbuffers::GetSizePrefixedRoot<::VArray>(bytes.data())) {
}

VArray::VArray(const ::VArray *root) 
    : v_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &v_vector = root->v();
    if (v_vector != nullptr) {
        v_.reserve(v_vector->size());
        for (const auto &i: *v_vector) {
            v_.emplace_back(i);
        }
    }
}

Point2D::Point2D()
    : x_(0)
    , y_(0) {
}

Point2D::Point2D(const ::Point2D *root) 
    : x_(0)
    , y_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    x_ = root->x();
    y_ = root->y();
}

Tri2D::Tri2D()
    : p0_(std::nullopt)
    , p1_(std::nullopt)
    , p2_(std::nullopt) {
}

Tri2D::Tri2D(const ::Tri2D *root) 
    : p0_(std::nullopt)
    , p1_(std::nullopt)
    , p2_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto p0__local = root->p0();
    p0_ = decltype(p0_)(&p0__local);
    const auto p1__local = root->p1();
    p1_ = decltype(p1_)(&p1__local);
    const auto p2__local = root->p2();
    p2_ = decltype(p2_)(&p2__local);
}

::flatbuffers::Offset<::VTri2D>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VTri2D &o) {

    ::VTri2DBuilder instance_builder = ::VTri2DBuilder(builder);
    instance_builder.add_v(reinterpret_cast<const ::Tri2D *>(&o.v_));
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VTri2D &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VTri2D::VTri2D()
    : v_() {
}

VTri2D::VTri2D(const std::vector<uint8_t> &bytes)
    : VTri2D(::flatbuffers::GetSizePrefixedRoot<::VTri2D>(bytes.data())) {
}

VTri2D::VTri2D(const ::VTri2D *root) 
    : v_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto v__local = root->v();
    v_ = decltype(v_)(v__local);
}

::flatbuffers::Offset<::VFixedSizeBytes>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VFixedSizeBytes &o) {
    const decltype(builder.CreateVector(o.v_)) v_offset = builder.CreateVector(o.v_);

    ::VFixedSizeBytesBuilder instance_builder = ::VFixedSizeBytesBuilder(builder);
    instance_builder.add_sz(o.sz_);
    instance_builder.add_v(v_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VFixedSizeBytes &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VFixedSizeBytes::VFixedSizeBytes()
    : sz_(0)
    , v_() {
}

VFixedSizeBytes::VFixedSizeBytes(const std::vector<uint8_t> &bytes)
    : VFixedSizeBytes(::flatbuffers::GetSizePrefixedRoot<::VFixedSizeBytes>(bytes.data())) {
}

VFixedSizeBytes::VFixedSizeBytes(const ::VFixedSizeBytes *root) 
    : sz_(0)
    , v_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    sz_ = root->sz();
    const auto &v_vector = root->v();
    if (v_vector != nullptr) {
        std::copy(v_vector->begin(), v_vector->end(), std::back_inserter(v_));
    }
}

::flatbuffers::Offset<::VTimestampMsUtc>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VTimestampMsUtc &o) {

    ::VTimestampMsUtcBuilder instance_builder = ::VTimestampMsUtcBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VTimestampMsUtc &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VTimestampMsUtc::VTimestampMsUtc()
    : v_(0) {
}

VTimestampMsUtc::VTimestampMsUtc(const std::vector<uint8_t> &bytes)
    : VTimestampMsUtc(::flatbuffers::GetSizePrefixedRoot<::VTimestampMsUtc>(bytes.data())) {
}

VTimestampMsUtc::VTimestampMsUtc(const ::VTimestampMsUtc *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VTimestampMs>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VTimestampMs &o) {

    ::VTimestampMsBuilder instance_builder = ::VTimestampMsBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VTimestampMs &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VTimestampMs::VTimestampMs()
    : v_(0) {
}

VTimestampMs::VTimestampMs(const std::vector<uint8_t> &bytes)
    : VTimestampMs(::flatbuffers::GetSizePrefixedRoot<::VTimestampMs>(bytes.data())) {
}

VTimestampMs::VTimestampMs(const ::VTimestampMs *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VTimestampNsUtc>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VTimestampNsUtc &o) {

    ::VTimestampNsUtcBuilder instance_builder = ::VTimestampNsUtcBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VTimestampNsUtc &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VTimestampNsUtc::VTimestampNsUtc()
    : v_(0) {
}

VTimestampNsUtc::VTimestampNsUtc(const std::vector<uint8_t> &bytes)
    : VTimestampNsUtc(::flatbuffers::GetSizePrefixedRoot<::VTimestampNsUtc>(bytes.data())) {
}

VTimestampNsUtc::VTimestampNsUtc(const ::VTimestampNsUtc *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::VTimestampNs>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const VTimestampNs &o) {

    ::VTimestampNsBuilder instance_builder = ::VTimestampNsBuilder(builder);
    instance_builder.add_v(o.v_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const VTimestampNs &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

VTimestampNs::VTimestampNs()
    : v_(0) {
}

VTimestampNs::VTimestampNs(const std::vector<uint8_t> &bytes)
    : VTimestampNs(::flatbuffers::GetSizePrefixedRoot<::VTimestampNs>(bytes.data())) {
}

VTimestampNs::VTimestampNs(const ::VTimestampNs *root) 
    : v_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    v_ = root->v();
}

::flatbuffers::Offset<::ValueInstance>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ValueInstance &o) {
    const std::pair<::flatbuffers::Offset<void>, ::Value> v_offset = serialize_to(builder, o.v_);

    ::ValueInstanceBuilder instance_builder = ::ValueInstanceBuilder(builder);
    instance_builder.add_v(v_offset.first);
    instance_builder.add_v_type(v_offset.second);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ValueInstance &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ValueInstance::ValueInstance()
    : v_(std::make_shared<VBool>()) {
}

ValueInstance::ValueInstance(const std::vector<uint8_t> &bytes)
    : ValueInstance(::flatbuffers::GetSizePrefixedRoot<::ValueInstance>(bytes.data())) {
}

ValueInstance::ValueInstance(const ::ValueInstance *root) 
    : v_(std::make_shared<VBool>()) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->v() != nullptr) {
        switch (root->v_type()) {
            case ::Value::NONE: throw std::runtime_error("unexpected none variant");
            case ::Value::VBool: {
                const auto v__local = static_cast<const ::VBool *>(root->v());
                std::shared_ptr<VBool> v__shared = std::make_shared<VBool>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VUnit: {
                const auto v__local = static_cast<const ::VUnit *>(root->v());
                std::shared_ptr<VUnit> v__shared = std::make_shared<VUnit>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VChar: {
                const auto v__local = static_cast<const ::VChar *>(root->v());
                std::shared_ptr<VChar> v__shared = std::make_shared<VChar>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VNull: {
                const auto v__local = static_cast<const ::VNull *>(root->v());
                std::shared_ptr<VNull> v__shared = std::make_shared<VNull>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI8: {
                const auto v__local = static_cast<const ::VI8 *>(root->v());
                std::shared_ptr<VI8> v__shared = std::make_shared<VI8>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU8: {
                const auto v__local = static_cast<const ::VU8 *>(root->v());
                std::shared_ptr<VU8> v__shared = std::make_shared<VU8>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI16: {
                const auto v__local = static_cast<const ::VI16 *>(root->v());
                std::shared_ptr<VI16> v__shared = std::make_shared<VI16>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU16: {
                const auto v__local = static_cast<const ::VU16 *>(root->v());
                std::shared_ptr<VU16> v__shared = std::make_shared<VU16>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI32: {
                const auto v__local = static_cast<const ::VI32 *>(root->v());
                std::shared_ptr<VI32> v__shared = std::make_shared<VI32>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU32: {
                const auto v__local = static_cast<const ::VU32 *>(root->v());
                std::shared_ptr<VU32> v__shared = std::make_shared<VU32>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VF32: {
                const auto v__local = static_cast<const ::VF32 *>(root->v());
                std::shared_ptr<VF32> v__shared = std::make_shared<VF32>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VIsize: {
                const auto v__local = static_cast<const ::VIsize *>(root->v());
                std::shared_ptr<VIsize> v__shared = std::make_shared<VIsize>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VUsize: {
                const auto v__local = static_cast<const ::VUsize *>(root->v());
                std::shared_ptr<VUsize> v__shared = std::make_shared<VUsize>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VI64: {
                const auto v__local = static_cast<const ::VI64 *>(root->v());
                std::shared_ptr<VI64> v__shared = std::make_shared<VI64>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VU64: {
                const auto v__local = static_cast<const ::VU64 *>(root->v());
                std::shared_ptr<VU64> v__shared = std::make_shared<VU64>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VF64: {
                const auto v__local = static_cast<const ::VF64 *>(root->v());
                std::shared_ptr<VF64> v__shared = std::make_shared<VF64>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VStr: {
                const auto v__local = static_cast<const ::VStr *>(root->v());
                std::shared_ptr<VStr> v__shared = std::make_shared<VStr>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VBytes: {
                const auto v__local = static_cast<const ::VBytes *>(root->v());
                std::shared_ptr<VBytes> v__shared = std::make_shared<VBytes>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VArray: {
                const auto v__local = static_cast<const ::VArray *>(root->v());
                std::shared_ptr<VArray> v__shared = std::make_shared<VArray>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTri2D: {
                const auto v__local = static_cast<const ::VTri2D *>(root->v());
                std::shared_ptr<VTri2D> v__shared = std::make_shared<VTri2D>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VFixedSizeBytes: {
                const auto v__local = static_cast<const ::VFixedSizeBytes *>(root->v());
                std::shared_ptr<VFixedSizeBytes> v__shared = std::make_shared<VFixedSizeBytes>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampMsUtc: {
                const auto v__local = static_cast<const ::VTimestampMsUtc *>(root->v());
                std::shared_ptr<VTimestampMsUtc> v__shared = std::make_shared<VTimestampMsUtc>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampMs: {
                const auto v__local = static_cast<const ::VTimestampMs *>(root->v());
                std::shared_ptr<VTimestampMs> v__shared = std::make_shared<VTimestampMs>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampNsUtc: {
                const auto v__local = static_cast<const ::VTimestampNsUtc *>(root->v());
                std::shared_ptr<VTimestampNsUtc> v__shared = std::make_shared<VTimestampNsUtc>(v__local);
                v_ = v__shared;
                break;
            }
            case ::Value::VTimestampNs: {
                const auto v__local = static_cast<const ::VTimestampNs *>(root->v());
                std::shared_ptr<VTimestampNs> v__shared = std::make_shared<VTimestampNs>(v__local);
                v_ = v__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
}

} // namespace types
} // namespace ul
