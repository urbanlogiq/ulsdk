// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/crypto.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::Digest>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Digest &o) {
    if (std::holds_alternative<std::shared_ptr<Sha256>>(o)) {
        const std::shared_ptr<Sha256> &v = std::get<std::shared_ptr<Sha256>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Digest::Sha256);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::Sha256>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Sha256 &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::Sha256Builder instance_builder = ::Sha256Builder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Sha256 &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Sha256::Sha256()
    : b_() {
}

Sha256::Sha256(const std::vector<uint8_t> &bytes)
    : Sha256(::flatbuffers::GetSizePrefixedRoot<::Sha256>(bytes.data())) {
}

Sha256::Sha256(const ::Sha256 *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::CryptHeader>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const CryptHeader &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> kid_offset = builder.CreateString(o.kid_);
    const decltype(builder.CreateVector(o.nonce_)) nonce_offset = builder.CreateVector(o.nonce_);

    ::CryptHeaderBuilder instance_builder = ::CryptHeaderBuilder(builder);
    instance_builder.add_kid(kid_offset);
    instance_builder.add_nonce(nonce_offset);
    instance_builder.add_plaintext_len(o.plaintext_len_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const CryptHeader &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

CryptHeader::CryptHeader()
    : kid_()
    , nonce_()
    , plaintext_len_(0) {
}

CryptHeader::CryptHeader(const std::vector<uint8_t> &bytes)
    : CryptHeader(::flatbuffers::GetSizePrefixedRoot<::CryptHeader>(bytes.data())) {
}

CryptHeader::CryptHeader(const ::CryptHeader *root) 
    : kid_()
    , nonce_()
    , plaintext_len_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        kid_ = std::string(*root->kid()->begin(), *root->kid()->end());
    const auto &nonce_vector = root->nonce();
    if (nonce_vector != nullptr) {
        std::copy(nonce_vector->begin(), nonce_vector->end(), std::back_inserter(nonce_));
    }
    plaintext_len_ = root->plaintext_len();
}

::flatbuffers::Offset<::EncryptedObject>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const EncryptedObject &o) {
    const ::flatbuffers::Offset<::CryptHeader> header_offset = serialize_to(builder, o.header_);
    const decltype(builder.CreateVector(o.obj_)) obj_offset = builder.CreateVector(o.obj_);

    ::EncryptedObjectBuilder instance_builder = ::EncryptedObjectBuilder(builder);
    instance_builder.add_header(header_offset);
    instance_builder.add_obj(obj_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const EncryptedObject &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

EncryptedObject::EncryptedObject()
    : header_()
    , obj_() {
}

EncryptedObject::EncryptedObject(const std::vector<uint8_t> &bytes)
    : EncryptedObject(::flatbuffers::GetSizePrefixedRoot<::EncryptedObject>(bytes.data())) {
}

EncryptedObject::EncryptedObject(const ::EncryptedObject *root) 
    : header_()
    , obj_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->header() != nullptr) {
        header_ = decltype(header_)(root->header());
    }
    const auto &obj_vector = root->obj();
    if (obj_vector != nullptr) {
        std::copy(obj_vector->begin(), obj_vector->end(), std::back_inserter(obj_));
    }
}

::flatbuffers::Offset<::Signature>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Signature &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> kid_offset = builder.CreateString(o.kid_);
    const decltype(builder.CreateVector(o.sig_)) sig_offset = builder.CreateVector(o.sig_);

    ::SignatureBuilder instance_builder = ::SignatureBuilder(builder);
    instance_builder.add_kid(kid_offset);
    instance_builder.add_sig(sig_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Signature &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Signature::Signature()
    : kid_()
    , sig_() {
}

Signature::Signature(const std::vector<uint8_t> &bytes)
    : Signature(::flatbuffers::GetSizePrefixedRoot<::Signature>(bytes.data())) {
}

Signature::Signature(const ::Signature *root) 
    : kid_()
    , sig_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        kid_ = std::string(*root->kid()->begin(), *root->kid()->end());
    const auto &sig_vector = root->sig();
    if (sig_vector != nullptr) {
        std::copy(sig_vector->begin(), sig_vector->end(), std::back_inserter(sig_));
    }
}

} // namespace types
} // namespace ul
