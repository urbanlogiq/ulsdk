// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/entity.h"

namespace ul {
namespace types {

std::pair<::flatbuffers::Offset<void>, ::Geometry>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Geometry &o) {
    if (std::holds_alternative<std::shared_ptr<Point>>(o)) {
        const std::shared_ptr<Point> &v = std::get<std::shared_ptr<Point>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Geometry::Point);
    } else if (std::holds_alternative<std::shared_ptr<Line>>(o)) {
        const std::shared_ptr<Line> &v = std::get<std::shared_ptr<Line>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Geometry::Line);
    } else if (std::holds_alternative<std::shared_ptr<MultiLine>>(o)) {
        const std::shared_ptr<MultiLine> &v = std::get<std::shared_ptr<MultiLine>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Geometry::MultiLine);
    } else if (std::holds_alternative<std::shared_ptr<Polygon>>(o)) {
        const std::shared_ptr<Polygon> &v = std::get<std::shared_ptr<Polygon>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Geometry::Polygon);
    } else if (std::holds_alternative<std::shared_ptr<MultiPolygon>>(o)) {
        const std::shared_ptr<MultiPolygon> &v = std::get<std::shared_ptr<MultiPolygon>>(o);
        const auto offset = serialize_to(builder, *v);
        return std::make_pair(offset.Union(), ::Geometry::MultiPolygon);
    } else { 
        throw std::runtime_error("unreachable");
    }
}

::flatbuffers::Offset<::Point>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Point &o) {
    const decltype(builder.CreateVector(o.point_geo_)) point_geo_offset = builder.CreateVector(o.point_geo_);

    ::PointBuilder instance_builder = ::PointBuilder(builder);
    instance_builder.add_point_geo(point_geo_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Point &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Point::Point()
    : point_geo_() {
}

Point::Point(const std::vector<uint8_t> &bytes)
    : Point(::flatbuffers::GetSizePrefixedRoot<::Point>(bytes.data())) {
}

Point::Point(const ::Point *root) 
    : point_geo_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &point_geo_vector = root->point_geo();
    if (point_geo_vector != nullptr) {
        std::copy(point_geo_vector->begin(), point_geo_vector->end(), std::back_inserter(point_geo_));
    }
}

::flatbuffers::Offset<::Line>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Line &o) {
    std::vector<::flatbuffers::Offset<::Point>> line_geo_offsets = std::vector<::flatbuffers::Offset<::Point>>();
    line_geo_offsets.reserve(o.line_geo_.size());
    for (const auto &i: o.line_geo_) {
        line_geo_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Point>>> line_geo_offset = builder.CreateVector(line_geo_offsets);

    ::LineBuilder instance_builder = ::LineBuilder(builder);
    instance_builder.add_line_geo(line_geo_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Line &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Line::Line()
    : line_geo_() {
}

Line::Line(const std::vector<uint8_t> &bytes)
    : Line(::flatbuffers::GetSizePrefixedRoot<::Line>(bytes.data())) {
}

Line::Line(const ::Line *root) 
    : line_geo_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &line_geo_vector = root->line_geo();
    if (line_geo_vector != nullptr) {
        line_geo_.reserve(line_geo_vector->size());
        for (const auto &i: *line_geo_vector) {
            line_geo_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::MultiLine>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const MultiLine &o) {
    std::vector<::flatbuffers::Offset<::Line>> multiline_geo_offsets = std::vector<::flatbuffers::Offset<::Line>>();
    multiline_geo_offsets.reserve(o.multiline_geo_.size());
    for (const auto &i: o.multiline_geo_) {
        multiline_geo_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Line>>> multiline_geo_offset = builder.CreateVector(multiline_geo_offsets);

    ::MultiLineBuilder instance_builder = ::MultiLineBuilder(builder);
    instance_builder.add_multiline_geo(multiline_geo_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const MultiLine &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

MultiLine::MultiLine()
    : multiline_geo_() {
}

MultiLine::MultiLine(const std::vector<uint8_t> &bytes)
    : MultiLine(::flatbuffers::GetSizePrefixedRoot<::MultiLine>(bytes.data())) {
}

MultiLine::MultiLine(const ::MultiLine *root) 
    : multiline_geo_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &multiline_geo_vector = root->multiline_geo();
    if (multiline_geo_vector != nullptr) {
        multiline_geo_.reserve(multiline_geo_vector->size());
        for (const auto &i: *multiline_geo_vector) {
            multiline_geo_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::Polygon>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Polygon &o) {
    std::vector<::flatbuffers::Offset<::Line>> polygon_geo_offsets = std::vector<::flatbuffers::Offset<::Line>>();
    polygon_geo_offsets.reserve(o.polygon_geo_.size());
    for (const auto &i: o.polygon_geo_) {
        polygon_geo_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Line>>> polygon_geo_offset = builder.CreateVector(polygon_geo_offsets);

    ::PolygonBuilder instance_builder = ::PolygonBuilder(builder);
    instance_builder.add_polygon_geo(polygon_geo_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Polygon &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Polygon::Polygon()
    : polygon_geo_() {
}

Polygon::Polygon(const std::vector<uint8_t> &bytes)
    : Polygon(::flatbuffers::GetSizePrefixedRoot<::Polygon>(bytes.data())) {
}

Polygon::Polygon(const ::Polygon *root) 
    : polygon_geo_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &polygon_geo_vector = root->polygon_geo();
    if (polygon_geo_vector != nullptr) {
        polygon_geo_.reserve(polygon_geo_vector->size());
        for (const auto &i: *polygon_geo_vector) {
            polygon_geo_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::MultiPolygon>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const MultiPolygon &o) {
    std::vector<::flatbuffers::Offset<::Polygon>> multipolygon_geo_offsets = std::vector<::flatbuffers::Offset<::Polygon>>();
    multipolygon_geo_offsets.reserve(o.multipolygon_geo_.size());
    for (const auto &i: o.multipolygon_geo_) {
        multipolygon_geo_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::Polygon>>> multipolygon_geo_offset = builder.CreateVector(multipolygon_geo_offsets);

    ::MultiPolygonBuilder instance_builder = ::MultiPolygonBuilder(builder);
    instance_builder.add_multipolygon_geo(multipolygon_geo_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const MultiPolygon &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

MultiPolygon::MultiPolygon()
    : multipolygon_geo_() {
}

MultiPolygon::MultiPolygon(const std::vector<uint8_t> &bytes)
    : MultiPolygon(::flatbuffers::GetSizePrefixedRoot<::MultiPolygon>(bytes.data())) {
}

MultiPolygon::MultiPolygon(const ::MultiPolygon *root) 
    : multipolygon_geo_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &multipolygon_geo_vector = root->multipolygon_geo();
    if (multipolygon_geo_vector != nullptr) {
        multipolygon_geo_.reserve(multipolygon_geo_vector->size());
        for (const auto &i: *multipolygon_geo_vector) {
            multipolygon_geo_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::GraphEdge>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GraphEdge &o) {

    ::GraphEdgeBuilder instance_builder = ::GraphEdgeBuilder(builder);
    instance_builder.add__from(o._from_);
    instance_builder.add__kind(o._kind_);
    instance_builder.add__to(o._to_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const GraphEdge &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

GraphEdge::GraphEdge()
    : _from_(0)
    , _kind_(EdgeTy(0))
    , _to_(0) {
}

GraphEdge::GraphEdge(const std::vector<uint8_t> &bytes)
    : GraphEdge(::flatbuffers::GetSizePrefixedRoot<::GraphEdge>(bytes.data())) {
}

GraphEdge::GraphEdge(const ::GraphEdge *root) 
    : _from_(0)
    , _kind_(EdgeTy(0))
    , _to_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    _from_ = root->_from();
    _kind_ = root->_kind();
    _to_ = root->_to();
}

::flatbuffers::Offset<::GraphNode>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GraphNode &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> _description_offset = std::nullopt;
    if (o._description_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> _description_offset_val = builder.CreateString(o._description_.value());
        _description_offset = std::make_optional(_description_offset_val);
    }
    std::optional<std::pair<::flatbuffers::Offset<void>, ::Geometry>> _geom_offset = std::nullopt;
    if (o._geom_.has_value()) {
        const std::pair<::flatbuffers::Offset<void>, ::Geometry> _geom_offset_val = serialize_to(builder, o._geom_.value());
        _geom_offset = std::make_optional(_geom_offset_val);
    }
    std::optional<::flatbuffers::Offset<::Point>> _location_offset = std::nullopt;
    if (o._location_.has_value()) {
        const ::flatbuffers::Offset<::Point> _location_offset_val = serialize_to(builder, o._location_.value());
        _location_offset = std::make_optional(_location_offset_val);
    }
    std::optional<::flatbuffers::Offset<::GenericId>> _node_id_offset = std::nullopt;
    if (o._node_id_.has_value()) {
        const ::flatbuffers::Offset<::GenericId> _node_id_offset_val = serialize_to(builder, o._node_id_.value());
        _node_id_offset = std::make_optional(_node_id_offset_val);
    }
    std::optional<::flatbuffers::Offset<::ObjectId>> _stream_offset = std::nullopt;
    if (o._stream_.has_value()) {
        const ::flatbuffers::Offset<::ObjectId> _stream_offset_val = serialize_to(builder, o._stream_.value());
        _stream_offset = std::make_optional(_stream_offset_val);
    }

    ::GraphNodeBuilder instance_builder = ::GraphNodeBuilder(builder);
    if (_description_offset.has_value()) {
        instance_builder.add__description(_description_offset.value());
    }
    instance_builder.add__entity_type(o._entity_type_);
    if (_geom_offset.has_value()) {
        const auto _geom_opt = _geom_offset.value();
        instance_builder.add__geom(_geom_opt.first);
        instance_builder.add__geom_type(_geom_opt.second);
    }
    if (_location_offset.has_value()) {
        instance_builder.add__location(_location_offset.value());
    }
    if (_node_id_offset.has_value()) {
        instance_builder.add__node_id(_node_id_offset.value());
    }
    instance_builder.add__node_type(o._node_type_);
    if (_stream_offset.has_value()) {
        instance_builder.add__stream(_stream_offset.value());
    }
    instance_builder.add__uid(o._uid_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const GraphNode &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

GraphNode::GraphNode()
    : _description_(std::nullopt)
    , _entity_type_(EntityTy(0))
    , _geom_(std::nullopt)
    , _location_(std::nullopt)
    , _node_id_(std::nullopt)
    , _node_type_(NodeTy(0))
    , _stream_(std::nullopt)
    , _uid_(0) {
}

GraphNode::GraphNode(const std::vector<uint8_t> &bytes)
    : GraphNode(::flatbuffers::GetSizePrefixedRoot<::GraphNode>(bytes.data())) {
}

GraphNode::GraphNode(const ::GraphNode *root) 
    : _description_(std::nullopt)
    , _entity_type_(EntityTy(0))
    , _geom_(std::nullopt)
    , _location_(std::nullopt)
    , _node_id_(std::nullopt)
    , _node_type_(NodeTy(0))
    , _stream_(std::nullopt)
    , _uid_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->_description() != nullptr) {
        _description_ = std::string(*root->_description()->begin(), *root->_description()->end());
    }
    _entity_type_ = root->_entity_type();
    if (root->_geom() != nullptr) {
        switch (root->_geom_type()) {
            case ::Geometry::NONE: throw std::runtime_error("unexpected none variant");
            case ::Geometry::Point: {
                const auto _geom__local = static_cast<const ::Point *>(root->_geom());
                std::shared_ptr<Point> _geom__shared = std::make_shared<Point>(_geom__local);
                _geom_ = _geom__shared;
                break;
            }
            case ::Geometry::Line: {
                const auto _geom__local = static_cast<const ::Line *>(root->_geom());
                std::shared_ptr<Line> _geom__shared = std::make_shared<Line>(_geom__local);
                _geom_ = _geom__shared;
                break;
            }
            case ::Geometry::MultiLine: {
                const auto _geom__local = static_cast<const ::MultiLine *>(root->_geom());
                std::shared_ptr<MultiLine> _geom__shared = std::make_shared<MultiLine>(_geom__local);
                _geom_ = _geom__shared;
                break;
            }
            case ::Geometry::Polygon: {
                const auto _geom__local = static_cast<const ::Polygon *>(root->_geom());
                std::shared_ptr<Polygon> _geom__shared = std::make_shared<Polygon>(_geom__local);
                _geom_ = _geom__shared;
                break;
            }
            case ::Geometry::MultiPolygon: {
                const auto _geom__local = static_cast<const ::MultiPolygon *>(root->_geom());
                std::shared_ptr<MultiPolygon> _geom__shared = std::make_shared<MultiPolygon>(_geom__local);
                _geom_ = _geom__shared;
                break;
            }
            default: throw std::runtime_error("unknown union variant");
        }
    }
    if (root->_location() != nullptr) {
        _location_ = decltype(_location_)(root->_location());
    }
    if (root->_node_id() != nullptr) {
        _node_id_ = decltype(_node_id_)(root->_node_id());
    }
    _node_type_ = root->_node_type();
    if (root->_stream() != nullptr) {
        _stream_ = decltype(_stream_)(root->_stream());
    }
    _uid_ = root->_uid();
}

} // namespace types
} // namespace ul
