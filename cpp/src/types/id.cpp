// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/id.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::B2cId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const B2cId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::B2cIdBuilder instance_builder = ::B2cIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const B2cId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

B2cId::B2cId()
    : b_() {
}

B2cId::B2cId(const std::vector<uint8_t> &bytes)
    : B2cId(::flatbuffers::GetSizePrefixedRoot<::B2cId>(bytes.data())) {
}

B2cId::B2cId(const ::B2cId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::ColumnGroupId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ColumnGroupId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::ColumnGroupIdBuilder instance_builder = ::ColumnGroupIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ColumnGroupId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ColumnGroupId::ColumnGroupId()
    : b_() {
}

ColumnGroupId::ColumnGroupId(const std::vector<uint8_t> &bytes)
    : ColumnGroupId(::flatbuffers::GetSizePrefixedRoot<::ColumnGroupId>(bytes.data())) {
}

ColumnGroupId::ColumnGroupId(const ::ColumnGroupId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::ContentId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ContentId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::ContentIdBuilder instance_builder = ::ContentIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ContentId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ContentId::ContentId()
    : b_() {
}

ContentId::ContentId(const std::vector<uint8_t> &bytes)
    : ContentId(::flatbuffers::GetSizePrefixedRoot<::ContentId>(bytes.data())) {
}

ContentId::ContentId(const ::ContentId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::DataStateId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const DataStateId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::DataStateIdBuilder instance_builder = ::DataStateIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const DataStateId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

DataStateId::DataStateId()
    : b_() {
}

DataStateId::DataStateId(const std::vector<uint8_t> &bytes)
    : DataStateId(::flatbuffers::GetSizePrefixedRoot<::DataStateId>(bytes.data())) {
}

DataStateId::DataStateId(const ::DataStateId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::GenericId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GenericId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::GenericIdBuilder instance_builder = ::GenericIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const GenericId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

GenericId::GenericId()
    : b_() {
}

GenericId::GenericId(const std::vector<uint8_t> &bytes)
    : GenericId(::flatbuffers::GetSizePrefixedRoot<::GenericId>(bytes.data())) {
}

GenericId::GenericId(const ::GenericId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::GraphNodeId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const GraphNodeId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::GraphNodeIdBuilder instance_builder = ::GraphNodeIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const GraphNodeId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

GraphNodeId::GraphNodeId()
    : b_() {
}

GraphNodeId::GraphNodeId(const std::vector<uint8_t> &bytes)
    : GraphNodeId(::flatbuffers::GetSizePrefixedRoot<::GraphNodeId>(bytes.data())) {
}

GraphNodeId::GraphNodeId(const ::GraphNodeId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::ObjectId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const ObjectId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::ObjectIdBuilder instance_builder = ::ObjectIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const ObjectId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

ObjectId::ObjectId()
    : b_() {
}

ObjectId::ObjectId(const std::vector<uint8_t> &bytes)
    : ObjectId(::flatbuffers::GetSizePrefixedRoot<::ObjectId>(bytes.data())) {
}

ObjectId::ObjectId(const ::ObjectId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

::flatbuffers::Offset<::StreamId>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const StreamId &o) {
    const decltype(builder.CreateVector(o.b_)) b_offset = builder.CreateVector(o.b_);

    ::StreamIdBuilder instance_builder = ::StreamIdBuilder(builder);
    instance_builder.add_b(b_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const StreamId &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

StreamId::StreamId()
    : b_() {
}

StreamId::StreamId(const std::vector<uint8_t> &bytes)
    : StreamId(::flatbuffers::GetSizePrefixedRoot<::StreamId>(bytes.data())) {
}

StreamId::StreamId(const ::StreamId *root) 
    : b_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &b_vector = root->b();
    if (b_vector != nullptr) {
        std::copy(b_vector->begin(), b_vector->end(), std::back_inserter(b_));
    }
}

} // namespace types
} // namespace ul
