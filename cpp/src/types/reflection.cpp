// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/reflection.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::reflection::Type>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::Type &o) {

    ::reflection::TypeBuilder instance_builder = ::reflection::TypeBuilder(builder);
    instance_builder.add_base_size(o.base_size_);
    instance_builder.add_base_type(o.base_type_);
    instance_builder.add_element(o.element_);
    instance_builder.add_element_size(o.element_size_);
    instance_builder.add_fixed_length(o.fixed_length_);
    instance_builder.add_index(o.index_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::Type &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::Type::Type()
    : base_size_(4)
    , base_type_(BaseType(0))
    , element_(BaseType(0))
    , element_size_(0)
    , fixed_length_(0)
    , index_(-1) {
}

reflection::Type::Type(const std::vector<uint8_t> &bytes)
    : Type(::flatbuffers::GetSizePrefixedRoot<::reflection::Type>(bytes.data())) {
}

reflection::Type::Type(const ::reflection::Type *root) 
    : base_size_(4)
    , base_type_(BaseType(0))
    , element_(BaseType(0))
    , element_size_(0)
    , fixed_length_(0)
    , index_(-1) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    base_size_ = root->base_size();
    base_type_ = root->base_type();
    element_ = root->element();
    element_size_ = root->element_size();
    fixed_length_ = root->fixed_length();
    index_ = root->index();
}

::flatbuffers::Offset<::reflection::Enum>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::Enum &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::reflection::KeyValue>> attributes_offsets = std::vector<::flatbuffers::Offset<::reflection::KeyValue>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> declaration_file_offset = std::nullopt;
    if (o.declaration_file_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> declaration_file_offset_val = builder.CreateString(o.declaration_file_.value());
        declaration_file_offset = std::make_optional(declaration_file_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> documentation_offset = std::nullopt;
    if (o.documentation_.has_value()) {
        const auto &documentation__var = o.documentation_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> documentation_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: documentation__var) {
            documentation_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation_offset_val = builder.CreateVector(documentation_offsets);
        documentation_offset = std::make_optional(documentation_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    const ::flatbuffers::Offset<::reflection::Type> underlying_type_offset = serialize_to(builder, o.underlying_type_);
    std::vector<::flatbuffers::Offset<::reflection::EnumVal>> values_offsets = std::vector<::flatbuffers::Offset<::reflection::EnumVal>>();
    values_offsets.reserve(o.values_.size());
    for (const auto &i: o.values_) {
        values_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::EnumVal>>> values_offset = builder.CreateVector(values_offsets);

    ::reflection::EnumBuilder instance_builder = ::reflection::EnumBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    if (declaration_file_offset.has_value()) {
        instance_builder.add_declaration_file(declaration_file_offset.value());
    }
    if (documentation_offset.has_value()) {
        instance_builder.add_documentation(documentation_offset.value());
    }
    instance_builder.add_is_union(o.is_union_);
    instance_builder.add_name(name_offset);
    instance_builder.add_underlying_type(underlying_type_offset);
    instance_builder.add_values(values_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::Enum &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::Enum::Enum()
    : attributes_(std::nullopt)
    , declaration_file_(std::nullopt)
    , documentation_(std::nullopt)
    , is_union_(false)
    , name_()
    , underlying_type_()
    , values_() {
}

reflection::Enum::Enum(const std::vector<uint8_t> &bytes)
    : Enum(::flatbuffers::GetSizePrefixedRoot<::reflection::Enum>(bytes.data())) {
}

reflection::Enum::Enum(const ::reflection::Enum *root) 
    : attributes_(std::nullopt)
    , declaration_file_(std::nullopt)
    , documentation_(std::nullopt)
    , is_union_(false)
    , name_()
    , underlying_type_()
    , values_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    if (root->declaration_file() != nullptr) {
        declaration_file_ = std::string(*root->declaration_file()->begin(), *root->declaration_file()->end());
    }
    const auto &documentation_vector = root->documentation();
    if (documentation_vector != nullptr) {
        std::vector<std::string> documentation__target = std::vector<std::string>();
        for (const auto &i: *documentation_vector) {
            documentation__target.emplace_back(i->begin(), i->end());
        }
        documentation_ = std::make_optional(documentation__target);
    }
    is_union_ = root->is_union();
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->underlying_type() != nullptr) {
        underlying_type_ = decltype(underlying_type_)(root->underlying_type());
    }
    const auto &values_vector = root->values();
    if (values_vector != nullptr) {
        values_.reserve(values_vector->size());
        for (const auto &i: *values_vector) {
            values_.emplace_back(i);
        }
    }
}

::flatbuffers::Offset<::reflection::Object>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::Object &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::reflection::KeyValue>> attributes_offsets = std::vector<::flatbuffers::Offset<::reflection::KeyValue>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> declaration_file_offset = std::nullopt;
    if (o.declaration_file_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> declaration_file_offset_val = builder.CreateString(o.declaration_file_.value());
        declaration_file_offset = std::make_optional(declaration_file_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> documentation_offset = std::nullopt;
    if (o.documentation_.has_value()) {
        const auto &documentation__var = o.documentation_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> documentation_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: documentation__var) {
            documentation_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation_offset_val = builder.CreateVector(documentation_offsets);
        documentation_offset = std::make_optional(documentation_offset_val);
    }
    std::vector<::flatbuffers::Offset<::reflection::Field>> fields_offsets = std::vector<::flatbuffers::Offset<::reflection::Field>>();
    fields_offsets.reserve(o.fields_.size());
    for (const auto &i: o.fields_) {
        fields_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::Field>>> fields_offset = builder.CreateVector(fields_offsets);
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);

    ::reflection::ObjectBuilder instance_builder = ::reflection::ObjectBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    instance_builder.add_bytesize(o.bytesize_);
    if (declaration_file_offset.has_value()) {
        instance_builder.add_declaration_file(declaration_file_offset.value());
    }
    if (documentation_offset.has_value()) {
        instance_builder.add_documentation(documentation_offset.value());
    }
    instance_builder.add_fields(fields_offset);
    instance_builder.add_is_struct(o.is_struct_);
    instance_builder.add_minalign(o.minalign_);
    instance_builder.add_name(name_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::Object &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::Object::Object()
    : attributes_(std::nullopt)
    , bytesize_(0)
    , declaration_file_(std::nullopt)
    , documentation_(std::nullopt)
    , fields_()
    , is_struct_(false)
    , minalign_(0)
    , name_() {
}

reflection::Object::Object(const std::vector<uint8_t> &bytes)
    : Object(::flatbuffers::GetSizePrefixedRoot<::reflection::Object>(bytes.data())) {
}

reflection::Object::Object(const ::reflection::Object *root) 
    : attributes_(std::nullopt)
    , bytesize_(0)
    , declaration_file_(std::nullopt)
    , documentation_(std::nullopt)
    , fields_()
    , is_struct_(false)
    , minalign_(0)
    , name_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    bytesize_ = root->bytesize();
    if (root->declaration_file() != nullptr) {
        declaration_file_ = std::string(*root->declaration_file()->begin(), *root->declaration_file()->end());
    }
    const auto &documentation_vector = root->documentation();
    if (documentation_vector != nullptr) {
        std::vector<std::string> documentation__target = std::vector<std::string>();
        for (const auto &i: *documentation_vector) {
            documentation__target.emplace_back(i->begin(), i->end());
        }
        documentation_ = std::make_optional(documentation__target);
    }
    const auto &fields_vector = root->fields();
    if (fields_vector != nullptr) {
        fields_.reserve(fields_vector->size());
        for (const auto &i: *fields_vector) {
            fields_.emplace_back(i);
        }
    }
    is_struct_ = root->is_struct();
    minalign_ = root->minalign();
        name_ = std::string(*root->name()->begin(), *root->name()->end());
}

::flatbuffers::Offset<::reflection::EnumVal>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::EnumVal &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::reflection::KeyValue>> attributes_offsets = std::vector<::flatbuffers::Offset<::reflection::KeyValue>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> documentation_offset = std::nullopt;
    if (o.documentation_.has_value()) {
        const auto &documentation__var = o.documentation_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> documentation_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: documentation__var) {
            documentation_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation_offset_val = builder.CreateVector(documentation_offsets);
        documentation_offset = std::make_optional(documentation_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    std::optional<::flatbuffers::Offset<::reflection::Type>> union_type_offset = std::nullopt;
    if (o.union_type_.has_value()) {
        const ::flatbuffers::Offset<::reflection::Type> union_type_offset_val = serialize_to(builder, o.union_type_.value());
        union_type_offset = std::make_optional(union_type_offset_val);
    }

    ::reflection::EnumValBuilder instance_builder = ::reflection::EnumValBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    if (documentation_offset.has_value()) {
        instance_builder.add_documentation(documentation_offset.value());
    }
    instance_builder.add_name(name_offset);
    if (union_type_offset.has_value()) {
        instance_builder.add_union_type(union_type_offset.value());
    }
    instance_builder.add_value(o.value_);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::EnumVal &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::EnumVal::EnumVal()
    : attributes_(std::nullopt)
    , documentation_(std::nullopt)
    , name_()
    , union_type_(std::nullopt)
    , value_(0) {
}

reflection::EnumVal::EnumVal(const std::vector<uint8_t> &bytes)
    : EnumVal(::flatbuffers::GetSizePrefixedRoot<::reflection::EnumVal>(bytes.data())) {
}

reflection::EnumVal::EnumVal(const ::reflection::EnumVal *root) 
    : attributes_(std::nullopt)
    , documentation_(std::nullopt)
    , name_()
    , union_type_(std::nullopt)
    , value_(0) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    const auto &documentation_vector = root->documentation();
    if (documentation_vector != nullptr) {
        std::vector<std::string> documentation__target = std::vector<std::string>();
        for (const auto &i: *documentation_vector) {
            documentation__target.emplace_back(i->begin(), i->end());
        }
        documentation_ = std::make_optional(documentation__target);
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->union_type() != nullptr) {
        union_type_ = decltype(union_type_)(root->union_type());
    }
    value_ = root->value();
}

::flatbuffers::Offset<::reflection::Field>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::Field &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::reflection::KeyValue>> attributes_offsets = std::vector<::flatbuffers::Offset<::reflection::KeyValue>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> documentation_offset = std::nullopt;
    if (o.documentation_.has_value()) {
        const auto &documentation__var = o.documentation_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> documentation_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: documentation__var) {
            documentation_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation_offset_val = builder.CreateVector(documentation_offsets);
        documentation_offset = std::make_optional(documentation_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    const ::flatbuffers::Offset<::reflection::Type> type_offset = serialize_to(builder, o.type_);

    ::reflection::FieldBuilder instance_builder = ::reflection::FieldBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    instance_builder.add_default_integer(o.default_integer_);
    instance_builder.add_default_real(o.default_real_);
    instance_builder.add_deprecated(o.deprecated_);
    if (documentation_offset.has_value()) {
        instance_builder.add_documentation(documentation_offset.value());
    }
    instance_builder.add_id(o.id_);
    instance_builder.add_key(o.key_);
    instance_builder.add_name(name_offset);
    instance_builder.add_offset(o.offset_);
    instance_builder.add_offset64(o.offset64_);
    instance_builder.add_optional(o.optional_);
    instance_builder.add_padding(o.padding_);
    instance_builder.add_required(o.required_);
    instance_builder.add_type(type_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::Field &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::Field::Field()
    : attributes_(std::nullopt)
    , default_integer_(0)
    , default_real_(0)
    , deprecated_(false)
    , documentation_(std::nullopt)
    , id_(0)
    , key_(false)
    , name_()
    , offset_(0)
    , offset64_(false)
    , optional_(false)
    , padding_(0)
    , required_(false)
    , type_() {
}

reflection::Field::Field(const std::vector<uint8_t> &bytes)
    : Field(::flatbuffers::GetSizePrefixedRoot<::reflection::Field>(bytes.data())) {
}

reflection::Field::Field(const ::reflection::Field *root) 
    : attributes_(std::nullopt)
    , default_integer_(0)
    , default_real_(0)
    , deprecated_(false)
    , documentation_(std::nullopt)
    , id_(0)
    , key_(false)
    , name_()
    , offset_(0)
    , offset64_(false)
    , optional_(false)
    , padding_(0)
    , required_(false)
    , type_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    default_integer_ = root->default_integer();
    default_real_ = root->default_real();
    deprecated_ = root->deprecated();
    const auto &documentation_vector = root->documentation();
    if (documentation_vector != nullptr) {
        std::vector<std::string> documentation__target = std::vector<std::string>();
        for (const auto &i: *documentation_vector) {
            documentation__target.emplace_back(i->begin(), i->end());
        }
        documentation_ = std::make_optional(documentation__target);
    }
    id_ = root->id();
    key_ = root->key();
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    offset_ = root->offset();
    offset64_ = root->offset64();
    optional_ = root->optional();
    padding_ = root->padding();
    required_ = root->required();
    if (root->type() != nullptr) {
        type_ = decltype(type_)(root->type());
    }
}

::flatbuffers::Offset<::reflection::KeyValue>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::KeyValue &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> key_offset = builder.CreateString(o.key_);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> value_offset = std::nullopt;
    if (o.value_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> value_offset_val = builder.CreateString(o.value_.value());
        value_offset = std::make_optional(value_offset_val);
    }

    ::reflection::KeyValueBuilder instance_builder = ::reflection::KeyValueBuilder(builder);
    instance_builder.add_key(key_offset);
    if (value_offset.has_value()) {
        instance_builder.add_value(value_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::KeyValue &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::KeyValue::KeyValue()
    : key_()
    , value_(std::nullopt) {
}

reflection::KeyValue::KeyValue(const std::vector<uint8_t> &bytes)
    : KeyValue(::flatbuffers::GetSizePrefixedRoot<::reflection::KeyValue>(bytes.data())) {
}

reflection::KeyValue::KeyValue(const ::reflection::KeyValue *root) 
    : key_()
    , value_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        key_ = std::string(*root->key()->begin(), *root->key()->end());
    if (root->value() != nullptr) {
        value_ = std::string(*root->value()->begin(), *root->value()->end());
    }
}

::flatbuffers::Offset<::reflection::RPCCall>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::RPCCall &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::reflection::KeyValue>> attributes_offsets = std::vector<::flatbuffers::Offset<::reflection::KeyValue>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> documentation_offset = std::nullopt;
    if (o.documentation_.has_value()) {
        const auto &documentation__var = o.documentation_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> documentation_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: documentation__var) {
            documentation_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation_offset_val = builder.CreateVector(documentation_offsets);
        documentation_offset = std::make_optional(documentation_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    const ::flatbuffers::Offset<::reflection::Object> request_offset = serialize_to(builder, o.request_);
    const ::flatbuffers::Offset<::reflection::Object> response_offset = serialize_to(builder, o.response_);

    ::reflection::RPCCallBuilder instance_builder = ::reflection::RPCCallBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    if (documentation_offset.has_value()) {
        instance_builder.add_documentation(documentation_offset.value());
    }
    instance_builder.add_name(name_offset);
    instance_builder.add_request(request_offset);
    instance_builder.add_response(response_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::RPCCall &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::RPCCall::RPCCall()
    : attributes_(std::nullopt)
    , documentation_(std::nullopt)
    , name_()
    , request_()
    , response_() {
}

reflection::RPCCall::RPCCall(const std::vector<uint8_t> &bytes)
    : RPCCall(::flatbuffers::GetSizePrefixedRoot<::reflection::RPCCall>(bytes.data())) {
}

reflection::RPCCall::RPCCall(const ::reflection::RPCCall *root) 
    : attributes_(std::nullopt)
    , documentation_(std::nullopt)
    , name_()
    , request_()
    , response_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    const auto &documentation_vector = root->documentation();
    if (documentation_vector != nullptr) {
        std::vector<std::string> documentation__target = std::vector<std::string>();
        for (const auto &i: *documentation_vector) {
            documentation__target.emplace_back(i->begin(), i->end());
        }
        documentation_ = std::make_optional(documentation__target);
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->request() != nullptr) {
        request_ = decltype(request_)(root->request());
    }
    if (root->response() != nullptr) {
        response_ = decltype(response_)(root->response());
    }
}

::flatbuffers::Offset<::reflection::Schema>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::Schema &o) {
    std::vector<::flatbuffers::Offset<::reflection::Enum>> enums_offsets = std::vector<::flatbuffers::Offset<::reflection::Enum>>();
    enums_offsets.reserve(o.enums_.size());
    for (const auto &i: o.enums_) {
        enums_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::Enum>>> enums_offset = builder.CreateVector(enums_offsets);
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::SchemaFile>>>> fbs_files_offset = std::nullopt;
    if (o.fbs_files_.has_value()) {
        const auto &fbs_files__var = o.fbs_files_.value();
        std::vector<::flatbuffers::Offset<::reflection::SchemaFile>> fbs_files_offsets = std::vector<::flatbuffers::Offset<::reflection::SchemaFile>>();
        fbs_files_offsets.reserve(fbs_files__var.size());
        for (const auto &i: fbs_files__var) {
            fbs_files_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::SchemaFile>>> fbs_files_offset_val = builder.CreateVector(fbs_files_offsets);
        fbs_files_offset = std::make_optional(fbs_files_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> file_ext_offset = std::nullopt;
    if (o.file_ext_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> file_ext_offset_val = builder.CreateString(o.file_ext_.value());
        file_ext_offset = std::make_optional(file_ext_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> file_ident_offset = std::nullopt;
    if (o.file_ident_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> file_ident_offset_val = builder.CreateString(o.file_ident_.value());
        file_ident_offset = std::make_optional(file_ident_offset_val);
    }
    std::vector<::flatbuffers::Offset<::reflection::Object>> objects_offsets = std::vector<::flatbuffers::Offset<::reflection::Object>>();
    objects_offsets.reserve(o.objects_.size());
    for (const auto &i: o.objects_) {
        objects_offsets.push_back(serialize_to(builder, i));
    }
    const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::Object>>> objects_offset = builder.CreateVector(objects_offsets);
    std::optional<::flatbuffers::Offset<::reflection::Object>> root_table_offset = std::nullopt;
    if (o.root_table_.has_value()) {
        const ::flatbuffers::Offset<::reflection::Object> root_table_offset_val = serialize_to(builder, o.root_table_.value());
        root_table_offset = std::make_optional(root_table_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::Service>>>> services_offset = std::nullopt;
    if (o.services_.has_value()) {
        const auto &services__var = o.services_.value();
        std::vector<::flatbuffers::Offset<::reflection::Service>> services_offsets = std::vector<::flatbuffers::Offset<::reflection::Service>>();
        services_offsets.reserve(services__var.size());
        for (const auto &i: services__var) {
            services_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::Service>>> services_offset_val = builder.CreateVector(services_offsets);
        services_offset = std::make_optional(services_offset_val);
    }

    ::reflection::SchemaBuilder instance_builder = ::reflection::SchemaBuilder(builder);
    instance_builder.add_advanced_features(o.advanced_features_);
    instance_builder.add_enums(enums_offset);
    if (fbs_files_offset.has_value()) {
        instance_builder.add_fbs_files(fbs_files_offset.value());
    }
    if (file_ext_offset.has_value()) {
        instance_builder.add_file_ext(file_ext_offset.value());
    }
    if (file_ident_offset.has_value()) {
        instance_builder.add_file_ident(file_ident_offset.value());
    }
    instance_builder.add_objects(objects_offset);
    if (root_table_offset.has_value()) {
        instance_builder.add_root_table(root_table_offset.value());
    }
    if (services_offset.has_value()) {
        instance_builder.add_services(services_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::Schema &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::Schema::Schema()
    : advanced_features_(AdvancedFeatures(0))
    , enums_()
    , fbs_files_(std::nullopt)
    , file_ext_(std::nullopt)
    , file_ident_(std::nullopt)
    , objects_()
    , root_table_(std::nullopt)
    , services_(std::nullopt) {
}

reflection::Schema::Schema(const std::vector<uint8_t> &bytes)
    : Schema(::flatbuffers::GetSizePrefixedRoot<::reflection::Schema>(bytes.data())) {
}

reflection::Schema::Schema(const ::reflection::Schema *root) 
    : advanced_features_(AdvancedFeatures(0))
    , enums_()
    , fbs_files_(std::nullopt)
    , file_ext_(std::nullopt)
    , file_ident_(std::nullopt)
    , objects_()
    , root_table_(std::nullopt)
    , services_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    advanced_features_ = root->advanced_features();
    const auto &enums_vector = root->enums();
    if (enums_vector != nullptr) {
        enums_.reserve(enums_vector->size());
        for (const auto &i: *enums_vector) {
            enums_.emplace_back(i);
        }
    }
    const auto &fbs_files_vector = root->fbs_files();
    if (fbs_files_vector != nullptr) {
        decltype(fbs_files_)::value_type fbs_files__target = decltype(fbs_files_)::value_type();
        fbs_files__target.reserve(fbs_files_vector->size());
        for (const auto &i: *fbs_files_vector) {
            fbs_files__target.emplace_back(i);
        }
        fbs_files_ = std::make_optional(fbs_files__target);
    }
    if (root->file_ext() != nullptr) {
        file_ext_ = std::string(*root->file_ext()->begin(), *root->file_ext()->end());
    }
    if (root->file_ident() != nullptr) {
        file_ident_ = std::string(*root->file_ident()->begin(), *root->file_ident()->end());
    }
    const auto &objects_vector = root->objects();
    if (objects_vector != nullptr) {
        objects_.reserve(objects_vector->size());
        for (const auto &i: *objects_vector) {
            objects_.emplace_back(i);
        }
    }
    if (root->root_table() != nullptr) {
        root_table_ = decltype(root_table_)(root->root_table());
    }
    const auto &services_vector = root->services();
    if (services_vector != nullptr) {
        decltype(services_)::value_type services__target = decltype(services_)::value_type();
        services__target.reserve(services_vector->size());
        for (const auto &i: *services_vector) {
            services__target.emplace_back(i);
        }
        services_ = std::make_optional(services__target);
    }
}

::flatbuffers::Offset<::reflection::SchemaFile>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::SchemaFile &o) {
    const ::flatbuffers::Offset<::flatbuffers::String> filename_offset = builder.CreateString(o.filename_);
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> included_filenames_offset = std::nullopt;
    if (o.included_filenames_.has_value()) {
        const auto &included_filenames__var = o.included_filenames_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> included_filenames_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: included_filenames__var) {
            included_filenames_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> included_filenames_offset_val = builder.CreateVector(included_filenames_offsets);
        included_filenames_offset = std::make_optional(included_filenames_offset_val);
    }

    ::reflection::SchemaFileBuilder instance_builder = ::reflection::SchemaFileBuilder(builder);
    instance_builder.add_filename(filename_offset);
    if (included_filenames_offset.has_value()) {
        instance_builder.add_included_filenames(included_filenames_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::SchemaFile &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::SchemaFile::SchemaFile()
    : filename_()
    , included_filenames_(std::nullopt) {
}

reflection::SchemaFile::SchemaFile(const std::vector<uint8_t> &bytes)
    : SchemaFile(::flatbuffers::GetSizePrefixedRoot<::reflection::SchemaFile>(bytes.data())) {
}

reflection::SchemaFile::SchemaFile(const ::reflection::SchemaFile *root) 
    : filename_()
    , included_filenames_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

        filename_ = std::string(*root->filename()->begin(), *root->filename()->end());
    const auto &included_filenames_vector = root->included_filenames();
    if (included_filenames_vector != nullptr) {
        std::vector<std::string> included_filenames__target = std::vector<std::string>();
        for (const auto &i: *included_filenames_vector) {
            included_filenames__target.emplace_back(i->begin(), i->end());
        }
        included_filenames_ = std::make_optional(included_filenames__target);
    }
}

::flatbuffers::Offset<::reflection::Service>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const reflection::Service &o) {
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>>> attributes_offset = std::nullopt;
    if (o.attributes_.has_value()) {
        const auto &attributes__var = o.attributes_.value();
        std::vector<::flatbuffers::Offset<::reflection::KeyValue>> attributes_offsets = std::vector<::flatbuffers::Offset<::reflection::KeyValue>>();
        attributes_offsets.reserve(attributes__var.size());
        for (const auto &i: attributes__var) {
            attributes_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::KeyValue>>> attributes_offset_val = builder.CreateVector(attributes_offsets);
        attributes_offset = std::make_optional(attributes_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::RPCCall>>>> calls_offset = std::nullopt;
    if (o.calls_.has_value()) {
        const auto &calls__var = o.calls_.value();
        std::vector<::flatbuffers::Offset<::reflection::RPCCall>> calls_offsets = std::vector<::flatbuffers::Offset<::reflection::RPCCall>>();
        calls_offsets.reserve(calls__var.size());
        for (const auto &i: calls__var) {
            calls_offsets.push_back(serialize_to(builder, i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::reflection::RPCCall>>> calls_offset_val = builder.CreateVector(calls_offsets);
        calls_offset = std::make_optional(calls_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> declaration_file_offset = std::nullopt;
    if (o.declaration_file_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> declaration_file_offset_val = builder.CreateString(o.declaration_file_.value());
        declaration_file_offset = std::make_optional(declaration_file_offset_val);
    }
    std::optional<::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>> documentation_offset = std::nullopt;
    if (o.documentation_.has_value()) {
        const auto &documentation__var = o.documentation_.value();
        std::vector<::flatbuffers::Offset<::flatbuffers::String>> documentation_offsets = std::vector<::flatbuffers::Offset<::flatbuffers::String>>();
        for (const auto &i: documentation__var) {
            documentation_offsets.push_back(builder.CreateString(i));
        }
        const ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> documentation_offset_val = builder.CreateVector(documentation_offsets);
        documentation_offset = std::make_optional(documentation_offset_val);
    }
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);

    ::reflection::ServiceBuilder instance_builder = ::reflection::ServiceBuilder(builder);
    if (attributes_offset.has_value()) {
        instance_builder.add_attributes(attributes_offset.value());
    }
    if (calls_offset.has_value()) {
        instance_builder.add_calls(calls_offset.value());
    }
    if (declaration_file_offset.has_value()) {
        instance_builder.add_declaration_file(declaration_file_offset.value());
    }
    if (documentation_offset.has_value()) {
        instance_builder.add_documentation(documentation_offset.value());
    }
    instance_builder.add_name(name_offset);
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const reflection::Service &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

reflection::Service::Service()
    : attributes_(std::nullopt)
    , calls_(std::nullopt)
    , declaration_file_(std::nullopt)
    , documentation_(std::nullopt)
    , name_() {
}

reflection::Service::Service(const std::vector<uint8_t> &bytes)
    : Service(::flatbuffers::GetSizePrefixedRoot<::reflection::Service>(bytes.data())) {
}

reflection::Service::Service(const ::reflection::Service *root) 
    : attributes_(std::nullopt)
    , calls_(std::nullopt)
    , declaration_file_(std::nullopt)
    , documentation_(std::nullopt)
    , name_() {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    const auto &attributes_vector = root->attributes();
    if (attributes_vector != nullptr) {
        decltype(attributes_)::value_type attributes__target = decltype(attributes_)::value_type();
        attributes__target.reserve(attributes_vector->size());
        for (const auto &i: *attributes_vector) {
            attributes__target.emplace_back(i);
        }
        attributes_ = std::make_optional(attributes__target);
    }
    const auto &calls_vector = root->calls();
    if (calls_vector != nullptr) {
        decltype(calls_)::value_type calls__target = decltype(calls_)::value_type();
        calls__target.reserve(calls_vector->size());
        for (const auto &i: *calls_vector) {
            calls__target.emplace_back(i);
        }
        calls_ = std::make_optional(calls__target);
    }
    if (root->declaration_file() != nullptr) {
        declaration_file_ = std::string(*root->declaration_file()->begin(), *root->declaration_file()->end());
    }
    const auto &documentation_vector = root->documentation();
    if (documentation_vector != nullptr) {
        std::vector<std::string> documentation__target = std::vector<std::string>();
        for (const auto &i: *documentation_vector) {
            documentation__target.emplace_back(i->begin(), i->end());
        }
        documentation_ = std::make_optional(documentation__target);
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
}

} // namespace types
} // namespace ul
