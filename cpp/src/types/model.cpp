// Copyright (c), CommunityLogiq Software
// 
// THIS FILE IS AUTOGENERATED, DO NOT EDIT

#include <stdexcept>

#include "ulsdk/types/model.h"

namespace ul {
namespace types {

::flatbuffers::Offset<::Model>
serialize_to(::flatbuffers::FlatBufferBuilder &builder, const Model &o) {
    const ::flatbuffers::Offset<::ObjectId> location_offset = serialize_to(builder, o.location_);
    const ::flatbuffers::Offset<::flatbuffers::String> name_offset = builder.CreateString(o.name_);
    std::optional<::flatbuffers::Offset<::flatbuffers::String>> source_offset = std::nullopt;
    if (o.source_.has_value()) {
        const ::flatbuffers::Offset<::flatbuffers::String> source_offset_val = builder.CreateString(o.source_.value());
        source_offset = std::make_optional(source_offset_val);
    }

    ::ModelBuilder instance_builder = ::ModelBuilder(builder);
    instance_builder.add_location(location_offset);
    instance_builder.add_name(name_offset);
    if (source_offset.has_value()) {
        instance_builder.add_source(source_offset.value());
    }
    return instance_builder.Finish();
}

std::vector<uint8_t> to_bytes(const Model &o) {
    ::flatbuffers::FlatBufferBuilder builder;
    const auto offset = serialize_to(builder, o);
    builder.FinishSizePrefixed(offset);
    const auto span = builder.GetBufferSpan();
    return std::vector<uint8_t>(span.begin(), span.end());
}

Model::Model()
    : location_()
    , name_()
    , source_(std::nullopt) {
}

Model::Model(const std::vector<uint8_t> &bytes)
    : Model(::flatbuffers::GetSizePrefixedRoot<::Model>(bytes.data())) {
}

Model::Model(const ::Model *root) 
    : location_()
    , name_()
    , source_(std::nullopt) {
    if (root == nullptr) {
        throw std::runtime_error("cannot deserialize flatbuffer type");
    }

    if (root->location() != nullptr) {
        location_ = decltype(location_)(root->location());
    }
        name_ = std::string(*root->name()->begin(), *root->name()->end());
    if (root->source() != nullptr) {
        source_ = std::string(*root->source()->begin(), *root->source()->end());
    }
}

} // namespace types
} // namespace ul
