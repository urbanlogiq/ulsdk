# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .generated.reflection.Enum import Enum as FbsEnum
from .generated.reflection.EnumVal import EnumVal as FbsEnumVal
from .generated.reflection.Field import Field as FbsField
from .generated.reflection.KeyValue import KeyValue as FbsKeyValue
from .generated.reflection.Object import Object as FbsObject
from .generated.reflection.RPCCall import RPCCall as FbsRPCCall
from .generated.reflection.Schema import Schema as FbsSchema
from .generated.reflection.SchemaFile import SchemaFile as FbsSchemaFile
from .generated.reflection.Service import Service as FbsService
from .generated.reflection.Type import Type as FbsType

class ReflectionAdvancedFeatures(Enum):
    AdvancedArrayFeatures = 1
    AdvancedUnionFeatures = 2
    OptionalScalars = 4
    DefaultVectorsAndStrings = 8

class ReflectionBaseType(Enum):
    None_ = 0
    UType = 1
    Bool = 2
    Byte = 3
    UByte = 4
    Short = 5
    UShort = 6
    Int = 7
    UInt = 8
    Long = 9
    ULong = 10
    Float = 11
    Double = 12
    String = 13
    Vector = 14
    Obj = 15
    Union_ = 16
    Array = 17
    Vector64 = 18
    MaxBaseType = 19


@dataclass
class ReflectionType:
    # The size (octets) of the `base_type` field.
    base_size: "int"

    base_type: "ReflectionBaseType"

    element: "ReflectionBaseType"

    # The size (octets) of the `element` field, if present.
    element_size: "int"

    fixed_length: "int"

    index: "int"

    @classmethod
    def from_fbs(cls, o: FbsType) -> Self:
        base_size = o.BaseSize()
        base_type = ReflectionBaseType(o.BaseType())
        element = ReflectionBaseType(o.Element())
        element_size = o.ElementSize()
        fixed_length = o.FixedLength()
        index = o.Index()
        return cls(base_size, base_type, element, element_size, fixed_length, index)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsType.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.Type import (
            Start,
            AddBaseSize,
            AddBaseType,
            AddElement,
            AddElementSize,
            AddFixedLength,
            AddIndex,
            End,
        )
        
        Start(builder)
        AddBaseSize(builder, self.base_size)
        AddBaseType(builder, self.base_type.value)
        AddElement(builder, self.element.value)
        AddElementSize(builder, self.element_size)
        AddFixedLength(builder, self.fixed_length)
        AddIndex(builder, self.index)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        base_size = 0
        base_type = ReflectionBaseType(0)
        element = ReflectionBaseType(0)
        element_size = 0
        fixed_length = 0
        index = 0
        return cls(base_size, base_type, element, element_size, fixed_length, index)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.base_size == other.base_size
        eq = eq and self.base_type == other.base_type
        eq = eq and self.element == other.element
        eq = eq and self.element_size == other.element_size
        eq = eq and self.fixed_length == other.fixed_length
        eq = eq and self.index == other.index

        return eq

@dataclass
class ReflectionEnum:
    attributes: Optional["List[ReflectionKeyValue]"]

    # File that this Enum is declared in.
    declaration_file: Optional["str"]

    documentation: Optional["List[str]"]

    is_union: "bool"

    name: "str"

    underlying_type: "ReflectionType"

    values: "List[ReflectionEnumVal]"

    @classmethod
    def from_fbs(cls, o: FbsEnum) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = ReflectionKeyValue.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        declaration_file = None
        declaration_file_str = o.DeclarationFile()
        if declaration_file_str is not None:
            declaration_file = declaration_file_str.decode('utf-8')
        documentation = list()
        if not o.DocumentationIsNone():
            for i in range(o.DocumentationLength()):
                documentation.append(o.Documentation(i))
        is_union = o.IsUnion()
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        underlying_type_obj = o.UnderlyingType()
        if underlying_type_obj is not None:
            underlying_type = ReflectionType.from_fbs(underlying_type_obj)
        else:
            raise ValueError("UnderlyingType is required")
        values = list()
        if not o.ValuesIsNone():
            for i in range(o.ValuesLength()):
                values_val = None
                values_obj = o.Values(i)
                if values_obj is not None:
                    values_val = ReflectionEnumVal.from_fbs(values_obj)
                values.append(values_val)
        return cls(attributes, declaration_file, documentation, is_union, name, underlying_type, values)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsEnum.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.Enum import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddDeclarationFile,
            AddDocumentation,
            StartDocumentationVector,
            AddIsUnion,
            AddName,
            AddUnderlyingType,
            AddValues,
            StartValuesVector,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        declaration_file_offset = None
        if self.declaration_file is not None:
            declaration_file_offset = builder.CreateString(self.declaration_file)
        documentation_offset = None
        if self.documentation is not None:
            documentation_offsets = list()
            for value in self.documentation:
                documentation_offsets.append(builder.CreateString(value))
            StartDocumentationVector(builder, len(self.documentation))
            for i in reversed(range(len(self.documentation))):
                builder.PrependUOffsetTRelative(documentation_offsets[i])
            documentation_offset = builder.EndVector()
        name_offset = builder.CreateString(self.name)
        underlying_type_offset = self.underlying_type.serialize_to(builder)
        values_offsets = list()
        for value in self.values:
            values_offsets.append(value.serialize_to(builder))
        StartValuesVector(builder, len(self.values))
        for i in reversed(range(len(self.values))):
            builder.PrependUOffsetTRelative(values_offsets[i])
        values_offset = builder.EndVector()
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        if declaration_file_offset is not None:
            AddDeclarationFile(builder, declaration_file_offset)
        if documentation_offset is not None:
            AddDocumentation(builder, documentation_offset)
        AddIsUnion(builder, self.is_union)
        AddName(builder, name_offset)
        AddUnderlyingType(builder, underlying_type_offset)
        AddValues(builder, values_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        declaration_file = ""
        documentation = []
        is_union = False
        name = ""
        underlying_type = ReflectionType.make_default()
        values = []
        return cls(attributes, declaration_file, documentation, is_union, name, underlying_type, values)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        eq = eq and self.declaration_file == other.declaration_file
        self_documentation = self.documentation
        other_documentation = other.documentation
        if self_documentation is not None and other_documentation is not None:
            if len(self_documentation) != len(other_documentation):
                return False
            for i in range(len(self_documentation)):
                eq = eq and self_documentation[i] == other_documentation[i]
        elif self_documentation is not None and other_documentation is None:
            return False
        elif self_documentation is None and other_documentation is not None:
            return False
        eq = eq and self.is_union == other.is_union
        eq = eq and self.name == other.name
        eq = eq and self.underlying_type == other.underlying_type
        if len(self.values) != len(other.values):
            return False
        for i in range(len(self.values)):
            eq = eq and self.values[i] == other.values[i]

        return eq

@dataclass
class ReflectionObject:
    attributes: Optional["List[ReflectionKeyValue]"]

    bytesize: "int"

    # File that this Object is declared in.
    declaration_file: Optional["str"]

    documentation: Optional["List[str]"]

    fields: "List[ReflectionField]"

    is_struct: "bool"

    minalign: "int"

    name: "str"

    @classmethod
    def from_fbs(cls, o: FbsObject) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = ReflectionKeyValue.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        bytesize = o.Bytesize()
        declaration_file = None
        declaration_file_str = o.DeclarationFile()
        if declaration_file_str is not None:
            declaration_file = declaration_file_str.decode('utf-8')
        documentation = list()
        if not o.DocumentationIsNone():
            for i in range(o.DocumentationLength()):
                documentation.append(o.Documentation(i))
        fields = list()
        if not o.FieldsIsNone():
            for i in range(o.FieldsLength()):
                fields_val = None
                fields_obj = o.Fields(i)
                if fields_obj is not None:
                    fields_val = ReflectionField.from_fbs(fields_obj)
                fields.append(fields_val)
        is_struct = o.IsStruct()
        minalign = o.Minalign()
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        return cls(attributes, bytesize, declaration_file, documentation, fields, is_struct, minalign, name)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsObject.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.Object import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddBytesize,
            AddDeclarationFile,
            AddDocumentation,
            StartDocumentationVector,
            AddFields,
            StartFieldsVector,
            AddIsStruct,
            AddMinalign,
            AddName,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        declaration_file_offset = None
        if self.declaration_file is not None:
            declaration_file_offset = builder.CreateString(self.declaration_file)
        documentation_offset = None
        if self.documentation is not None:
            documentation_offsets = list()
            for value in self.documentation:
                documentation_offsets.append(builder.CreateString(value))
            StartDocumentationVector(builder, len(self.documentation))
            for i in reversed(range(len(self.documentation))):
                builder.PrependUOffsetTRelative(documentation_offsets[i])
            documentation_offset = builder.EndVector()
        fields_offsets = list()
        for value in self.fields:
            fields_offsets.append(value.serialize_to(builder))
        StartFieldsVector(builder, len(self.fields))
        for i in reversed(range(len(self.fields))):
            builder.PrependUOffsetTRelative(fields_offsets[i])
        fields_offset = builder.EndVector()
        name_offset = builder.CreateString(self.name)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        AddBytesize(builder, self.bytesize)
        if declaration_file_offset is not None:
            AddDeclarationFile(builder, declaration_file_offset)
        if documentation_offset is not None:
            AddDocumentation(builder, documentation_offset)
        AddFields(builder, fields_offset)
        AddIsStruct(builder, self.is_struct)
        AddMinalign(builder, self.minalign)
        AddName(builder, name_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        bytesize = 0
        declaration_file = ""
        documentation = []
        fields = []
        is_struct = False
        minalign = 0
        name = ""
        return cls(attributes, bytesize, declaration_file, documentation, fields, is_struct, minalign, name)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        eq = eq and self.bytesize == other.bytesize
        eq = eq and self.declaration_file == other.declaration_file
        self_documentation = self.documentation
        other_documentation = other.documentation
        if self_documentation is not None and other_documentation is not None:
            if len(self_documentation) != len(other_documentation):
                return False
            for i in range(len(self_documentation)):
                eq = eq and self_documentation[i] == other_documentation[i]
        elif self_documentation is not None and other_documentation is None:
            return False
        elif self_documentation is None and other_documentation is not None:
            return False
        if len(self.fields) != len(other.fields):
            return False
        for i in range(len(self.fields)):
            eq = eq and self.fields[i] == other.fields[i]
        eq = eq and self.is_struct == other.is_struct
        eq = eq and self.minalign == other.minalign
        eq = eq and self.name == other.name

        return eq

@dataclass
class ReflectionEnumVal:
    attributes: Optional["List[ReflectionKeyValue]"]

    documentation: Optional["List[str]"]

    name: "str"

    union_type: Optional["ReflectionType"]

    value: "int"

    @classmethod
    def from_fbs(cls, o: FbsEnumVal) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = ReflectionKeyValue.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        documentation = list()
        if not o.DocumentationIsNone():
            for i in range(o.DocumentationLength()):
                documentation.append(o.Documentation(i))
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        union_type = None
        union_type_obj = o.UnionType()
        if union_type_obj is not None:
            union_type = ReflectionType.from_fbs(union_type_obj)
        value = o.Value()
        return cls(attributes, documentation, name, union_type, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsEnumVal.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.EnumVal import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddDocumentation,
            StartDocumentationVector,
            AddName,
            AddUnionType,
            AddValue,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        documentation_offset = None
        if self.documentation is not None:
            documentation_offsets = list()
            for value in self.documentation:
                documentation_offsets.append(builder.CreateString(value))
            StartDocumentationVector(builder, len(self.documentation))
            for i in reversed(range(len(self.documentation))):
                builder.PrependUOffsetTRelative(documentation_offsets[i])
            documentation_offset = builder.EndVector()
        name_offset = builder.CreateString(self.name)
        union_type_offset = None
        if self.union_type is not None:
            union_type_offset = self.union_type.serialize_to(builder)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        if documentation_offset is not None:
            AddDocumentation(builder, documentation_offset)
        AddName(builder, name_offset)
        if union_type_offset is not None:
            AddUnionType(builder, union_type_offset)
        AddValue(builder, self.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        documentation = []
        name = ""
        union_type = ReflectionType.make_default()
        value = 0
        return cls(attributes, documentation, name, union_type, value)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        self_documentation = self.documentation
        other_documentation = other.documentation
        if self_documentation is not None and other_documentation is not None:
            if len(self_documentation) != len(other_documentation):
                return False
            for i in range(len(self_documentation)):
                eq = eq and self_documentation[i] == other_documentation[i]
        elif self_documentation is not None and other_documentation is None:
            return False
        elif self_documentation is None and other_documentation is not None:
            return False
        eq = eq and self.name == other.name
        eq = eq and self.union_type == other.union_type
        eq = eq and self.value == other.value

        return eq

@dataclass
class ReflectionField:
    attributes: Optional["List[ReflectionKeyValue]"]

    default_integer: "int"

    default_real: "float"

    deprecated: "bool"

    documentation: Optional["List[str]"]

    id: "int"

    key: "bool"

    name: "str"

    offset: "int"

    # If the field uses 64-bit offsets.
    offset64: "bool"

    optional: "bool"

    # Number of padding octets to always add after this field. Structs only.
    padding: "int"

    required: "bool"

    type: "ReflectionType"

    @classmethod
    def from_fbs(cls, o: FbsField) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = ReflectionKeyValue.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        default_integer = o.DefaultInteger()
        default_real = o.DefaultReal()
        deprecated = o.Deprecated()
        documentation = list()
        if not o.DocumentationIsNone():
            for i in range(o.DocumentationLength()):
                documentation.append(o.Documentation(i))
        id = o.Id()
        key = o.Key()
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        offset = o.Offset()
        offset64 = o.Offset64()
        optional = o.Optional()
        padding = o.Padding()
        required = o.Required()
        type_obj = o.Type()
        if type_obj is not None:
            type = ReflectionType.from_fbs(type_obj)
        else:
            raise ValueError("Type is required")
        return cls(attributes, default_integer, default_real, deprecated, documentation, id, key, name, offset, offset64, optional, padding, required, type)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsField.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.Field import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddDefaultInteger,
            AddDefaultReal,
            AddDeprecated,
            AddDocumentation,
            StartDocumentationVector,
            AddId,
            AddKey,
            AddName,
            AddOffset,
            AddOffset64,
            AddOptional,
            AddPadding,
            AddRequired,
            AddType,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        documentation_offset = None
        if self.documentation is not None:
            documentation_offsets = list()
            for value in self.documentation:
                documentation_offsets.append(builder.CreateString(value))
            StartDocumentationVector(builder, len(self.documentation))
            for i in reversed(range(len(self.documentation))):
                builder.PrependUOffsetTRelative(documentation_offsets[i])
            documentation_offset = builder.EndVector()
        name_offset = builder.CreateString(self.name)
        type_offset = self.type.serialize_to(builder)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        AddDefaultInteger(builder, self.default_integer)
        AddDefaultReal(builder, self.default_real)
        AddDeprecated(builder, self.deprecated)
        if documentation_offset is not None:
            AddDocumentation(builder, documentation_offset)
        AddId(builder, self.id)
        AddKey(builder, self.key)
        AddName(builder, name_offset)
        AddOffset(builder, self.offset)
        AddOffset64(builder, self.offset64)
        AddOptional(builder, self.optional)
        AddPadding(builder, self.padding)
        AddRequired(builder, self.required)
        AddType(builder, type_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        default_integer = 0
        default_real = 0.0
        deprecated = False
        documentation = []
        id = 0
        key = False
        name = ""
        offset = 0
        offset64 = False
        optional = False
        padding = 0
        required = False
        type = ReflectionType.make_default()
        return cls(attributes, default_integer, default_real, deprecated, documentation, id, key, name, offset, offset64, optional, padding, required, type)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        eq = eq and self.default_integer == other.default_integer
        eq = eq and self.default_real == other.default_real
        eq = eq and self.deprecated == other.deprecated
        self_documentation = self.documentation
        other_documentation = other.documentation
        if self_documentation is not None and other_documentation is not None:
            if len(self_documentation) != len(other_documentation):
                return False
            for i in range(len(self_documentation)):
                eq = eq and self_documentation[i] == other_documentation[i]
        elif self_documentation is not None and other_documentation is None:
            return False
        elif self_documentation is None and other_documentation is not None:
            return False
        eq = eq and self.id == other.id
        eq = eq and self.key == other.key
        eq = eq and self.name == other.name
        eq = eq and self.offset == other.offset
        eq = eq and self.offset64 == other.offset64
        eq = eq and self.optional == other.optional
        eq = eq and self.padding == other.padding
        eq = eq and self.required == other.required
        eq = eq and self.type == other.type

        return eq

@dataclass
class ReflectionKeyValue:
    key: "str"

    value: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsKeyValue) -> Self:
        key_str = o.Key()
        assert key_str is not None
        key = key_str.decode('utf-8')
        value = None
        value_str = o.Value()
        if value_str is not None:
            value = value_str.decode('utf-8')
        return cls(key, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsKeyValue.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.KeyValue import (
            Start,
            AddKey,
            AddValue,
            End,
        )
        key_offset = builder.CreateString(self.key)
        value_offset = None
        if self.value is not None:
            value_offset = builder.CreateString(self.value)
        
        Start(builder)
        AddKey(builder, key_offset)
        if value_offset is not None:
            AddValue(builder, value_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        key = ""
        value = ""
        return cls(key, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.key == other.key
        eq = eq and self.value == other.value

        return eq

@dataclass
class ReflectionRPCCall:
    attributes: Optional["List[ReflectionKeyValue]"]

    documentation: Optional["List[str]"]

    name: "str"

    request: "ReflectionObject"

    response: "ReflectionObject"

    @classmethod
    def from_fbs(cls, o: FbsRPCCall) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = ReflectionKeyValue.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        documentation = list()
        if not o.DocumentationIsNone():
            for i in range(o.DocumentationLength()):
                documentation.append(o.Documentation(i))
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        request_obj = o.Request()
        if request_obj is not None:
            request = ReflectionObject.from_fbs(request_obj)
        else:
            raise ValueError("Request is required")
        response_obj = o.Response()
        if response_obj is not None:
            response = ReflectionObject.from_fbs(response_obj)
        else:
            raise ValueError("Response is required")
        return cls(attributes, documentation, name, request, response)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRPCCall.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.RPCCall import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddDocumentation,
            StartDocumentationVector,
            AddName,
            AddRequest,
            AddResponse,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        documentation_offset = None
        if self.documentation is not None:
            documentation_offsets = list()
            for value in self.documentation:
                documentation_offsets.append(builder.CreateString(value))
            StartDocumentationVector(builder, len(self.documentation))
            for i in reversed(range(len(self.documentation))):
                builder.PrependUOffsetTRelative(documentation_offsets[i])
            documentation_offset = builder.EndVector()
        name_offset = builder.CreateString(self.name)
        request_offset = self.request.serialize_to(builder)
        response_offset = self.response.serialize_to(builder)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        if documentation_offset is not None:
            AddDocumentation(builder, documentation_offset)
        AddName(builder, name_offset)
        AddRequest(builder, request_offset)
        AddResponse(builder, response_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        documentation = []
        name = ""
        request = ReflectionObject.make_default()
        response = ReflectionObject.make_default()
        return cls(attributes, documentation, name, request, response)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        self_documentation = self.documentation
        other_documentation = other.documentation
        if self_documentation is not None and other_documentation is not None:
            if len(self_documentation) != len(other_documentation):
                return False
            for i in range(len(self_documentation)):
                eq = eq and self_documentation[i] == other_documentation[i]
        elif self_documentation is not None and other_documentation is None:
            return False
        elif self_documentation is None and other_documentation is not None:
            return False
        eq = eq and self.name == other.name
        eq = eq and self.request == other.request
        eq = eq and self.response == other.response

        return eq

@dataclass
class ReflectionSchema:
    advanced_features: "ReflectionAdvancedFeatures"

    enums: "List[ReflectionEnum]"

    # All the files used in this compilation. Files are relative to where
    # flatc was invoked.
    fbs_files: Optional["List[ReflectionSchemaFile]"]

    file_ext: Optional["str"]

    file_ident: Optional["str"]

    objects: "List[ReflectionObject]"

    root_table: Optional["ReflectionObject"]

    services: Optional["List[ReflectionService]"]

    @classmethod
    def from_fbs(cls, o: FbsSchema) -> Self:
        advanced_features = ReflectionAdvancedFeatures(o.AdvancedFeatures())
        enums = list()
        if not o.EnumsIsNone():
            for i in range(o.EnumsLength()):
                enums_val = None
                enums_obj = o.Enums(i)
                if enums_obj is not None:
                    enums_val = ReflectionEnum.from_fbs(enums_obj)
                enums.append(enums_val)
        fbs_files = list()
        if not o.FbsFilesIsNone():
            for i in range(o.FbsFilesLength()):
                fbs_files_val = None
                fbs_files_obj = o.FbsFiles(i)
                if fbs_files_obj is not None:
                    fbs_files_val = ReflectionSchemaFile.from_fbs(fbs_files_obj)
                fbs_files.append(fbs_files_val)
        file_ext = None
        file_ext_str = o.FileExt()
        if file_ext_str is not None:
            file_ext = file_ext_str.decode('utf-8')
        file_ident = None
        file_ident_str = o.FileIdent()
        if file_ident_str is not None:
            file_ident = file_ident_str.decode('utf-8')
        objects = list()
        if not o.ObjectsIsNone():
            for i in range(o.ObjectsLength()):
                objects_val = None
                objects_obj = o.Objects(i)
                if objects_obj is not None:
                    objects_val = ReflectionObject.from_fbs(objects_obj)
                objects.append(objects_val)
        root_table = None
        root_table_obj = o.RootTable()
        if root_table_obj is not None:
            root_table = ReflectionObject.from_fbs(root_table_obj)
        services = list()
        if not o.ServicesIsNone():
            for i in range(o.ServicesLength()):
                services_val = None
                services_obj = o.Services(i)
                if services_obj is not None:
                    services_val = ReflectionService.from_fbs(services_obj)
                services.append(services_val)
        return cls(advanced_features, enums, fbs_files, file_ext, file_ident, objects, root_table, services)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsSchema.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.Schema import (
            Start,
            AddAdvancedFeatures,
            AddEnums,
            StartEnumsVector,
            AddFbsFiles,
            StartFbsFilesVector,
            AddFileExt,
            AddFileIdent,
            AddObjects,
            StartObjectsVector,
            AddRootTable,
            AddServices,
            StartServicesVector,
            End,
        )
        enums_offsets = list()
        for value in self.enums:
            enums_offsets.append(value.serialize_to(builder))
        StartEnumsVector(builder, len(self.enums))
        for i in reversed(range(len(self.enums))):
            builder.PrependUOffsetTRelative(enums_offsets[i])
        enums_offset = builder.EndVector()
        fbs_files_offset = None
        if self.fbs_files is not None:
            fbs_files_offsets = list()
            for value in self.fbs_files:
                fbs_files_offsets.append(value.serialize_to(builder))
            StartFbsFilesVector(builder, len(self.fbs_files))
            for i in reversed(range(len(self.fbs_files))):
                builder.PrependUOffsetTRelative(fbs_files_offsets[i])
            fbs_files_offset = builder.EndVector()
        file_ext_offset = None
        if self.file_ext is not None:
            file_ext_offset = builder.CreateString(self.file_ext)
        file_ident_offset = None
        if self.file_ident is not None:
            file_ident_offset = builder.CreateString(self.file_ident)
        objects_offsets = list()
        for value in self.objects:
            objects_offsets.append(value.serialize_to(builder))
        StartObjectsVector(builder, len(self.objects))
        for i in reversed(range(len(self.objects))):
            builder.PrependUOffsetTRelative(objects_offsets[i])
        objects_offset = builder.EndVector()
        root_table_offset = None
        if self.root_table is not None:
            root_table_offset = self.root_table.serialize_to(builder)
        services_offset = None
        if self.services is not None:
            services_offsets = list()
            for value in self.services:
                services_offsets.append(value.serialize_to(builder))
            StartServicesVector(builder, len(self.services))
            for i in reversed(range(len(self.services))):
                builder.PrependUOffsetTRelative(services_offsets[i])
            services_offset = builder.EndVector()
        
        Start(builder)
        AddAdvancedFeatures(builder, self.advanced_features.value)
        AddEnums(builder, enums_offset)
        if fbs_files_offset is not None:
            AddFbsFiles(builder, fbs_files_offset)
        if file_ext_offset is not None:
            AddFileExt(builder, file_ext_offset)
        if file_ident_offset is not None:
            AddFileIdent(builder, file_ident_offset)
        AddObjects(builder, objects_offset)
        if root_table_offset is not None:
            AddRootTable(builder, root_table_offset)
        if services_offset is not None:
            AddServices(builder, services_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        advanced_features = ReflectionAdvancedFeatures(1)
        enums = []
        fbs_files = []
        file_ext = ""
        file_ident = ""
        objects = []
        root_table = ReflectionObject.make_default()
        services = []
        return cls(advanced_features, enums, fbs_files, file_ext, file_ident, objects, root_table, services)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.advanced_features == other.advanced_features
        if len(self.enums) != len(other.enums):
            return False
        for i in range(len(self.enums)):
            eq = eq and self.enums[i] == other.enums[i]
        self_fbs_files = self.fbs_files
        other_fbs_files = other.fbs_files
        if self_fbs_files is not None and other_fbs_files is not None:
            if len(self_fbs_files) != len(other_fbs_files):
                return False
            for i in range(len(self_fbs_files)):
                eq = eq and self_fbs_files[i] == other_fbs_files[i]
        elif self_fbs_files is not None and other_fbs_files is None:
            return False
        elif self_fbs_files is None and other_fbs_files is not None:
            return False
        eq = eq and self.file_ext == other.file_ext
        eq = eq and self.file_ident == other.file_ident
        if len(self.objects) != len(other.objects):
            return False
        for i in range(len(self.objects)):
            eq = eq and self.objects[i] == other.objects[i]
        eq = eq and self.root_table == other.root_table
        self_services = self.services
        other_services = other.services
        if self_services is not None and other_services is not None:
            if len(self_services) != len(other_services):
                return False
            for i in range(len(self_services)):
                eq = eq and self_services[i] == other_services[i]
        elif self_services is not None and other_services is None:
            return False
        elif self_services is None and other_services is not None:
            return False

        return eq

@dataclass
class ReflectionSchemaFile:
    """ File specific information.
     Symbols declared within a file may be recovered by iterating over all
     symbols and examining the `declaration_file` field.
    """

    # Filename, relative to project root.
    filename: "str"

    # Names of included files, relative to project root.
    included_filenames: Optional["List[str]"]

    @classmethod
    def from_fbs(cls, o: FbsSchemaFile) -> Self:
        filename_str = o.Filename()
        assert filename_str is not None
        filename = filename_str.decode('utf-8')
        included_filenames = list()
        if not o.IncludedFilenamesIsNone():
            for i in range(o.IncludedFilenamesLength()):
                included_filenames.append(o.IncludedFilenames(i))
        return cls(filename, included_filenames)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsSchemaFile.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.SchemaFile import (
            Start,
            AddFilename,
            AddIncludedFilenames,
            StartIncludedFilenamesVector,
            End,
        )
        filename_offset = builder.CreateString(self.filename)
        included_filenames_offset = None
        if self.included_filenames is not None:
            included_filenames_offsets = list()
            for value in self.included_filenames:
                included_filenames_offsets.append(builder.CreateString(value))
            StartIncludedFilenamesVector(builder, len(self.included_filenames))
            for i in reversed(range(len(self.included_filenames))):
                builder.PrependUOffsetTRelative(included_filenames_offsets[i])
            included_filenames_offset = builder.EndVector()
        
        Start(builder)
        AddFilename(builder, filename_offset)
        if included_filenames_offset is not None:
            AddIncludedFilenames(builder, included_filenames_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        filename = ""
        included_filenames = []
        return cls(filename, included_filenames)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.filename == other.filename
        self_included_filenames = self.included_filenames
        other_included_filenames = other.included_filenames
        if self_included_filenames is not None and other_included_filenames is not None:
            if len(self_included_filenames) != len(other_included_filenames):
                return False
            for i in range(len(self_included_filenames)):
                eq = eq and self_included_filenames[i] == other_included_filenames[i]
        elif self_included_filenames is not None and other_included_filenames is None:
            return False
        elif self_included_filenames is None and other_included_filenames is not None:
            return False

        return eq

@dataclass
class ReflectionService:
    attributes: Optional["List[ReflectionKeyValue]"]

    calls: Optional["List[ReflectionRPCCall]"]

    # File that this Service is declared in.
    declaration_file: Optional["str"]

    documentation: Optional["List[str]"]

    name: "str"

    @classmethod
    def from_fbs(cls, o: FbsService) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = ReflectionKeyValue.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        calls = list()
        if not o.CallsIsNone():
            for i in range(o.CallsLength()):
                calls_val = None
                calls_obj = o.Calls(i)
                if calls_obj is not None:
                    calls_val = ReflectionRPCCall.from_fbs(calls_obj)
                calls.append(calls_val)
        declaration_file = None
        declaration_file_str = o.DeclarationFile()
        if declaration_file_str is not None:
            declaration_file = declaration_file_str.decode('utf-8')
        documentation = list()
        if not o.DocumentationIsNone():
            for i in range(o.DocumentationLength()):
                documentation.append(o.Documentation(i))
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        return cls(attributes, calls, declaration_file, documentation, name)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsService.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.reflection.Service import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddCalls,
            StartCallsVector,
            AddDeclarationFile,
            AddDocumentation,
            StartDocumentationVector,
            AddName,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        calls_offset = None
        if self.calls is not None:
            calls_offsets = list()
            for value in self.calls:
                calls_offsets.append(value.serialize_to(builder))
            StartCallsVector(builder, len(self.calls))
            for i in reversed(range(len(self.calls))):
                builder.PrependUOffsetTRelative(calls_offsets[i])
            calls_offset = builder.EndVector()
        declaration_file_offset = None
        if self.declaration_file is not None:
            declaration_file_offset = builder.CreateString(self.declaration_file)
        documentation_offset = None
        if self.documentation is not None:
            documentation_offsets = list()
            for value in self.documentation:
                documentation_offsets.append(builder.CreateString(value))
            StartDocumentationVector(builder, len(self.documentation))
            for i in reversed(range(len(self.documentation))):
                builder.PrependUOffsetTRelative(documentation_offsets[i])
            documentation_offset = builder.EndVector()
        name_offset = builder.CreateString(self.name)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        if calls_offset is not None:
            AddCalls(builder, calls_offset)
        if declaration_file_offset is not None:
            AddDeclarationFile(builder, declaration_file_offset)
        if documentation_offset is not None:
            AddDocumentation(builder, documentation_offset)
        AddName(builder, name_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        calls = []
        declaration_file = ""
        documentation = []
        name = ""
        return cls(attributes, calls, declaration_file, documentation, name)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        self_calls = self.calls
        other_calls = other.calls
        if self_calls is not None and other_calls is not None:
            if len(self_calls) != len(other_calls):
                return False
            for i in range(len(self_calls)):
                eq = eq and self_calls[i] == other_calls[i]
        elif self_calls is not None and other_calls is None:
            return False
        elif self_calls is None and other_calls is not None:
            return False
        eq = eq and self.declaration_file == other.declaration_file
        self_documentation = self.documentation
        other_documentation = other.documentation
        if self_documentation is not None and other_documentation is not None:
            if len(self_documentation) != len(other_documentation):
                return False
            for i in range(len(self_documentation)):
                eq = eq and self_documentation[i] == other_documentation[i]
        elif self_documentation is not None and other_documentation is None:
            return False
        elif self_documentation is None and other_documentation is not None:
            return False
        eq = eq and self.name == other.name

        return eq
