# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .Schema import (
    Binary,
    Bool,
    Buffer,
    Date,
    DateUnit,
    Decimal,
    DictionaryEncoding,
    DictionaryKind,
    Duration,
    Endianness,
    Feature,
    Field,
    FixedSizeBinary,
    FixedSizeList,
    FloatingPoint,
    Int,
    Interval,
    IntervalUnit,
    KeyValue,
    LargeBinary,
    LargeList,
    LargeUtf8,
    List_,
    Map,
    MetadataVersion,
    Null,
    Precision,
    Schema,
    Struct_,
    Time,
    TimeUnit,
    Timestamp,
    Type,
    Union_,
    UnionMode,
    Utf8,
)
from .data import (
    AttributePair,
    DayOfWeek,
    DirectionAndRoadName,
    DirectionAndRoadNames,
    DirectionTy,
    NamedParameter,
    NamedParameterFlags,
    RoadUserTy,
    Source,
    StatisticTy,
    TimeGranularity,
    TurnTy,
)
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .job import (
    DeprecatedRunSpec,
    DeprecatedTaskParameter,
    Edge,
    EmbeddedTable,
    Job,
    Node,
    ParamIndices,
    RunSpec,
    Schematic,
    Status,
    Task,
    TaskErrorTy,
    TaskList,
    TaskParameter,
    TaskParameterValue,
    TaskPriority,
    TaskRunFlags,
)
from .reflection import (
    ReflectionAdvancedFeatures,
    ReflectionBaseType,
    ReflectionEnum,
    ReflectionEnumVal,
    ReflectionField,
    ReflectionKeyValue,
    ReflectionObject,
    ReflectionRPCCall,
    ReflectionSchema,
    ReflectionSchemaFile,
    ReflectionService,
    ReflectionType,
)
from .value import (
    Point2D,
    Tri2D,
    VArray,
    VBool,
    VBytes,
    VChar,
    VF32,
    VF64,
    VFixedSizeBytes,
    VI16,
    VI32,
    VI64,
    VI8,
    VIsize,
    VNull,
    VStr,
    VTimestampMs,
    VTimestampMsUtc,
    VTimestampNs,
    VTimestampNsUtc,
    VTri2D,
    VU16,
    VU32,
    VU64,
    VU8,
    VUnit,
    VUsize,
    Value,
    ValueInstance,
    ValueTy,
)
from .generated.AttributePair import AttributePair as FbsAttributePair
from .generated.B2cId import B2cId as FbsB2cId
from .generated.Binary import Binary as FbsBinary
from .generated.Bool import Bool as FbsBool
from .generated.Buffer import Buffer as FbsBuffer
from .generated.ByteArray import ByteArray as FbsByteArray
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.Date import Date as FbsDate
from .generated.Decimal import Decimal as FbsDecimal
from .generated.DeprecatedRunSpec import DeprecatedRunSpec as FbsDeprecatedRunSpec
from .generated.DeprecatedTaskParameter import DeprecatedTaskParameter as FbsDeprecatedTaskParameter
from .generated.DictionaryEncoding import DictionaryEncoding as FbsDictionaryEncoding
from .generated.DirectionAndRoadName import DirectionAndRoadName as FbsDirectionAndRoadName
from .generated.DirectionAndRoadNames import DirectionAndRoadNames as FbsDirectionAndRoadNames
from .generated.Duration import Duration as FbsDuration
from .generated.Edge import Edge as FbsEdge
from .generated.EmbeddedTable import EmbeddedTable as FbsEmbeddedTable
from .generated.Field import Field as FbsField
from .generated.FixedSizeBinary import FixedSizeBinary as FbsFixedSizeBinary
from .generated.FixedSizeList import FixedSizeList as FbsFixedSizeList
from .generated.FloatingPoint import FloatingPoint as FbsFloatingPoint
from .generated.GenericId import GenericId as FbsGenericId
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.Int import Int as FbsInt
from .generated.Interval import Interval as FbsInterval
from .generated.Job import Job as FbsJob
from .generated.KeyValue import KeyValue as FbsKeyValue
from .generated.LargeBinary import LargeBinary as FbsLargeBinary
from .generated.LargeList import LargeList as FbsLargeList
from .generated.LargeUtf8 import LargeUtf8 as FbsLargeUtf8
from .generated.Layout import Layout as FbsLayout
from .generated.List import List as FbsList
from .generated.Map import Map as FbsMap
from .generated.NamedParameter import NamedParameter as FbsNamedParameter
from .generated.Node import Node as FbsNode
from .generated.Null import Null as FbsNull
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.ParamIndices import ParamIndices as FbsParamIndices
from .generated.ParameterFlags import ParameterFlags as FbsParameterFlags
from .generated.Point2D import Point2D as FbsPoint2D
from .generated.RunSpec import RunSpec as FbsRunSpec
from .generated.Schema import Schema as FbsSchema
from .generated.Schematic import Schematic as FbsSchematic
from .generated.Source import Source as FbsSource
from .generated.StreamId import StreamId as FbsStreamId
from .generated.Struct_ import Struct_ as FbsStruct_
from .generated.Task import Task as FbsTask
from .generated.TaskList import TaskList as FbsTaskList
from .generated.TaskParameter import TaskParameter as FbsTaskParameter
from .generated.TileData import TileData as FbsTileData
from .generated.TileSettings import TileSettings as FbsTileSettings
from .generated.Time import Time as FbsTime
from .generated.Timestamp import Timestamp as FbsTimestamp
from .generated.Tri2D import Tri2D as FbsTri2D
from .generated.Union import Union as FbsUnion
from .generated.UserSettings import UserSettings as FbsUserSettings
from .generated.Utf8 import Utf8 as FbsUtf8
from .generated.VArray import VArray as FbsVArray
from .generated.VBool import VBool as FbsVBool
from .generated.VBytes import VBytes as FbsVBytes
from .generated.VChar import VChar as FbsVChar
from .generated.VF32 import VF32 as FbsVF32
from .generated.VF64 import VF64 as FbsVF64
from .generated.VFixedSizeBytes import VFixedSizeBytes as FbsVFixedSizeBytes
from .generated.VI16 import VI16 as FbsVI16
from .generated.VI32 import VI32 as FbsVI32
from .generated.VI64 import VI64 as FbsVI64
from .generated.VI8 import VI8 as FbsVI8
from .generated.VIsize import VIsize as FbsVIsize
from .generated.VNull import VNull as FbsVNull
from .generated.VStr import VStr as FbsVStr
from .generated.VTimestampMs import VTimestampMs as FbsVTimestampMs
from .generated.VTimestampMsUtc import VTimestampMsUtc as FbsVTimestampMsUtc
from .generated.VTimestampNs import VTimestampNs as FbsVTimestampNs
from .generated.VTimestampNsUtc import VTimestampNsUtc as FbsVTimestampNsUtc
from .generated.VTri2D import VTri2D as FbsVTri2D
from .generated.VU16 import VU16 as FbsVU16
from .generated.VU32 import VU32 as FbsVU32
from .generated.VU64 import VU64 as FbsVU64
from .generated.VU8 import VU8 as FbsVU8
from .generated.VUnit import VUnit as FbsVUnit
from .generated.VUsize import VUsize as FbsVUsize
from .generated.ValueInstance import ValueInstance as FbsValueInstance
from .generated.WorkLog import WorkLog as FbsWorkLog
from .generated.WorklogParameter import WorklogParameter as FbsWorklogParameter
from .generated.reflection.Enum import Enum as FbsEnum
from .generated.reflection.EnumVal import EnumVal as FbsEnumVal
from .generated.reflection.Field import Field as FbsField
from .generated.reflection.KeyValue import KeyValue as FbsKeyValue
from .generated.reflection.Object import Object as FbsObject
from .generated.reflection.RPCCall import RPCCall as FbsRPCCall
from .generated.reflection.Schema import Schema as FbsSchema
from .generated.reflection.SchemaFile import SchemaFile as FbsSchemaFile
from .generated.reflection.Service import Service as FbsService
from .generated.reflection.Type import Type as FbsType
from .generated.ParameterValue import ParameterValue as FbsParameterValue
from .generated.TaskParameterValue import TaskParameterValue as FbsTaskParameterValue
from .generated.Type import Type as FbsType
from .generated.Value import Value as FbsValue

class AggregationTy(Enum):
    Invalid = 0
    Sum = 1
    Average = 2

class ChartTypeTy(Enum):
    Invalid = 0
    Bar = 1
    HorizontalBar = 2
    Doughnut = 3
    Line = 4
    SimpleTable = 5
    SingleNumber = 6
    Text = 7
    DashboardTable = 8

class ValuesFormatTy(Enum):
    Invalid = 0
    RawNumber = 1
    Percentage = 2


@dataclass
class ByteArray:
    b: Optional["List[int]"]

    @classmethod
    def from_fbs(cls, o: FbsByteArray) -> Self:
        b = list()
        if not o.BIsNone():
            for i in range(o.BLength()):
                b.append(o.B(i))
        return cls(b)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsByteArray.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ByteArray import (
            Start,
            AddB,
            StartBVector,
            End,
        )
        b_offset = None
        if self.b is not None:
            StartBVector(builder, len(self.b))
            for i in reversed(range(len(self.b))):
                builder.PrependUint8(self.b[i])
            b_offset = builder.EndVector()
        
        Start(builder)
        if b_offset is not None:
            AddB(builder, b_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        b = []
        return cls(b)

    def __eq__(self, other) -> bool:
        eq = True
        self_b = self.b
        other_b = other.b
        if self_b is not None and other_b is not None:
            if len(self_b) != len(other_b):
                return False
            for i in range(len(self_b)):
                eq = eq and self_b[i] == other_b[i]
        elif self_b is not None and other_b is None:
            return False
        elif self_b is None and other_b is not None:
            return False

        return eq

@dataclass
class ParameterFlags:
    flags: "int"

    @classmethod
    def from_fbs(cls, o: FbsParameterFlags) -> Self:
        flags = o.Flags()
        return cls(flags)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsParameterFlags.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ParameterFlags import (
            Start,
            AddFlags,
            End,
        )
        
        Start(builder)
        AddFlags(builder, self.flags)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        flags = 0
        return cls(flags)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.flags == other.flags

        return eq

@dataclass
class ParameterValue:
    value: Union[
        "ByteArray",
        "ObjectId",
        "ParameterFlags",
        "ValueInstance",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.ParameterValue import ParameterValue
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, ByteArray):
            return (offset, ParameterValue().ByteArray)
        elif isinstance(self.value, ObjectId):
            return (offset, ParameterValue().ObjectId)
        elif isinstance(self.value, ParameterFlags):
            return (offset, ParameterValue().ParameterFlags)
        elif isinstance(self.value, ValueInstance):
            return (offset, ParameterValue().ValueInstance)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        ParameterValue_ty_instance = FbsParameterValue()
        if ty == ParameterValue_ty_instance.ByteArray:
            val = FbsByteArray();
            val.Init(source, pos)
            return cls(ByteArray.from_fbs(val))
        elif ty == ParameterValue_ty_instance.ObjectId:
            val = FbsObjectId();
            val.Init(source, pos)
            return cls(ObjectId.from_fbs(val))
        elif ty == ParameterValue_ty_instance.ParameterFlags:
            val = FbsParameterFlags();
            val.Init(source, pos)
            return cls(ParameterFlags.from_fbs(val))
        elif ty == ParameterValue_ty_instance.ValueInstance:
            val = FbsValueInstance();
            val.Init(source, pos)
            return cls(ValueInstance.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(ByteArray.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class Layout:
    # The height of the chart tile in react-grid-layout grid units
    height: "int"

    # The width in react-grid-layout grid units
    width: "int"

    # The x position in react-grid-layout grid units
    x: "int"

    # The y position in react-grid-layout grid units
    y: "int"

    @classmethod
    def from_fbs(cls, o: FbsLayout) -> Self:
        height = o.Height()
        width = o.Width()
        x = o.X()
        y = o.Y()
        return cls(height, width, x, y)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsLayout.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Layout import (
            Start,
            AddHeight,
            AddWidth,
            AddX,
            AddY,
            End,
        )
        
        Start(builder)
        AddHeight(builder, self.height)
        AddWidth(builder, self.width)
        AddX(builder, self.x)
        AddY(builder, self.y)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        height = 0
        width = 0
        x = 0
        y = 0
        return cls(height, width, x, y)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.height == other.height
        eq = eq and self.width == other.width
        eq = eq and self.x == other.x
        eq = eq and self.y == other.y

        return eq

@dataclass
class TileSettings:
    # The column of tbe aggregation dataset to use
    aggregation: "AggregationTy"

    # The category
    category: "int"

    # What chart type to display the data as
    chart_type: "ChartTypeTy"

    # The field name from the metadata and dataset. Note that if it is a
    # relationshipField, it will use the displayName instead
    field_name: "str"

    # Whether to group the other fields under "Other" if not showing all columns
    group_others: "bool"

    # Record-count tiles report on the total number of graph nodes for the stream in the area, rather than
    # on any specific field in that stream.
    is_record_count_tile: "bool"

    # Whether it is a relationship field (or a non-associated field)
    is_relationship_field: "bool"

    # The metadata id for the field shown
    metadata_id: "ObjectId"

    # Which output stream the report belongs to
    output_stream_index: "int"

    record_count_stream_id: Optional["ObjectId"]

    # Which columns the user has selected to show. If this is a relationship field, the user
    # can select which of the relationship fields to show. If it is nonassociated field, it's
    # possible that they only want to show certain ranges, which would be stored here, but
    # that isn't currently supported
    selected_columns: "List[str]"

    # Font size for text tiles
    text_tile_font_size: "int"

    # The title of the tile
    title: "str"

    # Percentage or RawNumber
    values_format: "ValuesFormatTy"

    @classmethod
    def from_fbs(cls, o: FbsTileSettings) -> Self:
        aggregation = AggregationTy(o.Aggregation())
        category = o.Category()
        chart_type = ChartTypeTy(o.ChartType())
        field_name_str = o.FieldName()
        assert field_name_str is not None
        field_name = field_name_str.decode('utf-8')
        group_others = o.GroupOthers()
        is_record_count_tile = o.IsRecordCountTile()
        is_relationship_field = o.IsRelationshipField()
        metadata_id_obj = o.MetadataId()
        if metadata_id_obj is not None:
            metadata_id = ObjectId.from_fbs(metadata_id_obj)
        else:
            raise ValueError("MetadataId is required")
        output_stream_index = o.OutputStreamIndex()
        record_count_stream_id = None
        record_count_stream_id_obj = o.RecordCountStreamId()
        if record_count_stream_id_obj is not None:
            record_count_stream_id = ObjectId.from_fbs(record_count_stream_id_obj)
        selected_columns = list()
        if not o.SelectedColumnsIsNone():
            for i in range(o.SelectedColumnsLength()):
                selected_columns.append(o.SelectedColumns(i))
        text_tile_font_size = o.TextTileFontSize()
        title_str = o.Title()
        assert title_str is not None
        title = title_str.decode('utf-8')
        values_format = ValuesFormatTy(o.ValuesFormat())
        return cls(aggregation, category, chart_type, field_name, group_others, is_record_count_tile, is_relationship_field, metadata_id, output_stream_index, record_count_stream_id, selected_columns, text_tile_font_size, title, values_format)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTileSettings.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TileSettings import (
            Start,
            AddAggregation,
            AddCategory,
            AddChartType,
            AddFieldName,
            AddGroupOthers,
            AddIsRecordCountTile,
            AddIsRelationshipField,
            AddMetadataId,
            AddOutputStreamIndex,
            AddRecordCountStreamId,
            AddSelectedColumns,
            StartSelectedColumnsVector,
            AddTextTileFontSize,
            AddTitle,
            AddValuesFormat,
            End,
        )
        field_name_offset = builder.CreateString(self.field_name)
        metadata_id_offset = self.metadata_id.serialize_to(builder)
        record_count_stream_id_offset = None
        if self.record_count_stream_id is not None:
            record_count_stream_id_offset = self.record_count_stream_id.serialize_to(builder)
        selected_columns_offsets = list()
        for value in self.selected_columns:
            selected_columns_offsets.append(builder.CreateString(value))
        StartSelectedColumnsVector(builder, len(self.selected_columns))
        for i in reversed(range(len(self.selected_columns))):
            builder.PrependUOffsetTRelative(selected_columns_offsets[i])
        selected_columns_offset = builder.EndVector()
        title_offset = builder.CreateString(self.title)
        
        Start(builder)
        AddAggregation(builder, self.aggregation.value)
        AddCategory(builder, self.category)
        AddChartType(builder, self.chart_type.value)
        AddFieldName(builder, field_name_offset)
        AddGroupOthers(builder, self.group_others)
        AddIsRecordCountTile(builder, self.is_record_count_tile)
        AddIsRelationshipField(builder, self.is_relationship_field)
        AddMetadataId(builder, metadata_id_offset)
        AddOutputStreamIndex(builder, self.output_stream_index)
        if record_count_stream_id_offset is not None:
            AddRecordCountStreamId(builder, record_count_stream_id_offset)
        AddSelectedColumns(builder, selected_columns_offset)
        AddTextTileFontSize(builder, self.text_tile_font_size)
        AddTitle(builder, title_offset)
        AddValuesFormat(builder, self.values_format.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        aggregation = AggregationTy(0)
        category = 0
        chart_type = ChartTypeTy(0)
        field_name = ""
        group_others = False
        is_record_count_tile = False
        is_relationship_field = False
        metadata_id = ObjectId.make_default()
        output_stream_index = 0
        record_count_stream_id = ObjectId.make_default()
        selected_columns = []
        text_tile_font_size = 0
        title = ""
        values_format = ValuesFormatTy(0)
        return cls(aggregation, category, chart_type, field_name, group_others, is_record_count_tile, is_relationship_field, metadata_id, output_stream_index, record_count_stream_id, selected_columns, text_tile_font_size, title, values_format)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.aggregation == other.aggregation
        eq = eq and self.category == other.category
        eq = eq and self.chart_type == other.chart_type
        eq = eq and self.field_name == other.field_name
        eq = eq and self.group_others == other.group_others
        eq = eq and self.is_record_count_tile == other.is_record_count_tile
        eq = eq and self.is_relationship_field == other.is_relationship_field
        eq = eq and self.metadata_id == other.metadata_id
        eq = eq and self.output_stream_index == other.output_stream_index
        eq = eq and self.record_count_stream_id == other.record_count_stream_id
        if len(self.selected_columns) != len(other.selected_columns):
            return False
        for i in range(len(self.selected_columns)):
            eq = eq and self.selected_columns[i] == other.selected_columns[i]
        eq = eq and self.text_tile_font_size == other.text_tile_font_size
        eq = eq and self.title == other.title
        eq = eq and self.values_format == other.values_format

        return eq

@dataclass
class TileData:
    layout: "Layout"

    tile_settings: "TileSettings"

    @classmethod
    def from_fbs(cls, o: FbsTileData) -> Self:
        layout_obj = o.Layout()
        if layout_obj is not None:
            layout = Layout.from_fbs(layout_obj)
        else:
            raise ValueError("Layout is required")
        tile_settings_obj = o.TileSettings()
        if tile_settings_obj is not None:
            tile_settings = TileSettings.from_fbs(tile_settings_obj)
        else:
            raise ValueError("TileSettings is required")
        return cls(layout, tile_settings)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTileData.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TileData import (
            Start,
            AddLayout,
            AddTileSettings,
            End,
        )
        layout_offset = self.layout.serialize_to(builder)
        tile_settings_offset = self.tile_settings.serialize_to(builder)
        
        Start(builder)
        AddLayout(builder, layout_offset)
        AddTileSettings(builder, tile_settings_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        layout = Layout.make_default()
        tile_settings = TileSettings.make_default()
        return cls(layout, tile_settings)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.layout == other.layout
        eq = eq and self.tile_settings == other.tile_settings

        return eq

@dataclass
class UserSettings:
    is_template: "bool"

    tile_data: "List[TileData]"

    @classmethod
    def from_fbs(cls, o: FbsUserSettings) -> Self:
        is_template = o.IsTemplate()
        tile_data = list()
        if not o.TileDataIsNone():
            for i in range(o.TileDataLength()):
                tile_data_val = None
                tile_data_obj = o.TileData(i)
                if tile_data_obj is not None:
                    tile_data_val = TileData.from_fbs(tile_data_obj)
                tile_data.append(tile_data_val)
        return cls(is_template, tile_data)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUserSettings.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UserSettings import (
            Start,
            AddIsTemplate,
            AddTileData,
            StartTileDataVector,
            End,
        )
        tile_data_offsets = list()
        for value in self.tile_data:
            tile_data_offsets.append(value.serialize_to(builder))
        StartTileDataVector(builder, len(self.tile_data))
        for i in reversed(range(len(self.tile_data))):
            builder.PrependUOffsetTRelative(tile_data_offsets[i])
        tile_data_offset = builder.EndVector()
        
        Start(builder)
        AddIsTemplate(builder, self.is_template)
        AddTileData(builder, tile_data_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        is_template = False
        tile_data = []
        return cls(is_template, tile_data)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.is_template == other.is_template
        if len(self.tile_data) != len(other.tile_data):
            return False
        for i in range(len(self.tile_data)):
            eq = eq and self.tile_data[i] == other.tile_data[i]

        return eq

@dataclass
class WorkLog:
    # Input streams and/or worklogs. These may be either work logs or streams.
    input_streams: Optional["List[ObjectId]"]

    job_id: Optional["ObjectId"]

    # A human-readable tag.
    name: Optional["str"]

    # The output_streams contain a list of Parquet documents that consist of
    # the results. These documents may expire (ie: if this is a temporary
    # step) so there should be enough information in the worklog necessary
    # to reconstruct these output streams.
    output_streams: "List[ObjectId]"

    # These are the serialized parameters passed into the task which created
    # this worklog.
    params: "List[WorklogParameter]"

    # Worklogs can contain multiple "levels". Consider the case where the user
    # submits a request for multiple ADT reports. We will create separate ADT
    # reports as required but also one that ties them all together. There are a
    # couple reasons for this; the primary is that the output of a schematic
    # node is allocated before the job is run and before it knows how many
    # worklogs will be generated. Another is that it makes it it easy (or
    # easier) to organize because we can sort based on "stuff the user requested",
    # instead of just "stuff the system generated".
    parent: Optional["ObjectId"]

    # The schematic used behind creating the worklog. This may be empty/null
    # if we are just layering data, for example.
    schematic: "ObjectId"

    user_settings: Optional["UserSettings"]

    @classmethod
    def from_fbs(cls, o: FbsWorkLog) -> Self:
        input_streams = list()
        if not o.InputStreamsIsNone():
            for i in range(o.InputStreamsLength()):
                input_streams_val = None
                input_streams_obj = o.InputStreams(i)
                if input_streams_obj is not None:
                    input_streams_val = ObjectId.from_fbs(input_streams_obj)
                input_streams.append(input_streams_val)
        job_id = None
        job_id_obj = o.JobId()
        if job_id_obj is not None:
            job_id = ObjectId.from_fbs(job_id_obj)
        name = None
        name_str = o.Name()
        if name_str is not None:
            name = name_str.decode('utf-8')
        output_streams = list()
        if not o.OutputStreamsIsNone():
            for i in range(o.OutputStreamsLength()):
                output_streams_val = None
                output_streams_obj = o.OutputStreams(i)
                if output_streams_obj is not None:
                    output_streams_val = ObjectId.from_fbs(output_streams_obj)
                output_streams.append(output_streams_val)
        params = list()
        if not o.ParamsIsNone():
            for i in range(o.ParamsLength()):
                params_val = None
                params_obj = o.Params(i)
                if params_obj is not None:
                    params_val = WorklogParameter.from_fbs(params_obj)
                params.append(params_val)
        parent = None
        parent_obj = o.Parent()
        if parent_obj is not None:
            parent = ObjectId.from_fbs(parent_obj)
        schematic_obj = o.Schematic()
        if schematic_obj is not None:
            schematic = ObjectId.from_fbs(schematic_obj)
        else:
            raise ValueError("Schematic is required")
        user_settings = None
        user_settings_obj = o.UserSettings()
        if user_settings_obj is not None:
            user_settings = UserSettings.from_fbs(user_settings_obj)
        return cls(input_streams, job_id, name, output_streams, params, parent, schematic, user_settings)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsWorkLog.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.WorkLog import (
            Start,
            AddInputStreams,
            StartInputStreamsVector,
            AddJobId,
            AddName,
            AddOutputStreams,
            StartOutputStreamsVector,
            AddParams,
            StartParamsVector,
            AddParent,
            AddSchematic,
            AddUserSettings,
            End,
        )
        input_streams_offset = None
        if self.input_streams is not None:
            input_streams_offsets = list()
            for value in self.input_streams:
                input_streams_offsets.append(value.serialize_to(builder))
            StartInputStreamsVector(builder, len(self.input_streams))
            for i in reversed(range(len(self.input_streams))):
                builder.PrependUOffsetTRelative(input_streams_offsets[i])
            input_streams_offset = builder.EndVector()
        job_id_offset = None
        if self.job_id is not None:
            job_id_offset = self.job_id.serialize_to(builder)
        name_offset = None
        if self.name is not None:
            name_offset = builder.CreateString(self.name)
        output_streams_offsets = list()
        for value in self.output_streams:
            output_streams_offsets.append(value.serialize_to(builder))
        StartOutputStreamsVector(builder, len(self.output_streams))
        for i in reversed(range(len(self.output_streams))):
            builder.PrependUOffsetTRelative(output_streams_offsets[i])
        output_streams_offset = builder.EndVector()
        params_offsets = list()
        for value in self.params:
            params_offsets.append(value.serialize_to(builder))
        StartParamsVector(builder, len(self.params))
        for i in reversed(range(len(self.params))):
            builder.PrependUOffsetTRelative(params_offsets[i])
        params_offset = builder.EndVector()
        parent_offset = None
        if self.parent is not None:
            parent_offset = self.parent.serialize_to(builder)
        schematic_offset = self.schematic.serialize_to(builder)
        user_settings_offset = None
        if self.user_settings is not None:
            user_settings_offset = self.user_settings.serialize_to(builder)
        
        Start(builder)
        if input_streams_offset is not None:
            AddInputStreams(builder, input_streams_offset)
        if job_id_offset is not None:
            AddJobId(builder, job_id_offset)
        if name_offset is not None:
            AddName(builder, name_offset)
        AddOutputStreams(builder, output_streams_offset)
        AddParams(builder, params_offset)
        if parent_offset is not None:
            AddParent(builder, parent_offset)
        AddSchematic(builder, schematic_offset)
        if user_settings_offset is not None:
            AddUserSettings(builder, user_settings_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        input_streams = []
        job_id = ObjectId.make_default()
        name = ""
        output_streams = []
        params = []
        parent = ObjectId.make_default()
        schematic = ObjectId.make_default()
        user_settings = UserSettings.make_default()
        return cls(input_streams, job_id, name, output_streams, params, parent, schematic, user_settings)

    def __eq__(self, other) -> bool:
        eq = True
        self_input_streams = self.input_streams
        other_input_streams = other.input_streams
        if self_input_streams is not None and other_input_streams is not None:
            if len(self_input_streams) != len(other_input_streams):
                return False
            for i in range(len(self_input_streams)):
                eq = eq and self_input_streams[i] == other_input_streams[i]
        elif self_input_streams is not None and other_input_streams is None:
            return False
        elif self_input_streams is None and other_input_streams is not None:
            return False
        eq = eq and self.job_id == other.job_id
        eq = eq and self.name == other.name
        if len(self.output_streams) != len(other.output_streams):
            return False
        for i in range(len(self.output_streams)):
            eq = eq and self.output_streams[i] == other.output_streams[i]
        if len(self.params) != len(other.params):
            return False
        for i in range(len(self.params)):
            eq = eq and self.params[i] == other.params[i]
        eq = eq and self.parent == other.parent
        eq = eq and self.schematic == other.schematic
        eq = eq and self.user_settings == other.user_settings

        return eq

@dataclass
class WorklogParameter:
    key: "str"

    value: Optional["ParameterValue"]

    @classmethod
    def from_fbs(cls, o: FbsWorklogParameter) -> Self:
        key_str = o.Key()
        assert key_str is not None
        key = key_str.decode('utf-8')
        value = None
        value_val = o.Value()
        if value_val is not None:
            value_ty = o.ValueType()
            value = ParameterValue.from_fbs(value_val, value_ty)
        return cls(key, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsWorklogParameter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.WorklogParameter import (
            Start,
            AddKey,
            AddValue,
            AddValueType,
            End,
        )
        key_offset = builder.CreateString(self.key)
        value_offset, value_ty = (None, None)
        if self.value is not None:
            value_offset, value_ty = self.value.serialize_to(builder)
        
        Start(builder)
        AddKey(builder, key_offset)
        if value_offset is not None and value_ty is not None:
            AddValue(builder, value_offset)
            AddValueType(builder, value_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        key = ""
        value = ParameterValue.make_default()
        return cls(key, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.key == other.key
        eq = eq and self.value == other.value

        return eq
