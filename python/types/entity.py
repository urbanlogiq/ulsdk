# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .generated.B2cId import B2cId as FbsB2cId
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.GenericId import GenericId as FbsGenericId
from .generated.GraphEdge import GraphEdge as FbsGraphEdge
from .generated.GraphNode import GraphNode as FbsGraphNode
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.Line import Line as FbsLine
from .generated.MultiLine import MultiLine as FbsMultiLine
from .generated.MultiPolygon import MultiPolygon as FbsMultiPolygon
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.Point import Point as FbsPoint
from .generated.Polygon import Polygon as FbsPolygon
from .generated.StreamId import StreamId as FbsStreamId
from .generated.Geometry import Geometry as FbsGeometry

class EdgeTy(Enum):
    E_INVALID = 0
    E_POSTAL_CODE = 1
    E_INTERSECTS = 2
    E_CONTAINS = 3
    E_WITHIN = 4
    E_HAS_COUNTS = 5
    E_OCCURS_AT = 6
    E_REALM = 7
    E_SEARCH_ATTRIBUTES = 8
    E_ASSOCIATED_TFC_LOOP = 9
    E_TRAFFIC_METRICS = 10
    E_TIME_DENSITY = 11
    E_CRASHBOARD_AGGREGATE_BY = 12
    E_OPPOSING_ROAD_SEGMENT = 13
    E_ASSOCIATED_CAMERA = 14

class EntityTy(Enum):
    T_INVALID = 0
    T_TFC = 1
    T_TFC_LOOP = 2
    T_TFC_CRASH = 3
    T_TFC_TMC_REPORT = 4
    T_ROAD_SEGMENT = 5
    T_INTERSECTION = 6
    T_SIDEWAlK = 7
    T_BIKEWAY = 8
    T_TRANSIT_LINE = 9
    T_BIA = 10
    T_NEIGHBOURHOOD = 11
    T_NIA = 12
    T_WARD = 13
    T_DISTRICT = 14
    T_CONSTITUENCY = 15
    T_POSTAL_CODE_GEO = 16
    T_BUSINESS = 17
    T_LAND_PARCEL = 18
    T_ADDRESS = 19
    T_POSTAL_CODE_DEMOGRAPHICS = 20
    T_ZONE = 21
    T_PARK = 22
    T_PARKING_LOT = 23
    T_PARKING_TICKET = 24
    T_PLACE_OF_INTEREST = 25
    T_DAYCARE_CENTRE = 26
    T_MEDICAL_CENTRE = 27
    T_COMMERCIAL_LAND = 28
    T_DEVELOPMENT_APPLICATION = 29
    T_AVAILABLE_COMMERCIAL_SPACE = 30
    T_BUILDING_FOOTPRINT = 31
    T_DEVELOPED_EMPLOYMENT_LAND = 32
    T_VACANT_EMPLOYMENT_LAND = 33
    T_STREET = 34
    T_BIKESHARE_STATION = 35
    T_SUBWAY_LINE = 36
    T_ON_STREET_PARKING = 37
    T_PEDESTRIAN_ROUTE = 38
    T_HERITAGE_DISTRICT = 39
    T_BUS_ROUTE = 40
    T_BUS_STOP = 41
    T_POLITICAL_BOUNDARY = 42
    T_CRIME = 43
    T_EVENT = 44
    T_TFC_SEGMENT_VOLUMES = 45
    T_TFC_TMC_COUNTS = 46
    T_TFC_AADT = 47
    T_CONNECTIVITY_CORRIDORS = 48
    T_MEDIANS = 49
    T_EVACUATION_ROUTES = 50
    T_TRAFFIC_METRICS = 51
    T_COUNTERMEASURES_DEVICES = 52
    T_TRAFFIC_INCIDENTS = 53
    T_BLOCKGROUP_DEMOGRAPHIC = 54
    T_PARKING_METER = 55
    T_PROPERTY_VALUE_ASSESSMENT = 56
    T_GOLF_COURSE = 57
    T_BUILDING_PERMIT = 58
    T_REALM = 59
    T_ROAD_SEGMENT_COUNT_LOCATION = 60
    T_INTERSECTION_COUNT_LOCATION = 61
    T_TRIPS_ORIGIN_DESTINATION_PASSTHROUGH_BIA = 62
    T_WORKLOGS = 63
    T_FORECAST = 64
    T_BRIDGES = 65
    T_OPEN_MARKETS = 66
    T_BIKE_FACILITIES = 67
    T_DOG_LICENCES = 68
    T_PEDESTRIAN_COUNT_LOCATION = 69
    T_DISADVANTAGED_AREA = 70
    T_TRANSPORTATION_ANALYSIS_ZONE = 71
    T_ELECTION_DISTRICT = 72
    T_DISSEMINATION_AREA = 73
    T_RETAIL_AREA = 74
    T_GROWTH_CENTER = 75
    T_SEARCH_ATTRIBUTES = 76
    T_PROPERTY = 77
    T_DESIGNATED_AREA = 78
    T_PROVINCIAL_FOREST = 79
    T_TIMBER_SUPPLY_AREA = 80
    T_COMMUNICATION_SITE = 81
    T_CUT_BLOCK = 82
    T_PERMIT = 83
    T_LICENCE = 84
    T_MAP_NOTATION = 85
    T_REAL_PROPERTY_PROJECT = 86
    T_RECREATION_SITE = 87
    T_RECREATION_LINE = 88
    T_RECREATION_POLYGON = 89
    T_SPECIAL_ACCESS_ROAD = 90
    T_GROWTH_YIELD_SAMPLE = 91
    T_OLD_GROWTH_MANAGEMENT_AREA = 92
    T_TREATY_AREA = 93
    T_TREATY_LAND = 94
    T_RELATED_TREATY_LAND = 95
    T_ALC_ALR = 96
    T_CONSERVATION_LAND = 97
    T_MINFILE_MINERAL_OCCURRENCE_DATABASE = 98
    T_CROWN_GRANTED_MINERAL_CLAIM = 99
    T_MINERAL_RESERVES_SITES_BUSINESS_VIEW = 100
    T_PETROLEUM_TITLE = 101
    T_CONSERVANCY_AREA = 102
    T_WILDLIFE_MANAGEMENT_AREA = 103
    T_RESERVOIR_PERMIT = 104
    T_WATER_LICENSED_WORK = 105
    T_WATER_RIGHTS_APPLICATION = 106
    T_WATER_RIGHTS_LICENCE = 107
    T_GUIDE_OUTFITTER_AREA = 108
    T_UNGULATE_WINTER_RANGE = 109
    T_WILDLIFE_HABITAT_AREAS = 110
    T_ROAD_SEGMENT_EXACT_COUNT_LOCATION = 111
    T_EASEMENT = 112
    T_STREET_LIGHT = 113
    T_TRAIL = 114
    T_ROAD_SEGMENT_TRAVEL_TIME_LOCATION = 115
    T_CONSTRUCTION_PROJECT = 116
    T_FACILITY = 117
    T_SUBDIVISION_APPLICATION = 118
    T_GARBAGE_ROUTE = 119
    T_PUBLIC_ART = 120
    T_CENSUS_TRACTS_DEMOGRAPHIC = 121
    T_COMMUNITY_OF_CONCERN = 122
    T_LIBRARY = 123
    T_SCHOOL = 124
    T_STREET_TREE = 125
    T_ELECTRIC_VEHICLE_CHARGING_STATION = 126
    T_VISION_ZERO_SAFETY_CORRIDOR = 127
    T_TRAFFIC_VOLUME_MODEL = 128
    T_PLANNING_PROJECT = 129
    T_PHARMACY = 130
    T_CENSUS_BLOCK = 131
    T_ZIP_CODE = 132
    T_FIRE_ASSESSMENT = 133
    T_TRANSPORTATION_PAVEMENT = 134
    T_VEHICLE = 135
    T_TRIBAL_LAND = 136
    T_FIRE_STATION = 137
    T_WILDFIRE = 138
    T_ACTIVE_TRANSPORTATION_LOCATION = 139
    T_TIME_DENSITY = 140
    T_YOUTH_DISABILITY_SUPPORT_SERVICES = 141
    T_HOME_FIRE_RISK = 142
    T_COUNT_LOCATION = 143
    T_RAILROAD = 144
    T_COMMUNITY_CENTER = 145
    T_MEAL_SITE = 146
    T_FOOD_BANK_AND_PARTNER = 147
    T_HOUSING_UNIT = 148
    T_BIKE_RACK = 149
    T_IMPROVEMENT_AREA = 150
    T_ZONING_DISTRICT = 151
    T_RIGHT_OF_WAY = 152
    T_FREEWAY = 153
    T_BIKE_SUPPORT = 154
    T_BIKE_CROSSING = 155
    T_CYCLING_JUNCTION = 156
    T_LANEWAYS = 157
    T_CROSSWALK = 158
    T_ISSUE = 159
    T_MONUMENT = 160
    T_WATER_PARCEL = 161
    T_CONTOUR = 162
    T_CAPITAL_PROJECT = 163
    T_SIGN = 164
    T_SIGN_POLE = 165
    T_REQUEST = 166
    T_EMERGENCY_RESPONSE_ROAD = 167
    T_RAILWAY_CROSSING = 168
    T_MOBILITY_HUB = 169
    T_CORRIDOR = 170
    T_CRASH = 171
    T_RAIL_LINE = 172
    T_RAIL_STOP = 173
    T_ROUTE = 174
    T_ROUTE_STOP = 175
    T_TRANSIT_STOP = 176
    T_TRANSIT_CENTER = 177
    T_EXPLORE_MODE_INTERSECTION = 178
    T_ETS_SEGMENT = 179
    T_FSA = 180
    T_NEIGHBORHOOD_BUSINESS_ASSOCIATION = 181
    T_COUNCIL_DISTRICT = 182
    T_PROJECT_CRASHBOARD = 183
    T_ELEVATION_LINE = 184
    T_AREA = 185
    T_TAX_LOT = 186
    T_FLOOD = 187
    T_COUNTY = 188
    T_CITY = 189
    T_ELEMENTARY_SCHOOL_DISTRICT = 190
    T_HIGH_SCHOOL_DISTRICT = 191
    T_MIDDLE_SCHOOL_DISTRICT = 192
    T_POLICY_AREA = 193
    T_2020_CENSUS_BLOCK = 194
    T_2010_CENSUS_BLOCK = 195
    T_2020_CENSUS_TRACT = 196
    T_NON_CTP_ROADS = 197
    T_COMMERCIAL_VACANCY = 198
    T_TESTING_SITE = 199
    T_CLINIC = 200
    T_STREET_LITTER = 201
    T_CHILDCARE_CENTER = 202
    T_CAMERA = 203
    T_ALLEY = 204
    T_PAVEMENT = 205
    T_PAVEMENT_STRIP = 206
    T_POLE = 207
    T_DASHBOARD_BUSINESS = 208
    T_SIGNAL = 209
    T_MAST_ARM = 210
    T_CAMERA_EXPLORE = 211
    T_DASHBOARD_PROPERTY = 212
    T_POLICE_REPORTED_CRASH = 213
    T_PARKING_SPACE = 214
    T_FIRE_RISK_SCORE = 215
    T_FIRE_RISK_CAUSE = 216
    T_FIRE_DEPARTMENT = 217
    T_PLANNED_SIDEWALK = 218
    T_PROPOSED_PEDESTRIAN_PROJECT = 219
    T_PROPOSED_BIKE_PROJECT = 220
    T_ADMINISTRATIVE_AREA = 221
    T_CURB_RAMP = 222
    T_PARKING_PERMIT_AREA = 223
    T_PARCEL = 224
    T_BOUNDARY = 225
    T_RAILWAY = 226
    T_SOIL = 227
    T_UTILITY_CABINET = 228
    T_SIGNAL_CABINET = 229
    T_PEDESTRIAN_BUTTON = 230
    T_TRAFFIC_CALMING = 231
    T_CURB = 232
    T_TRUCK_ROUTE = 233
    T_GREENWAY = 234
    T_ROAD_EDGE = 235
    T_RESTAURANT = 236
    T_BARRIER = 237
    T_PAVEMENT_MARKING = 238
    T_PLANNING_AREA = 239
    T_ORDER = 240
    T_FIRE_HYDRANT = 241
    T_CANNABIS_AND_LIQUOR_STORES = 242
    T_CENSUS_SUBDIVISION = 243
    T_SPEED_HUMP = 244
    T_CRASH_CUSHION = 245
    T_DEFAULT_AREA_FILTER = 246
    T_PLAYGROUND = 247
    T_PICNIC_SHELTER = 248
    T_TENNIS_COURT = 249
    T_SPORTS_FIELD = 250
    T_WASHROOM = 251
    T_BASEBALL_DIAMOND = 252
    T_ITS_DEVICE = 253
    T_SHORTLINE = 254
    T_TRANSIT_RELATED = 255
    T_FREIGHT_ANALYSIS_DASHBOARD = 256
    T_ACCESS_POINT = 257
    T_CENSUS_DIVISION = 258
    T_STATE_PROVINCE = 259
    T_FEDERAL = 260
    T_CANNABIS_AND_LIQUOR_STORES_TRANSFER = 261

class NodeTy(Enum):
    N_INVALID = 0
    N_ENTITY = 1
    N_EMITTER = 2
    N_BOUNDARY = 3


@dataclass
class Point:
    point_geo: "List[float]"

    @classmethod
    def from_fbs(cls, o: FbsPoint) -> Self:
        point_geo = list()
        if not o.PointGeoIsNone():
            for i in range(o.PointGeoLength()):
                point_geo.append(o.PointGeo(i))
        return cls(point_geo)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsPoint.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Point import (
            Start,
            AddPointGeo,
            StartPointGeoVector,
            End,
        )
        StartPointGeoVector(builder, len(self.point_geo))
        for i in reversed(range(len(self.point_geo))):
            builder.PrependFloat32(self.point_geo[i])
        point_geo_offset = builder.EndVector()
        
        Start(builder)
        AddPointGeo(builder, point_geo_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        point_geo = []
        return cls(point_geo)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.point_geo) != len(other.point_geo):
            return False
        for i in range(len(self.point_geo)):
            eq = eq and self.point_geo[i] == other.point_geo[i]

        return eq

@dataclass
class Line:
    line_geo: "List[Point]"

    @classmethod
    def from_fbs(cls, o: FbsLine) -> Self:
        line_geo = list()
        if not o.LineGeoIsNone():
            for i in range(o.LineGeoLength()):
                line_geo_val = None
                line_geo_obj = o.LineGeo(i)
                if line_geo_obj is not None:
                    line_geo_val = Point.from_fbs(line_geo_obj)
                line_geo.append(line_geo_val)
        return cls(line_geo)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsLine.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Line import (
            Start,
            AddLineGeo,
            StartLineGeoVector,
            End,
        )
        line_geo_offsets = list()
        for value in self.line_geo:
            line_geo_offsets.append(value.serialize_to(builder))
        StartLineGeoVector(builder, len(self.line_geo))
        for i in reversed(range(len(self.line_geo))):
            builder.PrependUOffsetTRelative(line_geo_offsets[i])
        line_geo_offset = builder.EndVector()
        
        Start(builder)
        AddLineGeo(builder, line_geo_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        line_geo = []
        return cls(line_geo)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.line_geo) != len(other.line_geo):
            return False
        for i in range(len(self.line_geo)):
            eq = eq and self.line_geo[i] == other.line_geo[i]

        return eq

@dataclass
class MultiLine:
    multiline_geo: "List[Line]"

    @classmethod
    def from_fbs(cls, o: FbsMultiLine) -> Self:
        multiline_geo = list()
        if not o.MultilineGeoIsNone():
            for i in range(o.MultilineGeoLength()):
                multiline_geo_val = None
                multiline_geo_obj = o.MultilineGeo(i)
                if multiline_geo_obj is not None:
                    multiline_geo_val = Line.from_fbs(multiline_geo_obj)
                multiline_geo.append(multiline_geo_val)
        return cls(multiline_geo)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsMultiLine.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.MultiLine import (
            Start,
            AddMultilineGeo,
            StartMultilineGeoVector,
            End,
        )
        multiline_geo_offsets = list()
        for value in self.multiline_geo:
            multiline_geo_offsets.append(value.serialize_to(builder))
        StartMultilineGeoVector(builder, len(self.multiline_geo))
        for i in reversed(range(len(self.multiline_geo))):
            builder.PrependUOffsetTRelative(multiline_geo_offsets[i])
        multiline_geo_offset = builder.EndVector()
        
        Start(builder)
        AddMultilineGeo(builder, multiline_geo_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        multiline_geo = []
        return cls(multiline_geo)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.multiline_geo) != len(other.multiline_geo):
            return False
        for i in range(len(self.multiline_geo)):
            eq = eq and self.multiline_geo[i] == other.multiline_geo[i]

        return eq

@dataclass
class Polygon:
    """ Polygon is an array of arrays of points.
     The first array is exterior coords, following are any interior holes
    """

    polygon_geo: "List[Line]"

    @classmethod
    def from_fbs(cls, o: FbsPolygon) -> Self:
        polygon_geo = list()
        if not o.PolygonGeoIsNone():
            for i in range(o.PolygonGeoLength()):
                polygon_geo_val = None
                polygon_geo_obj = o.PolygonGeo(i)
                if polygon_geo_obj is not None:
                    polygon_geo_val = Line.from_fbs(polygon_geo_obj)
                polygon_geo.append(polygon_geo_val)
        return cls(polygon_geo)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsPolygon.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Polygon import (
            Start,
            AddPolygonGeo,
            StartPolygonGeoVector,
            End,
        )
        polygon_geo_offsets = list()
        for value in self.polygon_geo:
            polygon_geo_offsets.append(value.serialize_to(builder))
        StartPolygonGeoVector(builder, len(self.polygon_geo))
        for i in reversed(range(len(self.polygon_geo))):
            builder.PrependUOffsetTRelative(polygon_geo_offsets[i])
        polygon_geo_offset = builder.EndVector()
        
        Start(builder)
        AddPolygonGeo(builder, polygon_geo_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        polygon_geo = []
        return cls(polygon_geo)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.polygon_geo) != len(other.polygon_geo):
            return False
        for i in range(len(self.polygon_geo)):
            eq = eq and self.polygon_geo[i] == other.polygon_geo[i]

        return eq

@dataclass
class MultiPolygon:
    multipolygon_geo: "List[Polygon]"

    @classmethod
    def from_fbs(cls, o: FbsMultiPolygon) -> Self:
        multipolygon_geo = list()
        if not o.MultipolygonGeoIsNone():
            for i in range(o.MultipolygonGeoLength()):
                multipolygon_geo_val = None
                multipolygon_geo_obj = o.MultipolygonGeo(i)
                if multipolygon_geo_obj is not None:
                    multipolygon_geo_val = Polygon.from_fbs(multipolygon_geo_obj)
                multipolygon_geo.append(multipolygon_geo_val)
        return cls(multipolygon_geo)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsMultiPolygon.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.MultiPolygon import (
            Start,
            AddMultipolygonGeo,
            StartMultipolygonGeoVector,
            End,
        )
        multipolygon_geo_offsets = list()
        for value in self.multipolygon_geo:
            multipolygon_geo_offsets.append(value.serialize_to(builder))
        StartMultipolygonGeoVector(builder, len(self.multipolygon_geo))
        for i in reversed(range(len(self.multipolygon_geo))):
            builder.PrependUOffsetTRelative(multipolygon_geo_offsets[i])
        multipolygon_geo_offset = builder.EndVector()
        
        Start(builder)
        AddMultipolygonGeo(builder, multipolygon_geo_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        multipolygon_geo = []
        return cls(multipolygon_geo)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.multipolygon_geo) != len(other.multipolygon_geo):
            return False
        for i in range(len(self.multipolygon_geo)):
            eq = eq and self.multipolygon_geo[i] == other.multipolygon_geo[i]

        return eq

@dataclass
class Geometry:
    value: Union[
        "Point",
        "Line",
        "MultiLine",
        "Polygon",
        "MultiPolygon",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.Geometry import Geometry
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, Point):
            return (offset, Geometry().Point)
        elif isinstance(self.value, Line):
            return (offset, Geometry().Line)
        elif isinstance(self.value, MultiLine):
            return (offset, Geometry().MultiLine)
        elif isinstance(self.value, Polygon):
            return (offset, Geometry().Polygon)
        elif isinstance(self.value, MultiPolygon):
            return (offset, Geometry().MultiPolygon)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        Geometry_ty_instance = FbsGeometry()
        if ty == Geometry_ty_instance.Point:
            val = FbsPoint();
            val.Init(source, pos)
            return cls(Point.from_fbs(val))
        elif ty == Geometry_ty_instance.Line:
            val = FbsLine();
            val.Init(source, pos)
            return cls(Line.from_fbs(val))
        elif ty == Geometry_ty_instance.MultiLine:
            val = FbsMultiLine();
            val.Init(source, pos)
            return cls(MultiLine.from_fbs(val))
        elif ty == Geometry_ty_instance.Polygon:
            val = FbsPolygon();
            val.Init(source, pos)
            return cls(Polygon.from_fbs(val))
        elif ty == Geometry_ty_instance.MultiPolygon:
            val = FbsMultiPolygon();
            val.Init(source, pos)
            return cls(MultiPolygon.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(Point.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class GraphEdge:
    _from: "int"

    _kind: "EdgeTy"

    _to: "int"

    @classmethod
    def from_fbs(cls, o: FbsGraphEdge) -> Self:
        _from = o._From()
        _kind = EdgeTy(o._Kind())
        _to = o._To()
        return cls(_from, _kind, _to)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsGraphEdge.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.GraphEdge import (
            Start,
            Add_From,
            Add_Kind,
            Add_To,
            End,
        )
        
        Start(builder)
        Add_From(builder, self._from)
        Add_Kind(builder, self._kind.value)
        Add_To(builder, self._to)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        _from = 0
        _kind = EdgeTy(0)
        _to = 0
        return cls(_from, _kind, _to)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self._from == other._from
        eq = eq and self._kind == other._kind
        eq = eq and self._to == other._to

        return eq

@dataclass
class GraphNode:
    # A human-centric description of this graph node.
    _description: Optional["str"]

    # Entity type (ie: traffic loop, road, power line, building, business, demographic data, collision,  ...)
    _entity_type: "EntityTy"

    # polygon / line / point / null
    _geom: Optional["Geometry"]

    # lat/lng point in space, or centroid if not a point
    _location: Optional["Point"]

    # Record id in the data source.
    _node_id: Optional["GenericId"]

    # Node type, such as emitter vs. entity
    _node_type: "NodeTy"

    # ID of the associated data source
    _stream: Optional["ObjectId"]

    # Unique database-specific identifier
    _uid: "int"

    @classmethod
    def from_fbs(cls, o: FbsGraphNode) -> Self:
        _description = None
        _description_str = o._Description()
        if _description_str is not None:
            _description = _description_str.decode('utf-8')
        _entity_type = EntityTy(o._EntityType())
        _geom = None
        _geom_val = o._Geom()
        if _geom_val is not None:
            _geom_ty = o._GeomType()
            _geom = Geometry.from_fbs(_geom_val, _geom_ty)
        _location = None
        _location_obj = o._Location()
        if _location_obj is not None:
            _location = Point.from_fbs(_location_obj)
        _node_id = None
        _node_id_obj = o._NodeId()
        if _node_id_obj is not None:
            _node_id = GenericId.from_fbs(_node_id_obj)
        _node_type = NodeTy(o._NodeType())
        _stream = None
        _stream_obj = o._Stream()
        if _stream_obj is not None:
            _stream = ObjectId.from_fbs(_stream_obj)
        _uid = o._Uid()
        return cls(_description, _entity_type, _geom, _location, _node_id, _node_type, _stream, _uid)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsGraphNode.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.GraphNode import (
            Start,
            Add_Description,
            Add_EntityType,
            Add_Geom,
            Add_GeomType,
            Add_Location,
            Add_NodeId,
            Add_NodeType,
            Add_Stream,
            Add_Uid,
            End,
        )
        _description_offset = None
        if self._description is not None:
            _description_offset = builder.CreateString(self._description)
        _geom_offset, _geom_ty = (None, None)
        if self._geom is not None:
            _geom_offset, _geom_ty = self._geom.serialize_to(builder)
        _location_offset = None
        if self._location is not None:
            _location_offset = self._location.serialize_to(builder)
        _node_id_offset = None
        if self._node_id is not None:
            _node_id_offset = self._node_id.serialize_to(builder)
        _stream_offset = None
        if self._stream is not None:
            _stream_offset = self._stream.serialize_to(builder)
        
        Start(builder)
        if _description_offset is not None:
            Add_Description(builder, _description_offset)
        Add_EntityType(builder, self._entity_type.value)
        if _geom_offset is not None and _geom_ty is not None:
            Add_Geom(builder, _geom_offset)
            Add_GeomType(builder, _geom_ty)
        if _location_offset is not None:
            Add_Location(builder, _location_offset)
        if _node_id_offset is not None:
            Add_NodeId(builder, _node_id_offset)
        Add_NodeType(builder, self._node_type.value)
        if _stream_offset is not None:
            Add_Stream(builder, _stream_offset)
        Add_Uid(builder, self._uid)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        _description = ""
        _entity_type = EntityTy(0)
        _geom = Geometry.make_default()
        _location = Point.make_default()
        _node_id = GenericId.make_default()
        _node_type = NodeTy(0)
        _stream = ObjectId.make_default()
        _uid = 0
        return cls(_description, _entity_type, _geom, _location, _node_id, _node_type, _stream, _uid)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self._description == other._description
        eq = eq and self._entity_type == other._entity_type
        eq = eq and self._geom == other._geom
        eq = eq and self._location == other._location
        eq = eq and self._node_id == other._node_id
        eq = eq and self._node_type == other._node_type
        eq = eq and self._stream == other._stream
        eq = eq and self._uid == other._uid

        return eq
