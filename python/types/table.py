# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .Schema import (
    Binary,
    Bool,
    Buffer,
    Date,
    DateUnit,
    Decimal,
    DictionaryEncoding,
    DictionaryKind,
    Duration,
    Endianness,
    Feature,
    Field,
    FixedSizeBinary,
    FixedSizeList,
    FloatingPoint,
    Int,
    Interval,
    IntervalUnit,
    KeyValue,
    LargeBinary,
    LargeList,
    LargeUtf8,
    List_,
    Map,
    MetadataVersion,
    Null,
    Precision,
    Schema,
    Struct_,
    Time,
    TimeUnit,
    Timestamp,
    Type,
    Union_,
    UnionMode,
    Utf8,
)
from .api import SortOrder
from .crypto import (
    CryptHeader,
    Digest,
    EncryptedObject,
    Sha256,
    Signature,
)
from .data import (
    AttributePair,
    DayOfWeek,
    DirectionAndRoadName,
    DirectionAndRoadNames,
    DirectionTy,
    NamedParameter,
    NamedParameterFlags,
    RoadUserTy,
    Source,
    StatisticTy,
    TimeGranularity,
    TurnTy,
)
from .entity import (
    EdgeTy,
    EntityTy,
    Geometry,
    GraphEdge,
    GraphNode,
    Line,
    MultiLine,
    MultiPolygon,
    NodeTy,
    Point,
    Polygon,
)
from .fs import (
    Attr,
    Chunk,
    Directory,
    DirectoryEntry,
    DirectoryList,
    Entry,
    EntryTy,
    File,
    ListDirectory,
    ListEntry,
    ListFile,
    ListObject,
    ListSlot,
    MoveRequest,
    NewLink,
    ObjectRef,
    Slot,
    TopLevelDirectory,
)
from .fun import Fn
from .graph import (
    EdgeList,
    EdgeQuery,
    Geom,
    GeomOp,
    GraphQuery,
    NodeIdPair,
    NodeList,
    NodeQuery,
    OrderBy,
    Predicate,
    Projection,
    QueryPathElement,
    QueryPathElementUnion,
    ValueTransform,
)
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .job import (
    DeprecatedRunSpec,
    DeprecatedTaskParameter,
    Edge,
    EmbeddedTable,
    Job,
    Node,
    ParamIndices,
    RunSpec,
    Schematic,
    Status,
    Task,
    TaskErrorTy,
    TaskList,
    TaskParameter,
    TaskParameterValue,
    TaskPriority,
    TaskRunFlags,
)
from .object import (
    DataCatalogObject,
    DataCatalogObjectFlags,
    DataCatalogObjectTy,
    ObjectIdList,
    ObjectIdPair,
    ObjectIdPairList,
    ObjectSummary,
    ObjectSummaryList,
)
from .query import (
    AllColumns,
    Arrow,
    BinaryQueryElement,
    Case,
    Column,
    DataCatalog,
    DeleteQueryElement,
    Distinct,
    Expr,
    ExprUnion,
    Function,
    Join,
    JoinTy,
    MvdbSubcollection,
    NullableUint,
    OrderByExpr,
    Parameter,
    ParameterInstance,
    ParameterSlot,
    ParameterizedQuery,
    Partition,
    Query,
    QueryElement,
    QueryElementOp,
    QueryElementUnion,
    QueryTableSource,
    SetExpr,
    Subcollection,
    TableOrderBy,
    TableSource,
    TableSourceUnion,
    TypeHint,
    UnaryQueryElement,
    UnsetArgument,
    UpdateQueryElement,
    ValueIndex,
    Vector,
    When,
    Window,
    WorklogSubcollection,
)
from .reflection import (
    ReflectionAdvancedFeatures,
    ReflectionBaseType,
    ReflectionEnum,
    ReflectionEnumVal,
    ReflectionField,
    ReflectionKeyValue,
    ReflectionObject,
    ReflectionRPCCall,
    ReflectionSchema,
    ReflectionSchemaFile,
    ReflectionService,
    ReflectionType,
)
from .stream import (
    AxisType,
    FormatFlags,
    Stream,
    StreamFlags,
)
from .value import (
    Point2D,
    Tri2D,
    VArray,
    VBool,
    VBytes,
    VChar,
    VF32,
    VF64,
    VFixedSizeBytes,
    VI16,
    VI32,
    VI64,
    VI8,
    VIsize,
    VNull,
    VStr,
    VTimestampMs,
    VTimestampMsUtc,
    VTimestampNs,
    VTimestampNsUtc,
    VTri2D,
    VU16,
    VU32,
    VU64,
    VU8,
    VUnit,
    VUsize,
    Value,
    ValueInstance,
    ValueTy,
)
from .worklog import (
    AggregationTy,
    ByteArray,
    ChartTypeTy,
    Layout,
    ParameterFlags,
    ParameterValue,
    TileData,
    TileSettings,
    UserSettings,
    ValuesFormatTy,
    WorkLog,
    WorklogParameter,
)
from .generated.AllColumns import AllColumns as FbsAllColumns
from .generated.Arrow import Arrow as FbsArrow
from .generated.Attr import Attr as FbsAttr
from .generated.AttributePair import AttributePair as FbsAttributePair
from .generated.B2cId import B2cId as FbsB2cId
from .generated.Binary import Binary as FbsBinary
from .generated.BinaryQueryElement import BinaryQueryElement as FbsBinaryQueryElement
from .generated.Bool import Bool as FbsBool
from .generated.Buffer import Buffer as FbsBuffer
from .generated.ByteArray import ByteArray as FbsByteArray
from .generated.Case import Case as FbsCase
from .generated.ChangeOpEntry import ChangeOpEntry as FbsChangeOpEntry
from .generated.ChangeSet import ChangeSet as FbsChangeSet
from .generated.Chunk import Chunk as FbsChunk
from .generated.Column import Column as FbsColumn
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.CryptHeader import CryptHeader as FbsCryptHeader
from .generated.DataCatalog import DataCatalog as FbsDataCatalog
from .generated.DataCatalogObject import DataCatalogObject as FbsDataCatalogObject
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.Date import Date as FbsDate
from .generated.Decimal import Decimal as FbsDecimal
from .generated.Delete import Delete as FbsDelete
from .generated.DeleteQueryElement import DeleteQueryElement as FbsDeleteQueryElement
from .generated.DeprecatedRunSpec import DeprecatedRunSpec as FbsDeprecatedRunSpec
from .generated.DeprecatedTaskParameter import DeprecatedTaskParameter as FbsDeprecatedTaskParameter
from .generated.DictionaryEncoding import DictionaryEncoding as FbsDictionaryEncoding
from .generated.DiffStream import DiffStream as FbsDiffStream
from .generated.DirectionAndRoadName import DirectionAndRoadName as FbsDirectionAndRoadName
from .generated.DirectionAndRoadNames import DirectionAndRoadNames as FbsDirectionAndRoadNames
from .generated.Directory import Directory as FbsDirectory
from .generated.DirectoryEntry import DirectoryEntry as FbsDirectoryEntry
from .generated.DirectoryList import DirectoryList as FbsDirectoryList
from .generated.Distinct import Distinct as FbsDistinct
from .generated.Duration import Duration as FbsDuration
from .generated.Edge import Edge as FbsEdge
from .generated.EdgeList import EdgeList as FbsEdgeList
from .generated.EdgeQuery import EdgeQuery as FbsEdgeQuery
from .generated.EmbeddedTable import EmbeddedTable as FbsEmbeddedTable
from .generated.EncryptedObject import EncryptedObject as FbsEncryptedObject
from .generated.Expr import Expr as FbsExpr
from .generated.Field import Field as FbsField
from .generated.File import File as FbsFile
from .generated.FixedSizeBinary import FixedSizeBinary as FbsFixedSizeBinary
from .generated.FixedSizeList import FixedSizeList as FbsFixedSizeList
from .generated.FloatingPoint import FloatingPoint as FbsFloatingPoint
from .generated.Function import Function as FbsFunction
from .generated.GenericId import GenericId as FbsGenericId
from .generated.Geom import Geom as FbsGeom
from .generated.GeomOp import GeomOp as FbsGeomOp
from .generated.GraphEdge import GraphEdge as FbsGraphEdge
from .generated.GraphNode import GraphNode as FbsGraphNode
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.GraphQuery import GraphQuery as FbsGraphQuery
from .generated.History import History as FbsHistory
from .generated.Int import Int as FbsInt
from .generated.Interval import Interval as FbsInterval
from .generated.Job import Job as FbsJob
from .generated.Join import Join as FbsJoin
from .generated.KeyValue import KeyValue as FbsKeyValue
from .generated.LargeBinary import LargeBinary as FbsLargeBinary
from .generated.LargeList import LargeList as FbsLargeList
from .generated.LargeUtf8 import LargeUtf8 as FbsLargeUtf8
from .generated.Layout import Layout as FbsLayout
from .generated.Line import Line as FbsLine
from .generated.List import List as FbsList
from .generated.ListDirectory import ListDirectory as FbsListDirectory
from .generated.ListFile import ListFile as FbsListFile
from .generated.ListObject import ListObject as FbsListObject
from .generated.ListSlot import ListSlot as FbsListSlot
from .generated.Map import Map as FbsMap
from .generated.Modify import Modify as FbsModify
from .generated.MoveRequest import MoveRequest as FbsMoveRequest
from .generated.MultiLine import MultiLine as FbsMultiLine
from .generated.MultiPolygon import MultiPolygon as FbsMultiPolygon
from .generated.MvdbSubcollection import MvdbSubcollection as FbsMvdbSubcollection
from .generated.NamedParameter import NamedParameter as FbsNamedParameter
from .generated.NewLink import NewLink as FbsNewLink
from .generated.NewTable import NewTable as FbsNewTable
from .generated.Node import Node as FbsNode
from .generated.NodeIdPair import NodeIdPair as FbsNodeIdPair
from .generated.NodeList import NodeList as FbsNodeList
from .generated.NodeQuery import NodeQuery as FbsNodeQuery
from .generated.Null import Null as FbsNull
from .generated.NullableUint import NullableUint as FbsNullableUint
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.ObjectIdList import ObjectIdList as FbsObjectIdList
from .generated.ObjectIdPair import ObjectIdPair as FbsObjectIdPair
from .generated.ObjectIdPairList import ObjectIdPairList as FbsObjectIdPairList
from .generated.ObjectRef import ObjectRef as FbsObjectRef
from .generated.ObjectSummary import ObjectSummary as FbsObjectSummary
from .generated.ObjectSummaryList import ObjectSummaryList as FbsObjectSummaryList
from .generated.OpEntry import OpEntry as FbsOpEntry
from .generated.OrderBy import OrderBy as FbsOrderBy
from .generated.OrderByExpr import OrderByExpr as FbsOrderByExpr
from .generated.ParamIndices import ParamIndices as FbsParamIndices
from .generated.Parameter import Parameter as FbsParameter
from .generated.ParameterFlags import ParameterFlags as FbsParameterFlags
from .generated.ParameterInstance import ParameterInstance as FbsParameterInstance
from .generated.ParameterizedQuery import ParameterizedQuery as FbsParameterizedQuery
from .generated.Partition import Partition as FbsPartition
from .generated.Point import Point as FbsPoint
from .generated.Point2D import Point2D as FbsPoint2D
from .generated.Polygon import Polygon as FbsPolygon
from .generated.Projection import Projection as FbsProjection
from .generated.Query import Query as FbsQuery
from .generated.QueryElement import QueryElement as FbsQueryElement
from .generated.QueryPathElement import QueryPathElement as FbsQueryPathElement
from .generated.QueryTableSource import QueryTableSource as FbsQueryTableSource
from .generated.Restore import Restore as FbsRestore
from .generated.RestoreRow import RestoreRow as FbsRestoreRow
from .generated.RmRow import RmRow as FbsRmRow
from .generated.RunSpec import RunSpec as FbsRunSpec
from .generated.Schema import Schema as FbsSchema
from .generated.Schematic import Schematic as FbsSchematic
from .generated.Set import Set as FbsSet
from .generated.SetExpr import SetExpr as FbsSetExpr
from .generated.Sha256 import Sha256 as FbsSha256
from .generated.Signature import Signature as FbsSignature
from .generated.Slot import Slot as FbsSlot
from .generated.Source import Source as FbsSource
from .generated.Stream import Stream as FbsStream
from .generated.StreamId import StreamId as FbsStreamId
from .generated.Struct_ import Struct_ as FbsStruct_
from .generated.TableOrderBy import TableOrderBy as FbsTableOrderBy
from .generated.TableSource import TableSource as FbsTableSource
from .generated.Task import Task as FbsTask
from .generated.TaskList import TaskList as FbsTaskList
from .generated.TaskParameter import TaskParameter as FbsTaskParameter
from .generated.TileData import TileData as FbsTileData
from .generated.TileSettings import TileSettings as FbsTileSettings
from .generated.Time import Time as FbsTime
from .generated.Timestamp import Timestamp as FbsTimestamp
from .generated.TopLevelDirectory import TopLevelDirectory as FbsTopLevelDirectory
from .generated.Tri2D import Tri2D as FbsTri2D
from .generated.UnaryQueryElement import UnaryQueryElement as FbsUnaryQueryElement
from .generated.Union import Union as FbsUnion
from .generated.UnsetArgument import UnsetArgument as FbsUnsetArgument
from .generated.UpdateQueryElement import UpdateQueryElement as FbsUpdateQueryElement
from .generated.UserSettings import UserSettings as FbsUserSettings
from .generated.Utf8 import Utf8 as FbsUtf8
from .generated.VArray import VArray as FbsVArray
from .generated.VBool import VBool as FbsVBool
from .generated.VBytes import VBytes as FbsVBytes
from .generated.VChar import VChar as FbsVChar
from .generated.VF32 import VF32 as FbsVF32
from .generated.VF64 import VF64 as FbsVF64
from .generated.VFixedSizeBytes import VFixedSizeBytes as FbsVFixedSizeBytes
from .generated.VI16 import VI16 as FbsVI16
from .generated.VI32 import VI32 as FbsVI32
from .generated.VI64 import VI64 as FbsVI64
from .generated.VI8 import VI8 as FbsVI8
from .generated.VIsize import VIsize as FbsVIsize
from .generated.VNull import VNull as FbsVNull
from .generated.VStr import VStr as FbsVStr
from .generated.VTimestampMs import VTimestampMs as FbsVTimestampMs
from .generated.VTimestampMsUtc import VTimestampMsUtc as FbsVTimestampMsUtc
from .generated.VTimestampNs import VTimestampNs as FbsVTimestampNs
from .generated.VTimestampNsUtc import VTimestampNsUtc as FbsVTimestampNsUtc
from .generated.VTri2D import VTri2D as FbsVTri2D
from .generated.VU16 import VU16 as FbsVU16
from .generated.VU32 import VU32 as FbsVU32
from .generated.VU64 import VU64 as FbsVU64
from .generated.VU8 import VU8 as FbsVU8
from .generated.VUnit import VUnit as FbsVUnit
from .generated.VUsize import VUsize as FbsVUsize
from .generated.ValueIndex import ValueIndex as FbsValueIndex
from .generated.ValueInstance import ValueInstance as FbsValueInstance
from .generated.Vector import Vector as FbsVector
from .generated.When import When as FbsWhen
from .generated.Window import Window as FbsWindow
from .generated.WorkLog import WorkLog as FbsWorkLog
from .generated.WorklogParameter import WorklogParameter as FbsWorklogParameter
from .generated.WorklogSubcollection import WorklogSubcollection as FbsWorklogSubcollection
from .generated.reflection.Enum import Enum as FbsEnum
from .generated.reflection.EnumVal import EnumVal as FbsEnumVal
from .generated.reflection.Field import Field as FbsField
from .generated.reflection.KeyValue import KeyValue as FbsKeyValue
from .generated.reflection.Object import Object as FbsObject
from .generated.reflection.RPCCall import RPCCall as FbsRPCCall
from .generated.reflection.Schema import Schema as FbsSchema
from .generated.reflection.SchemaFile import SchemaFile as FbsSchemaFile
from .generated.reflection.Service import Service as FbsService
from .generated.reflection.Type import Type as FbsType
from .generated.ChangeOp import ChangeOp as FbsChangeOp
from .generated.Digest import Digest as FbsDigest
from .generated.Entry import Entry as FbsEntry
from .generated.ExprUnion import ExprUnion as FbsExprUnion
from .generated.Geometry import Geometry as FbsGeometry
from .generated.ListEntry import ListEntry as FbsListEntry
from .generated.Op import Op as FbsOp
from .generated.ParameterSlot import ParameterSlot as FbsParameterSlot
from .generated.ParameterValue import ParameterValue as FbsParameterValue
from .generated.QueryElementUnion import QueryElementUnion as FbsQueryElementUnion
from .generated.QueryPathElementUnion import QueryPathElementUnion as FbsQueryPathElementUnion
from .generated.Subcollection import Subcollection as FbsSubcollection
from .generated.TableSourceUnion import TableSourceUnion as FbsTableSourceUnion
from .generated.TaskParameterValue import TaskParameterValue as FbsTaskParameterValue
from .generated.Type import Type as FbsType
from .generated.Value import Value as FbsValue


@dataclass
class Modify:
    col: "str"

    previous: Optional["ValueInstance"]

    row: "GenericId"

    value: "ValueInstance"

    @classmethod
    def from_fbs(cls, o: FbsModify) -> Self:
        col_str = o.Col()
        assert col_str is not None
        col = col_str.decode('utf-8')
        previous = None
        previous_obj = o.Previous()
        if previous_obj is not None:
            previous = ValueInstance.from_fbs(previous_obj)
        row_obj = o.Row()
        if row_obj is not None:
            row = GenericId.from_fbs(row_obj)
        else:
            raise ValueError("Row is required")
        value_obj = o.Value()
        if value_obj is not None:
            value = ValueInstance.from_fbs(value_obj)
        else:
            raise ValueError("Value is required")
        return cls(col, previous, row, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsModify.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Modify import (
            Start,
            AddCol,
            AddPrevious,
            AddRow,
            AddValue,
            End,
        )
        col_offset = builder.CreateString(self.col)
        previous_offset = None
        if self.previous is not None:
            previous_offset = self.previous.serialize_to(builder)
        row_offset = self.row.serialize_to(builder)
        value_offset = self.value.serialize_to(builder)
        
        Start(builder)
        AddCol(builder, col_offset)
        if previous_offset is not None:
            AddPrevious(builder, previous_offset)
        AddRow(builder, row_offset)
        AddValue(builder, value_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        col = ""
        previous = ValueInstance.make_default()
        row = GenericId.make_default()
        value = ValueInstance.make_default()
        return cls(col, previous, row, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.col == other.col
        eq = eq and self.previous == other.previous
        eq = eq and self.row == other.row
        eq = eq and self.value == other.value

        return eq

@dataclass
class Delete:
    row: "GenericId"

    @classmethod
    def from_fbs(cls, o: FbsDelete) -> Self:
        row_obj = o.Row()
        if row_obj is not None:
            row = GenericId.from_fbs(row_obj)
        else:
            raise ValueError("Row is required")
        return cls(row)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDelete.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Delete import (
            Start,
            AddRow,
            End,
        )
        row_offset = self.row.serialize_to(builder)
        
        Start(builder)
        AddRow(builder, row_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        row = GenericId.make_default()
        return cls(row)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.row == other.row

        return eq

@dataclass
class Restore:
    row: "GenericId"

    @classmethod
    def from_fbs(cls, o: FbsRestore) -> Self:
        row_obj = o.Row()
        if row_obj is not None:
            row = GenericId.from_fbs(row_obj)
        else:
            raise ValueError("Row is required")
        return cls(row)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRestore.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Restore import (
            Start,
            AddRow,
            End,
        )
        row_offset = self.row.serialize_to(builder)
        
        Start(builder)
        AddRow(builder, row_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        row = GenericId.make_default()
        return cls(row)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.row == other.row

        return eq

@dataclass
class ChangeOp:
    value: Union[
        "Modify",
        "Delete",
        "Restore",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.ChangeOp import ChangeOp
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, Modify):
            return (offset, ChangeOp().Modify)
        elif isinstance(self.value, Delete):
            return (offset, ChangeOp().Delete)
        elif isinstance(self.value, Restore):
            return (offset, ChangeOp().Restore)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        ChangeOp_ty_instance = FbsChangeOp()
        if ty == ChangeOp_ty_instance.Modify:
            val = FbsModify();
            val.Init(source, pos)
            return cls(Modify.from_fbs(val))
        elif ty == ChangeOp_ty_instance.Delete:
            val = FbsDelete();
            val.Init(source, pos)
            return cls(Delete.from_fbs(val))
        elif ty == ChangeOp_ty_instance.Restore:
            val = FbsRestore();
            val.Init(source, pos)
            return cls(Restore.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(Modify.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class Set:
    """ The Set operation is used to set the value of a cell in a table.
    """

    # Name of the column to set.
    col: "str"

    # The value of the ul_node_id column, which uniquely identifies the row.
    row: "GenericId"

    # The value to set.
    value: "ValueInstance"

    @classmethod
    def from_fbs(cls, o: FbsSet) -> Self:
        col_str = o.Col()
        assert col_str is not None
        col = col_str.decode('utf-8')
        row_obj = o.Row()
        if row_obj is not None:
            row = GenericId.from_fbs(row_obj)
        else:
            raise ValueError("Row is required")
        value_obj = o.Value()
        if value_obj is not None:
            value = ValueInstance.from_fbs(value_obj)
        else:
            raise ValueError("Value is required")
        return cls(col, row, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsSet.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Set import (
            Start,
            AddCol,
            AddRow,
            AddValue,
            End,
        )
        col_offset = builder.CreateString(self.col)
        row_offset = self.row.serialize_to(builder)
        value_offset = self.value.serialize_to(builder)
        
        Start(builder)
        AddCol(builder, col_offset)
        AddRow(builder, row_offset)
        AddValue(builder, value_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        col = ""
        row = GenericId.make_default()
        value = ValueInstance.make_default()
        return cls(col, row, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.col == other.col
        eq = eq and self.row == other.row
        eq = eq and self.value == other.value

        return eq

@dataclass
class RmRow:
    """ The RmRow operation is used to remove a row from a table.
    """

    # The value of the ul_node_id column, which uniquely identifies the row.
    row: "GenericId"

    @classmethod
    def from_fbs(cls, o: FbsRmRow) -> Self:
        row_obj = o.Row()
        if row_obj is not None:
            row = GenericId.from_fbs(row_obj)
        else:
            raise ValueError("Row is required")
        return cls(row)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRmRow.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RmRow import (
            Start,
            AddRow,
            End,
        )
        row_offset = self.row.serialize_to(builder)
        
        Start(builder)
        AddRow(builder, row_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        row = GenericId.make_default()
        return cls(row)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.row == other.row

        return eq

@dataclass
class RestoreRow:
    """ The RestoreRow operation restore a deleted row in the table
     "Restore" is implemented by setting the value of the `ul_keep` system column to true.
     This means that formerly "removed" rows are no longer treated as "removed" and will then be returned by queries.
    """

    # The value of the ul_node_id column, which uniquely identifies the row.
    row: "GenericId"

    @classmethod
    def from_fbs(cls, o: FbsRestoreRow) -> Self:
        row_obj = o.Row()
        if row_obj is not None:
            row = GenericId.from_fbs(row_obj)
        else:
            raise ValueError("Row is required")
        return cls(row)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRestoreRow.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RestoreRow import (
            Start,
            AddRow,
            End,
        )
        row_offset = self.row.serialize_to(builder)
        
        Start(builder)
        AddRow(builder, row_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        row = GenericId.make_default()
        return cls(row)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.row == other.row

        return eq

@dataclass
class Op:
    """ Table Ops are used to modify the contents of a table.
"""

    value: Union[
        "Set",
        "RmRow",
        "RestoreRow",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.Op import Op
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, Set):
            return (offset, Op().Set)
        elif isinstance(self.value, RmRow):
            return (offset, Op().RmRow)
        elif isinstance(self.value, RestoreRow):
            return (offset, Op().RestoreRow)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        Op_ty_instance = FbsOp()
        if ty == Op_ty_instance.Set:
            val = FbsSet();
            val.Init(source, pos)
            return cls(Set.from_fbs(val))
        elif ty == Op_ty_instance.RmRow:
            val = FbsRmRow();
            val.Init(source, pos)
            return cls(RmRow.from_fbs(val))
        elif ty == Op_ty_instance.RestoreRow:
            val = FbsRestoreRow();
            val.Init(source, pos)
            return cls(RestoreRow.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(Set.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class ChangeOpEntry:
    op: "ChangeOp"

    @classmethod
    def from_fbs(cls, o: FbsChangeOpEntry) -> Self:
        op_val = o.Op()
        if op_val is not None:
            op_ty = o.OpType()
            op = ChangeOp.from_fbs(op_val, op_ty)
        else:
            raise ValueError("Op is required")
        return cls(op)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsChangeOpEntry.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ChangeOpEntry import (
            Start,
            AddOp,
            AddOpType,
            End,
        )
        op_offset, op_ty = self.op.serialize_to(builder)
        
        Start(builder)
        AddOp(builder, op_offset)
        AddOpType(builder, op_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        op = ChangeOp.make_default()
        return cls(op)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.op == other.op

        return eq

@dataclass
class ChangeSet:
    attributes: Optional["List[Attr]"]

    ops: "List[ChangeOpEntry]"

    revision: "ContentId"

    when: "int"

    who: "B2cId"

    @classmethod
    def from_fbs(cls, o: FbsChangeSet) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = Attr.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        ops = list()
        if not o.OpsIsNone():
            for i in range(o.OpsLength()):
                ops_val = None
                ops_obj = o.Ops(i)
                if ops_obj is not None:
                    ops_val = ChangeOpEntry.from_fbs(ops_obj)
                ops.append(ops_val)
        revision_obj = o.Revision()
        if revision_obj is not None:
            revision = ContentId.from_fbs(revision_obj)
        else:
            raise ValueError("Revision is required")
        when = o.When()
        who_obj = o.Who()
        if who_obj is not None:
            who = B2cId.from_fbs(who_obj)
        else:
            raise ValueError("Who is required")
        return cls(attributes, ops, revision, when, who)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsChangeSet.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ChangeSet import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddOps,
            StartOpsVector,
            AddRevision,
            AddWhen,
            AddWho,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        ops_offsets = list()
        for value in self.ops:
            ops_offsets.append(value.serialize_to(builder))
        StartOpsVector(builder, len(self.ops))
        for i in reversed(range(len(self.ops))):
            builder.PrependUOffsetTRelative(ops_offsets[i])
        ops_offset = builder.EndVector()
        revision_offset = self.revision.serialize_to(builder)
        who_offset = self.who.serialize_to(builder)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        AddOps(builder, ops_offset)
        AddRevision(builder, revision_offset)
        AddWhen(builder, self.when)
        AddWho(builder, who_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        ops = []
        revision = ContentId.make_default()
        when = 0
        who = B2cId.make_default()
        return cls(attributes, ops, revision, when, who)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        if len(self.ops) != len(other.ops):
            return False
        for i in range(len(self.ops)):
            eq = eq and self.ops[i] == other.ops[i]
        eq = eq and self.revision == other.revision
        eq = eq and self.when == other.when
        eq = eq and self.who == other.who

        return eq

@dataclass
class DiffStream:
    """ A DiffStream encodes a sequence of operations that should be performed on a table.
     The operations are applied in order to the table, i.e. the ordering of the `seq` field is significant.
    """

    # We can optionally associate attributes with the diffstream.
    # When the change history of the table is retrieved, the attributes from the diffstream
    # will be accessible as the `attributes` field on the ChangeSet associated with this diffstream.
    attributes: Optional["List[Attr]"]

    # This is the head revision of the directory object that contains the table.
    base: "ContentId"

    seq: "List[OpEntry]"

    @classmethod
    def from_fbs(cls, o: FbsDiffStream) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = Attr.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        base_obj = o.Base()
        if base_obj is not None:
            base = ContentId.from_fbs(base_obj)
        else:
            raise ValueError("Base is required")
        seq = list()
        if not o.SeqIsNone():
            for i in range(o.SeqLength()):
                seq_val = None
                seq_obj = o.Seq(i)
                if seq_obj is not None:
                    seq_val = OpEntry.from_fbs(seq_obj)
                seq.append(seq_val)
        return cls(attributes, base, seq)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDiffStream.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DiffStream import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddBase,
            AddSeq,
            StartSeqVector,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        base_offset = self.base.serialize_to(builder)
        seq_offsets = list()
        for value in self.seq:
            seq_offsets.append(value.serialize_to(builder))
        StartSeqVector(builder, len(self.seq))
        for i in reversed(range(len(self.seq))):
            builder.PrependUOffsetTRelative(seq_offsets[i])
        seq_offset = builder.EndVector()
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        AddBase(builder, base_offset)
        AddSeq(builder, seq_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        base = ContentId.make_default()
        seq = []
        return cls(attributes, base, seq)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        eq = eq and self.base == other.base
        if len(self.seq) != len(other.seq):
            return False
        for i in range(len(self.seq)):
            eq = eq and self.seq[i] == other.seq[i]

        return eq

@dataclass
class History:
    changes: "List[ChangeSet]"

    continuation_id: Optional["ContentId"]

    @classmethod
    def from_fbs(cls, o: FbsHistory) -> Self:
        changes = list()
        if not o.ChangesIsNone():
            for i in range(o.ChangesLength()):
                changes_val = None
                changes_obj = o.Changes(i)
                if changes_obj is not None:
                    changes_val = ChangeSet.from_fbs(changes_obj)
                changes.append(changes_val)
        continuation_id = None
        continuation_id_obj = o.ContinuationId()
        if continuation_id_obj is not None:
            continuation_id = ContentId.from_fbs(continuation_id_obj)
        return cls(changes, continuation_id)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsHistory.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.History import (
            Start,
            AddChanges,
            StartChangesVector,
            AddContinuationId,
            End,
        )
        changes_offsets = list()
        for value in self.changes:
            changes_offsets.append(value.serialize_to(builder))
        StartChangesVector(builder, len(self.changes))
        for i in reversed(range(len(self.changes))):
            builder.PrependUOffsetTRelative(changes_offsets[i])
        changes_offset = builder.EndVector()
        continuation_id_offset = None
        if self.continuation_id is not None:
            continuation_id_offset = self.continuation_id.serialize_to(builder)
        
        Start(builder)
        AddChanges(builder, changes_offset)
        if continuation_id_offset is not None:
            AddContinuationId(builder, continuation_id_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        changes = []
        continuation_id = ContentId.make_default()
        return cls(changes, continuation_id)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.changes) != len(other.changes):
            return False
        for i in range(len(self.changes)):
            eq = eq and self.changes[i] == other.changes[i]
        eq = eq and self.continuation_id == other.continuation_id

        return eq

@dataclass
class NewTable:
    """ Body parameter for POST datacatalog/table/<objectId>
    """

    name: "str"

    parent: Optional["ObjectId"]

    # If specified, creates a new table using this as the object ID.
    target: Optional["ObjectId"]

    @classmethod
    def from_fbs(cls, o: FbsNewTable) -> Self:
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        parent = None
        parent_obj = o.Parent()
        if parent_obj is not None:
            parent = ObjectId.from_fbs(parent_obj)
        target = None
        target_obj = o.Target()
        if target_obj is not None:
            target = ObjectId.from_fbs(target_obj)
        return cls(name, parent, target)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNewTable.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NewTable import (
            Start,
            AddName,
            AddParent,
            AddTarget,
            End,
        )
        name_offset = builder.CreateString(self.name)
        parent_offset = None
        if self.parent is not None:
            parent_offset = self.parent.serialize_to(builder)
        target_offset = None
        if self.target is not None:
            target_offset = self.target.serialize_to(builder)
        
        Start(builder)
        AddName(builder, name_offset)
        if parent_offset is not None:
            AddParent(builder, parent_offset)
        if target_offset is not None:
            AddTarget(builder, target_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        name = ""
        parent = ObjectId.make_default()
        target = ObjectId.make_default()
        return cls(name, parent, target)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.name == other.name
        eq = eq and self.parent == other.parent
        eq = eq and self.target == other.target

        return eq

@dataclass
class OpEntry:
    op: "Op"

    @classmethod
    def from_fbs(cls, o: FbsOpEntry) -> Self:
        op_val = o.Op()
        if op_val is not None:
            op_ty = o.OpType()
            op = Op.from_fbs(op_val, op_ty)
        else:
            raise ValueError("Op is required")
        return cls(op)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsOpEntry.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.OpEntry import (
            Start,
            AddOp,
            AddOpType,
            End,
        )
        op_offset, op_ty = self.op.serialize_to(builder)
        
        Start(builder)
        AddOp(builder, op_offset)
        AddOpType(builder, op_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        op = Op.make_default()
        return cls(op)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.op == other.op

        return eq
