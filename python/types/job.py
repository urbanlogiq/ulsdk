# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .Schema import (
    Binary,
    Bool,
    Buffer,
    Date,
    DateUnit,
    Decimal,
    DictionaryEncoding,
    DictionaryKind,
    Duration,
    Endianness,
    Feature,
    Field,
    FixedSizeBinary,
    FixedSizeList,
    FloatingPoint,
    Int,
    Interval,
    IntervalUnit,
    KeyValue,
    LargeBinary,
    LargeList,
    LargeUtf8,
    List_,
    Map,
    MetadataVersion,
    Null,
    Precision,
    Schema,
    Struct_,
    Time,
    TimeUnit,
    Timestamp,
    Type,
    Union_,
    UnionMode,
    Utf8,
)
from .data import (
    AttributePair,
    DayOfWeek,
    DirectionAndRoadName,
    DirectionAndRoadNames,
    DirectionTy,
    NamedParameter,
    NamedParameterFlags,
    RoadUserTy,
    Source,
    StatisticTy,
    TimeGranularity,
    TurnTy,
)
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .reflection import (
    ReflectionAdvancedFeatures,
    ReflectionBaseType,
    ReflectionEnum,
    ReflectionEnumVal,
    ReflectionField,
    ReflectionKeyValue,
    ReflectionObject,
    ReflectionRPCCall,
    ReflectionSchema,
    ReflectionSchemaFile,
    ReflectionService,
    ReflectionType,
)
from .value import (
    Point2D,
    Tri2D,
    VArray,
    VBool,
    VBytes,
    VChar,
    VF32,
    VF64,
    VFixedSizeBytes,
    VI16,
    VI32,
    VI64,
    VI8,
    VIsize,
    VNull,
    VStr,
    VTimestampMs,
    VTimestampMsUtc,
    VTimestampNs,
    VTimestampNsUtc,
    VTri2D,
    VU16,
    VU32,
    VU64,
    VU8,
    VUnit,
    VUsize,
    Value,
    ValueInstance,
    ValueTy,
)
from .generated.AttributePair import AttributePair as FbsAttributePair
from .generated.B2cId import B2cId as FbsB2cId
from .generated.Binary import Binary as FbsBinary
from .generated.Bool import Bool as FbsBool
from .generated.Buffer import Buffer as FbsBuffer
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.Date import Date as FbsDate
from .generated.Decimal import Decimal as FbsDecimal
from .generated.DeprecatedRunSpec import DeprecatedRunSpec as FbsDeprecatedRunSpec
from .generated.DeprecatedTaskParameter import DeprecatedTaskParameter as FbsDeprecatedTaskParameter
from .generated.DictionaryEncoding import DictionaryEncoding as FbsDictionaryEncoding
from .generated.DirectionAndRoadName import DirectionAndRoadName as FbsDirectionAndRoadName
from .generated.DirectionAndRoadNames import DirectionAndRoadNames as FbsDirectionAndRoadNames
from .generated.Duration import Duration as FbsDuration
from .generated.Edge import Edge as FbsEdge
from .generated.EmbeddedTable import EmbeddedTable as FbsEmbeddedTable
from .generated.Field import Field as FbsField
from .generated.FixedSizeBinary import FixedSizeBinary as FbsFixedSizeBinary
from .generated.FixedSizeList import FixedSizeList as FbsFixedSizeList
from .generated.FloatingPoint import FloatingPoint as FbsFloatingPoint
from .generated.GenericId import GenericId as FbsGenericId
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.Int import Int as FbsInt
from .generated.Interval import Interval as FbsInterval
from .generated.Job import Job as FbsJob
from .generated.KeyValue import KeyValue as FbsKeyValue
from .generated.LargeBinary import LargeBinary as FbsLargeBinary
from .generated.LargeList import LargeList as FbsLargeList
from .generated.LargeUtf8 import LargeUtf8 as FbsLargeUtf8
from .generated.List import List as FbsList
from .generated.Map import Map as FbsMap
from .generated.NamedParameter import NamedParameter as FbsNamedParameter
from .generated.Node import Node as FbsNode
from .generated.Null import Null as FbsNull
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.ParamIndices import ParamIndices as FbsParamIndices
from .generated.Point2D import Point2D as FbsPoint2D
from .generated.RunSpec import RunSpec as FbsRunSpec
from .generated.Schema import Schema as FbsSchema
from .generated.Schematic import Schematic as FbsSchematic
from .generated.Source import Source as FbsSource
from .generated.StreamId import StreamId as FbsStreamId
from .generated.Struct_ import Struct_ as FbsStruct_
from .generated.Task import Task as FbsTask
from .generated.TaskList import TaskList as FbsTaskList
from .generated.TaskParameter import TaskParameter as FbsTaskParameter
from .generated.Time import Time as FbsTime
from .generated.Timestamp import Timestamp as FbsTimestamp
from .generated.Tri2D import Tri2D as FbsTri2D
from .generated.Union import Union as FbsUnion
from .generated.Utf8 import Utf8 as FbsUtf8
from .generated.VArray import VArray as FbsVArray
from .generated.VBool import VBool as FbsVBool
from .generated.VBytes import VBytes as FbsVBytes
from .generated.VChar import VChar as FbsVChar
from .generated.VF32 import VF32 as FbsVF32
from .generated.VF64 import VF64 as FbsVF64
from .generated.VFixedSizeBytes import VFixedSizeBytes as FbsVFixedSizeBytes
from .generated.VI16 import VI16 as FbsVI16
from .generated.VI32 import VI32 as FbsVI32
from .generated.VI64 import VI64 as FbsVI64
from .generated.VI8 import VI8 as FbsVI8
from .generated.VIsize import VIsize as FbsVIsize
from .generated.VNull import VNull as FbsVNull
from .generated.VStr import VStr as FbsVStr
from .generated.VTimestampMs import VTimestampMs as FbsVTimestampMs
from .generated.VTimestampMsUtc import VTimestampMsUtc as FbsVTimestampMsUtc
from .generated.VTimestampNs import VTimestampNs as FbsVTimestampNs
from .generated.VTimestampNsUtc import VTimestampNsUtc as FbsVTimestampNsUtc
from .generated.VTri2D import VTri2D as FbsVTri2D
from .generated.VU16 import VU16 as FbsVU16
from .generated.VU32 import VU32 as FbsVU32
from .generated.VU64 import VU64 as FbsVU64
from .generated.VU8 import VU8 as FbsVU8
from .generated.VUnit import VUnit as FbsVUnit
from .generated.VUsize import VUsize as FbsVUsize
from .generated.ValueInstance import ValueInstance as FbsValueInstance
from .generated.reflection.Enum import Enum as FbsEnum
from .generated.reflection.EnumVal import EnumVal as FbsEnumVal
from .generated.reflection.Field import Field as FbsField
from .generated.reflection.KeyValue import KeyValue as FbsKeyValue
from .generated.reflection.Object import Object as FbsObject
from .generated.reflection.RPCCall import RPCCall as FbsRPCCall
from .generated.reflection.Schema import Schema as FbsSchema
from .generated.reflection.SchemaFile import SchemaFile as FbsSchemaFile
from .generated.reflection.Service import Service as FbsService
from .generated.reflection.Type import Type as FbsType
from .generated.TaskParameterValue import TaskParameterValue as FbsTaskParameterValue
from .generated.Type import Type as FbsType
from .generated.Value import Value as FbsValue

class Status(Enum):
    Pending = 0
    Running = 1
    Complete = 2
    Error = 3
    RetryableError = 4

class TaskErrorTy(Enum):
    NONE = 0
    DuplicateData = 1

class TaskPriority(Enum):
    High = -256
    Medium = 0
    Low = 256

class TaskRunFlags(Enum):
    PodLocked = 1


@dataclass
class EmbeddedTable:
    v: "List[int]"

    @classmethod
    def from_fbs(cls, o: FbsEmbeddedTable) -> Self:
        v = list()
        if not o.VIsNone():
            for i in range(o.VLength()):
                v.append(o.V(i))
        return cls(v)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsEmbeddedTable.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.EmbeddedTable import (
            Start,
            AddV,
            StartVVector,
            End,
        )
        StartVVector(builder, len(self.v))
        for i in reversed(range(len(self.v))):
            builder.PrependUint8(self.v[i])
        v_offset = builder.EndVector()
        
        Start(builder)
        AddV(builder, v_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        v = []
        return cls(v)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.v) != len(other.v):
            return False
        for i in range(len(self.v)):
            eq = eq and self.v[i] == other.v[i]

        return eq

@dataclass
class TaskParameterValue:
    value: Union[
        "ObjectId",
        "EmbeddedTable",
        "ValueInstance",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.TaskParameterValue import TaskParameterValue
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, ObjectId):
            return (offset, TaskParameterValue().ObjectId)
        elif isinstance(self.value, EmbeddedTable):
            return (offset, TaskParameterValue().EmbeddedTable)
        elif isinstance(self.value, ValueInstance):
            return (offset, TaskParameterValue().ValueInstance)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        TaskParameterValue_ty_instance = FbsTaskParameterValue()
        if ty == TaskParameterValue_ty_instance.ObjectId:
            val = FbsObjectId();
            val.Init(source, pos)
            return cls(ObjectId.from_fbs(val))
        elif ty == TaskParameterValue_ty_instance.EmbeddedTable:
            val = FbsEmbeddedTable();
            val.Init(source, pos)
            return cls(EmbeddedTable.from_fbs(val))
        elif ty == TaskParameterValue_ty_instance.ValueInstance:
            val = FbsValueInstance();
            val.Init(source, pos)
            return cls(ValueInstance.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(ObjectId.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class DeprecatedRunSpec:
    param_indices: "List[ParamIndices]"

    params: "List[DeprecatedTaskParameter]"

    persist: "bool"

    schematic: "ObjectId"

    @classmethod
    def from_fbs(cls, o: FbsDeprecatedRunSpec) -> Self:
        param_indices = list()
        if not o.ParamIndicesIsNone():
            for i in range(o.ParamIndicesLength()):
                param_indices_val = None
                param_indices_obj = o.ParamIndices(i)
                if param_indices_obj is not None:
                    param_indices_val = ParamIndices.from_fbs(param_indices_obj)
                param_indices.append(param_indices_val)
        params = list()
        if not o.ParamsIsNone():
            for i in range(o.ParamsLength()):
                params_val = None
                params_obj = o.Params(i)
                if params_obj is not None:
                    params_val = DeprecatedTaskParameter.from_fbs(params_obj)
                params.append(params_val)
        persist = o.Persist()
        schematic_obj = o.Schematic()
        if schematic_obj is not None:
            schematic = ObjectId.from_fbs(schematic_obj)
        else:
            raise ValueError("Schematic is required")
        return cls(param_indices, params, persist, schematic)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDeprecatedRunSpec.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DeprecatedRunSpec import (
            Start,
            AddParamIndices,
            StartParamIndicesVector,
            AddParams,
            StartParamsVector,
            AddPersist,
            AddSchematic,
            End,
        )
        param_indices_offsets = list()
        for value in self.param_indices:
            param_indices_offsets.append(value.serialize_to(builder))
        StartParamIndicesVector(builder, len(self.param_indices))
        for i in reversed(range(len(self.param_indices))):
            builder.PrependUOffsetTRelative(param_indices_offsets[i])
        param_indices_offset = builder.EndVector()
        params_offsets = list()
        for value in self.params:
            params_offsets.append(value.serialize_to(builder))
        StartParamsVector(builder, len(self.params))
        for i in reversed(range(len(self.params))):
            builder.PrependUOffsetTRelative(params_offsets[i])
        params_offset = builder.EndVector()
        schematic_offset = self.schematic.serialize_to(builder)
        
        Start(builder)
        AddParamIndices(builder, param_indices_offset)
        AddParams(builder, params_offset)
        AddPersist(builder, self.persist)
        AddSchematic(builder, schematic_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        param_indices = []
        params = []
        persist = False
        schematic = ObjectId.make_default()
        return cls(param_indices, params, persist, schematic)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.param_indices) != len(other.param_indices):
            return False
        for i in range(len(self.param_indices)):
            eq = eq and self.param_indices[i] == other.param_indices[i]
        if len(self.params) != len(other.params):
            return False
        for i in range(len(self.params)):
            eq = eq and self.params[i] == other.params[i]
        eq = eq and self.persist == other.persist
        eq = eq and self.schematic == other.schematic

        return eq

@dataclass
class DeprecatedTaskParameter:
    flags: "int"

    key: "str"

    obj: Optional["ObjectId"]

    value: Optional["List[int]"]

    @classmethod
    def from_fbs(cls, o: FbsDeprecatedTaskParameter) -> Self:
        flags = o.Flags()
        key_str = o.Key()
        assert key_str is not None
        key = key_str.decode('utf-8')
        obj = None
        obj_obj = o.Obj()
        if obj_obj is not None:
            obj = ObjectId.from_fbs(obj_obj)
        value = list()
        if not o.ValueIsNone():
            for i in range(o.ValueLength()):
                value.append(o.Value(i))
        return cls(flags, key, obj, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDeprecatedTaskParameter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DeprecatedTaskParameter import (
            Start,
            AddFlags,
            AddKey,
            AddObj,
            AddValue,
            StartValueVector,
            End,
        )
        key_offset = builder.CreateString(self.key)
        obj_offset = None
        if self.obj is not None:
            obj_offset = self.obj.serialize_to(builder)
        value_offset = None
        if self.value is not None:
            StartValueVector(builder, len(self.value))
            for i in reversed(range(len(self.value))):
                builder.PrependUint8(self.value[i])
            value_offset = builder.EndVector()
        
        Start(builder)
        AddFlags(builder, self.flags)
        AddKey(builder, key_offset)
        if obj_offset is not None:
            AddObj(builder, obj_offset)
        if value_offset is not None:
            AddValue(builder, value_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        flags = 0
        key = ""
        obj = ObjectId.make_default()
        value = []
        return cls(flags, key, obj, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.flags == other.flags
        eq = eq and self.key == other.key
        eq = eq and self.obj == other.obj
        self_value = self.value
        other_value = other.value
        if self_value is not None and other_value is not None:
            if len(self_value) != len(other_value):
                return False
            for i in range(len(self_value)):
                eq = eq and self_value[i] == other_value[i]
        elif self_value is not None and other_value is None:
            return False
        elif self_value is None and other_value is not None:
            return False

        return eq

@dataclass
class Edge:
    from_: "int"

    to: "int"

    @classmethod
    def from_fbs(cls, o: FbsEdge) -> Self:
        from_ = o.From_()
        to = o.To()
        return cls(from_, to)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsEdge.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Edge import (
            Start,
            AddFrom_,
            AddTo,
            End,
        )
        
        Start(builder)
        AddFrom_(builder, self.from_)
        AddTo(builder, self.to)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        from_ = 0
        to = 0
        return cls(from_, to)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.from_ == other.from_
        eq = eq and self.to == other.to

        return eq

@dataclass
class Job:
    error_tys: Optional["List[TaskErrorTy]"]

    # Parameters verbatim from the RunSpec
    params: "List[TaskParameter]"

    # Is the job complete?
    status: "Status"

    # A list of all the tasks that constitute this job.
    tasks: "List[Task]"

    # User ID who created this job.
    user_id: "ObjectId"

    @classmethod
    def from_fbs(cls, o: FbsJob) -> Self:
        error_tys = list()
        if not o.ErrorTysIsNone():
            for i in range(o.ErrorTysLength()):
                error_tys.append(o.ErrorTys(i))
        params = list()
        if not o.ParamsIsNone():
            for i in range(o.ParamsLength()):
                params_val = None
                params_obj = o.Params(i)
                if params_obj is not None:
                    params_val = TaskParameter.from_fbs(params_obj)
                params.append(params_val)
        status = Status(o.Status())
        tasks = list()
        if not o.TasksIsNone():
            for i in range(o.TasksLength()):
                tasks_val = None
                tasks_obj = o.Tasks(i)
                if tasks_obj is not None:
                    tasks_val = Task.from_fbs(tasks_obj)
                tasks.append(tasks_val)
        user_id_obj = o.UserId()
        if user_id_obj is not None:
            user_id = ObjectId.from_fbs(user_id_obj)
        else:
            raise ValueError("UserId is required")
        return cls(error_tys, params, status, tasks, user_id)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsJob.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Job import (
            Start,
            AddErrorTys,
            StartErrorTysVector,
            AddParams,
            StartParamsVector,
            AddStatus,
            AddTasks,
            StartTasksVector,
            AddUserId,
            End,
        )
        error_tys_offset = None
        if self.error_tys is not None:
            StartErrorTysVector(builder, len(self.error_tys))
            for i in reversed(range(len(self.error_tys))):
                builder.PrependInt32(self.error_tys[i])
            error_tys_offset = builder.EndVector()
        params_offsets = list()
        for value in self.params:
            params_offsets.append(value.serialize_to(builder))
        StartParamsVector(builder, len(self.params))
        for i in reversed(range(len(self.params))):
            builder.PrependUOffsetTRelative(params_offsets[i])
        params_offset = builder.EndVector()
        tasks_offsets = list()
        for value in self.tasks:
            tasks_offsets.append(value.serialize_to(builder))
        StartTasksVector(builder, len(self.tasks))
        for i in reversed(range(len(self.tasks))):
            builder.PrependUOffsetTRelative(tasks_offsets[i])
        tasks_offset = builder.EndVector()
        user_id_offset = self.user_id.serialize_to(builder)
        
        Start(builder)
        if error_tys_offset is not None:
            AddErrorTys(builder, error_tys_offset)
        AddParams(builder, params_offset)
        AddStatus(builder, self.status.value)
        AddTasks(builder, tasks_offset)
        AddUserId(builder, user_id_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        error_tys = []
        params = []
        status = Status(0)
        tasks = []
        user_id = ObjectId.make_default()
        return cls(error_tys, params, status, tasks, user_id)

    def __eq__(self, other) -> bool:
        eq = True
        self_error_tys = self.error_tys
        other_error_tys = other.error_tys
        if self_error_tys is not None and other_error_tys is not None:
            if len(self_error_tys) != len(other_error_tys):
                return False
            for i in range(len(self_error_tys)):
                eq = eq and self_error_tys[i] == other_error_tys[i]
        elif self_error_tys is not None and other_error_tys is None:
            return False
        elif self_error_tys is None and other_error_tys is not None:
            return False
        if len(self.params) != len(other.params):
            return False
        for i in range(len(self.params)):
            eq = eq and self.params[i] == other.params[i]
        eq = eq and self.status == other.status
        if len(self.tasks) != len(other.tasks):
            return False
        for i in range(len(self.tasks)):
            eq = eq and self.tasks[i] == other.tasks[i]
        eq = eq and self.user_id == other.user_id

        return eq

@dataclass
class Node:
    name: "str"

    obj: "ObjectId"

    @classmethod
    def from_fbs(cls, o: FbsNode) -> Self:
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        obj_obj = o.Obj()
        if obj_obj is not None:
            obj = ObjectId.from_fbs(obj_obj)
        else:
            raise ValueError("Obj is required")
        return cls(name, obj)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNode.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Node import (
            Start,
            AddName,
            AddObj,
            End,
        )
        name_offset = builder.CreateString(self.name)
        obj_offset = self.obj.serialize_to(builder)
        
        Start(builder)
        AddName(builder, name_offset)
        AddObj(builder, obj_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        name = ""
        obj = ObjectId.make_default()
        return cls(name, obj)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.name == other.name
        eq = eq and self.obj == other.obj

        return eq

@dataclass
class ParamIndices:
    idxs: "List[int]"

    @classmethod
    def from_fbs(cls, o: FbsParamIndices) -> Self:
        idxs = list()
        if not o.IdxsIsNone():
            for i in range(o.IdxsLength()):
                idxs.append(o.Idxs(i))
        return cls(idxs)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsParamIndices.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ParamIndices import (
            Start,
            AddIdxs,
            StartIdxsVector,
            End,
        )
        StartIdxsVector(builder, len(self.idxs))
        for i in reversed(range(len(self.idxs))):
            builder.PrependInt32(self.idxs[i])
        idxs_offset = builder.EndVector()
        
        Start(builder)
        AddIdxs(builder, idxs_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        idxs = []
        return cls(idxs)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.idxs) != len(other.idxs):
            return False
        for i in range(len(self.idxs)):
            eq = eq and self.idxs[i] == other.idxs[i]

        return eq

@dataclass
class RunSpec:
    """ A RunSpec is the data required in order to kickstart a schematic job.
     It includes the ID of the schematic to run along with the parameters.
     The param_indices list must be *exactly* as long as the nodes list in
     the Schematic. Each entry in the param_indices list is itself a list
     that points to all the parameters in the params array. This lets
     us reuse the task parameters across nodes (ie: if we want a shared
     start_date / end_date to be used in a number of calculations)
    """

    notify: "bool"

    param_indices: "List[ParamIndices]"

    params: "List[TaskParameter]"

    persist: "bool"

    priority: "TaskPriority"

    schematic: "ObjectId"

    @classmethod
    def from_fbs(cls, o: FbsRunSpec) -> Self:
        notify = o.Notify()
        param_indices = list()
        if not o.ParamIndicesIsNone():
            for i in range(o.ParamIndicesLength()):
                param_indices_val = None
                param_indices_obj = o.ParamIndices(i)
                if param_indices_obj is not None:
                    param_indices_val = ParamIndices.from_fbs(param_indices_obj)
                param_indices.append(param_indices_val)
        params = list()
        if not o.ParamsIsNone():
            for i in range(o.ParamsLength()):
                params_val = None
                params_obj = o.Params(i)
                if params_obj is not None:
                    params_val = TaskParameter.from_fbs(params_obj)
                params.append(params_val)
        persist = o.Persist()
        priority = TaskPriority(o.Priority())
        schematic_obj = o.Schematic()
        if schematic_obj is not None:
            schematic = ObjectId.from_fbs(schematic_obj)
        else:
            raise ValueError("Schematic is required")
        return cls(notify, param_indices, params, persist, priority, schematic)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRunSpec.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RunSpec import (
            Start,
            AddNotify,
            AddParamIndices,
            StartParamIndicesVector,
            AddParams,
            StartParamsVector,
            AddPersist,
            AddPriority,
            AddSchematic,
            End,
        )
        param_indices_offsets = list()
        for value in self.param_indices:
            param_indices_offsets.append(value.serialize_to(builder))
        StartParamIndicesVector(builder, len(self.param_indices))
        for i in reversed(range(len(self.param_indices))):
            builder.PrependUOffsetTRelative(param_indices_offsets[i])
        param_indices_offset = builder.EndVector()
        params_offsets = list()
        for value in self.params:
            params_offsets.append(value.serialize_to(builder))
        StartParamsVector(builder, len(self.params))
        for i in reversed(range(len(self.params))):
            builder.PrependUOffsetTRelative(params_offsets[i])
        params_offset = builder.EndVector()
        schematic_offset = self.schematic.serialize_to(builder)
        
        Start(builder)
        AddNotify(builder, self.notify)
        AddParamIndices(builder, param_indices_offset)
        AddParams(builder, params_offset)
        AddPersist(builder, self.persist)
        AddPriority(builder, self.priority.value)
        AddSchematic(builder, schematic_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        notify = False
        param_indices = []
        params = []
        persist = False
        priority = TaskPriority(-256)
        schematic = ObjectId.make_default()
        return cls(notify, param_indices, params, persist, priority, schematic)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.notify == other.notify
        if len(self.param_indices) != len(other.param_indices):
            return False
        for i in range(len(self.param_indices)):
            eq = eq and self.param_indices[i] == other.param_indices[i]
        if len(self.params) != len(other.params):
            return False
        for i in range(len(self.params)):
            eq = eq and self.params[i] == other.params[i]
        eq = eq and self.persist == other.persist
        eq = eq and self.priority == other.priority
        eq = eq and self.schematic == other.schematic

        return eq

@dataclass
class Schematic:
    attributes: "List[AttributePair]"

    edges: "List[Edge]"

    name: Optional["str"]

    nodes: "List[Node]"

    @classmethod
    def from_fbs(cls, o: FbsSchematic) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = AttributePair.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        edges = list()
        if not o.EdgesIsNone():
            for i in range(o.EdgesLength()):
                edges_val = None
                edges_obj = o.Edges(i)
                if edges_obj is not None:
                    edges_val = Edge.from_fbs(edges_obj)
                edges.append(edges_val)
        name = None
        name_str = o.Name()
        if name_str is not None:
            name = name_str.decode('utf-8')
        nodes = list()
        if not o.NodesIsNone():
            for i in range(o.NodesLength()):
                nodes_val = None
                nodes_obj = o.Nodes(i)
                if nodes_obj is not None:
                    nodes_val = Node.from_fbs(nodes_obj)
                nodes.append(nodes_val)
        return cls(attributes, edges, name, nodes)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsSchematic.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Schematic import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddEdges,
            StartEdgesVector,
            AddName,
            AddNodes,
            StartNodesVector,
            End,
        )
        attributes_offsets = list()
        for value in self.attributes:
            attributes_offsets.append(value.serialize_to(builder))
        StartAttributesVector(builder, len(self.attributes))
        for i in reversed(range(len(self.attributes))):
            builder.PrependUOffsetTRelative(attributes_offsets[i])
        attributes_offset = builder.EndVector()
        edges_offsets = list()
        for value in self.edges:
            edges_offsets.append(value.serialize_to(builder))
        StartEdgesVector(builder, len(self.edges))
        for i in reversed(range(len(self.edges))):
            builder.PrependUOffsetTRelative(edges_offsets[i])
        edges_offset = builder.EndVector()
        name_offset = None
        if self.name is not None:
            name_offset = builder.CreateString(self.name)
        nodes_offsets = list()
        for value in self.nodes:
            nodes_offsets.append(value.serialize_to(builder))
        StartNodesVector(builder, len(self.nodes))
        for i in reversed(range(len(self.nodes))):
            builder.PrependUOffsetTRelative(nodes_offsets[i])
        nodes_offset = builder.EndVector()
        
        Start(builder)
        AddAttributes(builder, attributes_offset)
        AddEdges(builder, edges_offset)
        if name_offset is not None:
            AddName(builder, name_offset)
        AddNodes(builder, nodes_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        edges = []
        name = ""
        nodes = []
        return cls(attributes, edges, name, nodes)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.attributes) != len(other.attributes):
            return False
        for i in range(len(self.attributes)):
            eq = eq and self.attributes[i] == other.attributes[i]
        if len(self.edges) != len(other.edges):
            return False
        for i in range(len(self.edges)):
            eq = eq and self.edges[i] == other.edges[i]
        eq = eq and self.name == other.name
        if len(self.nodes) != len(other.nodes):
            return False
        for i in range(len(self.nodes)):
            eq = eq and self.nodes[i] == other.nodes[i]

        return eq

@dataclass
class Task:
    _id: "ObjectId"

    barrier_count: "int"

    # Task creation time, in ms-since-Unix-epoch UTC.
    created: "int"

    # If false, keep this object if it's a temporary/intermediate after job
    # creation. This must not be set if the output object above is a provided
    # stream.
    discard: "bool"

    # The downstream nodes to enable once this task is complete
    downstream: "List[ObjectId]"

    end: "int"

    error_ty: "TaskErrorTy"

    flags: "int"

    # Associated Job ID
    job_id: "ObjectId"

    # Task last poll time, in ms-since-Unix-epoch UTC.
    last_updated: "int"

    last_updated_by_pod: Optional["str"]

    # For errors, generic information.
    message: Optional["str"]

    name: "str"

    # The output of this step. If the task is computational (ie: not just a
    # data stream lookup) this is a blank object where the results will be
    # written. If it is a lookup of an existing stream, this will be populated
    # with the stream ID
    output: "ObjectId"

    # Parameter indices taken from the RunSpec for this particular task step.
    params: "ParamIndices"

    retries: "int"

    schematic_id: Optional["ObjectId"]

    # Task start time, in ms-since-Unix-epoch UTC.
    start: "int"

    # Task status
    status: "Status"

    # Task object, either a source or a stream
    task: "ObjectId"

    # The upstream nodes that enabled this task
    upstream: "List[ObjectId]"

    # User who created the job. This is the same as the user_id field in the
    # job structure but duplicated for convenience when looking up task related
    # information.
    user_id: "ObjectId"

    @classmethod
    def from_fbs(cls, o: FbsTask) -> Self:
        _id_obj = o._Id()
        if _id_obj is not None:
            _id = ObjectId.from_fbs(_id_obj)
        else:
            raise ValueError("_Id is required")
        barrier_count = o.BarrierCount()
        created = o.Created()
        discard = o.Discard()
        downstream = list()
        if not o.DownstreamIsNone():
            for i in range(o.DownstreamLength()):
                downstream_val = None
                downstream_obj = o.Downstream(i)
                if downstream_obj is not None:
                    downstream_val = ObjectId.from_fbs(downstream_obj)
                downstream.append(downstream_val)
        end = o.End()
        error_ty = TaskErrorTy(o.ErrorTy())
        flags = o.Flags()
        job_id_obj = o.JobId()
        if job_id_obj is not None:
            job_id = ObjectId.from_fbs(job_id_obj)
        else:
            raise ValueError("JobId is required")
        last_updated = o.LastUpdated()
        last_updated_by_pod = None
        last_updated_by_pod_str = o.LastUpdatedByPod()
        if last_updated_by_pod_str is not None:
            last_updated_by_pod = last_updated_by_pod_str.decode('utf-8')
        message = None
        message_str = o.Message()
        if message_str is not None:
            message = message_str.decode('utf-8')
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        output_obj = o.Output()
        if output_obj is not None:
            output = ObjectId.from_fbs(output_obj)
        else:
            raise ValueError("Output is required")
        params_obj = o.Params()
        if params_obj is not None:
            params = ParamIndices.from_fbs(params_obj)
        else:
            raise ValueError("Params is required")
        retries = o.Retries()
        schematic_id = None
        schematic_id_obj = o.SchematicId()
        if schematic_id_obj is not None:
            schematic_id = ObjectId.from_fbs(schematic_id_obj)
        start = o.Start()
        status = Status(o.Status())
        task_obj = o.Task()
        if task_obj is not None:
            task = ObjectId.from_fbs(task_obj)
        else:
            raise ValueError("Task is required")
        upstream = list()
        if not o.UpstreamIsNone():
            for i in range(o.UpstreamLength()):
                upstream_val = None
                upstream_obj = o.Upstream(i)
                if upstream_obj is not None:
                    upstream_val = ObjectId.from_fbs(upstream_obj)
                upstream.append(upstream_val)
        user_id_obj = o.UserId()
        if user_id_obj is not None:
            user_id = ObjectId.from_fbs(user_id_obj)
        else:
            raise ValueError("UserId is required")
        return cls(_id, barrier_count, created, discard, downstream, end, error_ty, flags, job_id, last_updated, last_updated_by_pod, message, name, output, params, retries, schematic_id, start, status, task, upstream, user_id)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTask.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Task import (
            Start,
            Add_Id,
            AddBarrierCount,
            AddCreated,
            AddDiscard,
            AddDownstream,
            StartDownstreamVector,
            AddEnd,
            AddErrorTy,
            AddFlags,
            AddJobId,
            AddLastUpdated,
            AddLastUpdatedByPod,
            AddMessage,
            AddName,
            AddOutput,
            AddParams,
            AddRetries,
            AddSchematicId,
            AddStart,
            AddStatus,
            AddTask,
            AddUpstream,
            StartUpstreamVector,
            AddUserId,
            End,
        )
        _id_offset = self._id.serialize_to(builder)
        downstream_offsets = list()
        for value in self.downstream:
            downstream_offsets.append(value.serialize_to(builder))
        StartDownstreamVector(builder, len(self.downstream))
        for i in reversed(range(len(self.downstream))):
            builder.PrependUOffsetTRelative(downstream_offsets[i])
        downstream_offset = builder.EndVector()
        job_id_offset = self.job_id.serialize_to(builder)
        last_updated_by_pod_offset = None
        if self.last_updated_by_pod is not None:
            last_updated_by_pod_offset = builder.CreateString(self.last_updated_by_pod)
        message_offset = None
        if self.message is not None:
            message_offset = builder.CreateString(self.message)
        name_offset = builder.CreateString(self.name)
        output_offset = self.output.serialize_to(builder)
        params_offset = self.params.serialize_to(builder)
        schematic_id_offset = None
        if self.schematic_id is not None:
            schematic_id_offset = self.schematic_id.serialize_to(builder)
        task_offset = self.task.serialize_to(builder)
        upstream_offsets = list()
        for value in self.upstream:
            upstream_offsets.append(value.serialize_to(builder))
        StartUpstreamVector(builder, len(self.upstream))
        for i in reversed(range(len(self.upstream))):
            builder.PrependUOffsetTRelative(upstream_offsets[i])
        upstream_offset = builder.EndVector()
        user_id_offset = self.user_id.serialize_to(builder)
        
        Start(builder)
        Add_Id(builder, _id_offset)
        AddBarrierCount(builder, self.barrier_count)
        AddCreated(builder, self.created)
        AddDiscard(builder, self.discard)
        AddDownstream(builder, downstream_offset)
        AddEnd(builder, self.end)
        AddErrorTy(builder, self.error_ty.value)
        AddFlags(builder, self.flags)
        AddJobId(builder, job_id_offset)
        AddLastUpdated(builder, self.last_updated)
        if last_updated_by_pod_offset is not None:
            AddLastUpdatedByPod(builder, last_updated_by_pod_offset)
        if message_offset is not None:
            AddMessage(builder, message_offset)
        AddName(builder, name_offset)
        AddOutput(builder, output_offset)
        AddParams(builder, params_offset)
        AddRetries(builder, self.retries)
        if schematic_id_offset is not None:
            AddSchematicId(builder, schematic_id_offset)
        AddStart(builder, self.start)
        AddStatus(builder, self.status.value)
        AddTask(builder, task_offset)
        AddUpstream(builder, upstream_offset)
        AddUserId(builder, user_id_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        _id = ObjectId.make_default()
        barrier_count = 0
        created = 0
        discard = False
        downstream = []
        end = 0
        error_ty = TaskErrorTy(0)
        flags = 0
        job_id = ObjectId.make_default()
        last_updated = 0
        last_updated_by_pod = ""
        message = ""
        name = ""
        output = ObjectId.make_default()
        params = ParamIndices.make_default()
        retries = 0
        schematic_id = ObjectId.make_default()
        start = 0
        status = Status(0)
        task = ObjectId.make_default()
        upstream = []
        user_id = ObjectId.make_default()
        return cls(_id, barrier_count, created, discard, downstream, end, error_ty, flags, job_id, last_updated, last_updated_by_pod, message, name, output, params, retries, schematic_id, start, status, task, upstream, user_id)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self._id == other._id
        eq = eq and self.barrier_count == other.barrier_count
        eq = eq and self.created == other.created
        eq = eq and self.discard == other.discard
        if len(self.downstream) != len(other.downstream):
            return False
        for i in range(len(self.downstream)):
            eq = eq and self.downstream[i] == other.downstream[i]
        eq = eq and self.end == other.end
        eq = eq and self.error_ty == other.error_ty
        eq = eq and self.flags == other.flags
        eq = eq and self.job_id == other.job_id
        eq = eq and self.last_updated == other.last_updated
        eq = eq and self.last_updated_by_pod == other.last_updated_by_pod
        eq = eq and self.message == other.message
        eq = eq and self.name == other.name
        eq = eq and self.output == other.output
        eq = eq and self.params == other.params
        eq = eq and self.retries == other.retries
        eq = eq and self.schematic_id == other.schematic_id
        eq = eq and self.start == other.start
        eq = eq and self.status == other.status
        eq = eq and self.task == other.task
        if len(self.upstream) != len(other.upstream):
            return False
        for i in range(len(self.upstream)):
            eq = eq and self.upstream[i] == other.upstream[i]
        eq = eq and self.user_id == other.user_id

        return eq

@dataclass
class TaskList:
    tasks: "List[Task]"

    @classmethod
    def from_fbs(cls, o: FbsTaskList) -> Self:
        tasks = list()
        if not o.TasksIsNone():
            for i in range(o.TasksLength()):
                tasks_val = None
                tasks_obj = o.Tasks(i)
                if tasks_obj is not None:
                    tasks_val = Task.from_fbs(tasks_obj)
                tasks.append(tasks_val)
        return cls(tasks)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTaskList.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TaskList import (
            Start,
            AddTasks,
            StartTasksVector,
            End,
        )
        tasks_offsets = list()
        for value in self.tasks:
            tasks_offsets.append(value.serialize_to(builder))
        StartTasksVector(builder, len(self.tasks))
        for i in reversed(range(len(self.tasks))):
            builder.PrependUOffsetTRelative(tasks_offsets[i])
        tasks_offset = builder.EndVector()
        
        Start(builder)
        AddTasks(builder, tasks_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        tasks = []
        return cls(tasks)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.tasks) != len(other.tasks):
            return False
        for i in range(len(self.tasks)):
            eq = eq and self.tasks[i] == other.tasks[i]

        return eq

@dataclass
class TaskParameter:
    key: "str"

    value: "TaskParameterValue"

    @classmethod
    def from_fbs(cls, o: FbsTaskParameter) -> Self:
        key_str = o.Key()
        assert key_str is not None
        key = key_str.decode('utf-8')
        value_val = o.Value()
        if value_val is not None:
            value_ty = o.ValueType()
            value = TaskParameterValue.from_fbs(value_val, value_ty)
        else:
            raise ValueError("Value is required")
        return cls(key, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTaskParameter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TaskParameter import (
            Start,
            AddKey,
            AddValue,
            AddValueType,
            End,
        )
        key_offset = builder.CreateString(self.key)
        value_offset, value_ty = self.value.serialize_to(builder)
        
        Start(builder)
        AddKey(builder, key_offset)
        AddValue(builder, value_offset)
        AddValueType(builder, value_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        key = ""
        value = TaskParameterValue.make_default()
        return cls(key, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.key == other.key
        eq = eq and self.value == other.value

        return eq
