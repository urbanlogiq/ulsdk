# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .api import SortOrder
from .entity import (
    EdgeTy,
    EntityTy,
    Geometry,
    GraphEdge,
    GraphNode,
    Line,
    MultiLine,
    MultiPolygon,
    NodeTy,
    Point,
    Polygon,
)
from .fun import Fn
from .graph import (
    EdgeList,
    EdgeQuery,
    Geom,
    GeomOp,
    GraphQuery,
    NodeIdPair,
    NodeList,
    NodeQuery,
    OrderBy,
    Predicate,
    Projection,
    QueryPathElement,
    QueryPathElementUnion,
    ValueTransform,
)
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .value import (
    Point2D,
    Tri2D,
    VArray,
    VBool,
    VBytes,
    VChar,
    VF32,
    VF64,
    VFixedSizeBytes,
    VI16,
    VI32,
    VI64,
    VI8,
    VIsize,
    VNull,
    VStr,
    VTimestampMs,
    VTimestampMsUtc,
    VTimestampNs,
    VTimestampNsUtc,
    VTri2D,
    VU16,
    VU32,
    VU64,
    VU8,
    VUnit,
    VUsize,
    Value,
    ValueInstance,
    ValueTy,
)
from .generated.AllColumns import AllColumns as FbsAllColumns
from .generated.Arrow import Arrow as FbsArrow
from .generated.B2cId import B2cId as FbsB2cId
from .generated.BinaryQueryElement import BinaryQueryElement as FbsBinaryQueryElement
from .generated.Case import Case as FbsCase
from .generated.Column import Column as FbsColumn
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.DataCatalog import DataCatalog as FbsDataCatalog
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.DeleteQueryElement import DeleteQueryElement as FbsDeleteQueryElement
from .generated.Distinct import Distinct as FbsDistinct
from .generated.EdgeList import EdgeList as FbsEdgeList
from .generated.EdgeQuery import EdgeQuery as FbsEdgeQuery
from .generated.Expr import Expr as FbsExpr
from .generated.Function import Function as FbsFunction
from .generated.GenericId import GenericId as FbsGenericId
from .generated.Geom import Geom as FbsGeom
from .generated.GeomOp import GeomOp as FbsGeomOp
from .generated.GraphEdge import GraphEdge as FbsGraphEdge
from .generated.GraphNode import GraphNode as FbsGraphNode
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.GraphQuery import GraphQuery as FbsGraphQuery
from .generated.Join import Join as FbsJoin
from .generated.Line import Line as FbsLine
from .generated.MultiLine import MultiLine as FbsMultiLine
from .generated.MultiPolygon import MultiPolygon as FbsMultiPolygon
from .generated.MvdbSubcollection import MvdbSubcollection as FbsMvdbSubcollection
from .generated.NodeIdPair import NodeIdPair as FbsNodeIdPair
from .generated.NodeList import NodeList as FbsNodeList
from .generated.NodeQuery import NodeQuery as FbsNodeQuery
from .generated.NullableUint import NullableUint as FbsNullableUint
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.OrderBy import OrderBy as FbsOrderBy
from .generated.OrderByExpr import OrderByExpr as FbsOrderByExpr
from .generated.Parameter import Parameter as FbsParameter
from .generated.ParameterInstance import ParameterInstance as FbsParameterInstance
from .generated.ParameterizedQuery import ParameterizedQuery as FbsParameterizedQuery
from .generated.Partition import Partition as FbsPartition
from .generated.Point import Point as FbsPoint
from .generated.Point2D import Point2D as FbsPoint2D
from .generated.Polygon import Polygon as FbsPolygon
from .generated.Projection import Projection as FbsProjection
from .generated.Query import Query as FbsQuery
from .generated.QueryElement import QueryElement as FbsQueryElement
from .generated.QueryPathElement import QueryPathElement as FbsQueryPathElement
from .generated.QueryTableSource import QueryTableSource as FbsQueryTableSource
from .generated.SetExpr import SetExpr as FbsSetExpr
from .generated.StreamId import StreamId as FbsStreamId
from .generated.TableOrderBy import TableOrderBy as FbsTableOrderBy
from .generated.TableSource import TableSource as FbsTableSource
from .generated.Tri2D import Tri2D as FbsTri2D
from .generated.UnaryQueryElement import UnaryQueryElement as FbsUnaryQueryElement
from .generated.UnsetArgument import UnsetArgument as FbsUnsetArgument
from .generated.UpdateQueryElement import UpdateQueryElement as FbsUpdateQueryElement
from .generated.VArray import VArray as FbsVArray
from .generated.VBool import VBool as FbsVBool
from .generated.VBytes import VBytes as FbsVBytes
from .generated.VChar import VChar as FbsVChar
from .generated.VF32 import VF32 as FbsVF32
from .generated.VF64 import VF64 as FbsVF64
from .generated.VFixedSizeBytes import VFixedSizeBytes as FbsVFixedSizeBytes
from .generated.VI16 import VI16 as FbsVI16
from .generated.VI32 import VI32 as FbsVI32
from .generated.VI64 import VI64 as FbsVI64
from .generated.VI8 import VI8 as FbsVI8
from .generated.VIsize import VIsize as FbsVIsize
from .generated.VNull import VNull as FbsVNull
from .generated.VStr import VStr as FbsVStr
from .generated.VTimestampMs import VTimestampMs as FbsVTimestampMs
from .generated.VTimestampMsUtc import VTimestampMsUtc as FbsVTimestampMsUtc
from .generated.VTimestampNs import VTimestampNs as FbsVTimestampNs
from .generated.VTimestampNsUtc import VTimestampNsUtc as FbsVTimestampNsUtc
from .generated.VTri2D import VTri2D as FbsVTri2D
from .generated.VU16 import VU16 as FbsVU16
from .generated.VU32 import VU32 as FbsVU32
from .generated.VU64 import VU64 as FbsVU64
from .generated.VU8 import VU8 as FbsVU8
from .generated.VUnit import VUnit as FbsVUnit
from .generated.VUsize import VUsize as FbsVUsize
from .generated.ValueIndex import ValueIndex as FbsValueIndex
from .generated.ValueInstance import ValueInstance as FbsValueInstance
from .generated.Vector import Vector as FbsVector
from .generated.When import When as FbsWhen
from .generated.Window import Window as FbsWindow
from .generated.WorklogSubcollection import WorklogSubcollection as FbsWorklogSubcollection
from .generated.ExprUnion import ExprUnion as FbsExprUnion
from .generated.Geometry import Geometry as FbsGeometry
from .generated.ParameterSlot import ParameterSlot as FbsParameterSlot
from .generated.QueryElementUnion import QueryElementUnion as FbsQueryElementUnion
from .generated.QueryPathElementUnion import QueryPathElementUnion as FbsQueryPathElementUnion
from .generated.Subcollection import Subcollection as FbsSubcollection
from .generated.TableSourceUnion import TableSourceUnion as FbsTableSourceUnion
from .generated.Value import Value as FbsValue

class JoinTy(Enum):
    Inner = 0
    LeftOuter = 1
    RightOuter = 2
    Full = 3
    Cross = 4

class QueryElementOp(Enum):
    Union_ = 0
    Intersect = 1
    Except = 2

class TypeHint(Enum):
    None_ = 0
    TimestampMillis = 1
    TimestampNanos = 2
    Base64 = 3
    Uuid = 4


@dataclass
class ValueIndex:
    idx: "int"

    @classmethod
    def from_fbs(cls, o: FbsValueIndex) -> Self:
        idx = o.Idx()
        return cls(idx)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsValueIndex.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ValueIndex import (
            Start,
            AddIdx,
            End,
        )
        
        Start(builder)
        AddIdx(builder, self.idx)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        idx = 0
        return cls(idx)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.idx == other.idx

        return eq

@dataclass
class NullableUint:
    v: "int"

    @classmethod
    def from_fbs(cls, o: FbsNullableUint) -> Self:
        v = o.V()
        return cls(v)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNullableUint.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NullableUint import (
            Start,
            AddV,
            End,
        )
        
        Start(builder)
        AddV(builder, self.v)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        v = 0
        return cls(v)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.v == other.v

        return eq

@dataclass
class Column:
    name: "str"

    source: Optional["NullableUint"]

    type_hint: "TypeHint"

    @classmethod
    def from_fbs(cls, o: FbsColumn) -> Self:
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        source = None
        source_obj = o.Source()
        if source_obj is not None:
            source = NullableUint.from_fbs(source_obj)
        type_hint = TypeHint(o.TypeHint())
        return cls(name, source, type_hint)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsColumn.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Column import (
            Start,
            AddName,
            AddSource,
            AddTypeHint,
            End,
        )
        name_offset = builder.CreateString(self.name)
        source_offset = None
        if self.source is not None:
            source_offset = self.source.serialize_to(builder)
        
        Start(builder)
        AddName(builder, name_offset)
        if source_offset is not None:
            AddSource(builder, source_offset)
        AddTypeHint(builder, self.type_hint.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        name = ""
        source = NullableUint.make_default()
        type_hint = TypeHint(0)
        return cls(name, source, type_hint)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.name == other.name
        eq = eq and self.source == other.source
        eq = eq and self.type_hint == other.type_hint

        return eq

@dataclass
class Function:
    fn: "Fn"

    parameters: "List[Expr]"

    @classmethod
    def from_fbs(cls, o: FbsFunction) -> Self:
        fn = Fn(o.Fn())
        parameters = list()
        if not o.ParametersIsNone():
            for i in range(o.ParametersLength()):
                parameters_val = None
                parameters_obj = o.Parameters(i)
                if parameters_obj is not None:
                    parameters_val = Expr.from_fbs(parameters_obj)
                parameters.append(parameters_val)
        return cls(fn, parameters)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsFunction.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Function import (
            Start,
            AddFn,
            AddParameters,
            StartParametersVector,
            End,
        )
        parameters_offsets = list()
        for value in self.parameters:
            parameters_offsets.append(value.serialize_to(builder))
        StartParametersVector(builder, len(self.parameters))
        for i in reversed(range(len(self.parameters))):
            builder.PrependUOffsetTRelative(parameters_offsets[i])
        parameters_offset = builder.EndVector()
        
        Start(builder)
        AddFn(builder, self.fn.value)
        AddParameters(builder, parameters_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        fn = Fn(0)
        parameters = []
        return cls(fn, parameters)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.fn == other.fn
        if len(self.parameters) != len(other.parameters):
            return False
        for i in range(len(self.parameters)):
            eq = eq and self.parameters[i] == other.parameters[i]

        return eq

@dataclass
class AllColumns:
    source: Optional["NullableUint"]

    @classmethod
    def from_fbs(cls, o: FbsAllColumns) -> Self:
        source = None
        source_obj = o.Source()
        if source_obj is not None:
            source = NullableUint.from_fbs(source_obj)
        return cls(source)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsAllColumns.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.AllColumns import (
            Start,
            AddSource,
            End,
        )
        source_offset = None
        if self.source is not None:
            source_offset = self.source.serialize_to(builder)
        
        Start(builder)
        if source_offset is not None:
            AddSource(builder, source_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        source = NullableUint.make_default()
        return cls(source)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.source == other.source

        return eq

@dataclass
class Expr:
    exprs: "ExprUnion"

    @classmethod
    def from_fbs(cls, o: FbsExpr) -> Self:
        exprs_val = o.Exprs()
        if exprs_val is not None:
            exprs_ty = o.ExprsType()
            exprs = ExprUnion.from_fbs(exprs_val, exprs_ty)
        else:
            raise ValueError("Exprs is required")
        return cls(exprs)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsExpr.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Expr import (
            Start,
            AddExprs,
            AddExprsType,
            End,
        )
        exprs_offset, exprs_ty = self.exprs.serialize_to(builder)
        
        Start(builder)
        AddExprs(builder, exprs_offset)
        AddExprsType(builder, exprs_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        exprs = ExprUnion.make_default()
        return cls(exprs)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.exprs == other.exprs

        return eq

@dataclass
class Case:
    else_: Optional["Expr"]

    when: "List[When]"

    @classmethod
    def from_fbs(cls, o: FbsCase) -> Self:
        else_ = None
        else__obj = o.Else_()
        if else__obj is not None:
            else_ = Expr.from_fbs(else__obj)
        when = list()
        if not o.WhenIsNone():
            for i in range(o.WhenLength()):
                when_val = None
                when_obj = o.When(i)
                if when_obj is not None:
                    when_val = When.from_fbs(when_obj)
                when.append(when_val)
        return cls(else_, when)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsCase.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Case import (
            Start,
            AddElse_,
            AddWhen,
            StartWhenVector,
            End,
        )
        else__offset = None
        if self.else_ is not None:
            else__offset = self.else_.serialize_to(builder)
        when_offsets = list()
        for value in self.when:
            when_offsets.append(value.serialize_to(builder))
        StartWhenVector(builder, len(self.when))
        for i in reversed(range(len(self.when))):
            builder.PrependUOffsetTRelative(when_offsets[i])
        when_offset = builder.EndVector()
        
        Start(builder)
        if else__offset is not None:
            AddElse_(builder, else__offset)
        AddWhen(builder, when_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        else_ = Expr.make_default()
        when = []
        return cls(else_, when)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.else_ == other.else_
        if len(self.when) != len(other.when):
            return False
        for i in range(len(self.when)):
            eq = eq and self.when[i] == other.when[i]

        return eq

@dataclass
class OrderByExpr:
    order_by: "List[OrderBy]"

    @classmethod
    def from_fbs(cls, o: FbsOrderByExpr) -> Self:
        order_by = list()
        if not o.OrderByIsNone():
            for i in range(o.OrderByLength()):
                order_by_val = None
                order_by_obj = o.OrderBy(i)
                if order_by_obj is not None:
                    order_by_val = OrderBy.from_fbs(order_by_obj)
                order_by.append(order_by_val)
        return cls(order_by)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsOrderByExpr.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.OrderByExpr import (
            Start,
            AddOrderBy,
            StartOrderByVector,
            End,
        )
        order_by_offsets = list()
        for value in self.order_by:
            order_by_offsets.append(value.serialize_to(builder))
        StartOrderByVector(builder, len(self.order_by))
        for i in reversed(range(len(self.order_by))):
            builder.PrependUOffsetTRelative(order_by_offsets[i])
        order_by_offset = builder.EndVector()
        
        Start(builder)
        AddOrderBy(builder, order_by_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        order_by = []
        return cls(order_by)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.order_by) != len(other.order_by):
            return False
        for i in range(len(self.order_by)):
            eq = eq and self.order_by[i] == other.order_by[i]

        return eq

@dataclass
class Partition:
    expr: "Expr"

    @classmethod
    def from_fbs(cls, o: FbsPartition) -> Self:
        expr_obj = o.Expr()
        if expr_obj is not None:
            expr = Expr.from_fbs(expr_obj)
        else:
            raise ValueError("Expr is required")
        return cls(expr)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsPartition.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Partition import (
            Start,
            AddExpr,
            End,
        )
        expr_offset = self.expr.serialize_to(builder)
        
        Start(builder)
        AddExpr(builder, expr_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        expr = Expr.make_default()
        return cls(expr)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.expr == other.expr

        return eq

@dataclass
class UnsetArgument:
    @classmethod
    def from_fbs(cls, o: FbsUnsetArgument) -> Self:
        return cls()

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUnsetArgument.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UnsetArgument import (
            Start,
            End,
        )
        
        Start(builder)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        return cls()

    def __eq__(self, other) -> bool:
        eq = True

        return eq

@dataclass
class Window:
    fun: "Function"

    order_by: Optional["List[OrderBy]"]

    partition: Optional["List[Expr]"]

    @classmethod
    def from_fbs(cls, o: FbsWindow) -> Self:
        fun_obj = o.Fun()
        if fun_obj is not None:
            fun = Function.from_fbs(fun_obj)
        else:
            raise ValueError("Fun is required")
        order_by = list()
        if not o.OrderByIsNone():
            for i in range(o.OrderByLength()):
                order_by_val = None
                order_by_obj = o.OrderBy(i)
                if order_by_obj is not None:
                    order_by_val = OrderBy.from_fbs(order_by_obj)
                order_by.append(order_by_val)
        partition = list()
        if not o.PartitionIsNone():
            for i in range(o.PartitionLength()):
                partition_val = None
                partition_obj = o.Partition(i)
                if partition_obj is not None:
                    partition_val = Expr.from_fbs(partition_obj)
                partition.append(partition_val)
        return cls(fun, order_by, partition)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsWindow.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Window import (
            Start,
            AddFun,
            AddOrderBy,
            StartOrderByVector,
            AddPartition,
            StartPartitionVector,
            End,
        )
        fun_offset = self.fun.serialize_to(builder)
        order_by_offset = None
        if self.order_by is not None:
            order_by_offsets = list()
            for value in self.order_by:
                order_by_offsets.append(value.serialize_to(builder))
            StartOrderByVector(builder, len(self.order_by))
            for i in reversed(range(len(self.order_by))):
                builder.PrependUOffsetTRelative(order_by_offsets[i])
            order_by_offset = builder.EndVector()
        partition_offset = None
        if self.partition is not None:
            partition_offsets = list()
            for value in self.partition:
                partition_offsets.append(value.serialize_to(builder))
            StartPartitionVector(builder, len(self.partition))
            for i in reversed(range(len(self.partition))):
                builder.PrependUOffsetTRelative(partition_offsets[i])
            partition_offset = builder.EndVector()
        
        Start(builder)
        AddFun(builder, fun_offset)
        if order_by_offset is not None:
            AddOrderBy(builder, order_by_offset)
        if partition_offset is not None:
            AddPartition(builder, partition_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        fun = Function.make_default()
        order_by = []
        partition = []
        return cls(fun, order_by, partition)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.fun == other.fun
        self_order_by = self.order_by
        other_order_by = other.order_by
        if self_order_by is not None and other_order_by is not None:
            if len(self_order_by) != len(other_order_by):
                return False
            for i in range(len(self_order_by)):
                eq = eq and self_order_by[i] == other_order_by[i]
        elif self_order_by is not None and other_order_by is None:
            return False
        elif self_order_by is None and other_order_by is not None:
            return False
        self_partition = self.partition
        other_partition = other.partition
        if self_partition is not None and other_partition is not None:
            if len(self_partition) != len(other_partition):
                return False
            for i in range(len(self_partition)):
                eq = eq and self_partition[i] == other_partition[i]
        elif self_partition is not None and other_partition is None:
            return False
        elif self_partition is None and other_partition is not None:
            return False

        return eq

@dataclass
class ExprUnion:
    value: Union[
        "ValueIndex",
        "Column",
        "Function",
        "AllColumns",
        "Case",
        "OrderByExpr",
        "Partition",
        "UnsetArgument",
        "Window",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.ExprUnion import ExprUnion
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, ValueIndex):
            return (offset, ExprUnion().ValueIndex)
        elif isinstance(self.value, Column):
            return (offset, ExprUnion().Column)
        elif isinstance(self.value, Function):
            return (offset, ExprUnion().Function)
        elif isinstance(self.value, AllColumns):
            return (offset, ExprUnion().AllColumns)
        elif isinstance(self.value, Case):
            return (offset, ExprUnion().Case)
        elif isinstance(self.value, OrderByExpr):
            return (offset, ExprUnion().OrderByExpr)
        elif isinstance(self.value, Partition):
            return (offset, ExprUnion().Partition)
        elif isinstance(self.value, UnsetArgument):
            return (offset, ExprUnion().UnsetArgument)
        elif isinstance(self.value, Window):
            return (offset, ExprUnion().Window)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        ExprUnion_ty_instance = FbsExprUnion()
        if ty == ExprUnion_ty_instance.ValueIndex:
            val = FbsValueIndex();
            val.Init(source, pos)
            return cls(ValueIndex.from_fbs(val))
        elif ty == ExprUnion_ty_instance.Column:
            val = FbsColumn();
            val.Init(source, pos)
            return cls(Column.from_fbs(val))
        elif ty == ExprUnion_ty_instance.Function:
            val = FbsFunction();
            val.Init(source, pos)
            return cls(Function.from_fbs(val))
        elif ty == ExprUnion_ty_instance.AllColumns:
            val = FbsAllColumns();
            val.Init(source, pos)
            return cls(AllColumns.from_fbs(val))
        elif ty == ExprUnion_ty_instance.Case:
            val = FbsCase();
            val.Init(source, pos)
            return cls(Case.from_fbs(val))
        elif ty == ExprUnion_ty_instance.OrderByExpr:
            val = FbsOrderByExpr();
            val.Init(source, pos)
            return cls(OrderByExpr.from_fbs(val))
        elif ty == ExprUnion_ty_instance.Partition:
            val = FbsPartition();
            val.Init(source, pos)
            return cls(Partition.from_fbs(val))
        elif ty == ExprUnion_ty_instance.UnsetArgument:
            val = FbsUnsetArgument();
            val.Init(source, pos)
            return cls(UnsetArgument.from_fbs(val))
        elif ty == ExprUnion_ty_instance.Window:
            val = FbsWindow();
            val.Init(source, pos)
            return cls(Window.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(ValueIndex.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class Parameter:
    hint: "TypeHint"

    name: "str"

    ty: "ValueTy"

    @classmethod
    def from_fbs(cls, o: FbsParameter) -> Self:
        hint = TypeHint(o.Hint())
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        ty = ValueTy(o.Ty())
        return cls(hint, name, ty)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsParameter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Parameter import (
            Start,
            AddHint,
            AddName,
            AddTy,
            End,
        )
        name_offset = builder.CreateString(self.name)
        
        Start(builder)
        AddHint(builder, self.hint.value)
        AddName(builder, name_offset)
        AddTy(builder, self.ty.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        hint = TypeHint(0)
        name = ""
        ty = ValueTy(0)
        return cls(hint, name, ty)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.hint == other.hint
        eq = eq and self.name == other.name
        eq = eq and self.ty == other.ty

        return eq

@dataclass
class ParameterSlot:
    value: Union[
        "Parameter",
        "ValueInstance",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.ParameterSlot import ParameterSlot
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, Parameter):
            return (offset, ParameterSlot().Parameter)
        elif isinstance(self.value, ValueInstance):
            return (offset, ParameterSlot().ValueInstance)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        ParameterSlot_ty_instance = FbsParameterSlot()
        if ty == ParameterSlot_ty_instance.Parameter:
            val = FbsParameter();
            val.Init(source, pos)
            return cls(Parameter.from_fbs(val))
        elif ty == ParameterSlot_ty_instance.ValueInstance:
            val = FbsValueInstance();
            val.Init(source, pos)
            return cls(ValueInstance.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(Parameter.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class Distinct:
    """ The Distinct function defined in fun.fbs is for use in cases like:
     SELECT COUNT(DISTINCT c0), SUM(c1) FROM t GROUP BY c2;
     The `distinct` field here on the query element is to be used to remove duplicate rows, like:
     SELECT DISTINCT * FROM t;
     or
     SELECT DISTINCT ON (c0, c1) FROM t;
    """

    # If `on` is unset or has length 0, then the distinct is:
    # SELECT DISTINCT * FROM t;
    # If `on` has length > 0, then distinct is:
    # SELECT DISTINCT ON (c0, c1) FROM t;
    on: Optional["List[Expr]"]

    @classmethod
    def from_fbs(cls, o: FbsDistinct) -> Self:
        on = list()
        if not o.OnIsNone():
            for i in range(o.OnLength()):
                on_val = None
                on_obj = o.On(i)
                if on_obj is not None:
                    on_val = Expr.from_fbs(on_obj)
                on.append(on_val)
        return cls(on)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDistinct.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Distinct import (
            Start,
            AddOn,
            StartOnVector,
            End,
        )
        on_offset = None
        if self.on is not None:
            on_offsets = list()
            for value in self.on:
                on_offsets.append(value.serialize_to(builder))
            StartOnVector(builder, len(self.on))
            for i in reversed(range(len(self.on))):
                builder.PrependUOffsetTRelative(on_offsets[i])
            on_offset = builder.EndVector()
        
        Start(builder)
        if on_offset is not None:
            AddOn(builder, on_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        on = []
        return cls(on)

    def __eq__(self, other) -> bool:
        eq = True
        self_on = self.on
        other_on = other.on
        if self_on is not None and other_on is not None:
            if len(self_on) != len(other_on):
                return False
            for i in range(len(self_on)):
                eq = eq and self_on[i] == other_on[i]
        elif self_on is not None and other_on is None:
            return False
        elif self_on is None and other_on is not None:
            return False

        return eq

@dataclass
class UnaryQueryElement:
    distinct: Optional["Distinct"]

    fields: Optional["List[Expr]"]

    filter: Optional["Function"]

    group_by: Optional["List[Expr]"]

    joins: Optional["List[Join]"]

    limit: "int"

    order_by: Optional["List[TableOrderBy]"]

    sources: "List[TableSource]"

    @classmethod
    def from_fbs(cls, o: FbsUnaryQueryElement) -> Self:
        distinct = None
        distinct_obj = o.Distinct()
        if distinct_obj is not None:
            distinct = Distinct.from_fbs(distinct_obj)
        fields = list()
        if not o.FieldsIsNone():
            for i in range(o.FieldsLength()):
                fields_val = None
                fields_obj = o.Fields(i)
                if fields_obj is not None:
                    fields_val = Expr.from_fbs(fields_obj)
                fields.append(fields_val)
        filter = None
        filter_obj = o.Filter()
        if filter_obj is not None:
            filter = Function.from_fbs(filter_obj)
        group_by = list()
        if not o.GroupByIsNone():
            for i in range(o.GroupByLength()):
                group_by_val = None
                group_by_obj = o.GroupBy(i)
                if group_by_obj is not None:
                    group_by_val = Expr.from_fbs(group_by_obj)
                group_by.append(group_by_val)
        joins = list()
        if not o.JoinsIsNone():
            for i in range(o.JoinsLength()):
                joins_val = None
                joins_obj = o.Joins(i)
                if joins_obj is not None:
                    joins_val = Join.from_fbs(joins_obj)
                joins.append(joins_val)
        limit = o.Limit()
        order_by = list()
        if not o.OrderByIsNone():
            for i in range(o.OrderByLength()):
                order_by_val = None
                order_by_obj = o.OrderBy(i)
                if order_by_obj is not None:
                    order_by_val = TableOrderBy.from_fbs(order_by_obj)
                order_by.append(order_by_val)
        sources = list()
        if not o.SourcesIsNone():
            for i in range(o.SourcesLength()):
                sources_val = None
                sources_obj = o.Sources(i)
                if sources_obj is not None:
                    sources_val = TableSource.from_fbs(sources_obj)
                sources.append(sources_val)
        return cls(distinct, fields, filter, group_by, joins, limit, order_by, sources)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUnaryQueryElement.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UnaryQueryElement import (
            Start,
            AddDistinct,
            AddFields,
            StartFieldsVector,
            AddFilter,
            AddGroupBy,
            StartGroupByVector,
            AddJoins,
            StartJoinsVector,
            AddLimit,
            AddOrderBy,
            StartOrderByVector,
            AddSources,
            StartSourcesVector,
            End,
        )
        distinct_offset = None
        if self.distinct is not None:
            distinct_offset = self.distinct.serialize_to(builder)
        fields_offset = None
        if self.fields is not None:
            fields_offsets = list()
            for value in self.fields:
                fields_offsets.append(value.serialize_to(builder))
            StartFieldsVector(builder, len(self.fields))
            for i in reversed(range(len(self.fields))):
                builder.PrependUOffsetTRelative(fields_offsets[i])
            fields_offset = builder.EndVector()
        filter_offset = None
        if self.filter is not None:
            filter_offset = self.filter.serialize_to(builder)
        group_by_offset = None
        if self.group_by is not None:
            group_by_offsets = list()
            for value in self.group_by:
                group_by_offsets.append(value.serialize_to(builder))
            StartGroupByVector(builder, len(self.group_by))
            for i in reversed(range(len(self.group_by))):
                builder.PrependUOffsetTRelative(group_by_offsets[i])
            group_by_offset = builder.EndVector()
        joins_offset = None
        if self.joins is not None:
            joins_offsets = list()
            for value in self.joins:
                joins_offsets.append(value.serialize_to(builder))
            StartJoinsVector(builder, len(self.joins))
            for i in reversed(range(len(self.joins))):
                builder.PrependUOffsetTRelative(joins_offsets[i])
            joins_offset = builder.EndVector()
        order_by_offset = None
        if self.order_by is not None:
            order_by_offsets = list()
            for value in self.order_by:
                order_by_offsets.append(value.serialize_to(builder))
            StartOrderByVector(builder, len(self.order_by))
            for i in reversed(range(len(self.order_by))):
                builder.PrependUOffsetTRelative(order_by_offsets[i])
            order_by_offset = builder.EndVector()
        sources_offsets = list()
        for value in self.sources:
            sources_offsets.append(value.serialize_to(builder))
        StartSourcesVector(builder, len(self.sources))
        for i in reversed(range(len(self.sources))):
            builder.PrependUOffsetTRelative(sources_offsets[i])
        sources_offset = builder.EndVector()
        
        Start(builder)
        if distinct_offset is not None:
            AddDistinct(builder, distinct_offset)
        if fields_offset is not None:
            AddFields(builder, fields_offset)
        if filter_offset is not None:
            AddFilter(builder, filter_offset)
        if group_by_offset is not None:
            AddGroupBy(builder, group_by_offset)
        if joins_offset is not None:
            AddJoins(builder, joins_offset)
        AddLimit(builder, self.limit)
        if order_by_offset is not None:
            AddOrderBy(builder, order_by_offset)
        AddSources(builder, sources_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        distinct = Distinct.make_default()
        fields = []
        filter = Function.make_default()
        group_by = []
        joins = []
        limit = 0
        order_by = []
        sources = []
        return cls(distinct, fields, filter, group_by, joins, limit, order_by, sources)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.distinct == other.distinct
        self_fields = self.fields
        other_fields = other.fields
        if self_fields is not None and other_fields is not None:
            if len(self_fields) != len(other_fields):
                return False
            for i in range(len(self_fields)):
                eq = eq and self_fields[i] == other_fields[i]
        elif self_fields is not None and other_fields is None:
            return False
        elif self_fields is None and other_fields is not None:
            return False
        eq = eq and self.filter == other.filter
        self_group_by = self.group_by
        other_group_by = other.group_by
        if self_group_by is not None and other_group_by is not None:
            if len(self_group_by) != len(other_group_by):
                return False
            for i in range(len(self_group_by)):
                eq = eq and self_group_by[i] == other_group_by[i]
        elif self_group_by is not None and other_group_by is None:
            return False
        elif self_group_by is None and other_group_by is not None:
            return False
        self_joins = self.joins
        other_joins = other.joins
        if self_joins is not None and other_joins is not None:
            if len(self_joins) != len(other_joins):
                return False
            for i in range(len(self_joins)):
                eq = eq and self_joins[i] == other_joins[i]
        elif self_joins is not None and other_joins is None:
            return False
        elif self_joins is None and other_joins is not None:
            return False
        eq = eq and self.limit == other.limit
        self_order_by = self.order_by
        other_order_by = other.order_by
        if self_order_by is not None and other_order_by is not None:
            if len(self_order_by) != len(other_order_by):
                return False
            for i in range(len(self_order_by)):
                eq = eq and self_order_by[i] == other_order_by[i]
        elif self_order_by is not None and other_order_by is None:
            return False
        elif self_order_by is None and other_order_by is not None:
            return False
        if len(self.sources) != len(other.sources):
            return False
        for i in range(len(self.sources)):
            eq = eq and self.sources[i] == other.sources[i]

        return eq

@dataclass
class QueryElement:
    q: Optional["QueryElementUnion"]

    @classmethod
    def from_fbs(cls, o: FbsQueryElement) -> Self:
        q = None
        q_val = o.Q()
        if q_val is not None:
            q_ty = o.QType()
            q = QueryElementUnion.from_fbs(q_val, q_ty)
        return cls(q)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsQueryElement.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.QueryElement import (
            Start,
            AddQ,
            AddQType,
            End,
        )
        q_offset, q_ty = (None, None)
        if self.q is not None:
            q_offset, q_ty = self.q.serialize_to(builder)
        
        Start(builder)
        if q_offset is not None and q_ty is not None:
            AddQ(builder, q_offset)
            AddQType(builder, q_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        q = QueryElementUnion.make_default()
        return cls(q)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.q == other.q

        return eq

@dataclass
class BinaryQueryElement:
    lhs: "QueryElement"

    op: "QueryElementOp"

    rhs: "QueryElement"

    @classmethod
    def from_fbs(cls, o: FbsBinaryQueryElement) -> Self:
        lhs_obj = o.Lhs()
        if lhs_obj is not None:
            lhs = QueryElement.from_fbs(lhs_obj)
        else:
            raise ValueError("Lhs is required")
        op = QueryElementOp(o.Op())
        rhs_obj = o.Rhs()
        if rhs_obj is not None:
            rhs = QueryElement.from_fbs(rhs_obj)
        else:
            raise ValueError("Rhs is required")
        return cls(lhs, op, rhs)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsBinaryQueryElement.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.BinaryQueryElement import (
            Start,
            AddLhs,
            AddOp,
            AddRhs,
            End,
        )
        lhs_offset = self.lhs.serialize_to(builder)
        rhs_offset = self.rhs.serialize_to(builder)
        
        Start(builder)
        AddLhs(builder, lhs_offset)
        AddOp(builder, self.op.value)
        AddRhs(builder, rhs_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        lhs = QueryElement.make_default()
        op = QueryElementOp(0)
        rhs = QueryElement.make_default()
        return cls(lhs, op, rhs)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.lhs == other.lhs
        eq = eq and self.op == other.op
        eq = eq and self.rhs == other.rhs

        return eq

@dataclass
class MvdbSubcollection:
    subcollection: "str"

    @classmethod
    def from_fbs(cls, o: FbsMvdbSubcollection) -> Self:
        subcollection_str = o.Subcollection()
        assert subcollection_str is not None
        subcollection = subcollection_str.decode('utf-8')
        return cls(subcollection)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsMvdbSubcollection.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.MvdbSubcollection import (
            Start,
            AddSubcollection,
            End,
        )
        subcollection_offset = builder.CreateString(self.subcollection)
        
        Start(builder)
        AddSubcollection(builder, subcollection_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        subcollection = ""
        return cls(subcollection)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.subcollection == other.subcollection

        return eq

@dataclass
class WorklogSubcollection:
    idx: "int"

    @classmethod
    def from_fbs(cls, o: FbsWorklogSubcollection) -> Self:
        idx = o.Idx()
        return cls(idx)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsWorklogSubcollection.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.WorklogSubcollection import (
            Start,
            AddIdx,
            End,
        )
        
        Start(builder)
        AddIdx(builder, self.idx)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        idx = 0
        return cls(idx)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.idx == other.idx

        return eq

@dataclass
class Subcollection:
    value: Union[
        "MvdbSubcollection",
        "WorklogSubcollection",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.Subcollection import Subcollection
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, MvdbSubcollection):
            return (offset, Subcollection().MvdbSubcollection)
        elif isinstance(self.value, WorklogSubcollection):
            return (offset, Subcollection().WorklogSubcollection)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        Subcollection_ty_instance = FbsSubcollection()
        if ty == Subcollection_ty_instance.MvdbSubcollection:
            val = FbsMvdbSubcollection();
            val.Init(source, pos)
            return cls(MvdbSubcollection.from_fbs(val))
        elif ty == Subcollection_ty_instance.WorklogSubcollection:
            val = FbsWorklogSubcollection();
            val.Init(source, pos)
            return cls(WorklogSubcollection.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(MvdbSubcollection.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class DataCatalog:
    id: "ObjectId"

    revision: Optional["ContentId"]

    subcollection: Optional["Subcollection"]

    @classmethod
    def from_fbs(cls, o: FbsDataCatalog) -> Self:
        id_obj = o.Id()
        if id_obj is not None:
            id = ObjectId.from_fbs(id_obj)
        else:
            raise ValueError("Id is required")
        revision = None
        revision_obj = o.Revision()
        if revision_obj is not None:
            revision = ContentId.from_fbs(revision_obj)
        subcollection = None
        subcollection_val = o.Subcollection()
        if subcollection_val is not None:
            subcollection_ty = o.SubcollectionType()
            subcollection = Subcollection.from_fbs(subcollection_val, subcollection_ty)
        return cls(id, revision, subcollection)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDataCatalog.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DataCatalog import (
            Start,
            AddId,
            AddRevision,
            AddSubcollection,
            AddSubcollectionType,
            End,
        )
        id_offset = self.id.serialize_to(builder)
        revision_offset = None
        if self.revision is not None:
            revision_offset = self.revision.serialize_to(builder)
        subcollection_offset, subcollection_ty = (None, None)
        if self.subcollection is not None:
            subcollection_offset, subcollection_ty = self.subcollection.serialize_to(builder)
        
        Start(builder)
        AddId(builder, id_offset)
        if revision_offset is not None:
            AddRevision(builder, revision_offset)
        if subcollection_offset is not None and subcollection_ty is not None:
            AddSubcollection(builder, subcollection_offset)
            AddSubcollectionType(builder, subcollection_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        id = ObjectId.make_default()
        revision = ContentId.make_default()
        subcollection = Subcollection.make_default()
        return cls(id, revision, subcollection)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.id == other.id
        eq = eq and self.revision == other.revision
        eq = eq and self.subcollection == other.subcollection

        return eq

@dataclass
class Arrow:
    value: "List[int]"

    @classmethod
    def from_fbs(cls, o: FbsArrow) -> Self:
        value = list()
        if not o.ValueIsNone():
            for i in range(o.ValueLength()):
                value.append(o.Value(i))
        return cls(value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsArrow.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Arrow import (
            Start,
            AddValue,
            StartValueVector,
            End,
        )
        StartValueVector(builder, len(self.value))
        for i in reversed(range(len(self.value))):
            builder.PrependUint8(self.value[i])
        value_offset = builder.EndVector()
        
        Start(builder)
        AddValue(builder, value_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        value = []
        return cls(value)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.value) != len(other.value):
            return False
        for i in range(len(self.value)):
            eq = eq and self.value[i] == other.value[i]

        return eq

@dataclass
class Query:
    limit: "int"

    query: "QueryElement"

    values: Optional["List[ValueInstance]"]

    @classmethod
    def from_fbs(cls, o: FbsQuery) -> Self:
        limit = o.Limit()
        query_obj = o.Query()
        if query_obj is not None:
            query = QueryElement.from_fbs(query_obj)
        else:
            raise ValueError("Query is required")
        values = list()
        if not o.ValuesIsNone():
            for i in range(o.ValuesLength()):
                values_val = None
                values_obj = o.Values(i)
                if values_obj is not None:
                    values_val = ValueInstance.from_fbs(values_obj)
                values.append(values_val)
        return cls(limit, query, values)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsQuery.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Query import (
            Start,
            AddLimit,
            AddQuery,
            AddValues,
            StartValuesVector,
            End,
        )
        query_offset = self.query.serialize_to(builder)
        values_offset = None
        if self.values is not None:
            values_offsets = list()
            for value in self.values:
                values_offsets.append(value.serialize_to(builder))
            StartValuesVector(builder, len(self.values))
            for i in reversed(range(len(self.values))):
                builder.PrependUOffsetTRelative(values_offsets[i])
            values_offset = builder.EndVector()
        
        Start(builder)
        AddLimit(builder, self.limit)
        AddQuery(builder, query_offset)
        if values_offset is not None:
            AddValues(builder, values_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        limit = 0
        query = QueryElement.make_default()
        values = []
        return cls(limit, query, values)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.limit == other.limit
        eq = eq and self.query == other.query
        self_values = self.values
        other_values = other.values
        if self_values is not None and other_values is not None:
            if len(self_values) != len(other_values):
                return False
            for i in range(len(self_values)):
                eq = eq and self_values[i] == other_values[i]
        elif self_values is not None and other_values is None:
            return False
        elif self_values is None and other_values is not None:
            return False

        return eq

@dataclass
class QueryTableSource:
    q: "Query"

    @classmethod
    def from_fbs(cls, o: FbsQueryTableSource) -> Self:
        q_obj = o.Q()
        if q_obj is not None:
            q = Query.from_fbs(q_obj)
        else:
            raise ValueError("Q is required")
        return cls(q)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsQueryTableSource.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.QueryTableSource import (
            Start,
            AddQ,
            End,
        )
        q_offset = self.q.serialize_to(builder)
        
        Start(builder)
        AddQ(builder, q_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        q = Query.make_default()
        return cls(q)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.q == other.q

        return eq

@dataclass
class Vector:
    # List of vectordbs to query. If this is empty, query all available vectordbs.
    ids: "List[ObjectId]"

    limit: Optional["NullableUint"]

    # Optionally limit the results to those with a distance value less than
    # max_distance. We treat max_distance=0 as no limit.
    max_distance: "float"

    query: "str"

    @classmethod
    def from_fbs(cls, o: FbsVector) -> Self:
        ids = list()
        if not o.IdsIsNone():
            for i in range(o.IdsLength()):
                ids_val = None
                ids_obj = o.Ids(i)
                if ids_obj is not None:
                    ids_val = ObjectId.from_fbs(ids_obj)
                ids.append(ids_val)
        limit = None
        limit_obj = o.Limit()
        if limit_obj is not None:
            limit = NullableUint.from_fbs(limit_obj)
        max_distance = o.MaxDistance()
        query_str = o.Query()
        assert query_str is not None
        query = query_str.decode('utf-8')
        return cls(ids, limit, max_distance, query)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsVector.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Vector import (
            Start,
            AddIds,
            StartIdsVector,
            AddLimit,
            AddMaxDistance,
            AddQuery,
            End,
        )
        ids_offsets = list()
        for value in self.ids:
            ids_offsets.append(value.serialize_to(builder))
        StartIdsVector(builder, len(self.ids))
        for i in reversed(range(len(self.ids))):
            builder.PrependUOffsetTRelative(ids_offsets[i])
        ids_offset = builder.EndVector()
        limit_offset = None
        if self.limit is not None:
            limit_offset = self.limit.serialize_to(builder)
        query_offset = builder.CreateString(self.query)
        
        Start(builder)
        AddIds(builder, ids_offset)
        if limit_offset is not None:
            AddLimit(builder, limit_offset)
        AddMaxDistance(builder, self.max_distance)
        AddQuery(builder, query_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        ids = []
        limit = NullableUint.make_default()
        max_distance = 0.0
        query = ""
        return cls(ids, limit, max_distance, query)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.ids) != len(other.ids):
            return False
        for i in range(len(self.ids)):
            eq = eq and self.ids[i] == other.ids[i]
        eq = eq and self.limit == other.limit
        eq = eq and self.max_distance == other.max_distance
        eq = eq and self.query == other.query

        return eq

@dataclass
class TableSourceUnion:
    value: Union[
        "DataCatalog",
        "Arrow",
        "GraphQuery",
        "QueryTableSource",
        "Vector",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.TableSourceUnion import TableSourceUnion
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, DataCatalog):
            return (offset, TableSourceUnion().DataCatalog)
        elif isinstance(self.value, Arrow):
            return (offset, TableSourceUnion().Arrow)
        elif isinstance(self.value, GraphQuery):
            return (offset, TableSourceUnion().GraphQuery)
        elif isinstance(self.value, QueryTableSource):
            return (offset, TableSourceUnion().QueryTableSource)
        elif isinstance(self.value, Vector):
            return (offset, TableSourceUnion().Vector)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        TableSourceUnion_ty_instance = FbsTableSourceUnion()
        if ty == TableSourceUnion_ty_instance.DataCatalog:
            val = FbsDataCatalog();
            val.Init(source, pos)
            return cls(DataCatalog.from_fbs(val))
        elif ty == TableSourceUnion_ty_instance.Arrow:
            val = FbsArrow();
            val.Init(source, pos)
            return cls(Arrow.from_fbs(val))
        elif ty == TableSourceUnion_ty_instance.GraphQuery:
            val = FbsGraphQuery();
            val.Init(source, pos)
            return cls(GraphQuery.from_fbs(val))
        elif ty == TableSourceUnion_ty_instance.QueryTableSource:
            val = FbsQueryTableSource();
            val.Init(source, pos)
            return cls(QueryTableSource.from_fbs(val))
        elif ty == TableSourceUnion_ty_instance.Vector:
            val = FbsVector();
            val.Init(source, pos)
            return cls(Vector.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(DataCatalog.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class UpdateQueryElement:
    filter: Optional["Function"]

    sets: "List[SetExpr]"

    source: "TableSourceUnion"

    @classmethod
    def from_fbs(cls, o: FbsUpdateQueryElement) -> Self:
        filter = None
        filter_obj = o.Filter()
        if filter_obj is not None:
            filter = Function.from_fbs(filter_obj)
        sets = list()
        if not o.SetsIsNone():
            for i in range(o.SetsLength()):
                sets_val = None
                sets_obj = o.Sets(i)
                if sets_obj is not None:
                    sets_val = SetExpr.from_fbs(sets_obj)
                sets.append(sets_val)
        source_val = o.Source()
        if source_val is not None:
            source_ty = o.SourceType()
            source = TableSourceUnion.from_fbs(source_val, source_ty)
        else:
            raise ValueError("Source is required")
        return cls(filter, sets, source)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUpdateQueryElement.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UpdateQueryElement import (
            Start,
            AddFilter,
            AddSets,
            StartSetsVector,
            AddSource,
            AddSourceType,
            End,
        )
        filter_offset = None
        if self.filter is not None:
            filter_offset = self.filter.serialize_to(builder)
        sets_offsets = list()
        for value in self.sets:
            sets_offsets.append(value.serialize_to(builder))
        StartSetsVector(builder, len(self.sets))
        for i in reversed(range(len(self.sets))):
            builder.PrependUOffsetTRelative(sets_offsets[i])
        sets_offset = builder.EndVector()
        source_offset, source_ty = self.source.serialize_to(builder)
        
        Start(builder)
        if filter_offset is not None:
            AddFilter(builder, filter_offset)
        AddSets(builder, sets_offset)
        AddSource(builder, source_offset)
        AddSourceType(builder, source_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        filter = Function.make_default()
        sets = []
        source = TableSourceUnion.make_default()
        return cls(filter, sets, source)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.filter == other.filter
        if len(self.sets) != len(other.sets):
            return False
        for i in range(len(self.sets)):
            eq = eq and self.sets[i] == other.sets[i]
        eq = eq and self.source == other.source

        return eq

@dataclass
class DeleteQueryElement:
    filter: Optional["Function"]

    source: "TableSourceUnion"

    @classmethod
    def from_fbs(cls, o: FbsDeleteQueryElement) -> Self:
        filter = None
        filter_obj = o.Filter()
        if filter_obj is not None:
            filter = Function.from_fbs(filter_obj)
        source_val = o.Source()
        if source_val is not None:
            source_ty = o.SourceType()
            source = TableSourceUnion.from_fbs(source_val, source_ty)
        else:
            raise ValueError("Source is required")
        return cls(filter, source)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDeleteQueryElement.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DeleteQueryElement import (
            Start,
            AddFilter,
            AddSource,
            AddSourceType,
            End,
        )
        filter_offset = None
        if self.filter is not None:
            filter_offset = self.filter.serialize_to(builder)
        source_offset, source_ty = self.source.serialize_to(builder)
        
        Start(builder)
        if filter_offset is not None:
            AddFilter(builder, filter_offset)
        AddSource(builder, source_offset)
        AddSourceType(builder, source_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        filter = Function.make_default()
        source = TableSourceUnion.make_default()
        return cls(filter, source)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.filter == other.filter
        eq = eq and self.source == other.source

        return eq

@dataclass
class QueryElementUnion:
    value: Union[
        "UnaryQueryElement",
        "BinaryQueryElement",
        "UpdateQueryElement",
        "DeleteQueryElement",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.QueryElementUnion import QueryElementUnion
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, UnaryQueryElement):
            return (offset, QueryElementUnion().UnaryQueryElement)
        elif isinstance(self.value, BinaryQueryElement):
            return (offset, QueryElementUnion().BinaryQueryElement)
        elif isinstance(self.value, UpdateQueryElement):
            return (offset, QueryElementUnion().UpdateQueryElement)
        elif isinstance(self.value, DeleteQueryElement):
            return (offset, QueryElementUnion().DeleteQueryElement)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        QueryElementUnion_ty_instance = FbsQueryElementUnion()
        if ty == QueryElementUnion_ty_instance.UnaryQueryElement:
            val = FbsUnaryQueryElement();
            val.Init(source, pos)
            return cls(UnaryQueryElement.from_fbs(val))
        elif ty == QueryElementUnion_ty_instance.BinaryQueryElement:
            val = FbsBinaryQueryElement();
            val.Init(source, pos)
            return cls(BinaryQueryElement.from_fbs(val))
        elif ty == QueryElementUnion_ty_instance.UpdateQueryElement:
            val = FbsUpdateQueryElement();
            val.Init(source, pos)
            return cls(UpdateQueryElement.from_fbs(val))
        elif ty == QueryElementUnion_ty_instance.DeleteQueryElement:
            val = FbsDeleteQueryElement();
            val.Init(source, pos)
            return cls(DeleteQueryElement.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(UnaryQueryElement.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class Join:
    dest_col: Optional["str"]

    dest_idx: "int"

    src_col: Optional["str"]

    src_idx: "int"

    ty: "JoinTy"

    @classmethod
    def from_fbs(cls, o: FbsJoin) -> Self:
        dest_col = None
        dest_col_str = o.DestCol()
        if dest_col_str is not None:
            dest_col = dest_col_str.decode('utf-8')
        dest_idx = o.DestIdx()
        src_col = None
        src_col_str = o.SrcCol()
        if src_col_str is not None:
            src_col = src_col_str.decode('utf-8')
        src_idx = o.SrcIdx()
        ty = JoinTy(o.Ty())
        return cls(dest_col, dest_idx, src_col, src_idx, ty)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsJoin.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Join import (
            Start,
            AddDestCol,
            AddDestIdx,
            AddSrcCol,
            AddSrcIdx,
            AddTy,
            End,
        )
        dest_col_offset = None
        if self.dest_col is not None:
            dest_col_offset = builder.CreateString(self.dest_col)
        src_col_offset = None
        if self.src_col is not None:
            src_col_offset = builder.CreateString(self.src_col)
        
        Start(builder)
        if dest_col_offset is not None:
            AddDestCol(builder, dest_col_offset)
        AddDestIdx(builder, self.dest_idx)
        if src_col_offset is not None:
            AddSrcCol(builder, src_col_offset)
        AddSrcIdx(builder, self.src_idx)
        AddTy(builder, self.ty.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        dest_col = ""
        dest_idx = 0
        src_col = ""
        src_idx = 0
        ty = JoinTy(0)
        return cls(dest_col, dest_idx, src_col, src_idx, ty)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.dest_col == other.dest_col
        eq = eq and self.dest_idx == other.dest_idx
        eq = eq and self.src_col == other.src_col
        eq = eq and self.src_idx == other.src_idx
        eq = eq and self.ty == other.ty

        return eq

@dataclass
class ParameterInstance:
    p: "ParameterSlot"

    @classmethod
    def from_fbs(cls, o: FbsParameterInstance) -> Self:
        p_val = o.P()
        if p_val is not None:
            p_ty = o.PType()
            p = ParameterSlot.from_fbs(p_val, p_ty)
        else:
            raise ValueError("P is required")
        return cls(p)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsParameterInstance.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ParameterInstance import (
            Start,
            AddP,
            AddPType,
            End,
        )
        p_offset, p_ty = self.p.serialize_to(builder)
        
        Start(builder)
        AddP(builder, p_offset)
        AddPType(builder, p_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        p = ParameterSlot.make_default()
        return cls(p)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.p == other.p

        return eq

@dataclass
class ParameterizedQuery:
    limit: "int"

    parameters: Optional["List[ParameterInstance]"]

    query: "QueryElement"

    @classmethod
    def from_fbs(cls, o: FbsParameterizedQuery) -> Self:
        limit = o.Limit()
        parameters = list()
        if not o.ParametersIsNone():
            for i in range(o.ParametersLength()):
                parameters_val = None
                parameters_obj = o.Parameters(i)
                if parameters_obj is not None:
                    parameters_val = ParameterInstance.from_fbs(parameters_obj)
                parameters.append(parameters_val)
        query_obj = o.Query()
        if query_obj is not None:
            query = QueryElement.from_fbs(query_obj)
        else:
            raise ValueError("Query is required")
        return cls(limit, parameters, query)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsParameterizedQuery.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ParameterizedQuery import (
            Start,
            AddLimit,
            AddParameters,
            StartParametersVector,
            AddQuery,
            End,
        )
        parameters_offset = None
        if self.parameters is not None:
            parameters_offsets = list()
            for value in self.parameters:
                parameters_offsets.append(value.serialize_to(builder))
            StartParametersVector(builder, len(self.parameters))
            for i in reversed(range(len(self.parameters))):
                builder.PrependUOffsetTRelative(parameters_offsets[i])
            parameters_offset = builder.EndVector()
        query_offset = self.query.serialize_to(builder)
        
        Start(builder)
        AddLimit(builder, self.limit)
        if parameters_offset is not None:
            AddParameters(builder, parameters_offset)
        AddQuery(builder, query_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        limit = 0
        parameters = []
        query = QueryElement.make_default()
        return cls(limit, parameters, query)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.limit == other.limit
        self_parameters = self.parameters
        other_parameters = other.parameters
        if self_parameters is not None and other_parameters is not None:
            if len(self_parameters) != len(other_parameters):
                return False
            for i in range(len(self_parameters)):
                eq = eq and self_parameters[i] == other_parameters[i]
        elif self_parameters is not None and other_parameters is None:
            return False
        elif self_parameters is None and other_parameters is not None:
            return False
        eq = eq and self.query == other.query

        return eq

@dataclass
class SetExpr:
    """ SetExprs represent the expressions used as part of an UPDATE-type operation
    """

    # Because we cannot refer to multiple tables at once in a single UPDATE
    # operation we only need to name the column, we can just a string here
    # instead of a Column table.
    col: "str"

    # This is the expression that is evaluted to produce the value that is
    # assigned to the column named in the `col` field.
    expr: "Expr"

    @classmethod
    def from_fbs(cls, o: FbsSetExpr) -> Self:
        col_str = o.Col()
        assert col_str is not None
        col = col_str.decode('utf-8')
        expr_obj = o.Expr()
        if expr_obj is not None:
            expr = Expr.from_fbs(expr_obj)
        else:
            raise ValueError("Expr is required")
        return cls(col, expr)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsSetExpr.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.SetExpr import (
            Start,
            AddCol,
            AddExpr,
            End,
        )
        col_offset = builder.CreateString(self.col)
        expr_offset = self.expr.serialize_to(builder)
        
        Start(builder)
        AddCol(builder, col_offset)
        AddExpr(builder, expr_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        col = ""
        expr = Expr.make_default()
        return cls(col, expr)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.col == other.col
        eq = eq and self.expr == other.expr

        return eq

@dataclass
class TableOrderBy:
    order_by: "OrderBy"

    source: "int"

    # Because the `source` field defaults to 0 when unset, use this field to
    # indicate whether the source should be used. In some cases, such as when
    # you want to order by an column produced by aggregating on the result of
    # a join, the column isn't associated with any table source.
    #
    # In that case, set `use_source` to false and the verbatim string provided
    # in the `field` field of the `OrderBy` structure will be used for the order-by.
    use_source: "bool"

    @classmethod
    def from_fbs(cls, o: FbsTableOrderBy) -> Self:
        order_by_obj = o.OrderBy()
        if order_by_obj is not None:
            order_by = OrderBy.from_fbs(order_by_obj)
        else:
            raise ValueError("OrderBy is required")
        source = o.Source()
        use_source = o.UseSource()
        return cls(order_by, source, use_source)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTableOrderBy.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TableOrderBy import (
            Start,
            AddOrderBy,
            AddSource,
            AddUseSource,
            End,
        )
        order_by_offset = self.order_by.serialize_to(builder)
        
        Start(builder)
        AddOrderBy(builder, order_by_offset)
        AddSource(builder, self.source)
        AddUseSource(builder, self.use_source)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        order_by = OrderBy.make_default()
        source = 0
        use_source = False
        return cls(order_by, source, use_source)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.order_by == other.order_by
        eq = eq and self.source == other.source
        eq = eq and self.use_source == other.use_source

        return eq

@dataclass
class TableSource:
    fields: Optional["List[Expr]"]

    filter: Optional["Function"]

    group_by: Optional["List[Expr]"]

    order_by: Optional["List[OrderBy]"]

    t: "TableSourceUnion"

    @classmethod
    def from_fbs(cls, o: FbsTableSource) -> Self:
        fields = list()
        if not o.FieldsIsNone():
            for i in range(o.FieldsLength()):
                fields_val = None
                fields_obj = o.Fields(i)
                if fields_obj is not None:
                    fields_val = Expr.from_fbs(fields_obj)
                fields.append(fields_val)
        filter = None
        filter_obj = o.Filter()
        if filter_obj is not None:
            filter = Function.from_fbs(filter_obj)
        group_by = list()
        if not o.GroupByIsNone():
            for i in range(o.GroupByLength()):
                group_by_val = None
                group_by_obj = o.GroupBy(i)
                if group_by_obj is not None:
                    group_by_val = Expr.from_fbs(group_by_obj)
                group_by.append(group_by_val)
        order_by = list()
        if not o.OrderByIsNone():
            for i in range(o.OrderByLength()):
                order_by_val = None
                order_by_obj = o.OrderBy(i)
                if order_by_obj is not None:
                    order_by_val = OrderBy.from_fbs(order_by_obj)
                order_by.append(order_by_val)
        t_val = o.T()
        if t_val is not None:
            t_ty = o.TType()
            t = TableSourceUnion.from_fbs(t_val, t_ty)
        else:
            raise ValueError("T is required")
        return cls(fields, filter, group_by, order_by, t)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTableSource.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TableSource import (
            Start,
            AddFields,
            StartFieldsVector,
            AddFilter,
            AddGroupBy,
            StartGroupByVector,
            AddOrderBy,
            StartOrderByVector,
            AddT,
            AddTType,
            End,
        )
        fields_offset = None
        if self.fields is not None:
            fields_offsets = list()
            for value in self.fields:
                fields_offsets.append(value.serialize_to(builder))
            StartFieldsVector(builder, len(self.fields))
            for i in reversed(range(len(self.fields))):
                builder.PrependUOffsetTRelative(fields_offsets[i])
            fields_offset = builder.EndVector()
        filter_offset = None
        if self.filter is not None:
            filter_offset = self.filter.serialize_to(builder)
        group_by_offset = None
        if self.group_by is not None:
            group_by_offsets = list()
            for value in self.group_by:
                group_by_offsets.append(value.serialize_to(builder))
            StartGroupByVector(builder, len(self.group_by))
            for i in reversed(range(len(self.group_by))):
                builder.PrependUOffsetTRelative(group_by_offsets[i])
            group_by_offset = builder.EndVector()
        order_by_offset = None
        if self.order_by is not None:
            order_by_offsets = list()
            for value in self.order_by:
                order_by_offsets.append(value.serialize_to(builder))
            StartOrderByVector(builder, len(self.order_by))
            for i in reversed(range(len(self.order_by))):
                builder.PrependUOffsetTRelative(order_by_offsets[i])
            order_by_offset = builder.EndVector()
        t_offset, t_ty = self.t.serialize_to(builder)
        
        Start(builder)
        if fields_offset is not None:
            AddFields(builder, fields_offset)
        if filter_offset is not None:
            AddFilter(builder, filter_offset)
        if group_by_offset is not None:
            AddGroupBy(builder, group_by_offset)
        if order_by_offset is not None:
            AddOrderBy(builder, order_by_offset)
        AddT(builder, t_offset)
        AddTType(builder, t_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        fields = []
        filter = Function.make_default()
        group_by = []
        order_by = []
        t = TableSourceUnion.make_default()
        return cls(fields, filter, group_by, order_by, t)

    def __eq__(self, other) -> bool:
        eq = True
        self_fields = self.fields
        other_fields = other.fields
        if self_fields is not None and other_fields is not None:
            if len(self_fields) != len(other_fields):
                return False
            for i in range(len(self_fields)):
                eq = eq and self_fields[i] == other_fields[i]
        elif self_fields is not None and other_fields is None:
            return False
        elif self_fields is None and other_fields is not None:
            return False
        eq = eq and self.filter == other.filter
        self_group_by = self.group_by
        other_group_by = other.group_by
        if self_group_by is not None and other_group_by is not None:
            if len(self_group_by) != len(other_group_by):
                return False
            for i in range(len(self_group_by)):
                eq = eq and self_group_by[i] == other_group_by[i]
        elif self_group_by is not None and other_group_by is None:
            return False
        elif self_group_by is None and other_group_by is not None:
            return False
        self_order_by = self.order_by
        other_order_by = other.order_by
        if self_order_by is not None and other_order_by is not None:
            if len(self_order_by) != len(other_order_by):
                return False
            for i in range(len(self_order_by)):
                eq = eq and self_order_by[i] == other_order_by[i]
        elif self_order_by is not None and other_order_by is None:
            return False
        elif self_order_by is None and other_order_by is not None:
            return False
        eq = eq and self.t == other.t

        return eq

@dataclass
class When:
    cond: "Expr"

    value: "Expr"

    @classmethod
    def from_fbs(cls, o: FbsWhen) -> Self:
        cond_obj = o.Cond()
        if cond_obj is not None:
            cond = Expr.from_fbs(cond_obj)
        else:
            raise ValueError("Cond is required")
        value_obj = o.Value()
        if value_obj is not None:
            value = Expr.from_fbs(value_obj)
        else:
            raise ValueError("Value is required")
        return cls(cond, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsWhen.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.When import (
            Start,
            AddCond,
            AddValue,
            End,
        )
        cond_offset = self.cond.serialize_to(builder)
        value_offset = self.value.serialize_to(builder)
        
        Start(builder)
        AddCond(builder, cond_offset)
        AddValue(builder, value_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        cond = Expr.make_default()
        value = Expr.make_default()
        return cls(cond, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.cond == other.cond
        eq = eq and self.value == other.value

        return eq
