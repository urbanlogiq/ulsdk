# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .Schema import (
    Binary,
    Bool,
    Buffer,
    Date,
    DateUnit,
    Decimal,
    DictionaryEncoding,
    DictionaryKind,
    Duration,
    Endianness,
    Feature,
    Field,
    FixedSizeBinary,
    FixedSizeList,
    FloatingPoint,
    Int,
    Interval,
    IntervalUnit,
    KeyValue,
    LargeBinary,
    LargeList,
    LargeUtf8,
    List_,
    Map,
    MetadataVersion,
    Null,
    Precision,
    Schema,
    Struct_,
    Time,
    TimeUnit,
    Timestamp,
    Type,
    Union_,
    UnionMode,
    Utf8,
)
from .crypto import (
    CryptHeader,
    Digest,
    EncryptedObject,
    Sha256,
    Signature,
)
from .data import (
    AttributePair,
    DayOfWeek,
    DirectionAndRoadName,
    DirectionAndRoadNames,
    DirectionTy,
    NamedParameter,
    NamedParameterFlags,
    RoadUserTy,
    Source,
    StatisticTy,
    TimeGranularity,
    TurnTy,
)
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .job import (
    DeprecatedRunSpec,
    DeprecatedTaskParameter,
    Edge,
    EmbeddedTable,
    Job,
    Node,
    ParamIndices,
    RunSpec,
    Schematic,
    Status,
    Task,
    TaskErrorTy,
    TaskList,
    TaskParameter,
    TaskParameterValue,
    TaskPriority,
    TaskRunFlags,
)
from .object import (
    DataCatalogObject,
    DataCatalogObjectFlags,
    DataCatalogObjectTy,
    ObjectIdList,
    ObjectIdPair,
    ObjectIdPairList,
    ObjectSummary,
    ObjectSummaryList,
)
from .reflection import (
    ReflectionAdvancedFeatures,
    ReflectionBaseType,
    ReflectionEnum,
    ReflectionEnumVal,
    ReflectionField,
    ReflectionKeyValue,
    ReflectionObject,
    ReflectionRPCCall,
    ReflectionSchema,
    ReflectionSchemaFile,
    ReflectionService,
    ReflectionType,
)
from .stream import (
    AxisType,
    FormatFlags,
    Stream,
    StreamFlags,
)
from .value import (
    Point2D,
    Tri2D,
    VArray,
    VBool,
    VBytes,
    VChar,
    VF32,
    VF64,
    VFixedSizeBytes,
    VI16,
    VI32,
    VI64,
    VI8,
    VIsize,
    VNull,
    VStr,
    VTimestampMs,
    VTimestampMsUtc,
    VTimestampNs,
    VTimestampNsUtc,
    VTri2D,
    VU16,
    VU32,
    VU64,
    VU8,
    VUnit,
    VUsize,
    Value,
    ValueInstance,
    ValueTy,
)
from .worklog import (
    AggregationTy,
    ByteArray,
    ChartTypeTy,
    Layout,
    ParameterFlags,
    ParameterValue,
    TileData,
    TileSettings,
    UserSettings,
    ValuesFormatTy,
    WorkLog,
    WorklogParameter,
)
from .generated.Attr import Attr as FbsAttr
from .generated.AttributePair import AttributePair as FbsAttributePair
from .generated.B2cId import B2cId as FbsB2cId
from .generated.Binary import Binary as FbsBinary
from .generated.Bool import Bool as FbsBool
from .generated.Buffer import Buffer as FbsBuffer
from .generated.ByteArray import ByteArray as FbsByteArray
from .generated.Chunk import Chunk as FbsChunk
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.CryptHeader import CryptHeader as FbsCryptHeader
from .generated.DataCatalogObject import DataCatalogObject as FbsDataCatalogObject
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.Date import Date as FbsDate
from .generated.Decimal import Decimal as FbsDecimal
from .generated.DeprecatedRunSpec import DeprecatedRunSpec as FbsDeprecatedRunSpec
from .generated.DeprecatedTaskParameter import DeprecatedTaskParameter as FbsDeprecatedTaskParameter
from .generated.DictionaryEncoding import DictionaryEncoding as FbsDictionaryEncoding
from .generated.DirectionAndRoadName import DirectionAndRoadName as FbsDirectionAndRoadName
from .generated.DirectionAndRoadNames import DirectionAndRoadNames as FbsDirectionAndRoadNames
from .generated.Directory import Directory as FbsDirectory
from .generated.DirectoryEntry import DirectoryEntry as FbsDirectoryEntry
from .generated.DirectoryList import DirectoryList as FbsDirectoryList
from .generated.Duration import Duration as FbsDuration
from .generated.Edge import Edge as FbsEdge
from .generated.EmbeddedTable import EmbeddedTable as FbsEmbeddedTable
from .generated.EncryptedObject import EncryptedObject as FbsEncryptedObject
from .generated.Field import Field as FbsField
from .generated.File import File as FbsFile
from .generated.FixedSizeBinary import FixedSizeBinary as FbsFixedSizeBinary
from .generated.FixedSizeList import FixedSizeList as FbsFixedSizeList
from .generated.FloatingPoint import FloatingPoint as FbsFloatingPoint
from .generated.GenericId import GenericId as FbsGenericId
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.Int import Int as FbsInt
from .generated.Interval import Interval as FbsInterval
from .generated.Job import Job as FbsJob
from .generated.KeyValue import KeyValue as FbsKeyValue
from .generated.LargeBinary import LargeBinary as FbsLargeBinary
from .generated.LargeList import LargeList as FbsLargeList
from .generated.LargeUtf8 import LargeUtf8 as FbsLargeUtf8
from .generated.Layout import Layout as FbsLayout
from .generated.List import List as FbsList
from .generated.ListDirectory import ListDirectory as FbsListDirectory
from .generated.ListFile import ListFile as FbsListFile
from .generated.ListObject import ListObject as FbsListObject
from .generated.ListSlot import ListSlot as FbsListSlot
from .generated.Map import Map as FbsMap
from .generated.MoveRequest import MoveRequest as FbsMoveRequest
from .generated.NamedParameter import NamedParameter as FbsNamedParameter
from .generated.NewLink import NewLink as FbsNewLink
from .generated.Node import Node as FbsNode
from .generated.Null import Null as FbsNull
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.ObjectIdList import ObjectIdList as FbsObjectIdList
from .generated.ObjectIdPair import ObjectIdPair as FbsObjectIdPair
from .generated.ObjectIdPairList import ObjectIdPairList as FbsObjectIdPairList
from .generated.ObjectRef import ObjectRef as FbsObjectRef
from .generated.ObjectSummary import ObjectSummary as FbsObjectSummary
from .generated.ObjectSummaryList import ObjectSummaryList as FbsObjectSummaryList
from .generated.ParamIndices import ParamIndices as FbsParamIndices
from .generated.ParameterFlags import ParameterFlags as FbsParameterFlags
from .generated.Point2D import Point2D as FbsPoint2D
from .generated.RunSpec import RunSpec as FbsRunSpec
from .generated.Schema import Schema as FbsSchema
from .generated.Schematic import Schematic as FbsSchematic
from .generated.Sha256 import Sha256 as FbsSha256
from .generated.Signature import Signature as FbsSignature
from .generated.Slot import Slot as FbsSlot
from .generated.Source import Source as FbsSource
from .generated.Stream import Stream as FbsStream
from .generated.StreamId import StreamId as FbsStreamId
from .generated.Struct_ import Struct_ as FbsStruct_
from .generated.Task import Task as FbsTask
from .generated.TaskList import TaskList as FbsTaskList
from .generated.TaskParameter import TaskParameter as FbsTaskParameter
from .generated.TileData import TileData as FbsTileData
from .generated.TileSettings import TileSettings as FbsTileSettings
from .generated.Time import Time as FbsTime
from .generated.Timestamp import Timestamp as FbsTimestamp
from .generated.TopLevelDirectory import TopLevelDirectory as FbsTopLevelDirectory
from .generated.Tri2D import Tri2D as FbsTri2D
from .generated.Union import Union as FbsUnion
from .generated.UserSettings import UserSettings as FbsUserSettings
from .generated.Utf8 import Utf8 as FbsUtf8
from .generated.VArray import VArray as FbsVArray
from .generated.VBool import VBool as FbsVBool
from .generated.VBytes import VBytes as FbsVBytes
from .generated.VChar import VChar as FbsVChar
from .generated.VF32 import VF32 as FbsVF32
from .generated.VF64 import VF64 as FbsVF64
from .generated.VFixedSizeBytes import VFixedSizeBytes as FbsVFixedSizeBytes
from .generated.VI16 import VI16 as FbsVI16
from .generated.VI32 import VI32 as FbsVI32
from .generated.VI64 import VI64 as FbsVI64
from .generated.VI8 import VI8 as FbsVI8
from .generated.VIsize import VIsize as FbsVIsize
from .generated.VNull import VNull as FbsVNull
from .generated.VStr import VStr as FbsVStr
from .generated.VTimestampMs import VTimestampMs as FbsVTimestampMs
from .generated.VTimestampMsUtc import VTimestampMsUtc as FbsVTimestampMsUtc
from .generated.VTimestampNs import VTimestampNs as FbsVTimestampNs
from .generated.VTimestampNsUtc import VTimestampNsUtc as FbsVTimestampNsUtc
from .generated.VTri2D import VTri2D as FbsVTri2D
from .generated.VU16 import VU16 as FbsVU16
from .generated.VU32 import VU32 as FbsVU32
from .generated.VU64 import VU64 as FbsVU64
from .generated.VU8 import VU8 as FbsVU8
from .generated.VUnit import VUnit as FbsVUnit
from .generated.VUsize import VUsize as FbsVUsize
from .generated.ValueInstance import ValueInstance as FbsValueInstance
from .generated.WorkLog import WorkLog as FbsWorkLog
from .generated.WorklogParameter import WorklogParameter as FbsWorklogParameter
from .generated.reflection.Enum import Enum as FbsEnum
from .generated.reflection.EnumVal import EnumVal as FbsEnumVal
from .generated.reflection.Field import Field as FbsField
from .generated.reflection.KeyValue import KeyValue as FbsKeyValue
from .generated.reflection.Object import Object as FbsObject
from .generated.reflection.RPCCall import RPCCall as FbsRPCCall
from .generated.reflection.Schema import Schema as FbsSchema
from .generated.reflection.SchemaFile import SchemaFile as FbsSchemaFile
from .generated.reflection.Service import Service as FbsService
from .generated.reflection.Type import Type as FbsType
from .generated.Digest import Digest as FbsDigest
from .generated.Entry import Entry as FbsEntry
from .generated.ListEntry import ListEntry as FbsListEntry
from .generated.ParameterValue import ParameterValue as FbsParameterValue
from .generated.TaskParameterValue import TaskParameterValue as FbsTaskParameterValue
from .generated.Type import Type as FbsType
from .generated.Value import Value as FbsValue

class EntryTy(Enum):
    File = 0
    Directory = 1
    Object = 2
    TopLevelDirectory = 3


@dataclass
class File:
    account: "str"

    blob: Optional["GenericId"]

    chunks: Optional["List[Chunk]"]

    container: Optional["str"]

    digest: Optional["Digest"]

    mime: "str"

    size: "int"

    virus: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsFile) -> Self:
        account_str = o.Account()
        assert account_str is not None
        account = account_str.decode('utf-8')
        blob = None
        blob_obj = o.Blob()
        if blob_obj is not None:
            blob = GenericId.from_fbs(blob_obj)
        chunks = list()
        if not o.ChunksIsNone():
            for i in range(o.ChunksLength()):
                chunks_val = None
                chunks_obj = o.Chunks(i)
                if chunks_obj is not None:
                    chunks_val = Chunk.from_fbs(chunks_obj)
                chunks.append(chunks_val)
        container = None
        container_str = o.Container()
        if container_str is not None:
            container = container_str.decode('utf-8')
        digest = None
        digest_val = o.Digest()
        if digest_val is not None:
            digest_ty = o.DigestType()
            digest = Digest.from_fbs(digest_val, digest_ty)
        mime_str = o.Mime()
        assert mime_str is not None
        mime = mime_str.decode('utf-8')
        size = o.Size()
        virus = None
        virus_str = o.Virus()
        if virus_str is not None:
            virus = virus_str.decode('utf-8')
        return cls(account, blob, chunks, container, digest, mime, size, virus)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsFile.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.File import (
            Start,
            AddAccount,
            AddBlob,
            AddChunks,
            StartChunksVector,
            AddContainer,
            AddDigest,
            AddDigestType,
            AddMime,
            AddSize,
            AddVirus,
            End,
        )
        account_offset = builder.CreateString(self.account)
        blob_offset = None
        if self.blob is not None:
            blob_offset = self.blob.serialize_to(builder)
        chunks_offset = None
        if self.chunks is not None:
            chunks_offsets = list()
            for value in self.chunks:
                chunks_offsets.append(value.serialize_to(builder))
            StartChunksVector(builder, len(self.chunks))
            for i in reversed(range(len(self.chunks))):
                builder.PrependUOffsetTRelative(chunks_offsets[i])
            chunks_offset = builder.EndVector()
        container_offset = None
        if self.container is not None:
            container_offset = builder.CreateString(self.container)
        digest_offset, digest_ty = (None, None)
        if self.digest is not None:
            digest_offset, digest_ty = self.digest.serialize_to(builder)
        mime_offset = builder.CreateString(self.mime)
        virus_offset = None
        if self.virus is not None:
            virus_offset = builder.CreateString(self.virus)
        
        Start(builder)
        AddAccount(builder, account_offset)
        if blob_offset is not None:
            AddBlob(builder, blob_offset)
        if chunks_offset is not None:
            AddChunks(builder, chunks_offset)
        if container_offset is not None:
            AddContainer(builder, container_offset)
        if digest_offset is not None and digest_ty is not None:
            AddDigest(builder, digest_offset)
            AddDigestType(builder, digest_ty)
        AddMime(builder, mime_offset)
        AddSize(builder, self.size)
        if virus_offset is not None:
            AddVirus(builder, virus_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        account = ""
        blob = GenericId.make_default()
        chunks = []
        container = ""
        digest = Digest.make_default()
        mime = ""
        size = 0
        virus = ""
        return cls(account, blob, chunks, container, digest, mime, size, virus)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.account == other.account
        eq = eq and self.blob == other.blob
        self_chunks = self.chunks
        other_chunks = other.chunks
        if self_chunks is not None and other_chunks is not None:
            if len(self_chunks) != len(other_chunks):
                return False
            for i in range(len(self_chunks)):
                eq = eq and self_chunks[i] == other_chunks[i]
        elif self_chunks is not None and other_chunks is None:
            return False
        elif self_chunks is None and other_chunks is not None:
            return False
        eq = eq and self.container == other.container
        eq = eq and self.digest == other.digest
        eq = eq and self.mime == other.mime
        eq = eq and self.size == other.size
        eq = eq and self.virus == other.virus

        return eq

@dataclass
class Directory:
    """ This Directory table holds the entries in the actual directory
    """

    notifications: Optional["List[B2cId]"]

    slots: "List[Slot]"

    @classmethod
    def from_fbs(cls, o: FbsDirectory) -> Self:
        notifications = list()
        if not o.NotificationsIsNone():
            for i in range(o.NotificationsLength()):
                notifications_val = None
                notifications_obj = o.Notifications(i)
                if notifications_obj is not None:
                    notifications_val = B2cId.from_fbs(notifications_obj)
                notifications.append(notifications_val)
        slots = list()
        if not o.SlotsIsNone():
            for i in range(o.SlotsLength()):
                slots_val = None
                slots_obj = o.Slots(i)
                if slots_obj is not None:
                    slots_val = Slot.from_fbs(slots_obj)
                slots.append(slots_val)
        return cls(notifications, slots)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDirectory.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Directory import (
            Start,
            AddNotifications,
            StartNotificationsVector,
            AddSlots,
            StartSlotsVector,
            End,
        )
        notifications_offset = None
        if self.notifications is not None:
            notifications_offsets = list()
            for value in self.notifications:
                notifications_offsets.append(value.serialize_to(builder))
            StartNotificationsVector(builder, len(self.notifications))
            for i in reversed(range(len(self.notifications))):
                builder.PrependUOffsetTRelative(notifications_offsets[i])
            notifications_offset = builder.EndVector()
        slots_offsets = list()
        for value in self.slots:
            slots_offsets.append(value.serialize_to(builder))
        StartSlotsVector(builder, len(self.slots))
        for i in reversed(range(len(self.slots))):
            builder.PrependUOffsetTRelative(slots_offsets[i])
        slots_offset = builder.EndVector()
        
        Start(builder)
        if notifications_offset is not None:
            AddNotifications(builder, notifications_offset)
        AddSlots(builder, slots_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        notifications = []
        slots = []
        return cls(notifications, slots)

    def __eq__(self, other) -> bool:
        eq = True
        self_notifications = self.notifications
        other_notifications = other.notifications
        if self_notifications is not None and other_notifications is not None:
            if len(self_notifications) != len(other_notifications):
                return False
            for i in range(len(self_notifications)):
                eq = eq and self_notifications[i] == other_notifications[i]
        elif self_notifications is not None and other_notifications is None:
            return False
        elif self_notifications is None and other_notifications is not None:
            return False
        if len(self.slots) != len(other.slots):
            return False
        for i in range(len(self.slots)):
            eq = eq and self.slots[i] == other.slots[i]

        return eq

@dataclass
class ObjectRef:
    id: "ObjectId"

    ty: "DataCatalogObjectTy"

    @classmethod
    def from_fbs(cls, o: FbsObjectRef) -> Self:
        id_obj = o.Id()
        if id_obj is not None:
            id = ObjectId.from_fbs(id_obj)
        else:
            raise ValueError("Id is required")
        ty = DataCatalogObjectTy(o.Ty())
        return cls(id, ty)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsObjectRef.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ObjectRef import (
            Start,
            AddId,
            AddTy,
            End,
        )
        id_offset = self.id.serialize_to(builder)
        
        Start(builder)
        AddId(builder, id_offset)
        AddTy(builder, self.ty.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        id = ObjectId.make_default()
        ty = DataCatalogObjectTy(0)
        return cls(id, ty)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.id == other.id
        eq = eq and self.ty == other.ty

        return eq

@dataclass
class Entry:
    value: Union[
        "File",
        "Directory",
        "ObjectRef",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.Entry import Entry
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, File):
            return (offset, Entry().File)
        elif isinstance(self.value, Directory):
            return (offset, Entry().Directory)
        elif isinstance(self.value, ObjectRef):
            return (offset, Entry().ObjectRef)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        Entry_ty_instance = FbsEntry()
        if ty == Entry_ty_instance.File:
            val = FbsFile();
            val.Init(source, pos)
            return cls(File.from_fbs(val))
        elif ty == Entry_ty_instance.Directory:
            val = FbsDirectory();
            val.Init(source, pos)
            return cls(Directory.from_fbs(val))
        elif ty == Entry_ty_instance.ObjectRef:
            val = FbsObjectRef();
            val.Init(source, pos)
            return cls(ObjectRef.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(File.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class ListFile:
    mime: "str"

    size: "int"

    virus: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsListFile) -> Self:
        mime_str = o.Mime()
        assert mime_str is not None
        mime = mime_str.decode('utf-8')
        size = o.Size()
        virus = None
        virus_str = o.Virus()
        if virus_str is not None:
            virus = virus_str.decode('utf-8')
        return cls(mime, size, virus)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsListFile.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ListFile import (
            Start,
            AddMime,
            AddSize,
            AddVirus,
            End,
        )
        mime_offset = builder.CreateString(self.mime)
        virus_offset = None
        if self.virus is not None:
            virus_offset = builder.CreateString(self.virus)
        
        Start(builder)
        AddMime(builder, mime_offset)
        AddSize(builder, self.size)
        if virus_offset is not None:
            AddVirus(builder, virus_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        mime = ""
        size = 0
        virus = ""
        return cls(mime, size, virus)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.mime == other.mime
        eq = eq and self.size == other.size
        eq = eq and self.virus == other.virus

        return eq

@dataclass
class ListDirectory:
    @classmethod
    def from_fbs(cls, o: FbsListDirectory) -> Self:
        return cls()

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsListDirectory.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ListDirectory import (
            Start,
            End,
        )
        
        Start(builder)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        return cls()

    def __eq__(self, other) -> bool:
        eq = True

        return eq

@dataclass
class ListObject:
    id: "ObjectId"

    size: "int"

    ty: "DataCatalogObjectTy"

    @classmethod
    def from_fbs(cls, o: FbsListObject) -> Self:
        id_obj = o.Id()
        if id_obj is not None:
            id = ObjectId.from_fbs(id_obj)
        else:
            raise ValueError("Id is required")
        size = o.Size()
        ty = DataCatalogObjectTy(o.Ty())
        return cls(id, size, ty)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsListObject.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ListObject import (
            Start,
            AddId,
            AddSize,
            AddTy,
            End,
        )
        id_offset = self.id.serialize_to(builder)
        
        Start(builder)
        AddId(builder, id_offset)
        AddSize(builder, self.size)
        AddTy(builder, self.ty.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        id = ObjectId.make_default()
        size = 0
        ty = DataCatalogObjectTy(0)
        return cls(id, size, ty)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.id == other.id
        eq = eq and self.size == other.size
        eq = eq and self.ty == other.ty

        return eq

@dataclass
class TopLevelDirectory:
    b2c_entity: "B2cId"

    @classmethod
    def from_fbs(cls, o: FbsTopLevelDirectory) -> Self:
        b2c_entity_obj = o.B2cEntity()
        if b2c_entity_obj is not None:
            b2c_entity = B2cId.from_fbs(b2c_entity_obj)
        else:
            raise ValueError("B2cEntity is required")
        return cls(b2c_entity)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTopLevelDirectory.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TopLevelDirectory import (
            Start,
            AddB2cEntity,
            End,
        )
        b2c_entity_offset = self.b2c_entity.serialize_to(builder)
        
        Start(builder)
        AddB2cEntity(builder, b2c_entity_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        b2c_entity = B2cId.make_default()
        return cls(b2c_entity)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.b2c_entity == other.b2c_entity

        return eq

@dataclass
class ListEntry:
    value: Union[
        "ListFile",
        "ListDirectory",
        "ListObject",
        "TopLevelDirectory",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.ListEntry import ListEntry
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, ListFile):
            return (offset, ListEntry().ListFile)
        elif isinstance(self.value, ListDirectory):
            return (offset, ListEntry().ListDirectory)
        elif isinstance(self.value, ListObject):
            return (offset, ListEntry().ListObject)
        elif isinstance(self.value, TopLevelDirectory):
            return (offset, ListEntry().TopLevelDirectory)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        ListEntry_ty_instance = FbsListEntry()
        if ty == ListEntry_ty_instance.ListFile:
            val = FbsListFile();
            val.Init(source, pos)
            return cls(ListFile.from_fbs(val))
        elif ty == ListEntry_ty_instance.ListDirectory:
            val = FbsListDirectory();
            val.Init(source, pos)
            return cls(ListDirectory.from_fbs(val))
        elif ty == ListEntry_ty_instance.ListObject:
            val = FbsListObject();
            val.Init(source, pos)
            return cls(ListObject.from_fbs(val))
        elif ty == ListEntry_ty_instance.TopLevelDirectory:
            val = FbsTopLevelDirectory();
            val.Init(source, pos)
            return cls(TopLevelDirectory.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(ListFile.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class Attr:
    key: "str"

    v: "Value"

    @classmethod
    def from_fbs(cls, o: FbsAttr) -> Self:
        key_str = o.Key()
        assert key_str is not None
        key = key_str.decode('utf-8')
        v_val = o.V()
        if v_val is not None:
            v_ty = o.VType()
            v = Value.from_fbs(v_val, v_ty)
        else:
            raise ValueError("V is required")
        return cls(key, v)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsAttr.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Attr import (
            Start,
            AddKey,
            AddV,
            AddVType,
            End,
        )
        key_offset = builder.CreateString(self.key)
        v_offset, v_ty = self.v.serialize_to(builder)
        
        Start(builder)
        AddKey(builder, key_offset)
        AddV(builder, v_offset)
        AddVType(builder, v_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        key = ""
        v = Value.make_default()
        return cls(key, v)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.key == other.key
        eq = eq and self.v == other.v

        return eq

@dataclass
class Chunk:
    blob: "GenericId"

    digest: "Digest"

    size: "int"

    @classmethod
    def from_fbs(cls, o: FbsChunk) -> Self:
        blob_obj = o.Blob()
        if blob_obj is not None:
            blob = GenericId.from_fbs(blob_obj)
        else:
            raise ValueError("Blob is required")
        digest_val = o.Digest()
        if digest_val is not None:
            digest_ty = o.DigestType()
            digest = Digest.from_fbs(digest_val, digest_ty)
        else:
            raise ValueError("Digest is required")
        size = o.Size()
        return cls(blob, digest, size)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsChunk.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Chunk import (
            Start,
            AddBlob,
            AddDigest,
            AddDigestType,
            AddSize,
            End,
        )
        blob_offset = self.blob.serialize_to(builder)
        digest_offset, digest_ty = self.digest.serialize_to(builder)
        
        Start(builder)
        AddBlob(builder, blob_offset)
        AddDigest(builder, digest_offset)
        AddDigestType(builder, digest_ty)
        AddSize(builder, self.size)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        blob = GenericId.make_default()
        digest = Digest.make_default()
        size = 0
        return cls(blob, digest, size)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.blob == other.blob
        eq = eq and self.digest == other.digest
        eq = eq and self.size == other.size

        return eq

@dataclass
class DirectoryEntry:
    entry: "Entry"

    parent: "ObjectId"

    @classmethod
    def from_fbs(cls, o: FbsDirectoryEntry) -> Self:
        entry_val = o.Entry()
        if entry_val is not None:
            entry_ty = o.EntryType()
            entry = Entry.from_fbs(entry_val, entry_ty)
        else:
            raise ValueError("Entry is required")
        parent_obj = o.Parent()
        if parent_obj is not None:
            parent = ObjectId.from_fbs(parent_obj)
        else:
            raise ValueError("Parent is required")
        return cls(entry, parent)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDirectoryEntry.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DirectoryEntry import (
            Start,
            AddEntry,
            AddEntryType,
            AddParent,
            End,
        )
        entry_offset, entry_ty = self.entry.serialize_to(builder)
        parent_offset = self.parent.serialize_to(builder)
        
        Start(builder)
        AddEntry(builder, entry_offset)
        AddEntryType(builder, entry_ty)
        AddParent(builder, parent_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        entry = Entry.make_default()
        parent = ObjectId.make_default()
        return cls(entry, parent)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.entry == other.entry
        eq = eq and self.parent == other.parent

        return eq

@dataclass
class DirectoryList:
    slots: "List[ListSlot]"

    @classmethod
    def from_fbs(cls, o: FbsDirectoryList) -> Self:
        slots = list()
        if not o.SlotsIsNone():
            for i in range(o.SlotsLength()):
                slots_val = None
                slots_obj = o.Slots(i)
                if slots_obj is not None:
                    slots_val = ListSlot.from_fbs(slots_obj)
                slots.append(slots_val)
        return cls(slots)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDirectoryList.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DirectoryList import (
            Start,
            AddSlots,
            StartSlotsVector,
            End,
        )
        slots_offsets = list()
        for value in self.slots:
            slots_offsets.append(value.serialize_to(builder))
        StartSlotsVector(builder, len(self.slots))
        for i in reversed(range(len(self.slots))):
            builder.PrependUOffsetTRelative(slots_offsets[i])
        slots_offset = builder.EndVector()
        
        Start(builder)
        AddSlots(builder, slots_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        slots = []
        return cls(slots)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.slots) != len(other.slots):
            return False
        for i in range(len(self.slots)):
            eq = eq and self.slots[i] == other.slots[i]

        return eq

@dataclass
class ListSlot:
    attributes: Optional["List[Attr]"]

    entry: "ListEntry"

    id: "ObjectId"

    last_modified_by: Optional["B2cId"]

    name: "str"

    size: "int"

    time: "int"

    user_permissions: "int"

    @classmethod
    def from_fbs(cls, o: FbsListSlot) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = Attr.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        entry_val = o.Entry()
        if entry_val is not None:
            entry_ty = o.EntryType()
            entry = ListEntry.from_fbs(entry_val, entry_ty)
        else:
            raise ValueError("Entry is required")
        id_obj = o.Id()
        if id_obj is not None:
            id = ObjectId.from_fbs(id_obj)
        else:
            raise ValueError("Id is required")
        last_modified_by = None
        last_modified_by_obj = o.LastModifiedBy()
        if last_modified_by_obj is not None:
            last_modified_by = B2cId.from_fbs(last_modified_by_obj)
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        size = o.Size()
        time = o.Time()
        user_permissions = o.UserPermissions()
        return cls(attributes, entry, id, last_modified_by, name, size, time, user_permissions)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsListSlot.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ListSlot import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddEntry,
            AddEntryType,
            AddId,
            AddLastModifiedBy,
            AddName,
            AddSize,
            AddTime,
            AddUserPermissions,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        entry_offset, entry_ty = self.entry.serialize_to(builder)
        id_offset = self.id.serialize_to(builder)
        last_modified_by_offset = None
        if self.last_modified_by is not None:
            last_modified_by_offset = self.last_modified_by.serialize_to(builder)
        name_offset = builder.CreateString(self.name)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        AddEntry(builder, entry_offset)
        AddEntryType(builder, entry_ty)
        AddId(builder, id_offset)
        if last_modified_by_offset is not None:
            AddLastModifiedBy(builder, last_modified_by_offset)
        AddName(builder, name_offset)
        AddSize(builder, self.size)
        AddTime(builder, self.time)
        AddUserPermissions(builder, self.user_permissions)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        entry = ListEntry.make_default()
        id = ObjectId.make_default()
        last_modified_by = B2cId.make_default()
        name = ""
        size = 0
        time = 0
        user_permissions = 0
        return cls(attributes, entry, id, last_modified_by, name, size, time, user_permissions)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        eq = eq and self.entry == other.entry
        eq = eq and self.id == other.id
        eq = eq and self.last_modified_by == other.last_modified_by
        eq = eq and self.name == other.name
        eq = eq and self.size == other.size
        eq = eq and self.time == other.time
        eq = eq and self.user_permissions == other.user_permissions

        return eq

@dataclass
class MoveRequest:
    dest_name: Optional["str"]

    dest_root: Optional["ObjectId"]

    entry: "ObjectId"

    overwrite: "bool"

    @classmethod
    def from_fbs(cls, o: FbsMoveRequest) -> Self:
        dest_name = None
        dest_name_str = o.DestName()
        if dest_name_str is not None:
            dest_name = dest_name_str.decode('utf-8')
        dest_root = None
        dest_root_obj = o.DestRoot()
        if dest_root_obj is not None:
            dest_root = ObjectId.from_fbs(dest_root_obj)
        entry_obj = o.Entry()
        if entry_obj is not None:
            entry = ObjectId.from_fbs(entry_obj)
        else:
            raise ValueError("Entry is required")
        overwrite = o.Overwrite()
        return cls(dest_name, dest_root, entry, overwrite)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsMoveRequest.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.MoveRequest import (
            Start,
            AddDestName,
            AddDestRoot,
            AddEntry,
            AddOverwrite,
            End,
        )
        dest_name_offset = None
        if self.dest_name is not None:
            dest_name_offset = builder.CreateString(self.dest_name)
        dest_root_offset = None
        if self.dest_root is not None:
            dest_root_offset = self.dest_root.serialize_to(builder)
        entry_offset = self.entry.serialize_to(builder)
        
        Start(builder)
        if dest_name_offset is not None:
            AddDestName(builder, dest_name_offset)
        if dest_root_offset is not None:
            AddDestRoot(builder, dest_root_offset)
        AddEntry(builder, entry_offset)
        AddOverwrite(builder, self.overwrite)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        dest_name = ""
        dest_root = ObjectId.make_default()
        entry = ObjectId.make_default()
        overwrite = False
        return cls(dest_name, dest_root, entry, overwrite)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.dest_name == other.dest_name
        eq = eq and self.dest_root == other.dest_root
        eq = eq and self.entry == other.entry
        eq = eq and self.overwrite == other.overwrite

        return eq

@dataclass
class NewLink:
    """ Body parameter for PUT drive/<object>
    """

    name: "str"

    obj: "ObjectId"

    @classmethod
    def from_fbs(cls, o: FbsNewLink) -> Self:
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        obj_obj = o.Obj()
        if obj_obj is not None:
            obj = ObjectId.from_fbs(obj_obj)
        else:
            raise ValueError("Obj is required")
        return cls(name, obj)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNewLink.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NewLink import (
            Start,
            AddName,
            AddObj,
            End,
        )
        name_offset = builder.CreateString(self.name)
        obj_offset = self.obj.serialize_to(builder)
        
        Start(builder)
        AddName(builder, name_offset)
        AddObj(builder, obj_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        name = ""
        obj = ObjectId.make_default()
        return cls(name, obj)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.name == other.name
        eq = eq and self.obj == other.obj

        return eq

@dataclass
class Slot:
    attributes: Optional["List[Attr]"]

    id: "ObjectId"

    name: "str"

    ty: "EntryTy"

    @classmethod
    def from_fbs(cls, o: FbsSlot) -> Self:
        attributes = list()
        if not o.AttributesIsNone():
            for i in range(o.AttributesLength()):
                attributes_val = None
                attributes_obj = o.Attributes(i)
                if attributes_obj is not None:
                    attributes_val = Attr.from_fbs(attributes_obj)
                attributes.append(attributes_val)
        id_obj = o.Id()
        if id_obj is not None:
            id = ObjectId.from_fbs(id_obj)
        else:
            raise ValueError("Id is required")
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        ty = EntryTy(o.Ty())
        return cls(attributes, id, name, ty)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsSlot.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Slot import (
            Start,
            AddAttributes,
            StartAttributesVector,
            AddId,
            AddName,
            AddTy,
            End,
        )
        attributes_offset = None
        if self.attributes is not None:
            attributes_offsets = list()
            for value in self.attributes:
                attributes_offsets.append(value.serialize_to(builder))
            StartAttributesVector(builder, len(self.attributes))
            for i in reversed(range(len(self.attributes))):
                builder.PrependUOffsetTRelative(attributes_offsets[i])
            attributes_offset = builder.EndVector()
        id_offset = self.id.serialize_to(builder)
        name_offset = builder.CreateString(self.name)
        
        Start(builder)
        if attributes_offset is not None:
            AddAttributes(builder, attributes_offset)
        AddId(builder, id_offset)
        AddName(builder, name_offset)
        AddTy(builder, self.ty.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        attributes = []
        id = ObjectId.make_default()
        name = ""
        ty = EntryTy(0)
        return cls(attributes, id, name, ty)

    def __eq__(self, other) -> bool:
        eq = True
        self_attributes = self.attributes
        other_attributes = other.attributes
        if self_attributes is not None and other_attributes is not None:
            if len(self_attributes) != len(other_attributes):
                return False
            for i in range(len(self_attributes)):
                eq = eq and self_attributes[i] == other_attributes[i]
        elif self_attributes is not None and other_attributes is None:
            return False
        elif self_attributes is None and other_attributes is not None:
            return False
        eq = eq and self.id == other.id
        eq = eq and self.name == other.name
        eq = eq and self.ty == other.ty

        return eq
