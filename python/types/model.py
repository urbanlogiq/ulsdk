# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .generated.B2cId import B2cId as FbsB2cId
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.GenericId import GenericId as FbsGenericId
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.Model import Model as FbsModel
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.StreamId import StreamId as FbsStreamId


@dataclass
class Model:
    location: "ObjectId"

    name: "str"

    source: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsModel) -> Self:
        location_obj = o.Location()
        if location_obj is not None:
            location = ObjectId.from_fbs(location_obj)
        else:
            raise ValueError("Location is required")
        name_str = o.Name()
        assert name_str is not None
        name = name_str.decode('utf-8')
        source = None
        source_str = o.Source()
        if source_str is not None:
            source = source_str.decode('utf-8')
        return cls(location, name, source)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsModel.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Model import (
            Start,
            AddLocation,
            AddName,
            AddSource,
            End,
        )
        location_offset = self.location.serialize_to(builder)
        name_offset = builder.CreateString(self.name)
        source_offset = None
        if self.source is not None:
            source_offset = builder.CreateString(self.source)
        
        Start(builder)
        AddLocation(builder, location_offset)
        AddName(builder, name_offset)
        if source_offset is not None:
            AddSource(builder, source_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        location = ObjectId.make_default()
        name = ""
        source = ""
        return cls(location, name, source)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.location == other.location
        eq = eq and self.name == other.name
        eq = eq and self.source == other.source

        return eq
