# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .entity import (
    EdgeTy,
    EntityTy,
    Geometry,
    GraphEdge,
    GraphNode,
    Line,
    MultiLine,
    MultiPolygon,
    NodeTy,
    Point,
    Polygon,
)
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .generated.B2cId import B2cId as FbsB2cId
from .generated.CategoryFilter import CategoryFilter as FbsCategoryFilter
from .generated.ColumnGroup import ColumnGroup as FbsColumnGroup
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContentId import ContentId as FbsContentId
from .generated.DataStateGeometrySource import DataStateGeometrySource as FbsDataStateGeometrySource
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.DeprecatedDataStateJoin import DeprecatedDataStateJoin as FbsDeprecatedDataStateJoin
from .generated.FieldFilter import FieldFilter as FbsFieldFilter
from .generated.GenericId import GenericId as FbsGenericId
from .generated.GraphEdge import GraphEdge as FbsGraphEdge
from .generated.GraphNode import GraphNode as FbsGraphNode
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.JoinStackEntry import JoinStackEntry as FbsJoinStackEntry
from .generated.Line import Line as FbsLine
from .generated.MultiLine import MultiLine as FbsMultiLine
from .generated.MultiPolygon import MultiPolygon as FbsMultiPolygon
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.Point import Point as FbsPoint
from .generated.Polygon import Polygon as FbsPolygon
from .generated.RangeFilter import RangeFilter as FbsRangeFilter
from .generated.RawGeometrySource import RawGeometrySource as FbsRawGeometrySource
from .generated.RawGeometrySourceGeom import RawGeometrySourceGeom as FbsRawGeometrySourceGeom
from .generated.RelationshipRangeFilter import RelationshipRangeFilter as FbsRelationshipRangeFilter
from .generated.StackableDataStateJoin import StackableDataStateJoin as FbsStackableDataStateJoin
from .generated.StreamId import StreamId as FbsStreamId
from .generated.UserLayer import UserLayer as FbsUserLayer
from .generated.UserLayerDataState import UserLayerDataState as FbsUserLayerDataState
from .generated.UserProject import UserProject as FbsUserProject
from .generated.Filter import Filter as FbsFilter
from .generated.Geometry import Geometry as FbsGeometry
from .generated.JoinStackEntryGeometrySourceUnion import JoinStackEntryGeometrySourceUnion as FbsJoinStackEntryGeometrySourceUnion

class AggregateOp(Enum):
    Average = 0
    Relative = 1

class ColumnGroupType(Enum):
    None_ = 0
    Relationship = 1
    Column = 2

class FieldComparator(Enum):
    Greater = 0
    GreaterEqual = 1
    Less = 2
    LessEqual = 3
    Equal = 4
    NotEqual = 5

class JoinOperation(Enum):
    Intersect = 0
    Disjoint = 1
    BufferedIntersection = 2

class JoinType(Enum):
    Inner = 0
    Outer = 1

class LayerCombineMode(Enum):
    Union_ = 0
    Difference = 1


@dataclass
class CategoryFilter:
    column_group_id: "ColumnGroupId"

    comparator: "FieldComparator"

    include_nulls: "bool"

    values: "List[str]"

    @classmethod
    def from_fbs(cls, o: FbsCategoryFilter) -> Self:
        column_group_id_obj = o.ColumnGroupId()
        if column_group_id_obj is not None:
            column_group_id = ColumnGroupId.from_fbs(column_group_id_obj)
        else:
            raise ValueError("ColumnGroupId is required")
        comparator = FieldComparator(o.Comparator())
        include_nulls = o.IncludeNulls()
        values = list()
        if not o.ValuesIsNone():
            for i in range(o.ValuesLength()):
                values.append(o.Values(i))
        return cls(column_group_id, comparator, include_nulls, values)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsCategoryFilter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.CategoryFilter import (
            Start,
            AddColumnGroupId,
            AddComparator,
            AddIncludeNulls,
            AddValues,
            StartValuesVector,
            End,
        )
        column_group_id_offset = self.column_group_id.serialize_to(builder)
        values_offsets = list()
        for value in self.values:
            values_offsets.append(builder.CreateString(value))
        StartValuesVector(builder, len(self.values))
        for i in reversed(range(len(self.values))):
            builder.PrependUOffsetTRelative(values_offsets[i])
        values_offset = builder.EndVector()
        
        Start(builder)
        AddColumnGroupId(builder, column_group_id_offset)
        AddComparator(builder, self.comparator.value)
        AddIncludeNulls(builder, self.include_nulls)
        AddValues(builder, values_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        column_group_id = ColumnGroupId.make_default()
        comparator = FieldComparator(0)
        include_nulls = False
        values = []
        return cls(column_group_id, comparator, include_nulls, values)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.column_group_id == other.column_group_id
        eq = eq and self.comparator == other.comparator
        eq = eq and self.include_nulls == other.include_nulls
        if len(self.values) != len(other.values):
            return False
        for i in range(len(self.values)):
            eq = eq and self.values[i] == other.values[i]

        return eq

@dataclass
class RangeFilter:
    column_group_id: "ColumnGroupId"

    include_nulls: "bool"

    max: "float"

    min: "float"

    @classmethod
    def from_fbs(cls, o: FbsRangeFilter) -> Self:
        column_group_id_obj = o.ColumnGroupId()
        if column_group_id_obj is not None:
            column_group_id = ColumnGroupId.from_fbs(column_group_id_obj)
        else:
            raise ValueError("ColumnGroupId is required")
        include_nulls = o.IncludeNulls()
        max = o.Max()
        min = o.Min()
        return cls(column_group_id, include_nulls, max, min)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRangeFilter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RangeFilter import (
            Start,
            AddColumnGroupId,
            AddIncludeNulls,
            AddMax,
            AddMin,
            End,
        )
        column_group_id_offset = self.column_group_id.serialize_to(builder)
        
        Start(builder)
        AddColumnGroupId(builder, column_group_id_offset)
        AddIncludeNulls(builder, self.include_nulls)
        AddMax(builder, self.max)
        AddMin(builder, self.min)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        column_group_id = ColumnGroupId.make_default()
        include_nulls = False
        max = 0.0
        min = 0.0
        return cls(column_group_id, include_nulls, max, min)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.column_group_id == other.column_group_id
        eq = eq and self.include_nulls == other.include_nulls
        eq = eq and self.max == other.max
        eq = eq and self.min == other.min

        return eq

@dataclass
class RelationshipRangeFilter:
    aggregate_op: "AggregateOp"

    column_group_id: "ColumnGroupId"

    columns: "List[str]"

    include_nulls: "bool"

    max: "float"

    min: "float"

    @classmethod
    def from_fbs(cls, o: FbsRelationshipRangeFilter) -> Self:
        aggregate_op = AggregateOp(o.AggregateOp())
        column_group_id_obj = o.ColumnGroupId()
        if column_group_id_obj is not None:
            column_group_id = ColumnGroupId.from_fbs(column_group_id_obj)
        else:
            raise ValueError("ColumnGroupId is required")
        columns = list()
        if not o.ColumnsIsNone():
            for i in range(o.ColumnsLength()):
                columns.append(o.Columns(i))
        include_nulls = o.IncludeNulls()
        max = o.Max()
        min = o.Min()
        return cls(aggregate_op, column_group_id, columns, include_nulls, max, min)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRelationshipRangeFilter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RelationshipRangeFilter import (
            Start,
            AddAggregateOp,
            AddColumnGroupId,
            AddColumns,
            StartColumnsVector,
            AddIncludeNulls,
            AddMax,
            AddMin,
            End,
        )
        column_group_id_offset = self.column_group_id.serialize_to(builder)
        columns_offsets = list()
        for value in self.columns:
            columns_offsets.append(builder.CreateString(value))
        StartColumnsVector(builder, len(self.columns))
        for i in reversed(range(len(self.columns))):
            builder.PrependUOffsetTRelative(columns_offsets[i])
        columns_offset = builder.EndVector()
        
        Start(builder)
        AddAggregateOp(builder, self.aggregate_op.value)
        AddColumnGroupId(builder, column_group_id_offset)
        AddColumns(builder, columns_offset)
        AddIncludeNulls(builder, self.include_nulls)
        AddMax(builder, self.max)
        AddMin(builder, self.min)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        aggregate_op = AggregateOp(0)
        column_group_id = ColumnGroupId.make_default()
        columns = []
        include_nulls = False
        max = 0.0
        min = 0.0
        return cls(aggregate_op, column_group_id, columns, include_nulls, max, min)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.aggregate_op == other.aggregate_op
        eq = eq and self.column_group_id == other.column_group_id
        if len(self.columns) != len(other.columns):
            return False
        for i in range(len(self.columns)):
            eq = eq and self.columns[i] == other.columns[i]
        eq = eq and self.include_nulls == other.include_nulls
        eq = eq and self.max == other.max
        eq = eq and self.min == other.min

        return eq

@dataclass
class Filter:
    value: Union[
        "CategoryFilter",
        "RangeFilter",
        "RelationshipRangeFilter",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.Filter import Filter
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, CategoryFilter):
            return (offset, Filter().CategoryFilter)
        elif isinstance(self.value, RangeFilter):
            return (offset, Filter().RangeFilter)
        elif isinstance(self.value, RelationshipRangeFilter):
            return (offset, Filter().RelationshipRangeFilter)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        Filter_ty_instance = FbsFilter()
        if ty == Filter_ty_instance.CategoryFilter:
            val = FbsCategoryFilter();
            val.Init(source, pos)
            return cls(CategoryFilter.from_fbs(val))
        elif ty == Filter_ty_instance.RangeFilter:
            val = FbsRangeFilter();
            val.Init(source, pos)
            return cls(RangeFilter.from_fbs(val))
        elif ty == Filter_ty_instance.RelationshipRangeFilter:
            val = FbsRelationshipRangeFilter();
            val.Init(source, pos)
            return cls(RelationshipRangeFilter.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(CategoryFilter.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class DataStateGeometrySource:
    data_state_id: "DataStateId"

    @classmethod
    def from_fbs(cls, o: FbsDataStateGeometrySource) -> Self:
        data_state_id_obj = o.DataStateId()
        if data_state_id_obj is not None:
            data_state_id = DataStateId.from_fbs(data_state_id_obj)
        else:
            raise ValueError("DataStateId is required")
        return cls(data_state_id)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDataStateGeometrySource.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DataStateGeometrySource import (
            Start,
            AddDataStateId,
            End,
        )
        data_state_id_offset = self.data_state_id.serialize_to(builder)
        
        Start(builder)
        AddDataStateId(builder, data_state_id_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        data_state_id = DataStateId.make_default()
        return cls(data_state_id)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.data_state_id == other.data_state_id

        return eq

@dataclass
class RawGeometrySource:
    geoms: "List[RawGeometrySourceGeom]"

    @classmethod
    def from_fbs(cls, o: FbsRawGeometrySource) -> Self:
        geoms = list()
        if not o.GeomsIsNone():
            for i in range(o.GeomsLength()):
                geoms_val = None
                geoms_obj = o.Geoms(i)
                if geoms_obj is not None:
                    geoms_val = RawGeometrySourceGeom.from_fbs(geoms_obj)
                geoms.append(geoms_val)
        return cls(geoms)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRawGeometrySource.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RawGeometrySource import (
            Start,
            AddGeoms,
            StartGeomsVector,
            End,
        )
        geoms_offsets = list()
        for value in self.geoms:
            geoms_offsets.append(value.serialize_to(builder))
        StartGeomsVector(builder, len(self.geoms))
        for i in reversed(range(len(self.geoms))):
            builder.PrependUOffsetTRelative(geoms_offsets[i])
        geoms_offset = builder.EndVector()
        
        Start(builder)
        AddGeoms(builder, geoms_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        geoms = []
        return cls(geoms)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.geoms) != len(other.geoms):
            return False
        for i in range(len(self.geoms)):
            eq = eq and self.geoms[i] == other.geoms[i]

        return eq

@dataclass
class JoinStackEntryGeometrySourceUnion:
    value: Union[
        "DataStateGeometrySource",
        "RawGeometrySource",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.JoinStackEntryGeometrySourceUnion import JoinStackEntryGeometrySourceUnion
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, DataStateGeometrySource):
            return (offset, JoinStackEntryGeometrySourceUnion().DataStateGeometrySource)
        elif isinstance(self.value, RawGeometrySource):
            return (offset, JoinStackEntryGeometrySourceUnion().RawGeometrySource)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        JoinStackEntryGeometrySourceUnion_ty_instance = FbsJoinStackEntryGeometrySourceUnion()
        if ty == JoinStackEntryGeometrySourceUnion_ty_instance.DataStateGeometrySource:
            val = FbsDataStateGeometrySource();
            val.Init(source, pos)
            return cls(DataStateGeometrySource.from_fbs(val))
        elif ty == JoinStackEntryGeometrySourceUnion_ty_instance.RawGeometrySource:
            val = FbsRawGeometrySource();
            val.Init(source, pos)
            return cls(RawGeometrySource.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(DataStateGeometrySource.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class ColumnGroup:
    columns: "List[str]"

    display_name: "str"

    id: "ColumnGroupId"

    stream_id: Optional["StreamId"]

    ty: "ColumnGroupType"

    @classmethod
    def from_fbs(cls, o: FbsColumnGroup) -> Self:
        columns = list()
        if not o.ColumnsIsNone():
            for i in range(o.ColumnsLength()):
                columns.append(o.Columns(i))
        display_name_str = o.DisplayName()
        assert display_name_str is not None
        display_name = display_name_str.decode('utf-8')
        id_obj = o.Id()
        if id_obj is not None:
            id = ColumnGroupId.from_fbs(id_obj)
        else:
            raise ValueError("Id is required")
        stream_id = None
        stream_id_obj = o.StreamId()
        if stream_id_obj is not None:
            stream_id = StreamId.from_fbs(stream_id_obj)
        ty = ColumnGroupType(o.Ty())
        return cls(columns, display_name, id, stream_id, ty)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsColumnGroup.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ColumnGroup import (
            Start,
            AddColumns,
            StartColumnsVector,
            AddDisplayName,
            AddId,
            AddStreamId,
            AddTy,
            End,
        )
        columns_offsets = list()
        for value in self.columns:
            columns_offsets.append(builder.CreateString(value))
        StartColumnsVector(builder, len(self.columns))
        for i in reversed(range(len(self.columns))):
            builder.PrependUOffsetTRelative(columns_offsets[i])
        columns_offset = builder.EndVector()
        display_name_offset = builder.CreateString(self.display_name)
        id_offset = self.id.serialize_to(builder)
        stream_id_offset = None
        if self.stream_id is not None:
            stream_id_offset = self.stream_id.serialize_to(builder)
        
        Start(builder)
        AddColumns(builder, columns_offset)
        AddDisplayName(builder, display_name_offset)
        AddId(builder, id_offset)
        if stream_id_offset is not None:
            AddStreamId(builder, stream_id_offset)
        AddTy(builder, self.ty.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        columns = []
        display_name = ""
        id = ColumnGroupId.make_default()
        stream_id = StreamId.make_default()
        ty = ColumnGroupType(0)
        return cls(columns, display_name, id, stream_id, ty)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.columns) != len(other.columns):
            return False
        for i in range(len(self.columns)):
            eq = eq and self.columns[i] == other.columns[i]
        eq = eq and self.display_name == other.display_name
        eq = eq and self.id == other.id
        eq = eq and self.stream_id == other.stream_id
        eq = eq and self.ty == other.ty

        return eq

@dataclass
class DeprecatedDataStateJoin:
    distance: "float"

    from_: "DataStateId"

    operation: "JoinOperation"

    to: "DataStateId"

    @classmethod
    def from_fbs(cls, o: FbsDeprecatedDataStateJoin) -> Self:
        distance = o.Distance()
        from__obj = o.From_()
        if from__obj is not None:
            from_ = DataStateId.from_fbs(from__obj)
        else:
            raise ValueError("From_ is required")
        operation = JoinOperation(o.Operation())
        to_obj = o.To()
        if to_obj is not None:
            to = DataStateId.from_fbs(to_obj)
        else:
            raise ValueError("To is required")
        return cls(distance, from_, operation, to)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDeprecatedDataStateJoin.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DeprecatedDataStateJoin import (
            Start,
            AddDistance,
            AddFrom_,
            AddOperation,
            AddTo,
            End,
        )
        from__offset = self.from_.serialize_to(builder)
        to_offset = self.to.serialize_to(builder)
        
        Start(builder)
        AddDistance(builder, self.distance)
        AddFrom_(builder, from__offset)
        AddOperation(builder, self.operation.value)
        AddTo(builder, to_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        distance = 0.0
        from_ = DataStateId.make_default()
        operation = JoinOperation(0)
        to = DataStateId.make_default()
        return cls(distance, from_, operation, to)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.distance == other.distance
        eq = eq and self.from_ == other.from_
        eq = eq and self.operation == other.operation
        eq = eq and self.to == other.to

        return eq

@dataclass
class FieldFilter:
    filter: "Filter"

    @classmethod
    def from_fbs(cls, o: FbsFieldFilter) -> Self:
        filter_val = o.Filter()
        if filter_val is not None:
            filter_ty = o.FilterType()
            filter = Filter.from_fbs(filter_val, filter_ty)
        else:
            raise ValueError("Filter is required")
        return cls(filter)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsFieldFilter.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.FieldFilter import (
            Start,
            AddFilter,
            AddFilterType,
            End,
        )
        filter_offset, filter_ty = self.filter.serialize_to(builder)
        
        Start(builder)
        AddFilter(builder, filter_offset)
        AddFilterType(builder, filter_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        filter = Filter.make_default()
        return cls(filter)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.filter == other.filter

        return eq

@dataclass
class JoinStackEntry:
    buffer: "float"

    deprecated_data_state_id_do_not_use: Optional["DataStateId"]

    geometry_source: "JoinStackEntryGeometrySourceUnion"

    mode: "LayerCombineMode"

    @classmethod
    def from_fbs(cls, o: FbsJoinStackEntry) -> Self:
        buffer = o.Buffer()
        deprecated_data_state_id_do_not_use = None
        deprecated_data_state_id_do_not_use_obj = o.DeprecatedDataStateIdDoNotUse()
        if deprecated_data_state_id_do_not_use_obj is not None:
            deprecated_data_state_id_do_not_use = DataStateId.from_fbs(deprecated_data_state_id_do_not_use_obj)
        geometry_source_val = o.GeometrySource()
        if geometry_source_val is not None:
            geometry_source_ty = o.GeometrySourceType()
            geometry_source = JoinStackEntryGeometrySourceUnion.from_fbs(geometry_source_val, geometry_source_ty)
        else:
            raise ValueError("GeometrySource is required")
        mode = LayerCombineMode(o.Mode())
        return cls(buffer, deprecated_data_state_id_do_not_use, geometry_source, mode)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsJoinStackEntry.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.JoinStackEntry import (
            Start,
            AddBuffer,
            AddDeprecatedDataStateIdDoNotUse,
            AddGeometrySource,
            AddGeometrySourceType,
            AddMode,
            End,
        )
        deprecated_data_state_id_do_not_use_offset = None
        if self.deprecated_data_state_id_do_not_use is not None:
            deprecated_data_state_id_do_not_use_offset = self.deprecated_data_state_id_do_not_use.serialize_to(builder)
        geometry_source_offset, geometry_source_ty = self.geometry_source.serialize_to(builder)
        
        Start(builder)
        AddBuffer(builder, self.buffer)
        if deprecated_data_state_id_do_not_use_offset is not None:
            AddDeprecatedDataStateIdDoNotUse(builder, deprecated_data_state_id_do_not_use_offset)
        AddGeometrySource(builder, geometry_source_offset)
        AddGeometrySourceType(builder, geometry_source_ty)
        AddMode(builder, self.mode.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        buffer = 0.0
        deprecated_data_state_id_do_not_use = DataStateId.make_default()
        geometry_source = JoinStackEntryGeometrySourceUnion.make_default()
        mode = LayerCombineMode(0)
        return cls(buffer, deprecated_data_state_id_do_not_use, geometry_source, mode)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.buffer == other.buffer
        eq = eq and self.deprecated_data_state_id_do_not_use == other.deprecated_data_state_id_do_not_use
        eq = eq and self.geometry_source == other.geometry_source
        eq = eq and self.mode == other.mode

        return eq

@dataclass
class RawGeometrySourceGeom:
    geom: "Geometry"

    @classmethod
    def from_fbs(cls, o: FbsRawGeometrySourceGeom) -> Self:
        geom_val = o.Geom()
        if geom_val is not None:
            geom_ty = o.GeomType()
            geom = Geometry.from_fbs(geom_val, geom_ty)
        else:
            raise ValueError("Geom is required")
        return cls(geom)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRawGeometrySourceGeom.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RawGeometrySourceGeom import (
            Start,
            AddGeom,
            AddGeomType,
            End,
        )
        geom_offset, geom_ty = self.geom.serialize_to(builder)
        
        Start(builder)
        AddGeom(builder, geom_offset)
        AddGeomType(builder, geom_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        geom = Geometry.make_default()
        return cls(geom)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.geom == other.geom

        return eq

@dataclass
class StackableDataStateJoin:
    buffer: "float"

    join_stack: "List[JoinStackEntry]"

    op: "JoinOperation"

    target: "DataStateId"

    type: "JoinType"

    @classmethod
    def from_fbs(cls, o: FbsStackableDataStateJoin) -> Self:
        buffer = o.Buffer()
        join_stack = list()
        if not o.JoinStackIsNone():
            for i in range(o.JoinStackLength()):
                join_stack_val = None
                join_stack_obj = o.JoinStack(i)
                if join_stack_obj is not None:
                    join_stack_val = JoinStackEntry.from_fbs(join_stack_obj)
                join_stack.append(join_stack_val)
        op = JoinOperation(o.Op())
        target_obj = o.Target()
        if target_obj is not None:
            target = DataStateId.from_fbs(target_obj)
        else:
            raise ValueError("Target is required")
        type = JoinType(o.Type())
        return cls(buffer, join_stack, op, target, type)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsStackableDataStateJoin.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.StackableDataStateJoin import (
            Start,
            AddBuffer,
            AddJoinStack,
            StartJoinStackVector,
            AddOp,
            AddTarget,
            AddType,
            End,
        )
        join_stack_offsets = list()
        for value in self.join_stack:
            join_stack_offsets.append(value.serialize_to(builder))
        StartJoinStackVector(builder, len(self.join_stack))
        for i in reversed(range(len(self.join_stack))):
            builder.PrependUOffsetTRelative(join_stack_offsets[i])
        join_stack_offset = builder.EndVector()
        target_offset = self.target.serialize_to(builder)
        
        Start(builder)
        AddBuffer(builder, self.buffer)
        AddJoinStack(builder, join_stack_offset)
        AddOp(builder, self.op.value)
        AddTarget(builder, target_offset)
        AddType(builder, self.type.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        buffer = 0.0
        join_stack = []
        op = JoinOperation(0)
        target = DataStateId.make_default()
        type = JoinType(0)
        return cls(buffer, join_stack, op, target, type)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.buffer == other.buffer
        if len(self.join_stack) != len(other.join_stack):
            return False
        for i in range(len(self.join_stack)):
            eq = eq and self.join_stack[i] == other.join_stack[i]
        eq = eq and self.op == other.op
        eq = eq and self.target == other.target
        eq = eq and self.type == other.type

        return eq

@dataclass
class UserLayer:
    data_states: "List[UserLayerDataState]"

    deprecated_data_joins_do_not_use: Optional["List[DeprecatedDataStateJoin]"]

    joins: "List[StackableDataStateJoin]"

    name: Optional["str"]

    visible: "bool"

    @classmethod
    def from_fbs(cls, o: FbsUserLayer) -> Self:
        data_states = list()
        if not o.DataStatesIsNone():
            for i in range(o.DataStatesLength()):
                data_states_val = None
                data_states_obj = o.DataStates(i)
                if data_states_obj is not None:
                    data_states_val = UserLayerDataState.from_fbs(data_states_obj)
                data_states.append(data_states_val)
        deprecated_data_joins_do_not_use = list()
        if not o.DeprecatedDataJoinsDoNotUseIsNone():
            for i in range(o.DeprecatedDataJoinsDoNotUseLength()):
                deprecated_data_joins_do_not_use_val = None
                deprecated_data_joins_do_not_use_obj = o.DeprecatedDataJoinsDoNotUse(i)
                if deprecated_data_joins_do_not_use_obj is not None:
                    deprecated_data_joins_do_not_use_val = DeprecatedDataStateJoin.from_fbs(deprecated_data_joins_do_not_use_obj)
                deprecated_data_joins_do_not_use.append(deprecated_data_joins_do_not_use_val)
        joins = list()
        if not o.JoinsIsNone():
            for i in range(o.JoinsLength()):
                joins_val = None
                joins_obj = o.Joins(i)
                if joins_obj is not None:
                    joins_val = StackableDataStateJoin.from_fbs(joins_obj)
                joins.append(joins_val)
        name = None
        name_str = o.Name()
        if name_str is not None:
            name = name_str.decode('utf-8')
        visible = o.Visible()
        return cls(data_states, deprecated_data_joins_do_not_use, joins, name, visible)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUserLayer.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UserLayer import (
            Start,
            AddDataStates,
            StartDataStatesVector,
            AddDeprecatedDataJoinsDoNotUse,
            StartDeprecatedDataJoinsDoNotUseVector,
            AddJoins,
            StartJoinsVector,
            AddName,
            AddVisible,
            End,
        )
        data_states_offsets = list()
        for value in self.data_states:
            data_states_offsets.append(value.serialize_to(builder))
        StartDataStatesVector(builder, len(self.data_states))
        for i in reversed(range(len(self.data_states))):
            builder.PrependUOffsetTRelative(data_states_offsets[i])
        data_states_offset = builder.EndVector()
        deprecated_data_joins_do_not_use_offset = None
        if self.deprecated_data_joins_do_not_use is not None:
            deprecated_data_joins_do_not_use_offsets = list()
            for value in self.deprecated_data_joins_do_not_use:
                deprecated_data_joins_do_not_use_offsets.append(value.serialize_to(builder))
            StartDeprecatedDataJoinsDoNotUseVector(builder, len(self.deprecated_data_joins_do_not_use))
            for i in reversed(range(len(self.deprecated_data_joins_do_not_use))):
                builder.PrependUOffsetTRelative(deprecated_data_joins_do_not_use_offsets[i])
            deprecated_data_joins_do_not_use_offset = builder.EndVector()
        joins_offsets = list()
        for value in self.joins:
            joins_offsets.append(value.serialize_to(builder))
        StartJoinsVector(builder, len(self.joins))
        for i in reversed(range(len(self.joins))):
            builder.PrependUOffsetTRelative(joins_offsets[i])
        joins_offset = builder.EndVector()
        name_offset = None
        if self.name is not None:
            name_offset = builder.CreateString(self.name)
        
        Start(builder)
        AddDataStates(builder, data_states_offset)
        if deprecated_data_joins_do_not_use_offset is not None:
            AddDeprecatedDataJoinsDoNotUse(builder, deprecated_data_joins_do_not_use_offset)
        AddJoins(builder, joins_offset)
        if name_offset is not None:
            AddName(builder, name_offset)
        AddVisible(builder, self.visible)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        data_states = []
        deprecated_data_joins_do_not_use = []
        joins = []
        name = ""
        visible = False
        return cls(data_states, deprecated_data_joins_do_not_use, joins, name, visible)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.data_states) != len(other.data_states):
            return False
        for i in range(len(self.data_states)):
            eq = eq and self.data_states[i] == other.data_states[i]
        self_deprecated_data_joins_do_not_use = self.deprecated_data_joins_do_not_use
        other_deprecated_data_joins_do_not_use = other.deprecated_data_joins_do_not_use
        if self_deprecated_data_joins_do_not_use is not None and other_deprecated_data_joins_do_not_use is not None:
            if len(self_deprecated_data_joins_do_not_use) != len(other_deprecated_data_joins_do_not_use):
                return False
            for i in range(len(self_deprecated_data_joins_do_not_use)):
                eq = eq and self_deprecated_data_joins_do_not_use[i] == other_deprecated_data_joins_do_not_use[i]
        elif self_deprecated_data_joins_do_not_use is not None and other_deprecated_data_joins_do_not_use is None:
            return False
        elif self_deprecated_data_joins_do_not_use is None and other_deprecated_data_joins_do_not_use is not None:
            return False
        if len(self.joins) != len(other.joins):
            return False
        for i in range(len(self.joins)):
            eq = eq and self.joins[i] == other.joins[i]
        eq = eq and self.name == other.name
        eq = eq and self.visible == other.visible

        return eq

@dataclass
class UserLayerDataState:
    active_fields: "List[ColumnGroup]"

    data_state_id: "DataStateId"

    filters: "List[FieldFilter]"

    stream_id: "StreamId"

    @classmethod
    def from_fbs(cls, o: FbsUserLayerDataState) -> Self:
        active_fields = list()
        if not o.ActiveFieldsIsNone():
            for i in range(o.ActiveFieldsLength()):
                active_fields_val = None
                active_fields_obj = o.ActiveFields(i)
                if active_fields_obj is not None:
                    active_fields_val = ColumnGroup.from_fbs(active_fields_obj)
                active_fields.append(active_fields_val)
        data_state_id_obj = o.DataStateId()
        if data_state_id_obj is not None:
            data_state_id = DataStateId.from_fbs(data_state_id_obj)
        else:
            raise ValueError("DataStateId is required")
        filters = list()
        if not o.FiltersIsNone():
            for i in range(o.FiltersLength()):
                filters_val = None
                filters_obj = o.Filters(i)
                if filters_obj is not None:
                    filters_val = FieldFilter.from_fbs(filters_obj)
                filters.append(filters_val)
        stream_id_obj = o.StreamId()
        if stream_id_obj is not None:
            stream_id = StreamId.from_fbs(stream_id_obj)
        else:
            raise ValueError("StreamId is required")
        return cls(active_fields, data_state_id, filters, stream_id)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUserLayerDataState.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UserLayerDataState import (
            Start,
            AddActiveFields,
            StartActiveFieldsVector,
            AddDataStateId,
            AddFilters,
            StartFiltersVector,
            AddStreamId,
            End,
        )
        active_fields_offsets = list()
        for value in self.active_fields:
            active_fields_offsets.append(value.serialize_to(builder))
        StartActiveFieldsVector(builder, len(self.active_fields))
        for i in reversed(range(len(self.active_fields))):
            builder.PrependUOffsetTRelative(active_fields_offsets[i])
        active_fields_offset = builder.EndVector()
        data_state_id_offset = self.data_state_id.serialize_to(builder)
        filters_offsets = list()
        for value in self.filters:
            filters_offsets.append(value.serialize_to(builder))
        StartFiltersVector(builder, len(self.filters))
        for i in reversed(range(len(self.filters))):
            builder.PrependUOffsetTRelative(filters_offsets[i])
        filters_offset = builder.EndVector()
        stream_id_offset = self.stream_id.serialize_to(builder)
        
        Start(builder)
        AddActiveFields(builder, active_fields_offset)
        AddDataStateId(builder, data_state_id_offset)
        AddFilters(builder, filters_offset)
        AddStreamId(builder, stream_id_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        active_fields = []
        data_state_id = DataStateId.make_default()
        filters = []
        stream_id = StreamId.make_default()
        return cls(active_fields, data_state_id, filters, stream_id)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.active_fields) != len(other.active_fields):
            return False
        for i in range(len(self.active_fields)):
            eq = eq and self.active_fields[i] == other.active_fields[i]
        eq = eq and self.data_state_id == other.data_state_id
        if len(self.filters) != len(other.filters):
            return False
        for i in range(len(self.filters)):
            eq = eq and self.filters[i] == other.filters[i]
        eq = eq and self.stream_id == other.stream_id

        return eq

@dataclass
class UserProject:
    id: "GenericId"

    layers: "List[UserLayer]"

    name: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsUserProject) -> Self:
        id_obj = o.Id()
        if id_obj is not None:
            id = GenericId.from_fbs(id_obj)
        else:
            raise ValueError("Id is required")
        layers = list()
        if not o.LayersIsNone():
            for i in range(o.LayersLength()):
                layers_val = None
                layers_obj = o.Layers(i)
                if layers_obj is not None:
                    layers_val = UserLayer.from_fbs(layers_obj)
                layers.append(layers_val)
        name = None
        name_str = o.Name()
        if name_str is not None:
            name = name_str.decode('utf-8')
        return cls(id, layers, name)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUserProject.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UserProject import (
            Start,
            AddId,
            AddLayers,
            StartLayersVector,
            AddName,
            End,
        )
        id_offset = self.id.serialize_to(builder)
        layers_offsets = list()
        for value in self.layers:
            layers_offsets.append(value.serialize_to(builder))
        StartLayersVector(builder, len(self.layers))
        for i in reversed(range(len(self.layers))):
            builder.PrependUOffsetTRelative(layers_offsets[i])
        layers_offset = builder.EndVector()
        name_offset = None
        if self.name is not None:
            name_offset = builder.CreateString(self.name)
        
        Start(builder)
        AddId(builder, id_offset)
        AddLayers(builder, layers_offset)
        if name_offset is not None:
            AddName(builder, name_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        id = GenericId.make_default()
        layers = []
        name = ""
        return cls(id, layers, name)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.id == other.id
        if len(self.layers) != len(other.layers):
            return False
        for i in range(len(self.layers)):
            eq = eq and self.layers[i] == other.layers[i]
        eq = eq and self.name == other.name

        return eq
