# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
import json
from pyarrow import RecordBatch, BufferOutputStream, RecordBatchStreamWriter, RecordBatchStreamReader
from typing import Optional, Any, List, Dict, Self
from urllib.parse import quote_plus
from uuid import UUID
from ..request_context import RequestContext

@dataclass
class Principal:
    principal_type: "str"
    display_name: "str"
    id_: "str"
    email: "Optional[List[str]]"
    description: "Optional[str]"
    department: "Optional[str]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["principal_type"] = self.principal_type
        o["display_name"] = self.display_name
        o["id"] = self.id_
        o["email"] = None
        if self.email is not None:
            email_list = []
            for item in self.email:
                email_var = item
                email_list.append(email_var)
            o["email"] = email_list
        o["description"] = None
        if self.description is not None:
            o["description"] = self.description
        o["department"] = None
        if self.department is not None:
            o["department"] = self.department
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        principal_type = None
        display_name = None
        id_ = None
        email = None
        description = None
        department = None
    
        for key in o:
            if key == "principalType":
                principal_type_var = o[key]
                assert type(principal_type_var) is str
                principal_type = principal_type_var
            elif key == "displayName":
                display_name_var = o[key]
                assert type(display_name_var) is str
                display_name = display_name_var
            elif key == "id":
                id__var = o[key]
                assert type(id__var) is str
                id_ = id__var
            elif key == "email":
                if o[key] is not None:
                    email_var = o[key]
                    assert type(email_var) is list
                    email = []
                    for item in email_var:
                        email_item_var = item
                        assert type(email_item_var) is str
                        email_item = email_item_var
                        email.append(email_item)
                else:
                    email = None
            elif key == "description":
                if o[key] is not None:
                    description_var = o[key]
                    assert type(description_var) is str
                    description = description_var
                else:
                    description = None
            elif key == "department":
                if o[key] is not None:
                    department_var = o[key]
                    assert type(department_var) is str
                    department = department_var
                else:
                    department = None
    
        assert principal_type is not None
        assert display_name is not None
        assert id_ is not None
    
        return cls(principal_type, display_name, id_, email, description, department)

    @classmethod
    def make_default(cls) -> Self:
        principalType = ""
        displayName = ""
        id = ""
        email = None
        description = None
        department = None
    
        return cls(principalType, displayName, id, email, description, department)

@dataclass
class AdUser:
    display_name: "str"
    id_: "str"
    user_principal_name: "str"
    other_mails: "List[str]"
    department: "Optional[str]"
    created_date_time: "str"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["display_name"] = self.display_name
        o["id"] = self.id_
        o["user_principal_name"] = self.user_principal_name
        other_mails_list = []
        for item in self.other_mails:
            other_mails_var = item
            other_mails_list.append(other_mails_var)
        o["other_mails"] = other_mails_list
        o["department"] = None
        if self.department is not None:
            o["department"] = self.department
        o["created_date_time"] = self.created_date_time
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        display_name = None
        id_ = None
        user_principal_name = None
        other_mails = None
        department = None
        created_date_time = None
    
        for key in o:
            if key == "displayName":
                display_name_var = o[key]
                assert type(display_name_var) is str
                display_name = display_name_var
            elif key == "id":
                id__var = o[key]
                assert type(id__var) is str
                id_ = id__var
            elif key == "userPrincipalName":
                user_principal_name_var = o[key]
                assert type(user_principal_name_var) is str
                user_principal_name = user_principal_name_var
            elif key == "otherMails":
                other_mails_var = o[key]
                assert type(other_mails_var) is list
                other_mails = []
                for item in other_mails_var:
                    other_mails_item_var = item
                    assert type(other_mails_item_var) is str
                    other_mails_item = other_mails_item_var
                    other_mails.append(other_mails_item)
            elif key == "department":
                if o[key] is not None:
                    department_var = o[key]
                    assert type(department_var) is str
                    department = department_var
                else:
                    department = None
            elif key == "createdDateTime":
                created_date_time_var = o[key]
                assert type(created_date_time_var) is str
                created_date_time = created_date_time_var
    
        assert display_name is not None
        assert id_ is not None
        assert user_principal_name is not None
        assert other_mails is not None
        assert created_date_time is not None
    
        return cls(display_name, id_, user_principal_name, other_mails, department, created_date_time)

    @classmethod
    def make_default(cls) -> Self:
        displayName = ""
        id = ""
        userPrincipalName = ""
        otherMails = []
        department = None
        createdDateTime = ""
    
        return cls(displayName, id, userPrincipalName, otherMails, department, createdDateTime)

@dataclass
class DisplayNames:
    display_name: "str"
    id_: "str"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["display_name"] = self.display_name
        o["id"] = self.id_
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        display_name = None
        id_ = None
    
        for key in o:
            if key == "displayName":
                display_name_var = o[key]
                assert type(display_name_var) is str
                display_name = display_name_var
            elif key == "id":
                id__var = o[key]
                assert type(id__var) is str
                id_ = id__var
    
        assert display_name is not None
        assert id_ is not None
    
        return cls(display_name, id_)

    @classmethod
    def make_default(cls) -> Self:
        displayName = ""
        id = ""
    
        return cls(displayName, id)

@dataclass
class DeviceDetail:
    device_id: "Optional[str]"
    operating_system: "Optional[str]"
    browser: "Optional[str]"
    is_compliant: "Optional[bool]"
    is_managed: "Optional[bool]"
    trust_type: "Optional[str]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["device_id"] = None
        if self.device_id is not None:
            o["device_id"] = self.device_id
        o["operating_system"] = None
        if self.operating_system is not None:
            o["operating_system"] = self.operating_system
        o["browser"] = None
        if self.browser is not None:
            o["browser"] = self.browser
        o["is_compliant"] = None
        if self.is_compliant is not None:
            o["is_compliant"] = self.is_compliant
        o["is_managed"] = None
        if self.is_managed is not None:
            o["is_managed"] = self.is_managed
        o["trust_type"] = None
        if self.trust_type is not None:
            o["trust_type"] = self.trust_type
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        device_id = None
        operating_system = None
        browser = None
        is_compliant = None
        is_managed = None
        trust_type = None
    
        for key in o:
            if key == "deviceId":
                if o[key] is not None:
                    device_id_var = o[key]
                    assert type(device_id_var) is str
                    device_id = device_id_var
                else:
                    device_id = None
            elif key == "operatingSystem":
                if o[key] is not None:
                    operating_system_var = o[key]
                    assert type(operating_system_var) is str
                    operating_system = operating_system_var
                else:
                    operating_system = None
            elif key == "browser":
                if o[key] is not None:
                    browser_var = o[key]
                    assert type(browser_var) is str
                    browser = browser_var
                else:
                    browser = None
            elif key == "isCompliant":
                if o[key] is not None:
                    is_compliant_var = o[key]
                    assert type(is_compliant_var) is bool
                    is_compliant = is_compliant_var
                else:
                    is_compliant = None
            elif key == "isManaged":
                if o[key] is not None:
                    is_managed_var = o[key]
                    assert type(is_managed_var) is bool
                    is_managed = is_managed_var
                else:
                    is_managed = None
            elif key == "trustType":
                if o[key] is not None:
                    trust_type_var = o[key]
                    assert type(trust_type_var) is str
                    trust_type = trust_type_var
                else:
                    trust_type = None
    
    
        return cls(device_id, operating_system, browser, is_compliant, is_managed, trust_type)

    @classmethod
    def make_default(cls) -> Self:
        deviceId = None
        operatingSystem = None
        browser = None
        isCompliant = None
        isManaged = None
        trustType = None
    
        return cls(deviceId, operatingSystem, browser, isCompliant, isManaged, trustType)

@dataclass
class Coordinates:
    latitude: "Optional[float]"
    longitude: "Optional[float]"
    altitude: "Optional[float]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["latitude"] = None
        if self.latitude is not None:
            o["latitude"] = self.latitude
        o["longitude"] = None
        if self.longitude is not None:
            o["longitude"] = self.longitude
        o["altitude"] = None
        if self.altitude is not None:
            o["altitude"] = self.altitude
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        latitude = None
        longitude = None
        altitude = None
    
        for key in o:
            if key == "latitude":
                if o[key] is not None:
                    latitude_var = o[key]
                    assert type(latitude_var) is float
                    latitude = latitude_var
                else:
                    latitude = None
            elif key == "longitude":
                if o[key] is not None:
                    longitude_var = o[key]
                    assert type(longitude_var) is float
                    longitude = longitude_var
                else:
                    longitude = None
            elif key == "altitude":
                if o[key] is not None:
                    altitude_var = o[key]
                    assert type(altitude_var) is float
                    altitude = altitude_var
                else:
                    altitude = None
    
    
        return cls(latitude, longitude, altitude)

    @classmethod
    def make_default(cls) -> Self:
        latitude = None
        longitude = None
        altitude = None
    
        return cls(latitude, longitude, altitude)

@dataclass
class Location:
    city: "Optional[str]"
    state: "Optional[str]"
    country_or_region: "Optional[str]"
    geo_coordinates: "Optional[Coordinates]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["city"] = None
        if self.city is not None:
            o["city"] = self.city
        o["state"] = None
        if self.state is not None:
            o["state"] = self.state
        o["country_or_region"] = None
        if self.country_or_region is not None:
            o["country_or_region"] = self.country_or_region
        o["geo_coordinates"] = None
        if self.geo_coordinates is not None:
            o["geo_coordinates"] = self.geo_coordinates.to_dict()
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        city = None
        state = None
        country_or_region = None
        geo_coordinates = None
    
        for key in o:
            if key == "city":
                if o[key] is not None:
                    city_var = o[key]
                    assert type(city_var) is str
                    city = city_var
                else:
                    city = None
            elif key == "state":
                if o[key] is not None:
                    state_var = o[key]
                    assert type(state_var) is str
                    state = state_var
                else:
                    state = None
            elif key == "countryOrRegion":
                if o[key] is not None:
                    country_or_region_var = o[key]
                    assert type(country_or_region_var) is str
                    country_or_region = country_or_region_var
                else:
                    country_or_region = None
            elif key == "geoCoordinates":
                if o[key] is not None:
                    geo_coordinates_var = o[key]
                    assert type(geo_coordinates_var) is dict
                    geo_coordinates = Coordinates.from_dict(geo_coordinates_var)
                else:
                    geo_coordinates = None
    
    
        return cls(city, state, country_or_region, geo_coordinates)

    @classmethod
    def make_default(cls) -> Self:
        city = None
        state = None
        countryOrRegion = None
        geoCoordinates = None
    
        return cls(city, state, countryOrRegion, geoCoordinates)

@dataclass
class AuditLogEntry:
    id_: "Optional[str]"
    user_principal_name: "Optional[str]"
    user_id: "Optional[str]"
    created_date_time: "Optional[str]"
    ip_address: "Optional[str]"
    device_detail: "Optional[DeviceDetail]"
    location: "Optional[Location]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["id"] = None
        if self.id_ is not None:
            o["id"] = self.id_
        o["user_principal_name"] = None
        if self.user_principal_name is not None:
            o["user_principal_name"] = self.user_principal_name
        o["user_id"] = None
        if self.user_id is not None:
            o["user_id"] = self.user_id
        o["created_date_time"] = None
        if self.created_date_time is not None:
            o["created_date_time"] = self.created_date_time
        o["ip_address"] = None
        if self.ip_address is not None:
            o["ip_address"] = self.ip_address
        o["device_detail"] = None
        if self.device_detail is not None:
            o["device_detail"] = self.device_detail.to_dict()
        o["location"] = None
        if self.location is not None:
            o["location"] = self.location.to_dict()
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        id_ = None
        user_principal_name = None
        user_id = None
        created_date_time = None
        ip_address = None
        device_detail = None
        location = None
    
        for key in o:
            if key == "id":
                if o[key] is not None:
                    id__var = o[key]
                    assert type(id__var) is str
                    id_ = id__var
                else:
                    id_ = None
            elif key == "userPrincipalName":
                if o[key] is not None:
                    user_principal_name_var = o[key]
                    assert type(user_principal_name_var) is str
                    user_principal_name = user_principal_name_var
                else:
                    user_principal_name = None
            elif key == "userId":
                if o[key] is not None:
                    user_id_var = o[key]
                    assert type(user_id_var) is str
                    user_id = user_id_var
                else:
                    user_id = None
            elif key == "createdDateTime":
                if o[key] is not None:
                    created_date_time_var = o[key]
                    assert type(created_date_time_var) is str
                    created_date_time = created_date_time_var
                else:
                    created_date_time = None
            elif key == "ipAddress":
                if o[key] is not None:
                    ip_address_var = o[key]
                    assert type(ip_address_var) is str
                    ip_address = ip_address_var
                else:
                    ip_address = None
            elif key == "deviceDetail":
                if o[key] is not None:
                    device_detail_var = o[key]
                    assert type(device_detail_var) is dict
                    device_detail = DeviceDetail.from_dict(device_detail_var)
                else:
                    device_detail = None
            elif key == "location":
                if o[key] is not None:
                    location_var = o[key]
                    assert type(location_var) is dict
                    location = Location.from_dict(location_var)
                else:
                    location = None
    
    
        return cls(id_, user_principal_name, user_id, created_date_time, ip_address, device_detail, location)

    @classmethod
    def make_default(cls) -> Self:
        id = None
        userPrincipalName = None
        userId = None
        createdDateTime = None
        ipAddress = None
        deviceDetail = None
        location = None
    
        return cls(id, userPrincipalName, userId, createdDateTime, ipAddress, deviceDetail, location)

@dataclass
class AuditLog:
    value: "List[List[AuditLogEntry]]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        value_list = []
        for item in self.value:
            value_var_list = []
            for item in item:
                value_var_var = item.to_dict()
                value_var_list.append(value_var_var)
            value_var = value_var_list
            value_list.append(value_var)
        o["value"] = value_list
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        value = None
    
        for key in o:
            if key == "value":
                value_var = o[key]
                assert type(value_var) is list
                value = []
                for item in value_var:
                    value_item_var = item
                    assert type(value_item_var) is list
                    value_item = []
                    for item in value_item_var:
                        value_item_item_var = item
                        assert type(value_item_item_var) is dict
                        value_item_item = AuditLogEntry.from_dict(value_item_item_var)
                        value_item.append(value_item_item)
                    value.append(value_item)
    
        assert value is not None
    
        return cls(value)

    @classmethod
    def make_default(cls) -> Self:
        value = []
    
        return cls(value)

@dataclass
class AdUserWithAuditLog:
    display_name: "str"
    id_: "str"
    user_principal_name: "str"
    other_mails: "List[str]"
    department: "Optional[str]"
    created_date_time: "str"
    audit_log: "Optional[AuditLog]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["display_name"] = self.display_name
        o["id"] = self.id_
        o["user_principal_name"] = self.user_principal_name
        other_mails_list = []
        for item in self.other_mails:
            other_mails_var = item
            other_mails_list.append(other_mails_var)
        o["other_mails"] = other_mails_list
        o["department"] = None
        if self.department is not None:
            o["department"] = self.department
        o["created_date_time"] = self.created_date_time
        o["audit_log"] = None
        if self.audit_log is not None:
            o["audit_log"] = self.audit_log.to_dict()
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        display_name = None
        id_ = None
        user_principal_name = None
        other_mails = None
        department = None
        created_date_time = None
        audit_log = None
    
        for key in o:
            if key == "displayName":
                display_name_var = o[key]
                assert type(display_name_var) is str
                display_name = display_name_var
            elif key == "id":
                id__var = o[key]
                assert type(id__var) is str
                id_ = id__var
            elif key == "userPrincipalName":
                user_principal_name_var = o[key]
                assert type(user_principal_name_var) is str
                user_principal_name = user_principal_name_var
            elif key == "otherMails":
                other_mails_var = o[key]
                assert type(other_mails_var) is list
                other_mails = []
                for item in other_mails_var:
                    other_mails_item_var = item
                    assert type(other_mails_item_var) is str
                    other_mails_item = other_mails_item_var
                    other_mails.append(other_mails_item)
            elif key == "department":
                if o[key] is not None:
                    department_var = o[key]
                    assert type(department_var) is str
                    department = department_var
                else:
                    department = None
            elif key == "createdDateTime":
                created_date_time_var = o[key]
                assert type(created_date_time_var) is str
                created_date_time = created_date_time_var
            elif key == "auditLog":
                if o[key] is not None:
                    audit_log_var = o[key]
                    assert type(audit_log_var) is dict
                    audit_log = AuditLog.from_dict(audit_log_var)
                else:
                    audit_log = None
    
        assert display_name is not None
        assert id_ is not None
        assert user_principal_name is not None
        assert other_mails is not None
        assert created_date_time is not None
    
        return cls(display_name, id_, user_principal_name, other_mails, department, created_date_time, audit_log)

    @classmethod
    def make_default(cls) -> Self:
        displayName = ""
        id = ""
        userPrincipalName = ""
        otherMails = []
        department = None
        createdDateTime = ""
        auditLog = None
    
        return cls(displayName, id, userPrincipalName, otherMails, department, createdDateTime, auditLog)

@dataclass
class CreateUser:
    user: "AdUser"
    password: "str"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["user"] = self.user.to_dict()
        o["password"] = self.password
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        user = None
        password = None
    
        for key in o:
            if key == "user":
                user_var = o[key]
                assert type(user_var) is dict
                user = AdUser.from_dict(user_var)
            elif key == "password":
                password_var = o[key]
                assert type(password_var) is str
                password = password_var
    
        assert user is not None
        assert password is not None
    
        return cls(user, password)

    @classmethod
    def make_default(cls) -> Self:
        user = AdUser.make_default()
        password = ""
    
        return cls(user, password)

@dataclass
class UpdateCurrentUser:
    display_name: "Optional[str]"
    other_mails: "Optional[List[str]]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["display_name"] = None
        if self.display_name is not None:
            o["display_name"] = self.display_name
        o["other_mails"] = None
        if self.other_mails is not None:
            other_mails_list = []
            for item in self.other_mails:
                other_mails_var = item
                other_mails_list.append(other_mails_var)
            o["other_mails"] = other_mails_list
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        display_name = None
        other_mails = None
    
        for key in o:
            if key == "displayName":
                if o[key] is not None:
                    display_name_var = o[key]
                    assert type(display_name_var) is str
                    display_name = display_name_var
                else:
                    display_name = None
            elif key == "otherMails":
                if o[key] is not None:
                    other_mails_var = o[key]
                    assert type(other_mails_var) is list
                    other_mails = []
                    for item in other_mails_var:
                        other_mails_item_var = item
                        assert type(other_mails_item_var) is str
                        other_mails_item = other_mails_item_var
                        other_mails.append(other_mails_item)
                else:
                    other_mails = None
    
    
        return cls(display_name, other_mails)

    @classmethod
    def make_default(cls) -> Self:
        displayName = None
        otherMails = None
    
        return cls(displayName, otherMails)

@dataclass
class UpdateUser:
    display_name: "Optional[str]"
    other_mails: "Optional[List[str]]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["display_name"] = None
        if self.display_name is not None:
            o["display_name"] = self.display_name
        o["other_mails"] = None
        if self.other_mails is not None:
            other_mails_list = []
            for item in self.other_mails:
                other_mails_var = item
                other_mails_list.append(other_mails_var)
            o["other_mails"] = other_mails_list
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        display_name = None
        other_mails = None
    
        for key in o:
            if key == "displayName":
                if o[key] is not None:
                    display_name_var = o[key]
                    assert type(display_name_var) is str
                    display_name = display_name_var
                else:
                    display_name = None
            elif key == "otherMails":
                if o[key] is not None:
                    other_mails_var = o[key]
                    assert type(other_mails_var) is list
                    other_mails = []
                    for item in other_mails_var:
                        other_mails_item_var = item
                        assert type(other_mails_item_var) is str
                        other_mails_item = other_mails_item_var
                        other_mails.append(other_mails_item)
                else:
                    other_mails = None
    
    
        return cls(display_name, other_mails)

    @classmethod
    def make_default(cls) -> Self:
        displayName = None
        otherMails = None
    
        return cls(displayName, otherMails)

@dataclass
class AdGroup:
    id_: "str"
    display_name: "str"
    description: "Optional[str]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["id"] = self.id_
        o["display_name"] = self.display_name
        o["description"] = None
        if self.description is not None:
            o["description"] = self.description
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        id_ = None
        display_name = None
        description = None
    
        for key in o:
            if key == "id":
                id__var = o[key]
                assert type(id__var) is str
                id_ = id__var
            elif key == "displayName":
                display_name_var = o[key]
                assert type(display_name_var) is str
                display_name = display_name_var
            elif key == "description":
                if o[key] is not None:
                    description_var = o[key]
                    assert type(description_var) is str
                    description = description_var
                else:
                    description = None
    
        assert id_ is not None
        assert display_name is not None
    
        return cls(id_, display_name, description)

    @classmethod
    def make_default(cls) -> Self:
        id = ""
        displayName = ""
        description = None
    
        return cls(id, displayName, description)

@dataclass
class CreateGroup:
    display_name: "str"
    description: "Optional[str]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["display_name"] = self.display_name
        o["description"] = None
        if self.description is not None:
            o["description"] = self.description
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        display_name = None
        description = None
    
        for key in o:
            if key == "displayName":
                display_name_var = o[key]
                assert type(display_name_var) is str
                display_name = display_name_var
            elif key == "description":
                if o[key] is not None:
                    description_var = o[key]
                    assert type(description_var) is str
                    description = description_var
                else:
                    description = None
    
        assert display_name is not None
    
        return cls(display_name, description)

    @classmethod
    def make_default(cls) -> Self:
        displayName = ""
        description = None
    
        return cls(displayName, description)

@dataclass
class GroupMembership:
    id_: "str"
    object_type: "str"
    display_name: "str"
    other_mails: "Optional[List[str]]"
    department: "Optional[str]"
    created_date_time: "Optional[str]"

    def to_dict(self) -> Dict[str, Any]:
        o = dict()
        o["id"] = self.id_
        o["object_type"] = self.object_type
        o["display_name"] = self.display_name
        o["other_mails"] = None
        if self.other_mails is not None:
            other_mails_list = []
            for item in self.other_mails:
                other_mails_var = item
                other_mails_list.append(other_mails_var)
            o["other_mails"] = other_mails_list
        o["department"] = None
        if self.department is not None:
            o["department"] = self.department
        o["created_date_time"] = None
        if self.created_date_time is not None:
            o["created_date_time"] = self.created_date_time
        return o

    @classmethod
    def from_dict(cls, o: Dict[str, Any]) -> Self:
        id_ = None
        object_type = None
        display_name = None
        other_mails = None
        department = None
        created_date_time = None
    
        for key in o:
            if key == "id":
                id__var = o[key]
                assert type(id__var) is str
                id_ = id__var
            elif key == "objectType":
                object_type_var = o[key]
                assert type(object_type_var) is str
                object_type = object_type_var
            elif key == "displayName":
                display_name_var = o[key]
                assert type(display_name_var) is str
                display_name = display_name_var
            elif key == "otherMails":
                if o[key] is not None:
                    other_mails_var = o[key]
                    assert type(other_mails_var) is list
                    other_mails = []
                    for item in other_mails_var:
                        other_mails_item_var = item
                        assert type(other_mails_item_var) is str
                        other_mails_item = other_mails_item_var
                        other_mails.append(other_mails_item)
                else:
                    other_mails = None
            elif key == "department":
                if o[key] is not None:
                    department_var = o[key]
                    assert type(department_var) is str
                    department = department_var
                else:
                    department = None
            elif key == "createdDateTime":
                if o[key] is not None:
                    created_date_time_var = o[key]
                    assert type(created_date_time_var) is str
                    created_date_time = created_date_time_var
                else:
                    created_date_time = None
    
        assert id_ is not None
        assert object_type is not None
        assert display_name is not None
    
        return cls(id_, object_type, display_name, other_mails, department, created_date_time)

    @classmethod
    def make_default(cls) -> Self:
        id = ""
        objectType = ""
        displayName = ""
        otherMails = None
        department = None
        createdDateTime = None
    
        return cls(id, objectType, displayName, otherMails, department, createdDateTime)

def get_principal(
    ctx: RequestContext,
    id_: UUID,
) -> Principal:
    """Retrieves a single principal by id.

    Arguments:
    ctx: RequestContext -- A request context object
    id_: UUID -- The ID (uuid-style) of the principal to search for

    Returns:
    Details of the specified principal
    """

    path = "/v1/api/uldirectory/v1/principal/:id"
    path.replace(":id", str(id_), 1)

    params = dict()
    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    return Principal.from_dict(res_dict)

def get_principals(
    ctx: RequestContext,
    ids: str,
) -> List[Principal]:
    """Retrieves a list of principals specified by a comma-separated list of ids.

    Arguments:
    ctx: RequestContext -- A request context object
    ids: str -- The comma separated list of IDs (uuid-style) of the principals to search for

    Returns:
    Details of all the specified principals
    """

    path = "/v1/api/uldirectory/v1/principal/:ids"
    path.replace(":ids", str(ids), 1)

    params = dict()
    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    res_list = []
    for item in res_dict:
        res_list.append(Principal.from_dict(item))
    return res_list

def query_principals(
    ctx: RequestContext,
    query: str,
) -> List[Principal]:
    """Queries for principals. The query is performed as a substring match against the following fields:
    For users:
    - displayName
    - id
    - otherMails
    For groups:
    - displayName
    - id
    - description

    Arguments:
    ctx: RequestContext -- A request context object
    query: str -- The query string to search for

    Returns:
    A list of all matching directory principals.
    """

    path = "/v1/api/uldirectory/v1/principals/:query"
    path.replace(":query", str(query), 1)

    params = dict()
    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    res_list = []
    for item in res_dict:
        res_list.append(Principal.from_dict(item))
    return res_list

def get_users(
    ctx: RequestContext,
) -> List[AdUser]:
    """Retrieves details of all users in the directory that are visible to the current user.

    Arguments:
    ctx: RequestContext -- A request context object

    Returns:
    Details of all specified users.
    """

    path = "/v1/api/uldirectory/v1/users"
    params = dict()
    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    res_list = []
    for item in res_dict:
        res_list.append(AdUser.from_dict(item))
    return res_list

def get_users_display_names(
    ctx: RequestContext,
) -> List[DisplayNames]:
    """Retrieves the id and display name of every user in the directory.

    Arguments:
    ctx: RequestContext -- A request context object

    Returns:
    The list of users including their IDs and their display names
    """

    path = "/v1/api/uldirectory/v1/users/display_names"
    params = dict()
    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    res_list = []
    for item in res_dict:
        res_list.append(DisplayNames.from_dict(item))
    return res_list

def get_current_user(
    ctx: RequestContext,
    audit_log: Optional[bool],
) -> AdUserWithAuditLog:
    """Retrieves details of the current user.

    Arguments:
    ctx: RequestContext -- A request context object
    audit_log: Optional[bool] -- Whether to include the user's audit log in the response.

    Returns:
    The complete details of the specified user, including audit log if specified.
    """

    path = "/v1/api/uldirectory/v1/user"
    params = dict()
    if audit_log is not None:
        params["audit_log"] = "true" if audit_log else "false"

    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    return AdUserWithAuditLog.from_dict(res_dict)

def create_user(
    ctx: RequestContext,
) -> CreateUser:
    """Creates a new user in the directory.

    Arguments:
    ctx: RequestContext -- A request context object

    Returns:
    The details of the user along with their temporary, one-time-use password.
    """

    path = "/v1/api/uldirectory/v1/user"
    params = dict()
    headers = dict()
    body = None
    res = ctx.post(path, body=body, mimetype="text/plain", params=params, headers=headers)
    res_dict = json.loads(res)
    return CreateUser.from_dict(res_dict)

def update_current_user(
    ctx: RequestContext,
    update_user_request: UpdateCurrentUser,
) -> None:
    """Updates the current user.

    Arguments:
    ctx: RequestContext -- A request context object
    update_user_request: UpdateCurrentUser -- The details which which to update the current user
    """

    path = "/v1/api/uldirectory/v1/user"
    params = dict()
    headers = dict()
    body = json.dumps(update_user_request.to_dict())
    ctx.put(path, body=body, mimetype="application/json", params=params, headers=headers)
    return

def get_user(
    ctx: RequestContext,
    id_: UUID,
    audit_log: Optional[bool],
) -> AdUserWithAuditLog:
    """Retrieves details of a user by id.

    Arguments:
    ctx: RequestContext -- A request context object
    id_: UUID -- The ID of the user to retrieve details for
    audit_log: Optional[bool] -- Whether to include the user's audit log in the response.

    Returns:
    The complete details of the specified user, including audit log if specified.
    """

    path = "/v1/api/uldirectory/v1/user/:id"
    path.replace(":id", str(id_), 1)

    params = dict()
    if audit_log is not None:
        params["audit_log"] = "true" if audit_log else "false"

    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    return AdUserWithAuditLog.from_dict(res_dict)

def update_user(
    ctx: RequestContext,
    id_: UUID,
    update_user_request: UpdateUser,
) -> None:
    """Updates a user by id.

    Arguments:
    ctx: RequestContext -- A request context object
    id_: UUID -- The ID of the user to update
    update_user_request: UpdateUser -- The details which which to update the user
    """

    path = "/v1/api/uldirectory/v1/user/:id"
    path.replace(":id", str(id_), 1)

    params = dict()
    headers = dict()
    body = json.dumps(update_user_request.to_dict())
    ctx.put(path, body=body, mimetype="application/json", params=params, headers=headers)
    return

def delete_user(
    ctx: RequestContext,
    id_: UUID,
) -> None:
    """Deletes a user by id.

    Arguments:
    ctx: RequestContext -- A request context object
    id_: UUID -- The ID of the user to delete
    """

    path = "/v1/api/uldirectory/v1/user/:id"
    path.replace(":id", str(id_), 1)

    params = dict()
    headers = dict()
    ctx.delete(path, params=params, headers=headers)
    return

def get_groups(
    ctx: RequestContext,
) -> List[AdGroup]:
    """Retrieves a listing of all groups in the directory.

    Arguments:
    ctx: RequestContext -- A request context object

    Returns:
    A list of all the groups from the directory for which the current user is allowed to see.
    """

    path = "/v1/api/uldirectory/v1/group"
    params = dict()
    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    res_list = []
    for item in res_dict:
        res_list.append(AdGroup.from_dict(item))
    return res_list

def create_group(
    ctx: RequestContext,
    create_group_request: CreateGroup,
) -> AdGroup:
    """Creates a new group in the directory.

    Arguments:
    ctx: RequestContext -- A request context object
    create_group_request: CreateGroup -- The group creation request details

    Returns:
    Details of the created group
    """

    path = "/v1/api/uldirectory/v1/group"
    params = dict()
    headers = dict()
    body = json.dumps(create_group_request.to_dict())
    res = ctx.post(path, body=body, mimetype="application/json", params=params, headers=headers)
    res_dict = json.loads(res)
    return AdGroup.from_dict(res_dict)

def get_group_members(
    ctx: RequestContext,
    id_: UUID,
) -> List[GroupMembership]:
    """Retrieves a listing of all members of a group by group id.

    Arguments:
    ctx: RequestContext -- A request context object
    id_: UUID -- The ID of the group to retrieve members for

    Returns:
    The grouyp membership list.
    """

    path = "/v1/api/uldirectory/v1/group/:id/members"
    path.replace(":id", str(id_), 1)

    params = dict()
    headers = dict()
    res = ctx.get(path, params=params, headers=headers)
    res_dict = json.loads(res)
    res_list = []
    for item in res_dict:
        res_list.append(GroupMembership.from_dict(item))
    return res_list

def delete_group(
    ctx: RequestContext,
    id_: UUID,
) -> None:
    """Deletes a group by id.

    Arguments:
    ctx: RequestContext -- A request context object
    id_: UUID -- The ID of the group to delete
    """

    path = "/v1/api/uldirectory/v1/group/:id"
    path.replace(":id", str(id_), 1)

    params = dict()
    headers = dict()
    ctx.delete(path, params=params, headers=headers)
    return

def add_group_member(
    ctx: RequestContext,
    group: UUID,
    member: UUID,
) -> None:
    """Adds a member to a group.

    Arguments:
    ctx: RequestContext -- A request context object
    group: UUID -- The ID of the group to which to add the member
    member: UUID -- The ID of the member to add
    """

    path = "/v1/api/uldirectory/v1/group/:group/:member"
    path.replace(":group", str(group), 1)
    path.replace(":member", str(member), 1)

    params = dict()
    headers = dict()
    body = None
    ctx.put(path, body=body, mimetype="text/plain", params=params, headers=headers)
    return

def remove_group_member(
    ctx: RequestContext,
    group: UUID,
    member: UUID,
) -> None:
    """Removes a member from a group.

    Arguments:
    ctx: RequestContext -- A request context object
    group: UUID -- The ID of the group from which to remove the member
    member: UUID -- The ID of the member to remove
    """

    path = "/v1/api/uldirectory/v1/group/:group/:member"
    path.replace(":group", str(group), 1)
    path.replace(":member", str(member), 1)

    params = dict()
    headers = dict()
    ctx.delete(path, params=params, headers=headers)
    return
