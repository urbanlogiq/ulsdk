# automatically generated by the FlatBuffers compiler, do not modify

# namespace: 

import flatbuffers
from flatbuffers.compat import import_numpy
from typing import Any
from .DatasetSource import DatasetSource
from .UlField import UlField
from .UlFieldRelationship import UlFieldRelationship
from flatbuffers.table import Table
from typing import Optional
np = import_numpy()

class Metadata(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset: int = 0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Metadata()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsMetadata(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Metadata
    def Init(self, buf: bytes, pos: int):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Metadata
    def DisplayName(self) -> Optional[bytes]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def Description(self) -> Optional[bytes]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Metadata
    def Fields(self, j: int) -> Optional[UlField]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = UlField()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Metadata
    def FieldsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Metadata
    def FieldsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # Metadata
    def Summary(self, j: int):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Metadata
    def SummaryAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Metadata
    def SummaryLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Metadata
    def SummaryIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # Organizational category for frontend. Defaults to DC_HIDDEN.
    # Metadata
    def DatasetCategory(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 4294967295

    # Field groupings e.g. age ranges, ethnicities or hierarchical codes like zoning and NAICS
    # Metadata
    def FieldRelationships(self, j: int) -> Optional[UlFieldRelationship]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = UlFieldRelationship()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Metadata
    def FieldRelationshipsLength(self) -> int:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Metadata
    def FieldRelationshipsIsNone(self) -> bool:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        return o == 0

    # An optional field that is meant to provide information to the user on
    # where the data has come from
    # Metadata
    def Source(self) -> Optional[DatasetSource]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = DatasetSource()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Metadata
    def GeometrySourceType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # Metadata
    def GeometrySource(self) -> Optional[flatbuffers.table.Table]:
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

    # is to be included in the boundary selection modal
    # Metadata
    def AreaSelection(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # do not use user's viewport bounding box when fetching this stream's geometry from worldgraph
    # Metadata
    def DoNotFilterGeometryByViewport(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Metadata
    def EntityTy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # Metadata
    def UpdateCadence(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def MetadataStart(builder: flatbuffers.Builder):
    builder.StartObject(13)

def Start(builder: flatbuffers.Builder):
    MetadataStart(builder)

def MetadataAddDisplayName(builder: flatbuffers.Builder, displayName: int):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(displayName), 0)

def AddDisplayName(builder: flatbuffers.Builder, displayName: int):
    MetadataAddDisplayName(builder, displayName)

def MetadataAddDescription(builder: flatbuffers.Builder, description: int):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(description), 0)

def AddDescription(builder: flatbuffers.Builder, description: int):
    MetadataAddDescription(builder, description)

def MetadataAddFields(builder: flatbuffers.Builder, fields: int):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(fields), 0)

def AddFields(builder: flatbuffers.Builder, fields: int):
    MetadataAddFields(builder, fields)

def MetadataStartFieldsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartFieldsVector(builder, numElems: int) -> int:
    return MetadataStartFieldsVector(builder, numElems)

def MetadataAddSummary(builder: flatbuffers.Builder, summary: int):
    builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(summary), 0)

def AddSummary(builder: flatbuffers.Builder, summary: int):
    MetadataAddSummary(builder, summary)

def MetadataStartSummaryVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartSummaryVector(builder, numElems: int) -> int:
    return MetadataStartSummaryVector(builder, numElems)

def MetadataAddDatasetCategory(builder: flatbuffers.Builder, datasetCategory: int):
    builder.PrependUint32Slot(4, datasetCategory, 4294967295)

def AddDatasetCategory(builder: flatbuffers.Builder, datasetCategory: int):
    MetadataAddDatasetCategory(builder, datasetCategory)

def MetadataAddFieldRelationships(builder: flatbuffers.Builder, fieldRelationships: int):
    builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(fieldRelationships), 0)

def AddFieldRelationships(builder: flatbuffers.Builder, fieldRelationships: int):
    MetadataAddFieldRelationships(builder, fieldRelationships)

def MetadataStartFieldRelationshipsVector(builder, numElems: int) -> int:
    return builder.StartVector(4, numElems, 4)

def StartFieldRelationshipsVector(builder, numElems: int) -> int:
    return MetadataStartFieldRelationshipsVector(builder, numElems)

def MetadataAddSource(builder: flatbuffers.Builder, source: int):
    builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(source), 0)

def AddSource(builder: flatbuffers.Builder, source: int):
    MetadataAddSource(builder, source)

def MetadataAddGeometrySourceType(builder: flatbuffers.Builder, geometrySourceType: int):
    builder.PrependUint8Slot(7, geometrySourceType, 0)

def AddGeometrySourceType(builder: flatbuffers.Builder, geometrySourceType: int):
    MetadataAddGeometrySourceType(builder, geometrySourceType)

def MetadataAddGeometrySource(builder: flatbuffers.Builder, geometrySource: int):
    builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(geometrySource), 0)

def AddGeometrySource(builder: flatbuffers.Builder, geometrySource: int):
    MetadataAddGeometrySource(builder, geometrySource)

def MetadataAddAreaSelection(builder: flatbuffers.Builder, areaSelection: bool):
    builder.PrependBoolSlot(9, areaSelection, 0)

def AddAreaSelection(builder: flatbuffers.Builder, areaSelection: bool):
    MetadataAddAreaSelection(builder, areaSelection)

def MetadataAddDoNotFilterGeometryByViewport(builder: flatbuffers.Builder, doNotFilterGeometryByViewport: bool):
    builder.PrependBoolSlot(10, doNotFilterGeometryByViewport, 0)

def AddDoNotFilterGeometryByViewport(builder: flatbuffers.Builder, doNotFilterGeometryByViewport: bool):
    MetadataAddDoNotFilterGeometryByViewport(builder, doNotFilterGeometryByViewport)

def MetadataAddEntityTy(builder: flatbuffers.Builder, entityTy: int):
    builder.PrependInt32Slot(11, entityTy, 0)

def AddEntityTy(builder: flatbuffers.Builder, entityTy: int):
    MetadataAddEntityTy(builder, entityTy)

def MetadataAddUpdateCadence(builder: flatbuffers.Builder, updateCadence: int):
    builder.PrependUint32Slot(12, updateCadence, 0)

def AddUpdateCadence(builder: flatbuffers.Builder, updateCadence: int):
    MetadataAddUpdateCadence(builder, updateCadence)

def MetadataEnd(builder: flatbuffers.Builder) -> int:
    return builder.EndObject()

def End(builder: flatbuffers.Builder) -> int:
    return MetadataEnd(builder)
