# Copyright (c), CommunityLogiq Software
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT

from dataclasses import dataclass
from enum import Enum
from flatbuffers.table import Table
from flatbuffers.builder import Builder
from flatbuffers.util import RemoveSizePrefix
from typing import Union, List, Optional, Self, Tuple
from .Schema import (
    Binary,
    Bool,
    Buffer,
    Date,
    DateUnit,
    Decimal,
    DictionaryEncoding,
    DictionaryKind,
    Duration,
    Endianness,
    Feature,
    Field,
    FixedSizeBinary,
    FixedSizeList,
    FloatingPoint,
    Int,
    Interval,
    IntervalUnit,
    KeyValue,
    LargeBinary,
    LargeList,
    LargeUtf8,
    List_,
    Map,
    MetadataVersion,
    Null,
    Precision,
    Schema,
    Struct_,
    Time,
    TimeUnit,
    Timestamp,
    Type,
    Union_,
    UnionMode,
    Utf8,
)
from .api import SortOrder
from .data import (
    AttributePair,
    DayOfWeek,
    DirectionAndRoadName,
    DirectionAndRoadNames,
    DirectionTy,
    NamedParameter,
    NamedParameterFlags,
    RoadUserTy,
    Source,
    StatisticTy,
    TimeGranularity,
    TurnTy,
)
from .entity import (
    EdgeTy,
    EntityTy,
    Geometry,
    GraphEdge,
    GraphNode,
    Line,
    MultiLine,
    MultiPolygon,
    NodeTy,
    Point,
    Polygon,
)
from .fun import Fn
from .graph import (
    EdgeList,
    EdgeQuery,
    Geom,
    GeomOp,
    GraphQuery,
    NodeIdPair,
    NodeList,
    NodeQuery,
    OrderBy,
    Predicate,
    Projection,
    QueryPathElement,
    QueryPathElementUnion,
    ValueTransform,
)
from .id import (
    B2cId,
    ColumnGroupId,
    ContentId,
    DataStateId,
    GenericId,
    GraphNodeId,
    ObjectId,
    ObjectNamespace,
    StreamId,
)
from .reflection import (
    ReflectionAdvancedFeatures,
    ReflectionBaseType,
    ReflectionEnum,
    ReflectionEnumVal,
    ReflectionField,
    ReflectionKeyValue,
    ReflectionObject,
    ReflectionRPCCall,
    ReflectionSchema,
    ReflectionSchemaFile,
    ReflectionService,
    ReflectionType,
)
from .value import (
    Point2D,
    Tri2D,
    VArray,
    VBool,
    VBytes,
    VChar,
    VF32,
    VF64,
    VFixedSizeBytes,
    VI16,
    VI32,
    VI64,
    VI8,
    VIsize,
    VNull,
    VStr,
    VTimestampMs,
    VTimestampMsUtc,
    VTimestampNs,
    VTimestampNsUtc,
    VTri2D,
    VU16,
    VU32,
    VU64,
    VU8,
    VUnit,
    VUsize,
    Value,
    ValueInstance,
    ValueTy,
)
from .generated.AttributePair import AttributePair as FbsAttributePair
from .generated.B2cId import B2cId as FbsB2cId
from .generated.Binary import Binary as FbsBinary
from .generated.Bool import Bool as FbsBool
from .generated.Buffer import Buffer as FbsBuffer
from .generated.CategoryRelationshipData import CategoryRelationshipData as FbsCategoryRelationshipData
from .generated.ColumnGroupId import ColumnGroupId as FbsColumnGroupId
from .generated.ContactInfo import ContactInfo as FbsContactInfo
from .generated.ContentId import ContentId as FbsContentId
from .generated.DataStateId import DataStateId as FbsDataStateId
from .generated.DatacatalogGeometry import DatacatalogGeometry as FbsDatacatalogGeometry
from .generated.DatasetSource import DatasetSource as FbsDatasetSource
from .generated.Date import Date as FbsDate
from .generated.Dates import Dates as FbsDates
from .generated.DatetimeRange import DatetimeRange as FbsDatetimeRange
from .generated.Decimal import Decimal as FbsDecimal
from .generated.DictionaryEncoding import DictionaryEncoding as FbsDictionaryEncoding
from .generated.DirectionAndRoadName import DirectionAndRoadName as FbsDirectionAndRoadName
from .generated.DirectionAndRoadNames import DirectionAndRoadNames as FbsDirectionAndRoadNames
from .generated.Document import Document as FbsDocument
from .generated.Documents import Documents as FbsDocuments
from .generated.Duration import Duration as FbsDuration
from .generated.EdgeList import EdgeList as FbsEdgeList
from .generated.EdgeQuery import EdgeQuery as FbsEdgeQuery
from .generated.Field import Field as FbsField
from .generated.FixedSizeBinary import FixedSizeBinary as FbsFixedSizeBinary
from .generated.FixedSizeList import FixedSizeList as FbsFixedSizeList
from .generated.FloatAggregate import FloatAggregate as FbsFloatAggregate
from .generated.FloatBucket import FloatBucket as FbsFloatBucket
from .generated.FloatRange import FloatRange as FbsFloatRange
from .generated.FloatingPoint import FloatingPoint as FbsFloatingPoint
from .generated.GenericId import GenericId as FbsGenericId
from .generated.Geom import Geom as FbsGeom
from .generated.GeomOp import GeomOp as FbsGeomOp
from .generated.GeometryData import GeometryData as FbsGeometryData
from .generated.GraphEdge import GraphEdge as FbsGraphEdge
from .generated.GraphNode import GraphNode as FbsGraphNode
from .generated.GraphNodeId import GraphNodeId as FbsGraphNodeId
from .generated.GraphQuery import GraphQuery as FbsGraphQuery
from .generated.HierarchicalRelationship import HierarchicalRelationship as FbsHierarchicalRelationship
from .generated.HierarchyRelationshipData import HierarchyRelationshipData as FbsHierarchyRelationshipData
from .generated.Int import Int as FbsInt
from .generated.IntAggregate import IntAggregate as FbsIntAggregate
from .generated.IntBucket import IntBucket as FbsIntBucket
from .generated.IntRange import IntRange as FbsIntRange
from .generated.IntegerDisplayString import IntegerDisplayString as FbsIntegerDisplayString
from .generated.Interval import Interval as FbsInterval
from .generated.KeyValue import KeyValue as FbsKeyValue
from .generated.LargeBinary import LargeBinary as FbsLargeBinary
from .generated.LargeList import LargeList as FbsLargeList
from .generated.LargeUtf8 import LargeUtf8 as FbsLargeUtf8
from .generated.Line import Line as FbsLine
from .generated.List import List as FbsList
from .generated.Map import Map as FbsMap
from .generated.Metadata import Metadata as FbsMetadata
from .generated.MultiLine import MultiLine as FbsMultiLine
from .generated.MultiPolygon import MultiPolygon as FbsMultiPolygon
from .generated.NamedParameter import NamedParameter as FbsNamedParameter
from .generated.NestedCategoryRelationshipData import NestedCategoryRelationshipData as FbsNestedCategoryRelationshipData
from .generated.NestedCategoryRelationshipNode import NestedCategoryRelationshipNode as FbsNestedCategoryRelationshipNode
from .generated.NestedHierarchyRelationshipData import NestedHierarchyRelationshipData as FbsNestedHierarchyRelationshipData
from .generated.NestedHierarchyRelationshipNode import NestedHierarchyRelationshipNode as FbsNestedHierarchyRelationshipNode
from .generated.NestedStringCategories import NestedStringCategories as FbsNestedStringCategories
from .generated.NestedStringCategoryNode import NestedStringCategoryNode as FbsNestedStringCategoryNode
from .generated.NoGeometry import NoGeometry as FbsNoGeometry
from .generated.NodeIdPair import NodeIdPair as FbsNodeIdPair
from .generated.NodeList import NodeList as FbsNodeList
from .generated.NodeQuery import NodeQuery as FbsNodeQuery
from .generated.Null import Null as FbsNull
from .generated.NumericalFieldFormat import NumericalFieldFormat as FbsNumericalFieldFormat
from .generated.ObjectId import ObjectId as FbsObjectId
from .generated.OrderBy import OrderBy as FbsOrderBy
from .generated.Point import Point as FbsPoint
from .generated.Point2D import Point2D as FbsPoint2D
from .generated.Polygon import Polygon as FbsPolygon
from .generated.Projection import Projection as FbsProjection
from .generated.QueryPathElement import QueryPathElement as FbsQueryPathElement
from .generated.RawGeom import RawGeom as FbsRawGeom
from .generated.Schema import Schema as FbsSchema
from .generated.Source import Source as FbsSource
from .generated.StreamId import StreamId as FbsStreamId
from .generated.StringAggregate import StringAggregate as FbsStringAggregate
from .generated.StringCategories import StringCategories as FbsStringCategories
from .generated.Struct_ import Struct_ as FbsStruct_
from .generated.Time import Time as FbsTime
from .generated.TimeInterval import TimeInterval as FbsTimeInterval
from .generated.Timestamp import Timestamp as FbsTimestamp
from .generated.Tri2D import Tri2D as FbsTri2D
from .generated.UIntAggregate import UIntAggregate as FbsUIntAggregate
from .generated.UIntBucket import UIntBucket as FbsUIntBucket
from .generated.UlField import UlField as FbsUlField
from .generated.UlFieldRelationship import UlFieldRelationship as FbsUlFieldRelationship
from .generated.Union import Union as FbsUnion
from .generated.Utf8 import Utf8 as FbsUtf8
from .generated.VArray import VArray as FbsVArray
from .generated.VBool import VBool as FbsVBool
from .generated.VBytes import VBytes as FbsVBytes
from .generated.VChar import VChar as FbsVChar
from .generated.VF32 import VF32 as FbsVF32
from .generated.VF64 import VF64 as FbsVF64
from .generated.VFixedSizeBytes import VFixedSizeBytes as FbsVFixedSizeBytes
from .generated.VI16 import VI16 as FbsVI16
from .generated.VI32 import VI32 as FbsVI32
from .generated.VI64 import VI64 as FbsVI64
from .generated.VI8 import VI8 as FbsVI8
from .generated.VIsize import VIsize as FbsVIsize
from .generated.VNull import VNull as FbsVNull
from .generated.VStr import VStr as FbsVStr
from .generated.VTimestampMs import VTimestampMs as FbsVTimestampMs
from .generated.VTimestampMsUtc import VTimestampMsUtc as FbsVTimestampMsUtc
from .generated.VTimestampNs import VTimestampNs as FbsVTimestampNs
from .generated.VTimestampNsUtc import VTimestampNsUtc as FbsVTimestampNsUtc
from .generated.VTri2D import VTri2D as FbsVTri2D
from .generated.VU16 import VU16 as FbsVU16
from .generated.VU32 import VU32 as FbsVU32
from .generated.VU64 import VU64 as FbsVU64
from .generated.VU8 import VU8 as FbsVU8
from .generated.VUnit import VUnit as FbsVUnit
from .generated.VUsize import VUsize as FbsVUsize
from .generated.ValueInstance import ValueInstance as FbsValueInstance
from .generated.WorldGraphGeometry import WorldGraphGeometry as FbsWorldGraphGeometry
from .generated.reflection.Enum import Enum as FbsEnum
from .generated.reflection.EnumVal import EnumVal as FbsEnumVal
from .generated.reflection.Field import Field as FbsField
from .generated.reflection.KeyValue import KeyValue as FbsKeyValue
from .generated.reflection.Object import Object as FbsObject
from .generated.reflection.RPCCall import RPCCall as FbsRPCCall
from .generated.reflection.Schema import Schema as FbsSchema
from .generated.reflection.SchemaFile import SchemaFile as FbsSchemaFile
from .generated.reflection.Service import Service as FbsService
from .generated.reflection.Type import Type as FbsType
from .generated.ComponentData import ComponentData as FbsComponentData
from .generated.Geometry import Geometry as FbsGeometry
from .generated.GeometryDataUnion import GeometryDataUnion as FbsGeometryDataUnion
from .generated.GeometrySource import GeometrySource as FbsGeometrySource
from .generated.QueryPathElementUnion import QueryPathElementUnion as FbsQueryPathElementUnion
from .generated.Type import Type as FbsType
from .generated.UlFieldRelationshipData import UlFieldRelationshipData as FbsUlFieldRelationshipData
from .generated.Value import Value as FbsValue

class AggregationFunction(Enum):
    Any = 0
    Sum = 1
    Average = 2
    Min = 3
    Max = 4
    Latest = 5

class DatasetCategory(Enum):
    DC_BUSINESSES = 0
    DC_DEMOGRAPHICS = 1
    DC_ECONOMICS = 2
    DC_EVENTS = 3
    DC_INFRASTRUCTURE = 4
    DC_LAND_USE = 5
    DC_MOBILITY = 6
    DC_WEATHER = 7
    DC_BOUNDARY = 8
    DC_HEALTH = 9
    DC_HIDDEN = 4294967295

class FieldFlags(Enum):
    Filterable = 1
    Category = 2
    Rangeable = 4
    Editable = 8
    Nullable = 16
    Aggregated = 32
    RequiredForFilter = 64
    DoNotIncludeInAreaReport = 128
    AggregateIntoIntegerBuckets = 256
    Readonly = 512

class FieldUnit(Enum):
    U_INVALID = 0
    U_METRES = 1
    U_DEGREES_CELSIUS = 2
    U_KILOGRAMS = 3
    U_SECONDS = 4
    U_DOLLARS_CAD = 5
    U_DOLLARS_USD = 6
    U_DEGREES = 7
    U_KPH = 8
    U_MPH = 9
    U_PERCENTAGE = 10
    U_ACRES = 11
    U_SQUARE_FEET = 12
    U_MILES = 13

class NumericalFieldValueType(Enum):
    None_ = 0
    Percent = 1
    Ratio = 2

class UlFieldType(Enum):
    FT_UNKNOWN = 0
    FT_INT = 1
    FT_FLOAT = 2
    FT_STRING = 3
    FT_UUID = 4
    FT_POINT = 5
    FT_REGION = 6
    FT_DATETIME = 7
    FT_CURRENCY = 8
    FT_BOOLEAN = 9
    FT_DOCUMENT = 10
    FT_GEOMETRY = 11
    FT_JSON = 12
    FT_DATE = 13
    FT_EXTERNAL_URL = 14
    FT_CONTACT_INFO = 15
    FT_AGGREGATE_FLOAT = 16
    FT_AGGREGATE_UINT = 17
    FT_AGGREGATE_INT = 18
    FT_AGGREGATE_STRING = 19
    FT_AGGREGATE_FLOAT32 = 20
    FT_AGGREGATE_DATETIME = 21
    FT_BINARY = 22
    FT_TIME = 23
    FT_GEOMETRY_OR_NODE = 24

class UpdateCadence(Enum):
    UC_UNSET = 0
    UC_IRREGULAR = 1
    UC_DAILY = 2
    UC_WEEKLY = 3
    UC_BI_WEEKLY = 4
    UC_MONTHLY = 5


@dataclass
class StringCategories:
    categories: Optional["List[str]"]

    @classmethod
    def from_fbs(cls, o: FbsStringCategories) -> Self:
        categories = list()
        if not o.CategoriesIsNone():
            for i in range(o.CategoriesLength()):
                categories.append(o.Categories(i))
        return cls(categories)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsStringCategories.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.StringCategories import (
            Start,
            AddCategories,
            StartCategoriesVector,
            End,
        )
        categories_offset = None
        if self.categories is not None:
            categories_offsets = list()
            for value in self.categories:
                categories_offsets.append(builder.CreateString(value))
            StartCategoriesVector(builder, len(self.categories))
            for i in reversed(range(len(self.categories))):
                builder.PrependUOffsetTRelative(categories_offsets[i])
            categories_offset = builder.EndVector()
        
        Start(builder)
        if categories_offset is not None:
            AddCategories(builder, categories_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        categories = []
        return cls(categories)

    def __eq__(self, other) -> bool:
        eq = True
        self_categories = self.categories
        other_categories = other.categories
        if self_categories is not None and other_categories is not None:
            if len(self_categories) != len(other_categories):
                return False
            for i in range(len(self_categories)):
                eq = eq and self_categories[i] == other_categories[i]
        elif self_categories is not None and other_categories is None:
            return False
        elif self_categories is None and other_categories is not None:
            return False

        return eq

@dataclass
class NumericalFieldFormat:
    decimal_places: "int"

    offset: "float"

    scale: "float"

    value_type: "NumericalFieldValueType"

    @classmethod
    def from_fbs(cls, o: FbsNumericalFieldFormat) -> Self:
        decimal_places = o.DecimalPlaces()
        offset = o.Offset()
        scale = o.Scale()
        value_type = NumericalFieldValueType(o.ValueType())
        return cls(decimal_places, offset, scale, value_type)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNumericalFieldFormat.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NumericalFieldFormat import (
            Start,
            AddDecimalPlaces,
            AddOffset,
            AddScale,
            AddValueType,
            End,
        )
        
        Start(builder)
        AddDecimalPlaces(builder, self.decimal_places)
        AddOffset(builder, self.offset)
        AddScale(builder, self.scale)
        AddValueType(builder, self.value_type.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        decimal_places = 0
        offset = 0.0
        scale = 0.0
        value_type = NumericalFieldValueType(0)
        return cls(decimal_places, offset, scale, value_type)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.decimal_places == other.decimal_places
        eq = eq and self.offset == other.offset
        eq = eq and self.scale == other.scale
        eq = eq and self.value_type == other.value_type

        return eq

@dataclass
class IntRange:
    aggregation_protocol: "AggregationFunction"

    display_strings: Optional["List[IntegerDisplayString]"]

    enum_name: Optional["str"]

    field_format: Optional["NumericalFieldFormat"]

    max: "int"

    min: "int"

    @classmethod
    def from_fbs(cls, o: FbsIntRange) -> Self:
        aggregation_protocol = AggregationFunction(o.AggregationProtocol())
        display_strings = list()
        if not o.DisplayStringsIsNone():
            for i in range(o.DisplayStringsLength()):
                display_strings_val = None
                display_strings_obj = o.DisplayStrings(i)
                if display_strings_obj is not None:
                    display_strings_val = IntegerDisplayString.from_fbs(display_strings_obj)
                display_strings.append(display_strings_val)
        enum_name = None
        enum_name_str = o.EnumName()
        if enum_name_str is not None:
            enum_name = enum_name_str.decode('utf-8')
        field_format = None
        field_format_obj = o.FieldFormat()
        if field_format_obj is not None:
            field_format = NumericalFieldFormat.from_fbs(field_format_obj)
        max = o.Max()
        min = o.Min()
        return cls(aggregation_protocol, display_strings, enum_name, field_format, max, min)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsIntRange.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.IntRange import (
            Start,
            AddAggregationProtocol,
            AddDisplayStrings,
            StartDisplayStringsVector,
            AddEnumName,
            AddFieldFormat,
            AddMax,
            AddMin,
            End,
        )
        display_strings_offset = None
        if self.display_strings is not None:
            display_strings_offsets = list()
            for value in self.display_strings:
                display_strings_offsets.append(value.serialize_to(builder))
            StartDisplayStringsVector(builder, len(self.display_strings))
            for i in reversed(range(len(self.display_strings))):
                builder.PrependUOffsetTRelative(display_strings_offsets[i])
            display_strings_offset = builder.EndVector()
        enum_name_offset = None
        if self.enum_name is not None:
            enum_name_offset = builder.CreateString(self.enum_name)
        field_format_offset = None
        if self.field_format is not None:
            field_format_offset = self.field_format.serialize_to(builder)
        
        Start(builder)
        AddAggregationProtocol(builder, self.aggregation_protocol.value)
        if display_strings_offset is not None:
            AddDisplayStrings(builder, display_strings_offset)
        if enum_name_offset is not None:
            AddEnumName(builder, enum_name_offset)
        if field_format_offset is not None:
            AddFieldFormat(builder, field_format_offset)
        AddMax(builder, self.max)
        AddMin(builder, self.min)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        aggregation_protocol = AggregationFunction(0)
        display_strings = []
        enum_name = ""
        field_format = NumericalFieldFormat.make_default()
        max = 0
        min = 0
        return cls(aggregation_protocol, display_strings, enum_name, field_format, max, min)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.aggregation_protocol == other.aggregation_protocol
        self_display_strings = self.display_strings
        other_display_strings = other.display_strings
        if self_display_strings is not None and other_display_strings is not None:
            if len(self_display_strings) != len(other_display_strings):
                return False
            for i in range(len(self_display_strings)):
                eq = eq and self_display_strings[i] == other_display_strings[i]
        elif self_display_strings is not None and other_display_strings is None:
            return False
        elif self_display_strings is None and other_display_strings is not None:
            return False
        eq = eq and self.enum_name == other.enum_name
        eq = eq and self.field_format == other.field_format
        eq = eq and self.max == other.max
        eq = eq and self.min == other.min

        return eq

@dataclass
class FloatRange:
    aggregation_protocol: "AggregationFunction"

    field_format: Optional["NumericalFieldFormat"]

    max: "float"

    min: "float"

    @classmethod
    def from_fbs(cls, o: FbsFloatRange) -> Self:
        aggregation_protocol = AggregationFunction(o.AggregationProtocol())
        field_format = None
        field_format_obj = o.FieldFormat()
        if field_format_obj is not None:
            field_format = NumericalFieldFormat.from_fbs(field_format_obj)
        max = o.Max()
        min = o.Min()
        return cls(aggregation_protocol, field_format, max, min)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsFloatRange.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.FloatRange import (
            Start,
            AddAggregationProtocol,
            AddFieldFormat,
            AddMax,
            AddMin,
            End,
        )
        field_format_offset = None
        if self.field_format is not None:
            field_format_offset = self.field_format.serialize_to(builder)
        
        Start(builder)
        AddAggregationProtocol(builder, self.aggregation_protocol.value)
        if field_format_offset is not None:
            AddFieldFormat(builder, field_format_offset)
        AddMax(builder, self.max)
        AddMin(builder, self.min)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        aggregation_protocol = AggregationFunction(0)
        field_format = NumericalFieldFormat.make_default()
        max = 0.0
        min = 0.0
        return cls(aggregation_protocol, field_format, max, min)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.aggregation_protocol == other.aggregation_protocol
        eq = eq and self.field_format == other.field_format
        eq = eq and self.max == other.max
        eq = eq and self.min == other.min

        return eq

@dataclass
class DatetimeRange:
    intervals: Optional["List[TimeInterval]"]

    max: "int"

    min: "int"

    @classmethod
    def from_fbs(cls, o: FbsDatetimeRange) -> Self:
        intervals = list()
        if not o.IntervalsIsNone():
            for i in range(o.IntervalsLength()):
                intervals_val = None
                intervals_obj = o.Intervals(i)
                if intervals_obj is not None:
                    intervals_val = TimeInterval.from_fbs(intervals_obj)
                intervals.append(intervals_val)
        max = o.Max()
        min = o.Min()
        return cls(intervals, max, min)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDatetimeRange.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DatetimeRange import (
            Start,
            AddIntervals,
            StartIntervalsVector,
            AddMax,
            AddMin,
            End,
        )
        intervals_offset = None
        if self.intervals is not None:
            intervals_offsets = list()
            for value in self.intervals:
                intervals_offsets.append(value.serialize_to(builder))
            StartIntervalsVector(builder, len(self.intervals))
            for i in reversed(range(len(self.intervals))):
                builder.PrependUOffsetTRelative(intervals_offsets[i])
            intervals_offset = builder.EndVector()
        
        Start(builder)
        if intervals_offset is not None:
            AddIntervals(builder, intervals_offset)
        AddMax(builder, self.max)
        AddMin(builder, self.min)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        intervals = []
        max = 0
        min = 0
        return cls(intervals, max, min)

    def __eq__(self, other) -> bool:
        eq = True
        self_intervals = self.intervals
        other_intervals = other.intervals
        if self_intervals is not None and other_intervals is not None:
            if len(self_intervals) != len(other_intervals):
                return False
            for i in range(len(self_intervals)):
                eq = eq and self_intervals[i] == other_intervals[i]
        elif self_intervals is not None and other_intervals is None:
            return False
        elif self_intervals is None and other_intervals is not None:
            return False
        eq = eq and self.max == other.max
        eq = eq and self.min == other.min

        return eq

@dataclass
class Dates:
    max: "int"

    min: "int"

    unique_value_counts: Optional["List[int]"]

    unique_values: Optional["List[int]"]

    @classmethod
    def from_fbs(cls, o: FbsDates) -> Self:
        max = o.Max()
        min = o.Min()
        unique_value_counts = list()
        if not o.UniqueValueCountsIsNone():
            for i in range(o.UniqueValueCountsLength()):
                unique_value_counts.append(o.UniqueValueCounts(i))
        unique_values = list()
        if not o.UniqueValuesIsNone():
            for i in range(o.UniqueValuesLength()):
                unique_values.append(o.UniqueValues(i))
        return cls(max, min, unique_value_counts, unique_values)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDates.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Dates import (
            Start,
            AddMax,
            AddMin,
            AddUniqueValueCounts,
            StartUniqueValueCountsVector,
            AddUniqueValues,
            StartUniqueValuesVector,
            End,
        )
        unique_value_counts_offset = None
        if self.unique_value_counts is not None:
            StartUniqueValueCountsVector(builder, len(self.unique_value_counts))
            for i in reversed(range(len(self.unique_value_counts))):
                builder.PrependUint32(self.unique_value_counts[i])
            unique_value_counts_offset = builder.EndVector()
        unique_values_offset = None
        if self.unique_values is not None:
            StartUniqueValuesVector(builder, len(self.unique_values))
            for i in reversed(range(len(self.unique_values))):
                builder.PrependInt64(self.unique_values[i])
            unique_values_offset = builder.EndVector()
        
        Start(builder)
        AddMax(builder, self.max)
        AddMin(builder, self.min)
        if unique_value_counts_offset is not None:
            AddUniqueValueCounts(builder, unique_value_counts_offset)
        if unique_values_offset is not None:
            AddUniqueValues(builder, unique_values_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        max = 0
        min = 0
        unique_value_counts = []
        unique_values = []
        return cls(max, min, unique_value_counts, unique_values)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.max == other.max
        eq = eq and self.min == other.min
        self_unique_value_counts = self.unique_value_counts
        other_unique_value_counts = other.unique_value_counts
        if self_unique_value_counts is not None and other_unique_value_counts is not None:
            if len(self_unique_value_counts) != len(other_unique_value_counts):
                return False
            for i in range(len(self_unique_value_counts)):
                eq = eq and self_unique_value_counts[i] == other_unique_value_counts[i]
        elif self_unique_value_counts is not None and other_unique_value_counts is None:
            return False
        elif self_unique_value_counts is None and other_unique_value_counts is not None:
            return False
        self_unique_values = self.unique_values
        other_unique_values = other.unique_values
        if self_unique_values is not None and other_unique_values is not None:
            if len(self_unique_values) != len(other_unique_values):
                return False
            for i in range(len(self_unique_values)):
                eq = eq and self_unique_values[i] == other_unique_values[i]
        elif self_unique_values is not None and other_unique_values is None:
            return False
        elif self_unique_values is None and other_unique_values is not None:
            return False

        return eq

@dataclass
class NestedStringCategories:
    nesting_tree: "List[NestedStringCategoryNode]"

    @classmethod
    def from_fbs(cls, o: FbsNestedStringCategories) -> Self:
        nesting_tree = list()
        if not o.NestingTreeIsNone():
            for i in range(o.NestingTreeLength()):
                nesting_tree_val = None
                nesting_tree_obj = o.NestingTree(i)
                if nesting_tree_obj is not None:
                    nesting_tree_val = NestedStringCategoryNode.from_fbs(nesting_tree_obj)
                nesting_tree.append(nesting_tree_val)
        return cls(nesting_tree)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNestedStringCategories.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NestedStringCategories import (
            Start,
            AddNestingTree,
            StartNestingTreeVector,
            End,
        )
        nesting_tree_offsets = list()
        for value in self.nesting_tree:
            nesting_tree_offsets.append(value.serialize_to(builder))
        StartNestingTreeVector(builder, len(self.nesting_tree))
        for i in reversed(range(len(self.nesting_tree))):
            builder.PrependUOffsetTRelative(nesting_tree_offsets[i])
        nesting_tree_offset = builder.EndVector()
        
        Start(builder)
        AddNestingTree(builder, nesting_tree_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        nesting_tree = []
        return cls(nesting_tree)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.nesting_tree) != len(other.nesting_tree):
            return False
        for i in range(len(self.nesting_tree)):
            eq = eq and self.nesting_tree[i] == other.nesting_tree[i]

        return eq

@dataclass
class ComponentData:
    value: Union[
        "StringCategories",
        "IntRange",
        "FloatRange",
        "DatetimeRange",
        "Dates",
        "NestedStringCategories",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.ComponentData import ComponentData
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, StringCategories):
            return (offset, ComponentData().StringCategories)
        elif isinstance(self.value, IntRange):
            return (offset, ComponentData().IntRange)
        elif isinstance(self.value, FloatRange):
            return (offset, ComponentData().FloatRange)
        elif isinstance(self.value, DatetimeRange):
            return (offset, ComponentData().DatetimeRange)
        elif isinstance(self.value, Dates):
            return (offset, ComponentData().Dates)
        elif isinstance(self.value, NestedStringCategories):
            return (offset, ComponentData().NestedStringCategories)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        ComponentData_ty_instance = FbsComponentData()
        if ty == ComponentData_ty_instance.StringCategories:
            val = FbsStringCategories();
            val.Init(source, pos)
            return cls(StringCategories.from_fbs(val))
        elif ty == ComponentData_ty_instance.IntRange:
            val = FbsIntRange();
            val.Init(source, pos)
            return cls(IntRange.from_fbs(val))
        elif ty == ComponentData_ty_instance.FloatRange:
            val = FbsFloatRange();
            val.Init(source, pos)
            return cls(FloatRange.from_fbs(val))
        elif ty == ComponentData_ty_instance.DatetimeRange:
            val = FbsDatetimeRange();
            val.Init(source, pos)
            return cls(DatetimeRange.from_fbs(val))
        elif ty == ComponentData_ty_instance.Dates:
            val = FbsDates();
            val.Init(source, pos)
            return cls(Dates.from_fbs(val))
        elif ty == ComponentData_ty_instance.NestedStringCategories:
            val = FbsNestedStringCategories();
            val.Init(source, pos)
            return cls(NestedStringCategories.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(StringCategories.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class RawGeom:
    geom: "List[int]"

    @classmethod
    def from_fbs(cls, o: FbsRawGeom) -> Self:
        geom = list()
        if not o.GeomIsNone():
            for i in range(o.GeomLength()):
                geom.append(o.Geom(i))
        return cls(geom)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsRawGeom.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.RawGeom import (
            Start,
            AddGeom,
            StartGeomVector,
            End,
        )
        StartGeomVector(builder, len(self.geom))
        for i in reversed(range(len(self.geom))):
            builder.PrependUint8(self.geom[i])
        geom_offset = builder.EndVector()
        
        Start(builder)
        AddGeom(builder, geom_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        geom = []
        return cls(geom)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.geom) != len(other.geom):
            return False
        for i in range(len(self.geom)):
            eq = eq and self.geom[i] == other.geom[i]

        return eq

@dataclass
class GeometryDataUnion:
    value: Union[
        "RawGeom",
        "NodeIdPair",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.GeometryDataUnion import GeometryDataUnion
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, RawGeom):
            return (offset, GeometryDataUnion().RawGeom)
        elif isinstance(self.value, NodeIdPair):
            return (offset, GeometryDataUnion().NodeIdPair)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        GeometryDataUnion_ty_instance = FbsGeometryDataUnion()
        if ty == GeometryDataUnion_ty_instance.RawGeom:
            val = FbsRawGeom();
            val.Init(source, pos)
            return cls(RawGeom.from_fbs(val))
        elif ty == GeometryDataUnion_ty_instance.NodeIdPair:
            val = FbsNodeIdPair();
            val.Init(source, pos)
            return cls(NodeIdPair.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(RawGeom.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class NoGeometry:
    @classmethod
    def from_fbs(cls, o: FbsNoGeometry) -> Self:
        return cls()

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNoGeometry.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NoGeometry import (
            Start,
            End,
        )
        
        Start(builder)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        return cls()

    def __eq__(self, other) -> bool:
        eq = True

        return eq

@dataclass
class DatacatalogGeometry:
    column: "str"

    @classmethod
    def from_fbs(cls, o: FbsDatacatalogGeometry) -> Self:
        column_str = o.Column()
        assert column_str is not None
        column = column_str.decode('utf-8')
        return cls(column)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDatacatalogGeometry.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DatacatalogGeometry import (
            Start,
            AddColumn,
            End,
        )
        column_offset = builder.CreateString(self.column)
        
        Start(builder)
        AddColumn(builder, column_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        column = ""
        return cls(column)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.column == other.column

        return eq

@dataclass
class WorldGraphGeometry:
    """ For most streams with GeometrySourceType==WorldGraphGeometry, edge_path will
     be empty and start_stream_id will be unset.

     If edge_path is empty and start_stream_id is unset we just query for nodes
     whose stream predicate matches this stream's streamId in order to fetch the stream's geometry.

     If edge_path is non-empty and start_stream_id is set: Start at nodes with
     streamId=start_stream_id and follow the edge_path. Retrieve geometry from
     the last node on that path.

     If edge_path is non-empty and start_stream_id is unset: Start at nodes with
     streamId=id of this stream and follow the edge_path to retrieve the geeometry.

     If edge_path is empty and start_stream_id is set: Just query for nodes with
     streamId == start_stream_id.
    """

    # Edges to follow to reach the nodes with geometry.
    edge_path: "List[EdgeTy]"

    # Stream id of the starting node in the query path for the geometry
    start_stream_id: Optional["ObjectId"]

    @classmethod
    def from_fbs(cls, o: FbsWorldGraphGeometry) -> Self:
        edge_path = list()
        if not o.EdgePathIsNone():
            for i in range(o.EdgePathLength()):
                edge_path.append(o.EdgePath(i))
        start_stream_id = None
        start_stream_id_obj = o.StartStreamId()
        if start_stream_id_obj is not None:
            start_stream_id = ObjectId.from_fbs(start_stream_id_obj)
        return cls(edge_path, start_stream_id)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsWorldGraphGeometry.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.WorldGraphGeometry import (
            Start,
            AddEdgePath,
            StartEdgePathVector,
            AddStartStreamId,
            End,
        )
        StartEdgePathVector(builder, len(self.edge_path))
        for i in reversed(range(len(self.edge_path))):
            builder.PrependInt32(self.edge_path[i])
        edge_path_offset = builder.EndVector()
        start_stream_id_offset = None
        if self.start_stream_id is not None:
            start_stream_id_offset = self.start_stream_id.serialize_to(builder)
        
        Start(builder)
        AddEdgePath(builder, edge_path_offset)
        if start_stream_id_offset is not None:
            AddStartStreamId(builder, start_stream_id_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        edge_path = []
        start_stream_id = ObjectId.make_default()
        return cls(edge_path, start_stream_id)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.edge_path) != len(other.edge_path):
            return False
        for i in range(len(self.edge_path)):
            eq = eq and self.edge_path[i] == other.edge_path[i]
        eq = eq and self.start_stream_id == other.start_stream_id

        return eq

@dataclass
class GeometrySource:
    value: Union[
        "NoGeometry",
        "DatacatalogGeometry",
        "WorldGraphGeometry",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.GeometrySource import GeometrySource
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, NoGeometry):
            return (offset, GeometrySource().NoGeometry)
        elif isinstance(self.value, DatacatalogGeometry):
            return (offset, GeometrySource().DatacatalogGeometry)
        elif isinstance(self.value, WorldGraphGeometry):
            return (offset, GeometrySource().WorldGraphGeometry)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        GeometrySource_ty_instance = FbsGeometrySource()
        if ty == GeometrySource_ty_instance.NoGeometry:
            val = FbsNoGeometry();
            val.Init(source, pos)
            return cls(NoGeometry.from_fbs(val))
        elif ty == GeometrySource_ty_instance.DatacatalogGeometry:
            val = FbsDatacatalogGeometry();
            val.Init(source, pos)
            return cls(DatacatalogGeometry.from_fbs(val))
        elif ty == GeometrySource_ty_instance.WorldGraphGeometry:
            val = FbsWorldGraphGeometry();
            val.Init(source, pos)
            return cls(WorldGraphGeometry.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(NoGeometry.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class HierarchyRelationshipData:
    hierarchy: Optional["List[HierarchicalRelationship]"]

    @classmethod
    def from_fbs(cls, o: FbsHierarchyRelationshipData) -> Self:
        hierarchy = list()
        if not o.HierarchyIsNone():
            for i in range(o.HierarchyLength()):
                hierarchy_val = None
                hierarchy_obj = o.Hierarchy(i)
                if hierarchy_obj is not None:
                    hierarchy_val = HierarchicalRelationship.from_fbs(hierarchy_obj)
                hierarchy.append(hierarchy_val)
        return cls(hierarchy)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsHierarchyRelationshipData.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.HierarchyRelationshipData import (
            Start,
            AddHierarchy,
            StartHierarchyVector,
            End,
        )
        hierarchy_offset = None
        if self.hierarchy is not None:
            hierarchy_offsets = list()
            for value in self.hierarchy:
                hierarchy_offsets.append(value.serialize_to(builder))
            StartHierarchyVector(builder, len(self.hierarchy))
            for i in reversed(range(len(self.hierarchy))):
                builder.PrependUOffsetTRelative(hierarchy_offsets[i])
            hierarchy_offset = builder.EndVector()
        
        Start(builder)
        if hierarchy_offset is not None:
            AddHierarchy(builder, hierarchy_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        hierarchy = []
        return cls(hierarchy)

    def __eq__(self, other) -> bool:
        eq = True
        self_hierarchy = self.hierarchy
        other_hierarchy = other.hierarchy
        if self_hierarchy is not None and other_hierarchy is not None:
            if len(self_hierarchy) != len(other_hierarchy):
                return False
            for i in range(len(self_hierarchy)):
                eq = eq and self_hierarchy[i] == other_hierarchy[i]
        elif self_hierarchy is not None and other_hierarchy is None:
            return False
        elif self_hierarchy is None and other_hierarchy is not None:
            return False

        return eq

@dataclass
class CategoryRelationshipData:
    associated_fields: Optional["List[int]"]

    categories: Optional["List[int]"]

    @classmethod
    def from_fbs(cls, o: FbsCategoryRelationshipData) -> Self:
        associated_fields = list()
        if not o.AssociatedFieldsIsNone():
            for i in range(o.AssociatedFieldsLength()):
                associated_fields.append(o.AssociatedFields(i))
        categories = list()
        if not o.CategoriesIsNone():
            for i in range(o.CategoriesLength()):
                categories.append(o.Categories(i))
        return cls(associated_fields, categories)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsCategoryRelationshipData.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.CategoryRelationshipData import (
            Start,
            AddAssociatedFields,
            StartAssociatedFieldsVector,
            AddCategories,
            StartCategoriesVector,
            End,
        )
        associated_fields_offset = None
        if self.associated_fields is not None:
            StartAssociatedFieldsVector(builder, len(self.associated_fields))
            for i in reversed(range(len(self.associated_fields))):
                builder.PrependInt32(self.associated_fields[i])
            associated_fields_offset = builder.EndVector()
        categories_offset = None
        if self.categories is not None:
            StartCategoriesVector(builder, len(self.categories))
            for i in reversed(range(len(self.categories))):
                builder.PrependInt32(self.categories[i])
            categories_offset = builder.EndVector()
        
        Start(builder)
        if associated_fields_offset is not None:
            AddAssociatedFields(builder, associated_fields_offset)
        if categories_offset is not None:
            AddCategories(builder, categories_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        associated_fields = []
        categories = []
        return cls(associated_fields, categories)

    def __eq__(self, other) -> bool:
        eq = True
        self_associated_fields = self.associated_fields
        other_associated_fields = other.associated_fields
        if self_associated_fields is not None and other_associated_fields is not None:
            if len(self_associated_fields) != len(other_associated_fields):
                return False
            for i in range(len(self_associated_fields)):
                eq = eq and self_associated_fields[i] == other_associated_fields[i]
        elif self_associated_fields is not None and other_associated_fields is None:
            return False
        elif self_associated_fields is None and other_associated_fields is not None:
            return False
        self_categories = self.categories
        other_categories = other.categories
        if self_categories is not None and other_categories is not None:
            if len(self_categories) != len(other_categories):
                return False
            for i in range(len(self_categories)):
                eq = eq and self_categories[i] == other_categories[i]
        elif self_categories is not None and other_categories is None:
            return False
        elif self_categories is None and other_categories is not None:
            return False

        return eq

@dataclass
class NestedCategoryRelationshipData:
    categories: Optional["List[NestedCategoryRelationshipNode]"]

    @classmethod
    def from_fbs(cls, o: FbsNestedCategoryRelationshipData) -> Self:
        categories = list()
        if not o.CategoriesIsNone():
            for i in range(o.CategoriesLength()):
                categories_val = None
                categories_obj = o.Categories(i)
                if categories_obj is not None:
                    categories_val = NestedCategoryRelationshipNode.from_fbs(categories_obj)
                categories.append(categories_val)
        return cls(categories)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNestedCategoryRelationshipData.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NestedCategoryRelationshipData import (
            Start,
            AddCategories,
            StartCategoriesVector,
            End,
        )
        categories_offset = None
        if self.categories is not None:
            categories_offsets = list()
            for value in self.categories:
                categories_offsets.append(value.serialize_to(builder))
            StartCategoriesVector(builder, len(self.categories))
            for i in reversed(range(len(self.categories))):
                builder.PrependUOffsetTRelative(categories_offsets[i])
            categories_offset = builder.EndVector()
        
        Start(builder)
        if categories_offset is not None:
            AddCategories(builder, categories_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        categories = []
        return cls(categories)

    def __eq__(self, other) -> bool:
        eq = True
        self_categories = self.categories
        other_categories = other.categories
        if self_categories is not None and other_categories is not None:
            if len(self_categories) != len(other_categories):
                return False
            for i in range(len(self_categories)):
                eq = eq and self_categories[i] == other_categories[i]
        elif self_categories is not None and other_categories is None:
            return False
        elif self_categories is None and other_categories is not None:
            return False

        return eq

@dataclass
class NestedHierarchyRelationshipData:
    nodes: Optional["List[NestedHierarchyRelationshipNode]"]

    @classmethod
    def from_fbs(cls, o: FbsNestedHierarchyRelationshipData) -> Self:
        nodes = list()
        if not o.NodesIsNone():
            for i in range(o.NodesLength()):
                nodes_val = None
                nodes_obj = o.Nodes(i)
                if nodes_obj is not None:
                    nodes_val = NestedHierarchyRelationshipNode.from_fbs(nodes_obj)
                nodes.append(nodes_val)
        return cls(nodes)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNestedHierarchyRelationshipData.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NestedHierarchyRelationshipData import (
            Start,
            AddNodes,
            StartNodesVector,
            End,
        )
        nodes_offset = None
        if self.nodes is not None:
            nodes_offsets = list()
            for value in self.nodes:
                nodes_offsets.append(value.serialize_to(builder))
            StartNodesVector(builder, len(self.nodes))
            for i in reversed(range(len(self.nodes))):
                builder.PrependUOffsetTRelative(nodes_offsets[i])
            nodes_offset = builder.EndVector()
        
        Start(builder)
        if nodes_offset is not None:
            AddNodes(builder, nodes_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        nodes = []
        return cls(nodes)

    def __eq__(self, other) -> bool:
        eq = True
        self_nodes = self.nodes
        other_nodes = other.nodes
        if self_nodes is not None and other_nodes is not None:
            if len(self_nodes) != len(other_nodes):
                return False
            for i in range(len(self_nodes)):
                eq = eq and self_nodes[i] == other_nodes[i]
        elif self_nodes is not None and other_nodes is None:
            return False
        elif self_nodes is None and other_nodes is not None:
            return False

        return eq

@dataclass
class UlFieldRelationshipData:
    value: Union[
        "HierarchyRelationshipData",
        "CategoryRelationshipData",
        "NestedCategoryRelationshipData",
        "NestedHierarchyRelationshipData",
    ]

    def serialize_to(self, builder: Builder) -> Tuple[int, int]:
        from .generated.UlFieldRelationshipData import UlFieldRelationshipData
        offset = self.value.serialize_to(builder)
        if isinstance(self.value, HierarchyRelationshipData):
            return (offset, UlFieldRelationshipData().HierarchyRelationshipData)
        elif isinstance(self.value, CategoryRelationshipData):
            return (offset, UlFieldRelationshipData().CategoryRelationshipData)
        elif isinstance(self.value, NestedCategoryRelationshipData):
            return (offset, UlFieldRelationshipData().NestedCategoryRelationshipData)
        elif isinstance(self.value, NestedHierarchyRelationshipData):
            return (offset, UlFieldRelationshipData().NestedHierarchyRelationshipData)
        raise ValueError("Invalid union type")

    @classmethod
    def from_fbs(cls, o: Optional[Table], ty: int) -> Self:
        assert o is not None
        source = o.Bytes
        pos = o.Pos
        UlFieldRelationshipData_ty_instance = FbsUlFieldRelationshipData()
        if ty == UlFieldRelationshipData_ty_instance.HierarchyRelationshipData:
            val = FbsHierarchyRelationshipData();
            val.Init(source, pos)
            return cls(HierarchyRelationshipData.from_fbs(val))
        elif ty == UlFieldRelationshipData_ty_instance.CategoryRelationshipData:
            val = FbsCategoryRelationshipData();
            val.Init(source, pos)
            return cls(CategoryRelationshipData.from_fbs(val))
        elif ty == UlFieldRelationshipData_ty_instance.NestedCategoryRelationshipData:
            val = FbsNestedCategoryRelationshipData();
            val.Init(source, pos)
            return cls(NestedCategoryRelationshipData.from_fbs(val))
        elif ty == UlFieldRelationshipData_ty_instance.NestedHierarchyRelationshipData:
            val = FbsNestedHierarchyRelationshipData();
            val.Init(source, pos)
            return cls(NestedHierarchyRelationshipData.from_fbs(val))
        else:
            raise ValueError("Invalid union type")

    @classmethod
    def make_default(cls) -> Self:
        return cls(HierarchyRelationshipData.make_default())

    def __eq__(self, other) -> bool:
        if type(self.value) is not type(other.value):
            return False
        return self.value == other.value

@dataclass
class ContactInfo:
    address: Optional["str"]

    email: Optional["str"]

    name: Optional["str"]

    phone: Optional["str"]

    url: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsContactInfo) -> Self:
        address = None
        address_str = o.Address()
        if address_str is not None:
            address = address_str.decode('utf-8')
        email = None
        email_str = o.Email()
        if email_str is not None:
            email = email_str.decode('utf-8')
        name = None
        name_str = o.Name()
        if name_str is not None:
            name = name_str.decode('utf-8')
        phone = None
        phone_str = o.Phone()
        if phone_str is not None:
            phone = phone_str.decode('utf-8')
        url = None
        url_str = o.Url()
        if url_str is not None:
            url = url_str.decode('utf-8')
        return cls(address, email, name, phone, url)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsContactInfo.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.ContactInfo import (
            Start,
            AddAddress,
            AddEmail,
            AddName,
            AddPhone,
            AddUrl,
            End,
        )
        address_offset = None
        if self.address is not None:
            address_offset = builder.CreateString(self.address)
        email_offset = None
        if self.email is not None:
            email_offset = builder.CreateString(self.email)
        name_offset = None
        if self.name is not None:
            name_offset = builder.CreateString(self.name)
        phone_offset = None
        if self.phone is not None:
            phone_offset = builder.CreateString(self.phone)
        url_offset = None
        if self.url is not None:
            url_offset = builder.CreateString(self.url)
        
        Start(builder)
        if address_offset is not None:
            AddAddress(builder, address_offset)
        if email_offset is not None:
            AddEmail(builder, email_offset)
        if name_offset is not None:
            AddName(builder, name_offset)
        if phone_offset is not None:
            AddPhone(builder, phone_offset)
        if url_offset is not None:
            AddUrl(builder, url_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        address = ""
        email = ""
        name = ""
        phone = ""
        url = ""
        return cls(address, email, name, phone, url)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.address == other.address
        eq = eq and self.email == other.email
        eq = eq and self.name == other.name
        eq = eq and self.phone == other.phone
        eq = eq and self.url == other.url

        return eq

@dataclass
class DatasetSource:
    # Date information about the data source, such as the year it was generated.
    # This is a free-form text field that isn't interpreted in any means by the
    # system.
    date: Optional["str"]

    # The entity that created the data (Manifold, Government of Canada, Wejo, City
    source: Optional["str"]

    # A URL to where the data set can be fetched. Ideally a direct download but
    url: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsDatasetSource) -> Self:
        date = None
        date_str = o.Date()
        if date_str is not None:
            date = date_str.decode('utf-8')
        source = None
        source_str = o.Source()
        if source_str is not None:
            source = source_str.decode('utf-8')
        url = None
        url_str = o.Url()
        if url_str is not None:
            url = url_str.decode('utf-8')
        return cls(date, source, url)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDatasetSource.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.DatasetSource import (
            Start,
            AddDate,
            AddSource,
            AddUrl,
            End,
        )
        date_offset = None
        if self.date is not None:
            date_offset = builder.CreateString(self.date)
        source_offset = None
        if self.source is not None:
            source_offset = builder.CreateString(self.source)
        url_offset = None
        if self.url is not None:
            url_offset = builder.CreateString(self.url)
        
        Start(builder)
        if date_offset is not None:
            AddDate(builder, date_offset)
        if source_offset is not None:
            AddSource(builder, source_offset)
        if url_offset is not None:
            AddUrl(builder, url_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        date = ""
        source = ""
        url = ""
        return cls(date, source, url)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.date == other.date
        eq = eq and self.source == other.source
        eq = eq and self.url == other.url

        return eq

@dataclass
class Document:
    display_name: Optional["str"]

    filename: Optional["str"]

    mime_type: Optional["str"]

    url: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsDocument) -> Self:
        display_name = None
        display_name_str = o.DisplayName()
        if display_name_str is not None:
            display_name = display_name_str.decode('utf-8')
        filename = None
        filename_str = o.Filename()
        if filename_str is not None:
            filename = filename_str.decode('utf-8')
        mime_type = None
        mime_type_str = o.MimeType()
        if mime_type_str is not None:
            mime_type = mime_type_str.decode('utf-8')
        url = None
        url_str = o.Url()
        if url_str is not None:
            url = url_str.decode('utf-8')
        return cls(display_name, filename, mime_type, url)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDocument.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Document import (
            Start,
            AddDisplayName,
            AddFilename,
            AddMimeType,
            AddUrl,
            End,
        )
        display_name_offset = None
        if self.display_name is not None:
            display_name_offset = builder.CreateString(self.display_name)
        filename_offset = None
        if self.filename is not None:
            filename_offset = builder.CreateString(self.filename)
        mime_type_offset = None
        if self.mime_type is not None:
            mime_type_offset = builder.CreateString(self.mime_type)
        url_offset = None
        if self.url is not None:
            url_offset = builder.CreateString(self.url)
        
        Start(builder)
        if display_name_offset is not None:
            AddDisplayName(builder, display_name_offset)
        if filename_offset is not None:
            AddFilename(builder, filename_offset)
        if mime_type_offset is not None:
            AddMimeType(builder, mime_type_offset)
        if url_offset is not None:
            AddUrl(builder, url_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        display_name = ""
        filename = ""
        mime_type = ""
        url = ""
        return cls(display_name, filename, mime_type, url)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.display_name == other.display_name
        eq = eq and self.filename == other.filename
        eq = eq and self.mime_type == other.mime_type
        eq = eq and self.url == other.url

        return eq

@dataclass
class Documents:
    documents: Optional["List[Document]"]

    @classmethod
    def from_fbs(cls, o: FbsDocuments) -> Self:
        documents = list()
        if not o.DocumentsIsNone():
            for i in range(o.DocumentsLength()):
                documents_val = None
                documents_obj = o.Documents(i)
                if documents_obj is not None:
                    documents_val = Document.from_fbs(documents_obj)
                documents.append(documents_val)
        return cls(documents)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsDocuments.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Documents import (
            Start,
            AddDocuments,
            StartDocumentsVector,
            End,
        )
        documents_offset = None
        if self.documents is not None:
            documents_offsets = list()
            for value in self.documents:
                documents_offsets.append(value.serialize_to(builder))
            StartDocumentsVector(builder, len(self.documents))
            for i in reversed(range(len(self.documents))):
                builder.PrependUOffsetTRelative(documents_offsets[i])
            documents_offset = builder.EndVector()
        
        Start(builder)
        if documents_offset is not None:
            AddDocuments(builder, documents_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        documents = []
        return cls(documents)

    def __eq__(self, other) -> bool:
        eq = True
        self_documents = self.documents
        other_documents = other.documents
        if self_documents is not None and other_documents is not None:
            if len(self_documents) != len(other_documents):
                return False
            for i in range(len(self_documents)):
                eq = eq and self_documents[i] == other_documents[i]
        elif self_documents is not None and other_documents is None:
            return False
        elif self_documents is None and other_documents is not None:
            return False

        return eq

@dataclass
class FloatAggregate:
    count: "int"

    histo: Optional["List[FloatBucket]"]

    max: "float"

    mean: "float"

    min: "float"

    sum: "float"

    variance: "float"

    @classmethod
    def from_fbs(cls, o: FbsFloatAggregate) -> Self:
        count = o.Count()
        histo = list()
        if not o.HistoIsNone():
            for i in range(o.HistoLength()):
                histo_val = None
                histo_obj = o.Histo(i)
                if histo_obj is not None:
                    histo_val = FloatBucket.from_fbs(histo_obj)
                histo.append(histo_val)
        max = o.Max()
        mean = o.Mean()
        min = o.Min()
        sum = o.Sum()
        variance = o.Variance()
        return cls(count, histo, max, mean, min, sum, variance)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsFloatAggregate.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.FloatAggregate import (
            Start,
            AddCount,
            AddHisto,
            StartHistoVector,
            AddMax,
            AddMean,
            AddMin,
            AddSum,
            AddVariance,
            End,
        )
        histo_offset = None
        if self.histo is not None:
            histo_offsets = list()
            for value in self.histo:
                histo_offsets.append(value.serialize_to(builder))
            StartHistoVector(builder, len(self.histo))
            for i in reversed(range(len(self.histo))):
                builder.PrependUOffsetTRelative(histo_offsets[i])
            histo_offset = builder.EndVector()
        
        Start(builder)
        AddCount(builder, self.count)
        if histo_offset is not None:
            AddHisto(builder, histo_offset)
        AddMax(builder, self.max)
        AddMean(builder, self.mean)
        AddMin(builder, self.min)
        AddSum(builder, self.sum)
        AddVariance(builder, self.variance)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        count = 0
        histo = []
        max = 0.0
        mean = 0.0
        min = 0.0
        sum = 0.0
        variance = 0.0
        return cls(count, histo, max, mean, min, sum, variance)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.count == other.count
        self_histo = self.histo
        other_histo = other.histo
        if self_histo is not None and other_histo is not None:
            if len(self_histo) != len(other_histo):
                return False
            for i in range(len(self_histo)):
                eq = eq and self_histo[i] == other_histo[i]
        elif self_histo is not None and other_histo is None:
            return False
        elif self_histo is None and other_histo is not None:
            return False
        eq = eq and self.max == other.max
        eq = eq and self.mean == other.mean
        eq = eq and self.min == other.min
        eq = eq and self.sum == other.sum
        eq = eq and self.variance == other.variance

        return eq

@dataclass
class FloatBucket:
    count: "int"

    max: "float"

    @classmethod
    def from_fbs(cls, o: FbsFloatBucket) -> Self:
        count = o.Count()
        max = o.Max()
        return cls(count, max)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.FloatBucket import CreateFloatBucket
        count = self.count
        max = self.max
        return CreateFloatBucket(builder, count, max)

    @classmethod
    def make_default(cls) -> Self:
        count = 0
        max = 0.0
        return cls(count, max)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.count == other.count
        eq = eq and self.max == other.max

        return eq

@dataclass
class GeometryData:
    data: "GeometryDataUnion"

    @classmethod
    def from_fbs(cls, o: FbsGeometryData) -> Self:
        data_val = o.Data()
        if data_val is not None:
            data_ty = o.DataType()
            data = GeometryDataUnion.from_fbs(data_val, data_ty)
        else:
            raise ValueError("Data is required")
        return cls(data)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsGeometryData.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.GeometryData import (
            Start,
            AddData,
            AddDataType,
            End,
        )
        data_offset, data_ty = self.data.serialize_to(builder)
        
        Start(builder)
        AddData(builder, data_offset)
        AddDataType(builder, data_ty)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        data = GeometryDataUnion.make_default()
        return cls(data)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.data == other.data

        return eq

@dataclass
class HierarchicalRelationship:
    children: Optional["List[int]"]

    parent: "int"

    @classmethod
    def from_fbs(cls, o: FbsHierarchicalRelationship) -> Self:
        children = list()
        if not o.ChildrenIsNone():
            for i in range(o.ChildrenLength()):
                children.append(o.Children(i))
        parent = o.Parent()
        return cls(children, parent)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsHierarchicalRelationship.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.HierarchicalRelationship import (
            Start,
            AddChildren,
            StartChildrenVector,
            AddParent,
            End,
        )
        children_offset = None
        if self.children is not None:
            StartChildrenVector(builder, len(self.children))
            for i in reversed(range(len(self.children))):
                builder.PrependInt32(self.children[i])
            children_offset = builder.EndVector()
        
        Start(builder)
        if children_offset is not None:
            AddChildren(builder, children_offset)
        AddParent(builder, self.parent)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        children = []
        parent = 0
        return cls(children, parent)

    def __eq__(self, other) -> bool:
        eq = True
        self_children = self.children
        other_children = other.children
        if self_children is not None and other_children is not None:
            if len(self_children) != len(other_children):
                return False
            for i in range(len(self_children)):
                eq = eq and self_children[i] == other_children[i]
        elif self_children is not None and other_children is None:
            return False
        elif self_children is None and other_children is not None:
            return False
        eq = eq and self.parent == other.parent

        return eq

@dataclass
class IntAggregate:
    count: "int"

    histo: Optional["List[UIntBucket]"]

    max: "int"

    mean: "int"

    min: "int"

    sum: "int"

    variance: "int"

    @classmethod
    def from_fbs(cls, o: FbsIntAggregate) -> Self:
        count = o.Count()
        histo = list()
        if not o.HistoIsNone():
            for i in range(o.HistoLength()):
                histo_val = None
                histo_obj = o.Histo(i)
                if histo_obj is not None:
                    histo_val = UIntBucket.from_fbs(histo_obj)
                histo.append(histo_val)
        max = o.Max()
        mean = o.Mean()
        min = o.Min()
        sum = o.Sum()
        variance = o.Variance()
        return cls(count, histo, max, mean, min, sum, variance)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsIntAggregate.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.IntAggregate import (
            Start,
            AddCount,
            AddHisto,
            StartHistoVector,
            AddMax,
            AddMean,
            AddMin,
            AddSum,
            AddVariance,
            End,
        )
        histo_offset = None
        if self.histo is not None:
            histo_offsets = list()
            for value in self.histo:
                histo_offsets.append(value.serialize_to(builder))
            StartHistoVector(builder, len(self.histo))
            for i in reversed(range(len(self.histo))):
                builder.PrependUOffsetTRelative(histo_offsets[i])
            histo_offset = builder.EndVector()
        
        Start(builder)
        AddCount(builder, self.count)
        if histo_offset is not None:
            AddHisto(builder, histo_offset)
        AddMax(builder, self.max)
        AddMean(builder, self.mean)
        AddMin(builder, self.min)
        AddSum(builder, self.sum)
        AddVariance(builder, self.variance)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        count = 0
        histo = []
        max = 0
        mean = 0
        min = 0
        sum = 0
        variance = 0
        return cls(count, histo, max, mean, min, sum, variance)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.count == other.count
        self_histo = self.histo
        other_histo = other.histo
        if self_histo is not None and other_histo is not None:
            if len(self_histo) != len(other_histo):
                return False
            for i in range(len(self_histo)):
                eq = eq and self_histo[i] == other_histo[i]
        elif self_histo is not None and other_histo is None:
            return False
        elif self_histo is None and other_histo is not None:
            return False
        eq = eq and self.max == other.max
        eq = eq and self.mean == other.mean
        eq = eq and self.min == other.min
        eq = eq and self.sum == other.sum
        eq = eq and self.variance == other.variance

        return eq

@dataclass
class IntBucket:
    count: "int"

    max: "int"

    @classmethod
    def from_fbs(cls, o: FbsIntBucket) -> Self:
        count = o.Count()
        max = o.Max()
        return cls(count, max)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.IntBucket import CreateIntBucket
        count = self.count
        max = self.max
        return CreateIntBucket(builder, count, max)

    @classmethod
    def make_default(cls) -> Self:
        count = 0
        max = 0
        return cls(count, max)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.count == other.count
        eq = eq and self.max == other.max

        return eq

@dataclass
class IntegerDisplayString:
    display_name: "str"

    value: "int"

    @classmethod
    def from_fbs(cls, o: FbsIntegerDisplayString) -> Self:
        display_name_str = o.DisplayName()
        assert display_name_str is not None
        display_name = display_name_str.decode('utf-8')
        value = o.Value()
        return cls(display_name, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsIntegerDisplayString.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.IntegerDisplayString import (
            Start,
            AddDisplayName,
            AddValue,
            End,
        )
        display_name_offset = builder.CreateString(self.display_name)
        
        Start(builder)
        AddDisplayName(builder, display_name_offset)
        AddValue(builder, self.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        display_name = ""
        value = 0
        return cls(display_name, value)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.display_name == other.display_name
        eq = eq and self.value == other.value

        return eq

@dataclass
class Metadata:
    # is to be included in the boundary selection modal
    area_selection: "bool"

    # Organizational category for frontend. Defaults to DC_HIDDEN.
    dataset_category: "DatasetCategory"

    description: Optional["str"]

    display_name: Optional["str"]

    # do not use user's viewport bounding box when fetching this stream's geometry from worldgraph
    do_not_filter_geometry_by_viewport: "bool"

    entity_ty: "EntityTy"

    # Field groupings e.g. age ranges, ethnicities or hierarchical codes like zoning and NAICS
    field_relationships: Optional["List[UlFieldRelationship]"]

    fields: Optional["List[UlField]"]

    geometry_source: Optional["GeometrySource"]

    # An optional field that is meant to provide information to the user on
    # where the data has come from
    source: Optional["DatasetSource"]

    summary: Optional["List[int]"]

    update_cadence: "UpdateCadence"

    @classmethod
    def from_fbs(cls, o: FbsMetadata) -> Self:
        area_selection = o.AreaSelection()
        dataset_category = DatasetCategory(o.DatasetCategory())
        description = None
        description_str = o.Description()
        if description_str is not None:
            description = description_str.decode('utf-8')
        display_name = None
        display_name_str = o.DisplayName()
        if display_name_str is not None:
            display_name = display_name_str.decode('utf-8')
        do_not_filter_geometry_by_viewport = o.DoNotFilterGeometryByViewport()
        entity_ty = EntityTy(o.EntityTy())
        field_relationships = list()
        if not o.FieldRelationshipsIsNone():
            for i in range(o.FieldRelationshipsLength()):
                field_relationships_val = None
                field_relationships_obj = o.FieldRelationships(i)
                if field_relationships_obj is not None:
                    field_relationships_val = UlFieldRelationship.from_fbs(field_relationships_obj)
                field_relationships.append(field_relationships_val)
        fields = list()
        if not o.FieldsIsNone():
            for i in range(o.FieldsLength()):
                fields_val = None
                fields_obj = o.Fields(i)
                if fields_obj is not None:
                    fields_val = UlField.from_fbs(fields_obj)
                fields.append(fields_val)
        geometry_source = None
        geometry_source_val = o.GeometrySource()
        if geometry_source_val is not None:
            geometry_source_ty = o.GeometrySourceType()
            geometry_source = GeometrySource.from_fbs(geometry_source_val, geometry_source_ty)
        source = None
        source_obj = o.Source()
        if source_obj is not None:
            source = DatasetSource.from_fbs(source_obj)
        summary = list()
        if not o.SummaryIsNone():
            for i in range(o.SummaryLength()):
                summary.append(o.Summary(i))
        update_cadence = UpdateCadence(o.UpdateCadence())
        return cls(area_selection, dataset_category, description, display_name, do_not_filter_geometry_by_viewport, entity_ty, field_relationships, fields, geometry_source, source, summary, update_cadence)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsMetadata.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.Metadata import (
            Start,
            AddAreaSelection,
            AddDatasetCategory,
            AddDescription,
            AddDisplayName,
            AddDoNotFilterGeometryByViewport,
            AddEntityTy,
            AddFieldRelationships,
            StartFieldRelationshipsVector,
            AddFields,
            StartFieldsVector,
            AddGeometrySource,
            AddGeometrySourceType,
            AddSource,
            AddSummary,
            StartSummaryVector,
            AddUpdateCadence,
            End,
        )
        description_offset = None
        if self.description is not None:
            description_offset = builder.CreateString(self.description)
        display_name_offset = None
        if self.display_name is not None:
            display_name_offset = builder.CreateString(self.display_name)
        field_relationships_offset = None
        if self.field_relationships is not None:
            field_relationships_offsets = list()
            for value in self.field_relationships:
                field_relationships_offsets.append(value.serialize_to(builder))
            StartFieldRelationshipsVector(builder, len(self.field_relationships))
            for i in reversed(range(len(self.field_relationships))):
                builder.PrependUOffsetTRelative(field_relationships_offsets[i])
            field_relationships_offset = builder.EndVector()
        fields_offset = None
        if self.fields is not None:
            fields_offsets = list()
            for value in self.fields:
                fields_offsets.append(value.serialize_to(builder))
            StartFieldsVector(builder, len(self.fields))
            for i in reversed(range(len(self.fields))):
                builder.PrependUOffsetTRelative(fields_offsets[i])
            fields_offset = builder.EndVector()
        geometry_source_offset, geometry_source_ty = (None, None)
        if self.geometry_source is not None:
            geometry_source_offset, geometry_source_ty = self.geometry_source.serialize_to(builder)
        source_offset = None
        if self.source is not None:
            source_offset = self.source.serialize_to(builder)
        summary_offset = None
        if self.summary is not None:
            StartSummaryVector(builder, len(self.summary))
            for i in reversed(range(len(self.summary))):
                builder.PrependInt32(self.summary[i])
            summary_offset = builder.EndVector()
        
        Start(builder)
        AddAreaSelection(builder, self.area_selection)
        AddDatasetCategory(builder, self.dataset_category.value)
        if description_offset is not None:
            AddDescription(builder, description_offset)
        if display_name_offset is not None:
            AddDisplayName(builder, display_name_offset)
        AddDoNotFilterGeometryByViewport(builder, self.do_not_filter_geometry_by_viewport)
        AddEntityTy(builder, self.entity_ty.value)
        if field_relationships_offset is not None:
            AddFieldRelationships(builder, field_relationships_offset)
        if fields_offset is not None:
            AddFields(builder, fields_offset)
        if geometry_source_offset is not None and geometry_source_ty is not None:
            AddGeometrySource(builder, geometry_source_offset)
            AddGeometrySourceType(builder, geometry_source_ty)
        if source_offset is not None:
            AddSource(builder, source_offset)
        if summary_offset is not None:
            AddSummary(builder, summary_offset)
        AddUpdateCadence(builder, self.update_cadence.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        area_selection = False
        dataset_category = DatasetCategory(0)
        description = ""
        display_name = ""
        do_not_filter_geometry_by_viewport = False
        entity_ty = EntityTy(0)
        field_relationships = []
        fields = []
        geometry_source = GeometrySource.make_default()
        source = DatasetSource.make_default()
        summary = []
        update_cadence = UpdateCadence(0)
        return cls(area_selection, dataset_category, description, display_name, do_not_filter_geometry_by_viewport, entity_ty, field_relationships, fields, geometry_source, source, summary, update_cadence)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.area_selection == other.area_selection
        eq = eq and self.dataset_category == other.dataset_category
        eq = eq and self.description == other.description
        eq = eq and self.display_name == other.display_name
        eq = eq and self.do_not_filter_geometry_by_viewport == other.do_not_filter_geometry_by_viewport
        eq = eq and self.entity_ty == other.entity_ty
        self_field_relationships = self.field_relationships
        other_field_relationships = other.field_relationships
        if self_field_relationships is not None and other_field_relationships is not None:
            if len(self_field_relationships) != len(other_field_relationships):
                return False
            for i in range(len(self_field_relationships)):
                eq = eq and self_field_relationships[i] == other_field_relationships[i]
        elif self_field_relationships is not None and other_field_relationships is None:
            return False
        elif self_field_relationships is None and other_field_relationships is not None:
            return False
        self_fields = self.fields
        other_fields = other.fields
        if self_fields is not None and other_fields is not None:
            if len(self_fields) != len(other_fields):
                return False
            for i in range(len(self_fields)):
                eq = eq and self_fields[i] == other_fields[i]
        elif self_fields is not None and other_fields is None:
            return False
        elif self_fields is None and other_fields is not None:
            return False
        eq = eq and self.geometry_source == other.geometry_source
        eq = eq and self.source == other.source
        self_summary = self.summary
        other_summary = other.summary
        if self_summary is not None and other_summary is not None:
            if len(self_summary) != len(other_summary):
                return False
            for i in range(len(self_summary)):
                eq = eq and self_summary[i] == other_summary[i]
        elif self_summary is not None and other_summary is None:
            return False
        elif self_summary is None and other_summary is not None:
            return False
        eq = eq and self.update_cadence == other.update_cadence

        return eq

@dataclass
class NestedCategoryRelationshipNode:
    child_columns: Optional["List[int]"]

    column: "int"

    @classmethod
    def from_fbs(cls, o: FbsNestedCategoryRelationshipNode) -> Self:
        child_columns = list()
        if not o.ChildColumnsIsNone():
            for i in range(o.ChildColumnsLength()):
                child_columns.append(o.ChildColumns(i))
        column = o.Column()
        return cls(child_columns, column)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNestedCategoryRelationshipNode.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NestedCategoryRelationshipNode import (
            Start,
            AddChildColumns,
            StartChildColumnsVector,
            AddColumn,
            End,
        )
        child_columns_offset = None
        if self.child_columns is not None:
            StartChildColumnsVector(builder, len(self.child_columns))
            for i in reversed(range(len(self.child_columns))):
                builder.PrependInt32(self.child_columns[i])
            child_columns_offset = builder.EndVector()
        
        Start(builder)
        if child_columns_offset is not None:
            AddChildColumns(builder, child_columns_offset)
        AddColumn(builder, self.column)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        child_columns = []
        column = 0
        return cls(child_columns, column)

    def __eq__(self, other) -> bool:
        eq = True
        self_child_columns = self.child_columns
        other_child_columns = other.child_columns
        if self_child_columns is not None and other_child_columns is not None:
            if len(self_child_columns) != len(other_child_columns):
                return False
            for i in range(len(self_child_columns)):
                eq = eq and self_child_columns[i] == other_child_columns[i]
        elif self_child_columns is not None and other_child_columns is None:
            return False
        elif self_child_columns is None and other_child_columns is not None:
            return False
        eq = eq and self.column == other.column

        return eq

@dataclass
class NestedHierarchyRelationshipNode:
    child_columns: Optional["List[int]"]

    child_nodes: Optional["List[int]"]

    label: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsNestedHierarchyRelationshipNode) -> Self:
        child_columns = list()
        if not o.ChildColumnsIsNone():
            for i in range(o.ChildColumnsLength()):
                child_columns.append(o.ChildColumns(i))
        child_nodes = list()
        if not o.ChildNodesIsNone():
            for i in range(o.ChildNodesLength()):
                child_nodes.append(o.ChildNodes(i))
        label = None
        label_str = o.Label()
        if label_str is not None:
            label = label_str.decode('utf-8')
        return cls(child_columns, child_nodes, label)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNestedHierarchyRelationshipNode.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NestedHierarchyRelationshipNode import (
            Start,
            AddChildColumns,
            StartChildColumnsVector,
            AddChildNodes,
            StartChildNodesVector,
            AddLabel,
            End,
        )
        child_columns_offset = None
        if self.child_columns is not None:
            StartChildColumnsVector(builder, len(self.child_columns))
            for i in reversed(range(len(self.child_columns))):
                builder.PrependInt32(self.child_columns[i])
            child_columns_offset = builder.EndVector()
        child_nodes_offset = None
        if self.child_nodes is not None:
            StartChildNodesVector(builder, len(self.child_nodes))
            for i in reversed(range(len(self.child_nodes))):
                builder.PrependInt32(self.child_nodes[i])
            child_nodes_offset = builder.EndVector()
        label_offset = None
        if self.label is not None:
            label_offset = builder.CreateString(self.label)
        
        Start(builder)
        if child_columns_offset is not None:
            AddChildColumns(builder, child_columns_offset)
        if child_nodes_offset is not None:
            AddChildNodes(builder, child_nodes_offset)
        if label_offset is not None:
            AddLabel(builder, label_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        child_columns = []
        child_nodes = []
        label = ""
        return cls(child_columns, child_nodes, label)

    def __eq__(self, other) -> bool:
        eq = True
        self_child_columns = self.child_columns
        other_child_columns = other.child_columns
        if self_child_columns is not None and other_child_columns is not None:
            if len(self_child_columns) != len(other_child_columns):
                return False
            for i in range(len(self_child_columns)):
                eq = eq and self_child_columns[i] == other_child_columns[i]
        elif self_child_columns is not None and other_child_columns is None:
            return False
        elif self_child_columns is None and other_child_columns is not None:
            return False
        self_child_nodes = self.child_nodes
        other_child_nodes = other.child_nodes
        if self_child_nodes is not None and other_child_nodes is not None:
            if len(self_child_nodes) != len(other_child_nodes):
                return False
            for i in range(len(self_child_nodes)):
                eq = eq and self_child_nodes[i] == other_child_nodes[i]
        elif self_child_nodes is not None and other_child_nodes is None:
            return False
        elif self_child_nodes is None and other_child_nodes is not None:
            return False
        eq = eq and self.label == other.label

        return eq

@dataclass
class NestedStringCategoryNode:
    child_values: "List[str]"

    value: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsNestedStringCategoryNode) -> Self:
        child_values = list()
        if not o.ChildValuesIsNone():
            for i in range(o.ChildValuesLength()):
                child_values.append(o.ChildValues(i))
        value = None
        value_str = o.Value()
        if value_str is not None:
            value = value_str.decode('utf-8')
        return cls(child_values, value)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsNestedStringCategoryNode.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.NestedStringCategoryNode import (
            Start,
            AddChildValues,
            StartChildValuesVector,
            AddValue,
            End,
        )
        child_values_offsets = list()
        for value in self.child_values:
            child_values_offsets.append(builder.CreateString(value))
        StartChildValuesVector(builder, len(self.child_values))
        for i in reversed(range(len(self.child_values))):
            builder.PrependUOffsetTRelative(child_values_offsets[i])
        child_values_offset = builder.EndVector()
        value_offset = None
        if self.value is not None:
            value_offset = builder.CreateString(self.value)
        
        Start(builder)
        AddChildValues(builder, child_values_offset)
        if value_offset is not None:
            AddValue(builder, value_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        child_values = []
        value = ""
        return cls(child_values, value)

    def __eq__(self, other) -> bool:
        eq = True
        if len(self.child_values) != len(other.child_values):
            return False
        for i in range(len(self.child_values)):
            eq = eq and self.child_values[i] == other.child_values[i]
        eq = eq and self.value == other.value

        return eq

@dataclass
class StringAggregate:
    count: "int"

    str: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsStringAggregate) -> Self:
        count = o.Count()
        str = None
        str_str = o.Str()
        if str_str is not None:
            str = str_str.decode('utf-8')
        return cls(count, str)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsStringAggregate.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.StringAggregate import (
            Start,
            AddCount,
            AddStr,
            End,
        )
        str_offset = None
        if self.str is not None:
            str_offset = builder.CreateString(self.str)
        
        Start(builder)
        AddCount(builder, self.count)
        if str_offset is not None:
            AddStr(builder, str_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        count = 0
        str = ""
        return cls(count, str)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.count == other.count
        eq = eq and self.str == other.str

        return eq

@dataclass
class TimeInterval:
    max: "int"

    min: "int"

    @classmethod
    def from_fbs(cls, o: FbsTimeInterval) -> Self:
        max = o.Max()
        min = o.Min()
        return cls(max, min)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsTimeInterval.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.TimeInterval import (
            Start,
            AddMax,
            AddMin,
            End,
        )
        
        Start(builder)
        AddMax(builder, self.max)
        AddMin(builder, self.min)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        max = 0
        min = 0
        return cls(max, min)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.max == other.max
        eq = eq and self.min == other.min

        return eq

@dataclass
class UIntAggregate:
    count: "int"

    histo: Optional["List[UIntBucket]"]

    max: "int"

    mean: "int"

    min: "int"

    sum: "int"

    variance: "int"

    @classmethod
    def from_fbs(cls, o: FbsUIntAggregate) -> Self:
        count = o.Count()
        histo = list()
        if not o.HistoIsNone():
            for i in range(o.HistoLength()):
                histo_val = None
                histo_obj = o.Histo(i)
                if histo_obj is not None:
                    histo_val = UIntBucket.from_fbs(histo_obj)
                histo.append(histo_val)
        max = o.Max()
        mean = o.Mean()
        min = o.Min()
        sum = o.Sum()
        variance = o.Variance()
        return cls(count, histo, max, mean, min, sum, variance)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUIntAggregate.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UIntAggregate import (
            Start,
            AddCount,
            AddHisto,
            StartHistoVector,
            AddMax,
            AddMean,
            AddMin,
            AddSum,
            AddVariance,
            End,
        )
        histo_offset = None
        if self.histo is not None:
            histo_offsets = list()
            for value in self.histo:
                histo_offsets.append(value.serialize_to(builder))
            StartHistoVector(builder, len(self.histo))
            for i in reversed(range(len(self.histo))):
                builder.PrependUOffsetTRelative(histo_offsets[i])
            histo_offset = builder.EndVector()
        
        Start(builder)
        AddCount(builder, self.count)
        if histo_offset is not None:
            AddHisto(builder, histo_offset)
        AddMax(builder, self.max)
        AddMean(builder, self.mean)
        AddMin(builder, self.min)
        AddSum(builder, self.sum)
        AddVariance(builder, self.variance)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        count = 0
        histo = []
        max = 0
        mean = 0
        min = 0
        sum = 0
        variance = 0
        return cls(count, histo, max, mean, min, sum, variance)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.count == other.count
        self_histo = self.histo
        other_histo = other.histo
        if self_histo is not None and other_histo is not None:
            if len(self_histo) != len(other_histo):
                return False
            for i in range(len(self_histo)):
                eq = eq and self_histo[i] == other_histo[i]
        elif self_histo is not None and other_histo is None:
            return False
        elif self_histo is None and other_histo is not None:
            return False
        eq = eq and self.max == other.max
        eq = eq and self.mean == other.mean
        eq = eq and self.min == other.min
        eq = eq and self.sum == other.sum
        eq = eq and self.variance == other.variance

        return eq

@dataclass
class UIntBucket:
    count: "int"

    max: "int"

    @classmethod
    def from_fbs(cls, o: FbsUIntBucket) -> Self:
        count = o.Count()
        max = o.Max()
        return cls(count, max)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UIntBucket import CreateUIntBucket
        count = self.count
        max = self.max
        return CreateUIntBucket(builder, count, max)

    @classmethod
    def make_default(cls) -> Self:
        count = 0
        max = 0
        return cls(count, max)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.count == other.count
        eq = eq and self.max == other.max

        return eq

@dataclass
class UlField:
    breakdown_display_name: Optional["str"]

    component_data: Optional["ComponentData"]

    default: Optional["ValueInstance"]

    description: Optional["str"]

    display_name: Optional["str"]

    field_name: Optional["str"]

    field_type: "UlFieldType"

    flags: "int"

    storage_type: Optional["Type"]

    unit: "FieldUnit"

    @classmethod
    def from_fbs(cls, o: FbsUlField) -> Self:
        breakdown_display_name = None
        breakdown_display_name_str = o.BreakdownDisplayName()
        if breakdown_display_name_str is not None:
            breakdown_display_name = breakdown_display_name_str.decode('utf-8')
        component_data = None
        component_data_val = o.ComponentData()
        if component_data_val is not None:
            component_data_ty = o.ComponentDataType()
            component_data = ComponentData.from_fbs(component_data_val, component_data_ty)
        default = None
        default_obj = o.Default()
        if default_obj is not None:
            default = ValueInstance.from_fbs(default_obj)
        description = None
        description_str = o.Description()
        if description_str is not None:
            description = description_str.decode('utf-8')
        display_name = None
        display_name_str = o.DisplayName()
        if display_name_str is not None:
            display_name = display_name_str.decode('utf-8')
        field_name = None
        field_name_str = o.FieldName()
        if field_name_str is not None:
            field_name = field_name_str.decode('utf-8')
        field_type = UlFieldType(o.FieldType())
        flags = o.Flags()
        storage_type = None
        storage_type_val = o.StorageType()
        if storage_type_val is not None:
            storage_type_ty = o.StorageTypeType()
            storage_type = Type.from_fbs(storage_type_val, storage_type_ty)
        unit = FieldUnit(o.Unit())
        return cls(breakdown_display_name, component_data, default, description, display_name, field_name, field_type, flags, storage_type, unit)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUlField.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UlField import (
            Start,
            AddBreakdownDisplayName,
            AddComponentData,
            AddComponentDataType,
            AddDefault,
            AddDescription,
            AddDisplayName,
            AddFieldName,
            AddFieldType,
            AddFlags,
            AddStorageType,
            AddStorageTypeType,
            AddUnit,
            End,
        )
        breakdown_display_name_offset = None
        if self.breakdown_display_name is not None:
            breakdown_display_name_offset = builder.CreateString(self.breakdown_display_name)
        component_data_offset, component_data_ty = (None, None)
        if self.component_data is not None:
            component_data_offset, component_data_ty = self.component_data.serialize_to(builder)
        default_offset = None
        if self.default is not None:
            default_offset = self.default.serialize_to(builder)
        description_offset = None
        if self.description is not None:
            description_offset = builder.CreateString(self.description)
        display_name_offset = None
        if self.display_name is not None:
            display_name_offset = builder.CreateString(self.display_name)
        field_name_offset = None
        if self.field_name is not None:
            field_name_offset = builder.CreateString(self.field_name)
        storage_type_offset, storage_type_ty = (None, None)
        if self.storage_type is not None:
            storage_type_offset, storage_type_ty = self.storage_type.serialize_to(builder)
        
        Start(builder)
        if breakdown_display_name_offset is not None:
            AddBreakdownDisplayName(builder, breakdown_display_name_offset)
        if component_data_offset is not None and component_data_ty is not None:
            AddComponentData(builder, component_data_offset)
            AddComponentDataType(builder, component_data_ty)
        if default_offset is not None:
            AddDefault(builder, default_offset)
        if description_offset is not None:
            AddDescription(builder, description_offset)
        if display_name_offset is not None:
            AddDisplayName(builder, display_name_offset)
        if field_name_offset is not None:
            AddFieldName(builder, field_name_offset)
        AddFieldType(builder, self.field_type.value)
        AddFlags(builder, self.flags)
        if storage_type_offset is not None and storage_type_ty is not None:
            AddStorageType(builder, storage_type_offset)
            AddStorageTypeType(builder, storage_type_ty)
        AddUnit(builder, self.unit.value)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        breakdown_display_name = ""
        component_data = ComponentData.make_default()
        default = ValueInstance.make_default()
        description = ""
        display_name = ""
        field_name = ""
        field_type = UlFieldType(0)
        flags = 0
        storage_type = Type.make_default()
        unit = FieldUnit(0)
        return cls(breakdown_display_name, component_data, default, description, display_name, field_name, field_type, flags, storage_type, unit)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.breakdown_display_name == other.breakdown_display_name
        eq = eq and self.component_data == other.component_data
        eq = eq and self.default == other.default
        eq = eq and self.description == other.description
        eq = eq and self.display_name == other.display_name
        eq = eq and self.field_name == other.field_name
        eq = eq and self.field_type == other.field_type
        eq = eq and self.flags == other.flags
        eq = eq and self.storage_type == other.storage_type
        eq = eq and self.unit == other.unit

        return eq

@dataclass
class UlFieldRelationship:
    relationship_data: Optional["UlFieldRelationshipData"]

    relationship_display_name: Optional["str"]

    @classmethod
    def from_fbs(cls, o: FbsUlFieldRelationship) -> Self:
        relationship_data = None
        relationship_data_val = o.RelationshipData()
        if relationship_data_val is not None:
            relationship_data_ty = o.RelationshipDataType()
            relationship_data = UlFieldRelationshipData.from_fbs(relationship_data_val, relationship_data_ty)
        relationship_display_name = None
        relationship_display_name_str = o.RelationshipDisplayName()
        if relationship_display_name_str is not None:
            relationship_display_name = relationship_display_name_str.decode('utf-8')
        return cls(relationship_data, relationship_display_name)

    @classmethod
    def from_bytes(cls, data: bytes) -> Self:
        deprefixed = RemoveSizePrefix(data, 0)
        o = FbsUlFieldRelationship.GetRootAs(deprefixed[0], deprefixed[1])
        return cls.from_fbs(o)

    def serialize_to(self, builder: Builder) -> int:
        from .generated.UlFieldRelationship import (
            Start,
            AddRelationshipData,
            AddRelationshipDataType,
            AddRelationshipDisplayName,
            End,
        )
        relationship_data_offset, relationship_data_ty = (None, None)
        if self.relationship_data is not None:
            relationship_data_offset, relationship_data_ty = self.relationship_data.serialize_to(builder)
        relationship_display_name_offset = None
        if self.relationship_display_name is not None:
            relationship_display_name_offset = builder.CreateString(self.relationship_display_name)
        
        Start(builder)
        if relationship_data_offset is not None and relationship_data_ty is not None:
            AddRelationshipData(builder, relationship_data_offset)
            AddRelationshipDataType(builder, relationship_data_ty)
        if relationship_display_name_offset is not None:
            AddRelationshipDisplayName(builder, relationship_display_name_offset)
        return End(builder)

    def to_bytes(self) -> bytes:
        builder = Builder(0)
        offset = self.serialize_to(builder)
        builder.FinishSizePrefixed(offset)
        return builder.Output()

    @classmethod
    def make_default(cls) -> Self:
        relationship_data = UlFieldRelationshipData.make_default()
        relationship_display_name = ""
        return cls(relationship_data, relationship_display_name)

    def __eq__(self, other) -> bool:
        eq = True
        eq = eq and self.relationship_data == other.relationship_data
        eq = eq and self.relationship_display_name == other.relationship_display_name

        return eq
